---
title: AssemblyScript GeÃ§iÅŸ KÄ±lavuzu
---

Åimdiye kadar, alt grafikler [AssemblyScript'in ilk versiyonu](https://github.com/AssemblyScript/assemblyscript/tree/v0.6)'ndan (v0.6) birini kullanÄ±yordu. Sonunda [mevcut olan en yeni sÃ¼rÃ¼m](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10) iÃ§in destek ekledik! ğŸ‰

Bu, subgraph geliÅŸtiricilerin AS dilinin ve standart kitaplÄ±ÄŸÄ±n daha yeni Ã¶zelliklerini kullanmasÄ±nÄ± saÄŸlayacaktÄ±r.

Bu kÄ±lavuz, `0.22.0` sÃ¼rÃ¼mÃ¼nÃ¼n altÄ±ndaki `graph-cli`/`graph-ts` kullanan herkes iÃ§in geÃ§erlidir. HalihazÄ±rda bundan daha yÃ¼ksek (veya eÅŸit) bir sÃ¼rÃ¼mdeyseniz, zaten AssemblyScript'in `0.19.10` sÃ¼rÃ¼mÃ¼nÃ¼ kullanÄ±yorsunuz demektir ğŸ™‚

> Not: `0.24.0` itibarÄ±yla `graph-node`, subgraph bildiriminde belirtilen `apiVersion`'a baÄŸlÄ± olarak her iki sÃ¼rÃ¼mÃ¼ de destekleyebilir.

## Ã–zellikler

### Yeni iÅŸlevsellik

- `TypedArray`'ler artÄ±k [new `wrap` static method](https://www.assemblyscript.org/stdlib/typedarray.html#static-members) kullanÄ±larak `ArrayBuffer`'lerden oluÅŸturulabilir ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1))
- Yeni standart kitaplÄ±k iÅŸlevleri: `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare`and `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- X instanceof GenericClass desteÄŸi eklendi ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Daha verimli bir dizi varyantÄ± olan `StaticArray<T>` eklendi ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- `Array<T>#flat` eklendi ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- `Number#toString` Ã¼zerinde `radix` baÄŸÄ±msÄ±z deÄŸiÅŸkeni uygulandÄ± ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- Floating point deÄŸiÅŸmezlerinde ayÄ±rÄ±cÄ±lar iÃ§in destek eklendi ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7))
- Birinci sÄ±nÄ±f iÅŸlevler iÃ§in destek eklendi ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0))
- YerleÅŸik Ã¶ÄŸeler ekleyin: `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- `Array/TypedArray/String#at` Ã¶ÄŸesini uygulayÄ±n. ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- Åablon hazÄ±r bilgi dizeleri iÃ§in destek eklendi ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- `encodeURI(Component)` ve `decodeURI(Component)` ekleyin. ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- `toString`, `toDateString` ve `toTimeString`'i `Date`'e ekleyin. ([v0.18.29](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- `Date` iÃ§in `toUTCString` ekleyin. ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- `nonnull/NonNullable` yerleÅŸik tÃ¼rÃ¼ ekleyin. ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### Optimizasyonlar

- `exp`, `exp2`, `log`, `log2` ve `pow` gibi `Math` fonksiyonlarÄ±nÄ±n yerini daha hÄ±zlÄ± deÄŸiÅŸkenler almÄ±ÅŸtÄ±r. ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- `Math.mod`'u biraz optimize edildi. ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- Std Map ve Set'te daha fazla alan eriÅŸimi Ã¶nbelleÄŸe alÄ±ndÄ±. ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
- `ipow32/64`'te ikinin kuvvetleri iÃ§in optimize edildi. ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### DiÄŸerleri

- Bir dizi hazÄ±r bilgisinin tÃ¼rÃ¼ artÄ±k iÃ§eriÄŸinden Ã§Ä±karÄ±labilir. ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- stdlib Unicode 13.0.0 olarak gÃ¼ncellendi. ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))

## NasÄ±l YÃ¼kseltilir?

1. `subgraph.yaml` iÃ§indeki `apiVersion` eÅŸlemelerinizi `0.0.6` olarak deÄŸiÅŸtirin:

```yaml
...
dataSources:
  ...
    mapping:
      ...
      apiVersion: 0.0.6
      ...
```

2. ÅunlarÄ± Ã§alÄ±ÅŸtÄ±rarak, kullandÄ±ÄŸÄ±nÄ±z `graph-cli`'yi `en son` sÃ¼rÃ¼me gÃ¼ncelleyin:

```bash
# global olarak yÃ¼klediyseniz
npm install --global @graphprotocol/graph-cli@latest

# veya subgraph'inizde geliÅŸtirici baÄŸÄ±mlÄ±lÄ±ÄŸÄ± olarak varsa:
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. `graph-ts` iÃ§in de aynÄ±sÄ±nÄ± yapÄ±n, ancak genel olarak yÃ¼klemek yerine ana baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ±za kaydedin:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. Dili bozan deÄŸiÅŸiklikleri dÃ¼zeltmek iÃ§in kÄ±lavuzun geri kalanÄ±nÄ± takip edin.
5. `codegen`'i Ã§alÄ±ÅŸtÄ±rÄ±n ve yeniden `deploy edin`.

## Son Dakika DeÄŸiÅŸiklikleri

### Nullability

AssemblyScript'in eski sÃ¼rÃ¼mÃ¼nde ÅŸuna benzer bir kod oluÅŸturabilirsiniz:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

Ancak daha yeni sÃ¼rÃ¼mde, deÄŸer null olabileceÄŸinden, ÅŸu ÅŸekilde kontrol etmenizi gerektirir:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` is not null anymore
}
```

Veya ÅŸu ÅŸekilde zorlayÄ±n:

```typescript
let maybeValue = load()! // breaks in runtime if value is null

maybeValue.aMethod()
```

Hangisini seÃ§eceÄŸinizden emin deÄŸilseniz, her zaman gÃ¼venli sÃ¼rÃ¼mÃ¼ kullanmanÄ±zÄ± Ã¶neririz. DeÄŸer mevcut deÄŸilse, subgraph iÅŸleyicinizde bir geri dÃ¶nÃ¼ÅŸ iÃ§eren erken bir if ifadesi yapmak isteyebilirsiniz.

### DeÄŸiÅŸken GÃ¶lgeleme

[DeÄŸiÅŸken gÃ¶lgeleme](https://en.wikipedia.org/wiki/Variable_shadowing) yapmadan Ã¶nce ve bunun gibi bir kod iÅŸe yarayacaktÄ±:

```typescript
let a = 10
let b = 20
let a = a + b
```

Ancak artÄ±k bu mÃ¼mkÃ¼n deÄŸil ve derleyici ÅŸu hatayÄ± veriyor:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

DeÄŸiÅŸken gÃ¶lgelemeniz varsa, yinelenen deÄŸiÅŸkenlerinizi yeniden adlandÄ±rmanÄ±z gerekir.

### Null KarÅŸÄ±laÅŸtÄ±rmalarÄ±

Subgraph'inizde yÃ¼kseltme yaparak, bazen aÅŸaÄŸÄ±daki gibi hatalar alabilirsiniz:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

Ã‡Ã¶zmek iÃ§in `if` ifadesini aÅŸaÄŸÄ±daki gibi deÄŸiÅŸtirebilirsiniz:

```typescript
  if (!decimals) {

  // or

  if (decimals === null) {
```

AynÄ±sÄ±, == yerine != yapÄ±yorsanÄ±z da geÃ§erlidir.

### DÃ¶kÃ¼m

Daha Ã¶nce yayÄ±n yapmanÄ±n genel yolu, `as` anahtar kelimesini ÅŸu ÅŸekilde kullanmaktÄ±:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // equivalent to: <Uint8Array>byteArray
```

Ancak bu yalnÄ±zca iki senaryoda Ã§alÄ±ÅŸÄ±r:

- Temel dÃ¶kÃ¼m (`u8`, `i32`, `bool` gibi tipler arasÄ±nda; Ã¶rneÄŸin: `let b: isize = 10; b as usize`);
- SÄ±nÄ±f kalÄ±tÄ±mÄ± Ã¼zerinde yÃ¼kseltme (alt sÄ±nÄ±f â†’ Ã¼st sÄ±nÄ±f)

Ã–rnekler:

```typescript
// primitive casting
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
// upcasting on class inheritance
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // same as: bytes as Uint8Array
```

YayÄ±n yapmak isteyebileceÄŸiniz iki senaryo vardÄ±r, ancak `as`/`<T>var` kullanmak **gÃ¼venli deÄŸildir**:

- SÄ±nÄ±f kalÄ±tÄ±mÄ±na iliÅŸkin olumsuz deÄŸerlendirme (Ã¼st sÄ±nÄ±f â†’ alt sÄ±nÄ±f)
- Bir Ã¼st sÄ±nÄ±fÄ± paylaÅŸan iki tÃ¼r arasÄ±nda

```typescript
// downcasting on class inheritance
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // breaks in runtime :(
```

```typescript
// between two types that share a superclass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // breaks in runtime :(
```

Bu gibi durumlar iÃ§in `changetype<T>` iÅŸlevini kullanabilirsiniz:

```typescript
// downcasting on class inheritance
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // works :)
```

```typescript
// between two types that share a superclass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // works :)
```

YalnÄ±zca geÃ§ersiz kÄ±lÄ±nabilirliÄŸi kaldÄ±rmak istiyorsanÄ±z (ya da `<T>deÄŸiÅŸken`), `as` operatÃ¶rÃ¼nÃ¼ kullanmaya devam edebilirsiniz, ancak bu deÄŸerin boÅŸ olamayacaÄŸÄ±nÄ± bildiÄŸinizden emin olun, aksi takdirde bozulur.

```typescript
// remove nullability
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // safe remove null
}

let newBalance = new AccountBalance(balanceId)
```

Nullability durumu iÃ§in [Nullability kontrol Ã¶zelliÄŸine](https://www.assemblyscript.org/basics.html#nullability-checks) bir gÃ¶z atmanÄ±zÄ± Ã¶neririz, kodunuzu daha temiz hale getirecektir ğŸ™‚

AyrÄ±ca, dÃ¶kÃ¼mÃ¼ kolaylaÅŸtÄ±rmak iÃ§in bazÄ± tÃ¼rlerde birkaÃ§ statik yÃ¶ntem daha ekledik, bunlar:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### Ã–zellik EriÅŸimi ile GeÃ§ersiz KÄ±lÄ±nabilirlik (Nullability) KontrolÃ¼

[GeÃ§ersiz kÄ±lÄ±nabilirlik kontrol Ã¶zelliÄŸini](https://www.assemblyscript.org/basics.html#nullability-checks) kullanmak iÃ§in `if` deyimlerini veya (`?` ve `:`) Ã¼Ã§lÃ¼ operatÃ¶rÃ¼nÃ¼ ÅŸu ÅŸekilde kullanabilirsiniz:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// or

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

Bununla birlikte, bu yalnÄ±zca, bir mÃ¼lk eriÅŸiminde deÄŸil, bir deÄŸiÅŸken Ã¼zerinde `if` / Ã¼Ã§lÃ¼ yaptÄ±ÄŸÄ±nÄ±zda Ã§alÄ±ÅŸÄ±r, ÅŸu ÅŸekilde:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // doesn't compile
```

Bu hata hangi Ã§Ä±ktÄ±yÄ± verir:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Bu sorunu Ã§Ã¶zmek iÃ§in, bu Ã¶zellik eriÅŸimi iÃ§in bir deÄŸiÅŸken oluÅŸturabilirsiniz, bÃ¶ylece derleyici geÃ§ersizlik denetimi sihrini yapabilir:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // compiles just fine :)
```

### Ã–zellik EriÅŸimi ile OperatÃ¶r AÅŸÄ±rÄ± YÃ¼klemesi

Null yapÄ±labilen bir tÃ¼rÃ¼ (bir Ã¶zellik eriÅŸiminden) null olmayan bir tÃ¼rle toplamaya Ã§alÄ±ÅŸÄ±rsanÄ±z (Ã¶rnek olarak), AssemblyScript derleyicisi, deÄŸerlerden birinin null olabileceÄŸine dair bir derleme zamanÄ± hatasÄ± uyarÄ±sÄ± vermek yerine, sadece sessizce derler ve kodun Ã§alÄ±ÅŸma zamanÄ±nda kÄ±rÄ±lmasÄ± iÃ§in bir ÅŸans verir.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // give compile time error about nullability

let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // doesn't give compile time errors as it should
```

Bunun iÃ§in AssemblyScript derleyicisinde bir sorun aÃ§tÄ±k, ancak ÅŸimdilik subgraph eÅŸlemelerinizde bu tÃ¼r iÅŸlemler yapÄ±yorsanÄ±z, ondan Ã¶nce boÅŸ bir kontrol yapmak iÃ§in deÄŸiÅŸtirmelisiniz.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // now `n` is guaranteed to be a BigInt
```

### DeÄŸer BaÅŸlatma

Bunun gibi herhangi bir kodunuz varsa:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

Derlenir ancak Ã§alÄ±ÅŸma zamanÄ±nda bozulur, bunun nedeni deÄŸerin baÅŸlatÄ±lmamasÄ±dÄ±r, bu nedenle subgraph'inizin deÄŸerlerini ÅŸu ÅŸekilde baÅŸlattÄ±ÄŸÄ±ndan emin olun:

```typescript
var value = new Type() // initialized
value.x = 10
value.y = 'content'
```

AyrÄ±ca, bir GraphQL varlÄ±ÄŸÄ±nda ÅŸu ÅŸekilde null yapÄ±labilir Ã¶zellikleriniz varsa:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

Ve buna benzer bir kodunuz varsa:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

`total.amount` deÄŸerini baÅŸlattÄ±ÄŸÄ±nÄ±zdan emin olmanÄ±z gerekir, Ã§Ã¼nkÃ¼ toplam iÃ§in son satÄ±rdaki gibi eriÅŸmeye Ã§alÄ±ÅŸÄ±rsanÄ±z Ã§Ã¶kecektir. Yani ya Ã¶nce onu baÅŸlatÄ±rsÄ±nÄ±z:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

Veya GraphQL ÅŸemanÄ±zÄ± bu Ã¶zellik iÃ§in null yapÄ±labilir bir tÃ¼r kullanmayacak ÅŸekilde deÄŸiÅŸtirebilirsiniz, ardÄ±ndan `codegen` adÄ±mÄ±nda onu sÄ±fÄ±r olarak baÅŸlatacaÄŸÄ±z ğŸ˜‰

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest') // already initializes non-nullable properties
}

total.amount = total.amount + BigInt.fromI32(1)
```

### SÄ±nÄ±f Ã–zelliÄŸi BaÅŸlatma

DiÄŸer sÄ±nÄ±flar olan (sizin tarafÄ±nÄ±zdan veya standart kitaplÄ±k tarafÄ±ndan bildirilen) Ã¶zelliklere sahip herhangi bir sÄ±nÄ±fÄ± ÅŸu ÅŸekilde dÄ±ÅŸa aktarÄ±rsanÄ±z:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

Derleyici hata verecektir, Ã§Ã¼nkÃ¼ ya sÄ±nÄ±f olan Ã¶zellikler iÃ§in bir baÅŸlatÄ±cÄ± eklemeniz ya da `!` operatÃ¶rÃ¼nÃ¼ eklemeniz gerekir:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// or

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// or

export class Something {
  value!: Thing
}
```

### Dizi BaÅŸlatma

`Dizi` sÄ±nÄ±fÄ±, listenin uzunluÄŸunu baÅŸlatmak iÃ§in yine de bir sayÄ± kabul eder, ancak dikkatli olmalÄ±sÄ±nÄ±z Ã§Ã¼nkÃ¼ `.push` gibi iÅŸlemler aslÄ±nda baÅŸa eklemek yerine boyutu artÄ±racaktÄ±r, Ã¶rneÄŸin:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // size 6 :(
```

Kullanmakta olduÄŸunuz tÃ¼rlere, Ã¶rneÄŸin null yapÄ±labilir tÃ¼rlere ve bunlara nasÄ±l eriÅŸtiÄŸinize baÄŸlÄ± olarak, bunun gibi bir Ã§alÄ±ÅŸma zamanÄ± hatasÄ±yla karÅŸÄ±laÅŸabilirsiniz:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

AslÄ±nda baÅŸlangÄ±Ã§ta itmek iÃ§in, `diziyi`'i sÄ±fÄ±r boyutunda baÅŸlatmalÄ±sÄ±nÄ±z, bunun gibi:

```typescript
let arr = new Array<string>(0) // []

arr.push('something') // ["something"]
```

Veya onu indeks yoluyla deÄŸiÅŸtirmelisiniz:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'something' // ["something", "", "", "", ""]
```

### GraphQL ÅemasÄ±

Bu doÄŸrudan bir AssemblyScript deÄŸiÅŸikliÄŸi deÄŸildir, ancak `schema.graphql` dosyanÄ±zÄ± gÃ¼ncellemeniz gerekebilir.

ArtÄ±k tÃ¼rlerinizde Non-Nullable Lists olan alanlarÄ± tanÄ±mlayamazsÄ±nÄ±z. Bunun gibi bir ÅŸemanÄ±z varsa:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something]! # no longer valid
}
```

Liste tÃ¼rÃ¼nÃ¼n Ã¼yesine ÅŸu ÅŸekilde bir `!` eklemeniz gerekecek:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # valid
}
```

Bu, AssemblyScript sÃ¼rÃ¼mleri arasÄ±ndaki geÃ§ersiz kÄ±lÄ±nabilirlik farklÄ±lÄ±klarÄ± nedeniyle deÄŸiÅŸti ve bu `src/generated/schema.ts` dosyasÄ±yla ilgilidir (varsayÄ±lan yol, bunu deÄŸiÅŸtirmiÅŸ olabilirsiniz).

### DiÄŸerleri

- `Map#set` ve `Set#add` spesifikasyonla hizalandÄ± ve `bu` dÃ¶ndÃ¼rÃ¼ldÃ¼. ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Diziler artÄ±k ArrayBufferView'dan miras almaz, ancak artÄ±k farklÄ±dÄ±r. ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Nesne hazÄ±r bilgilerinden baÅŸlatÄ±lan sÄ±nÄ±flar artÄ±k bir oluÅŸturucu tanÄ±mlayamaz. ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Her iki iÅŸlenen de tamsayÄ±ysa, `**` ikili iÅŸleminin sonucu artÄ±k ortak payda tamsayÄ±sÄ±dÄ±r. Daha Ã¶nce, sonuÃ§ `Math/f.pow` Ã§aÄŸÄ±rÄ±yormuÅŸ gibi bir kayan noktaydÄ±. ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- `bool`'a yayÄ±n yaparken `NaN`'yi `false`'a zorlayÄ±n. ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9))
- `i8`/`u8` or `i16`/`u16` tipi kÃ¼Ã§Ã¼k bir tamsayÄ± deÄŸerini kaydÄ±rÄ±rken, RHS deÄŸerinin yalnÄ±zca sÄ±rasÄ±yla 3 en Ã¶nemsiz 4 biti sonucu etkiler; bu, bir `i32.shl`'nin RHS deÄŸerinin yalnÄ±zca en Ã¶nemsiz 5 bitinden etkilenmesine benzer. Ã–rnek: `someI8 << 8` daha Ã¶nce `0` deÄŸerini Ã¼retti, ancak ÅŸimdi RHS'yi `8 & 7 = 0` (3 bits) olarak maskelediÄŸi iÃ§in `someI8` Ã¼retiyor. ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0))
- Boyutlar farklÄ± olduÄŸunda iliÅŸkisel dizi karÅŸÄ±laÅŸtÄ±rmalarÄ±nÄ±n hata dÃ¼zeltmesi. ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
