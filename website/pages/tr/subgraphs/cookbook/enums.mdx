---
title: NFT Pazar Yerlerini Enums Kullanarak Kategorize Etme
---

Kodu daha temiz yapmak ve hata yapma riskini azaltmak için Enums kullanın. İşte NFT pazar yerlerinde Enums kullanımına bir örnek.

## Enum'lar Nedir?

Enum'lar veya numaralandırma türleri, bir dizi izin verilen değeri tanımlamanıza olanak tanıyan belirli bir veri türüdür.

### Şemanızda Enum Örnekleri

Bir pazar yerinde token sahiplik geçmişini izlemek için bir subgraph oluşturuyorsanız, her token `OriginalOwner`, `SecondOwner` ve `ThirdOwner` gibi farklı sahipliklerden geçebilir. Enum'ları kullanarak, bu belirli sahiplikleri tanımlayabilir ve yalnızca önceden tanımlanmış değerlerin atanmasını sağlayabilirsiniz.

Şemanızda enum tanımlayabilir ve bir kez tanımlandığında, bir varlık üzerinde bir enum alanı ayarlamak için enum değerlerinin dizi (string) gösterimini kullanabilirsiniz.

İşte yukarıdaki örneğe dayanarak, şemanızda bir enum tanımı şöyle görünebilir:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

This means that when you use the `TokenStatus` type in your schema, you expect it to be exactly one of predefined values: `OriginalOwner`, `SecondOwner`, or `ThirdOwner`, ensuring consistency and validity.

Enum'lar hakkında daha fazla bilgi edinmek için [Subgraph Oluşturma](/developing/creating-a-subgraph/#enums) ve [GraphQL dokümantasyonu](https://graphql.org/learn/schema/#enumeration-types) kaynaklarına göz atın.

## Enum Kullanmanın Faydaları

- **Anlaşılırlık:** Enum'lar değerlere anlamlı isimler verir, veriyi daha anlaşılır hale getirir.
- **Doğrulama:** Enum'lar katı değer tanımlamaları uygulayarak geçersiz veri girişlerini önler.
- **Bakım Kolaylığı:** Yeni kategoriler eklemek veya mevcut olanları değiştirmek gerektiğinde, enum'lar bunu odaklı bir şekilde yapmanıza olanak tanır.

### Enum'lar Olmadan

Türü Enum kullanmak yerine bir dize olarak tanımlamayı seçerseniz, kodunuz şöyle görünebilir:

```graphql
type Token @entity {
  id: ID!
  tokenId: BigInt!
  owner: Bytes! # Token Sahibi
  tokenStatus: String! # Token Durumunu Takip Eden Dize Alanı
  timestamp: BigInt!
}
```

Bu şemada, `TokenStatus` belirli, alabileceği değerler sınırlandırılmış olmayan basit bir dizedir.

#### Bu neden bir sorun?

- `TokenStatus` değerleri için bir kısıtlama yoktur. Bu yüzden yanlışlıkla herhangi bir dize atanabilir. Bu, yalnızca `OriginalOwner`, `SecondOwner` veya `ThirdOwner` gibi geçerli durumların ayarlandığını sağlamayı zorlaştırır.
- `OriginalOwner` yerine `Orgnalowner` gibi yazım hataları yaparak verilerin ve potansiyel sorguların güvenilmez hale gelmesine sebep olmak kolaydır.

### Enum Kullanımıyla

Serbest formda dizeler atamak yerine, `TokenStatus` için `OriginalOwner`, `SecondOwner` veya `ThirdOwner` gibi belirli değerlerle bir enum tanımlanabilir. Bir enum kullanmak, yalnızca izin verilen değerlerin kullanılmasını sağlar.

Enumlar; tür güvenliği sağlar, yazım hatası riskini en aza indirir ve tutarlı ve güvenilir sonuçlar sağlar.

## NFT Pazar Yerleri için Enum Tanımlama

> Not: Aşağıdaki kılavuz CryptoCoven NFT akıllı sözleşmesini kullanmaktadır.

NFT'lerin ticaretinin yapıldığı çeşitli pazar yerleri için enum tanımlamak için subgraph şemanızda aşağıdakini kullanın:

```gql
# Enum for Marketplaces that the CryptoCoven contract interacted with(likely a Trade/Mint)
enum Marketplace {
  OpenSeaV1 # Represents when a CryptoCoven NFT is traded on the marketplace
  OpenSeaV2 # Represents when a CryptoCoven NFT is traded on the OpenSeaV2 marketplace
  SeaPort # Represents when a CryptoCoven NFT is traded on the SeaPort marketplace
  LooksRare # Represents when a CryptoCoven NFT is traded on the LookRare marketplace
  # ...and other marketplaces
}
```

## NFT Pazar Yerleri için Enum Kullanımı

Tanımlandıktan sonra, enum'lar işlemleri veya olayları kategorize etmek için subgraph'inizde kullanılabilir.

Örneğin, NFT satışlarını kaydederken takasta yer alan pazar yerini enum kullanarak belirleyebilirsiniz.

### NFT Pazar Yerleri için Bir Fonksiyon İmplementasyonu

Here's how you can implement a function to retrieve the marketplace name from the enum as a string:

```ts
export function getMarketplaceName(marketplace: Marketplace): string {
  // Enum değerini bir dizeye eşlemek için if-else ifadelerini kullanma
  if (marketplace === Marketplace.OpenSeaV1) {
    return 'OpenSeaV1' // I Eğer pazar yeri OpenSea ise, onun dize temsilini döndür 
  } else if (marketplace === Marketplace.OpenSeaV2) {
    return 'OpenSeaV2'
  } else if (marketplace === Marketplace.SeaPort) {
    return 'SeaPort' // Eğer pazar yeri SeaPort ise, onun dize temsilini döndür
  } else if (marketplace === Marketplace.LooksRare) {
    return 'LooksRare' // Eğer pazar yeri LooksRare ise, onun dize temsilini döndür
    // ... ve diğer pazar yerleri
  }
}
```

## Enum Kullanımı için En İyi Uygulamalar

- **Tutarlı İsimlendirme:** Okunabilirliği artırmak için enum değerleri için net, açıklayıcı isimler kullanın.
- **Merkezi Yönetim:** Tutarlılık için enum'ları tek bir dosyada tutun. Böylece enum'ların güncellenmesi kolaylaşmış olur ve onların tek bir doğru bilgi kaynağı olmasını sağlar.
- **Dokümantasyon:** Amaçlarını ve kullanımını açıklamak için enum'a yorumlar ekleyin.

## Sorgularda Enum Kullanımı

Enums in queries help you improve data quality and make your results easier to interpret. They function as filters and response elements, ensuring consistency and reducing errors in marketplace values.

**Specifics**

- **Filtering with Enums:** Enums provide clear filters, allowing you to confidently include or exclude specific marketplaces.
- **Enums in Responses:** Enums guarantee that only recognized marketplace names are returned, making the results standardized and accurate.

### Sample Queries

#### Query 1: Account With The Highest NFT Marketplace Interactions

This query does the following:

- It finds the account with the highest unique NFT marketplace interactions, which is great for analyzing cross-marketplace activity.
- The marketplaces field uses the marketplace enum, ensuring consistent and validated marketplace values in the response.

```gql
{
  accounts(first: 1, orderBy: uniqueMarketplacesCount, orderDirection: desc) {
    id
    sendCount
    receiveCount
    totalSpent
    uniqueMarketplacesCount
    marketplaces {
      marketplace # This field returns the enum value representing the marketplace
    }
  }
}
```

#### Returns

This response provides account details and a list of unique marketplace interactions with enum values for standardized clarity:

```gql
{
  "data": {
    "accounts": [
      {
        "id": "0xb3abc96cb9a61576c03c955d75b703a890a14aa0",
        "sendCount": "44",
        "receiveCount": "44",
        "totalSpent": "1197500000000000000",
        "uniqueMarketplacesCount": "7",
        "marketplaces": [
          {
            "marketplace": "OpenSeaV1"
          },
          {
            "marketplace": "OpenSeaV2"
          },
          {
            "marketplace": "GenieSwap"
          },
          {
            "marketplace": "CryptoCoven"
          },
          {
            "marketplace": "Unknown"
          },
          {
            "marketplace": "LooksRare"
          },
          {
            "marketplace": "NFTX"
          }
        ]
      }
    ]
  }
}
```

#### Query 2: Most Active Marketplace for CryptoCoven transactions

This query does the following:

- It identifies the marketplace with the highest volume of CryptoCoven transactions.
- It uses the marketplace enum to ensure that only valid marketplace types appear in the response, adding reliability and consistency to your data.

```gql
{
  marketplaceInteractions(first: 1, orderBy: transactionCount, orderDirection: desc) {
    marketplace
    transactionCount
  }
}
```

#### Result 2

The expected response includes the marketplace and the corresponding transaction count, using the enum to indicate the marketplace type:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "Unknown",
        "transactionCount": "222"
      }
    ]
  }
}
```

#### Query 3: Marketplace Interactions with High Transaction Counts

This query does the following:

- It retrieves the top four marketplaces with over 100 transactions, excluding "Unknown" marketplaces.
- It uses enums as filters to ensure that only valid marketplace types are included, increasing accuracy.

```gql
{
  marketplaceInteractions(
    first: 4
    orderBy: transactionCount
    orderDirection: desc
    where: { transactionCount_gt: "100", marketplace_not: "Unknown" }
  ) {
    marketplace
    transactionCount
  }
}
```

#### Result 3

Expected output includes the marketplaces that meet the criteria, each represented by an enum value:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "NFTX",
        "transactionCount": "201"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "148"
      },
      {
        "marketplace": "CryptoCoven",
        "transactionCount": "117"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "111"
      }
    ]
  }
}
```

## Ek Kaynaklar

For additional information, check out this guide's [repo](https://github.com/chidubemokeke/Subgraph-Tutorial-Enums).
