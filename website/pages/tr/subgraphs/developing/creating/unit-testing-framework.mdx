---
title: Birim Testi Framework'Ã¼
---

Learn how to use Matchstick, a unit testing framework developed by [LimeChain](https://limechain.tech/). Matchstick enables subgraph developers to test their mapping logic in a sandboxed environment and sucessfully deploy their subgraphs.

## Benefits of Using Matchstick

- It's written in Rust and optimized for high performance.
- It gives you access to developer features, including the ability to mock contract calls, make assertions about the store state, monitor subgraph failures, check test performance, and many more.

## Buradan BaÅŸlayÄ±n

### Install Dependencies

In order to use the test helper methods and run tests, you need to install the following dependencies:

```sh
yarn add --dev matchstick-as
```

### Install PostgreSQL

`graph-node` depends on PostgreSQL, so if you don't already have it, then you will need to install it.

> Note: It's highly recommended to use the commands below to avoid unexpected errors.

#### Using MacOS

Installation command:

```sh
brew install postgresql
```

En son libpq.5.lib'e bir sembolik baÄŸ oluÅŸturun. _Bu dizini Ã¶nce oluÅŸturmanÄ±z gerekebilir_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Using Linux

Installation command (depends on your distro):

```sh
sudo apt install postgresql
```

### Using WSL (Windows Subsystem for Linux)

Matchstick'i WSL'de Docker yaklaÅŸÄ±mÄ± ve ikili yaklaÅŸÄ±mÄ± kullanarak kullanabilirsiniz. WSL biraz alengirli olabileceÄŸinden, aÅŸaÄŸÄ±daki gibi sorunlarla karÅŸÄ±laÅŸÄ±rsanÄ±z birkaÃ§ ipucu verelim

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

yada

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

LÃ¼tfen daha yeni bir Node.js sÃ¼rÃ¼mÃ¼nde olduÄŸunuzdan emin olun. graph-cli artÄ±k **v10.19.0**'Ä± desteklemiyor ve bu sÃ¼rÃ¼m, hala WSL'deki yeni Ubuntu gÃ¶rÃ¼ntÃ¼lerinin varsayÄ±lan sÃ¼rÃ¼mÃ¼dÃ¼r. Ã–rneÄŸin, Matchstick'in **v18.1.0** ile WSL'de Ã§alÄ±ÅŸtÄ±ÄŸÄ± doÄŸrulandÄ±, **nvm** aracÄ±lÄ±ÄŸÄ±yla veya global Node.js'inizi gÃ¼ncelleyerek buna geÃ§ebilirsiniz. Nodejs'nizi gÃ¼ncelledikten sonra `node_modules`'Ä± silmeyi ve `node_modules`'u tekrar Ã§alÄ±ÅŸtÄ±rmayÄ± unutmayÄ±n! Daha sonra, **libpq** yÃ¼klÃ¼ olduÄŸundan emin olun, bunu Ã§alÄ±ÅŸtÄ±rarak yapabilirsiniz

```
sudo apt-get install libpq-dev
```

Son olarak, `graph test`'i kullanmayÄ±n (global graph-cli yÃ¼klemenizi kullanmaktadÄ±r ve bazÄ± nedenlerden dolayÄ± ÅŸu anda WSL'de bozuk gibi gÃ¶rÃ¼nÃ¼yor), bunun yerine `yarn test` veya `npm run test` kullanÄ±n (bu, proje dÃ¼zeyindeki yerel graph-cli Ã¶rneÄŸini kullanacaktÄ±r, bu da harika Ã§alÄ±ÅŸÄ±r). Bunun iÃ§in tabiki `package.json` dosyanÄ±zda bir `"test"` script'i olmasÄ± gerektiÄŸini unutmayÄ±n, bunun gibi basit bir ÅŸey olabilir

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### Using Matchstick

**Matchstick**'i subgraph proje'nizde kullanmak iÃ§in sadece bir terminal aÃ§Ä±n, proje'nizin kÃ¶k(root) klasÃ¶rÃ¼ne gidin ve basitÃ§e `graph test [options] <datasource>` - komutunu Ã§alÄ±ÅŸtÄ±rÄ±n - bu en son **Matchstick** ikili dosyasÄ±nÄ± indirir ve belirtilen testi veya test klasÃ¶rÃ¼ndeki tÃ¼m testleri Ã§alÄ±ÅŸtÄ±rÄ±r (verikaynaÄŸÄ± bayraÄŸÄ± belirtilmezse mevcut tÃ¼m testler).

### CLI seÃ§enekleri

Bu, test klasÃ¶rÃ¼ndeki tÃ¼m testleri Ã§alÄ±ÅŸtÄ±racaktÄ±r:

```sh
graph test
```

Bu, gravity.test.ts adÄ±nda bir testi ve/veya gravity adÄ±nda bir klasÃ¶rdeki tÃ¼m testleri Ã§alÄ±ÅŸtÄ±racaktÄ±r:

```sh
graph test gravity
```

Bu sadece belirtilen test dosyasÄ±nÄ± Ã§alÄ±ÅŸtÄ±racaktÄ±r:

```sh
graph test path/to/file.test.ts
```

**SeÃ§enekler:**

```sh
-c, --coverage                Testleri kapsama modunda Ã§alÄ±ÅŸtÄ±rÄ±r
-d, --docker                  Testleri bir docker konteynerinde Ã§alÄ±ÅŸtÄ±rÄ±r (Not: Subgraph kÃ¶k klasÃ¶rÃ¼nden Ã§alÄ±ÅŸtÄ±rÄ±n)
-f,  --force                   Ä°kili: Ä°kilinin yeniden indirilmesini saÄŸlar. Docker: Dockerfile'Ä±n yeniden indirilmesi ve docker gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼n yeniden oluÅŸturulmasÄ±.
-h, --help                    KullanÄ±m bilgilerini gÃ¶sterir
-l, --logs                    Ä°ÅŸletim sistemi, CPU modeli ve indirme URL'si hakkÄ±nda konsola gÃ¼nlÃ¼k bilgilerini yazar (hata ayÄ±klama amaÃ§lÄ±dÄ±r)
-r, --recompile               Testlerin yeniden derlenmesini zorlar
-v, --version <tag>           Ä°ndirmek/kullanmak istediÄŸiniz rust ikilisinin sÃ¼rÃ¼mÃ¼nÃ¼ seÃ§menize yarar
```

### Docker

`graph-cli 0.25.2`'den itibaren `graph test` `-d` bayraÄŸÄ± ile `matchstick`'i bir docker konteynerinde Ã§alÄ±ÅŸtÄ±rmayÄ± desteklemektedir. Docker uygulamasÄ±, [bind mount](https://docs.docker.com/storage/bind-mounts/) kullandÄ±ÄŸÄ±ndan, `graph test -d` komutu her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda docker gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ yeniden oluÅŸturmak zorunda deÄŸildir. Alternatif olarak, [matchstick](https://github.com/LimeChain/matchstick#docker-) deposundan docker'Ä± manuel olarak Ã§alÄ±ÅŸtÄ±rmak iÃ§in talimatlarÄ± izleyebilirsiniz.

â— `graph test -d`, `docker run`'un `-t` bayraÄŸÄ±yla Ã§alÄ±ÅŸmasÄ±nÄ± zorlar. Bu, etkileÅŸimli olmayan ortamlar (Ã¶rneÄŸin, GitHub CI) iÃ§inde Ã§alÄ±ÅŸtÄ±rmak iÃ§in kaldÄ±rÄ±lmalÄ±dÄ±r.

â— Daha Ã¶nce `graph test` Ã§alÄ±ÅŸtÄ±rdÄ±ysanÄ±z, docker build sÄ±rasÄ±nda aÅŸaÄŸÄ±daki hatayla karÅŸÄ±laÅŸabilirsiniz:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

Bu durumda, kÃ¶k klasÃ¶r iÃ§inde bir `.dockerignore` dosyasÄ± oluÅŸturun ve `node_modules/binary-install-raw/bin`'i ekleyin

### YapÄ±landÄ±rma

Matchstick, `matchstick.yaml` yapÄ±landÄ±rma dosyasÄ± aracÄ±lÄ±ÄŸÄ±yla Ã¶zel testler, kÃ¼tÃ¼phaneler ve manifest yolunu kullanacak ÅŸekilde yapÄ±landÄ±rÄ±labilir:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Demo subgraph

[Demo Subgraph repo](https://github.com/LimeChain/demo-subgraph)sunu klonlayarak bu kÄ±lavuzdaki Ã¶rnekleri deneyebilir ve ve istediÄŸinizi yapabilirsiniz

### Ã–ÄŸretici videolar

AyrÄ±ca, "["How to use Matchstick to write unit tests for your subgraphs"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)" konulu video serisine gÃ¶z atabilirsiniz

## Test yapÄ±sÄ±

_**Ã–NEMLÄ°: AÅŸaÄŸÄ±da aÃ§Ä±klanan test yapÄ±sÄ± `matchstick-as` sÃ¼rÃ¼mÃ¼nÃ¼n >=0.5.0 olmasÄ±nÄ± gerektirir**_

### describe()

`describe(name: String , () => {})` - Bir test grubunu tanÄ±mlar.

**_Notlar:_**

- _AÃ§Ä±klamalar zorunlu deÄŸildir. Hala test() fonksiyonunu describe() bloklarÄ±nÄ±n dÄ±ÅŸÄ±nda kullanabilirsiniz_

Ã–rnek:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

Ä°Ã§ iÃ§e `describe()` Ã¶rneÄŸi:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Bir test durumu tanÄ±mlar. test() fonksiyonunu describe() bloklarÄ± iÃ§inde veya baÄŸÄ±msÄ±z olarak kullanabilirsiniz.

Ã–rnek:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

yada

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Dosyadaki tÃ¼m testlerden Ã¶nce bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `beforeAll`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun baÅŸÄ±nda Ã§alÄ±ÅŸÄ±r.

Ã–rnekler:

`beforeAll` iÃ§indeki kod, dosyadaki _tÃ¼m_ testlerden Ã¶nce bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

`beforeAll` iÃ§indeki kod, ilk describe bloÄŸundaki tÃ¼m testlerden Ã¶nce bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = â€œFirst Gravatarâ€
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Dosyadaki tÃ¼m testlerden sonra bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `afterAll`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun sonunda Ã§alÄ±ÅŸÄ±r.

Ã–rnek:

`afterAll` iÃ§indeki kod, dosyadaki _tÃ¼m_ testlerden sonra bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

`afterAll` iÃ§indeki kod, ilk describe bloÄŸundaki tÃ¼m testlerden sonra bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Her testten Ã¶nce bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `beforeEach`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun her testinden Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

Ã–rnekler: `beforeEach` iÃ§indeki kod, her testten Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

`beforeEach` iÃ§indeki kod, yalnÄ±zca o describe bloÄŸundaki her testten Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // displayName'i 1. Gravatar olarak gÃ¼ncellemesi gereken kod

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // imageUrl'yi https://www.gravatar.com/avatar/0x0 olarak deÄŸiÅŸtirmesi gereken kod

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Her testten sonra bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `afterEach`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun her testinden sonra Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

Ã–rnekler:

`afterEach` iÃ§indeki kod, her testten sonra Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // displayName'i 1. Gravatar olarak gÃ¼ncellemesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // imageUrl'yi https://www.gravatar.com/avatar/0x0 olarak deÄŸiÅŸtirmesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

`afterEach` iÃ§indeki kod, yalnÄ±zca o describe bloÄŸundaki her testten sonra Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // displayName'i 1. Gravatar olarak gÃ¼ncellemesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // imageUrl'yi https://www.gravatar.com/avatar/0x0 olarak deÄŸiÅŸtirmesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## AÃ§Ä±klamalar

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

SÃ¼rÃ¼m 0.6.0 itibariyle, assert fonksiyonlarÄ± Ã¶zel hata mesajlarÄ±nÄ± da desteklemektedir

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id 0x123 olmalÄ±dÄ±r')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value 1'e eÅŸit olmalÄ±dÄ±r')
assert.notInStore('Gravatar', '0x124', 'Gravatar store'da olmamalÄ±dÄ±r')
assert.addressEquals(Address.zero(), Address.zero(), 'Adres sÄ±fÄ±r olmalÄ±dÄ±r')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Byte deÄŸerleri eÅŸit olmalÄ±dÄ±r')
assert.i32Equals(2, 2, 'I32, 2'ye eÅŸit olmalÄ±dÄ±r')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt 1'e eÅŸit olmalÄ±dÄ±r')
assert.booleanEquals(true, true, 'Boolean true olmalÄ±dÄ±r')
assert.stringEquals('1', '1', 'String 1'e eÅŸit olmalÄ±dÄ±r')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Array'ler eÅŸit olmalÄ±dÄ±r')
assert.tupleEquals(
 changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
 changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
 'Tuple'lar eÅŸit olmalÄ±dÄ±r',
)
assert.assertTrue(true, 'True olmalÄ±dÄ±r')
assert.assertNull(null, 'Null olmalÄ±dÄ±r')
assert.assertNotNull('not null', 'Null olmamalÄ±dÄ±r')
assert.entityCount('Gravatar', 1, '2 gravatar olmalÄ±dÄ±r')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet ÅŸablonunda bir veri kaynaÄŸÄ± olmalÄ±dÄ±r')
assert.dataSourceExists(
 'GraphTokenLockWallet',
 Address.zero().toHexString(),
 'GraphTokenLockWallet sÄ±fÄ±r adresi iÃ§in bir veri kaynaÄŸÄ±na sahip olmalÄ±dÄ±r',
)
```

## Bir Birim Testi YazÄ±n

[Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts)'taki Gravatar Ã¶rneklerini kullanarak nasÄ±l basit bir birim test gÃ¶rÃ¼neceÄŸini gÃ¶relim.

AÅŸaÄŸÄ±daki iÅŸleyici fonksiyonuna sahip olduÄŸumuzu varsayarsak (iki yardÄ±mcÄ± iÅŸlevle birlikte):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Ã–nce projemizde bir test dosyasÄ± oluÅŸturmamÄ±z gerekiyor. Bunun nasÄ±l gÃ¶rÃ¼nebileceÄŸine dair bir Ã¶rnek:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Bir test varlÄ±ÄŸÄ± oluÅŸturun ve bunu depoya baÅŸlangÄ±Ã§ durumu olarak kaydedin (isteÄŸe baÄŸlÄ±)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Mock etkinlikleri oluÅŸturun
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Az Ã¶nce oluÅŸturduÄŸumuz olaylarÄ± geÃ§iren Ã§aÄŸrÄ± eÅŸleÅŸtirme fonksiyonlarÄ±
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Deponun durumunu doÄŸrulayÄ±n
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Bir sonraki testi temiz bir sayfa Ã¼zerinde baÅŸlatmak iÃ§in depoyu boÅŸaltÄ±n
  clearStore()
})

test('Next test', () => {
  //...
})
```

Analiz edilecek Ã§ok fazla ÅŸey var! Ã–ncelikle fark etmemiz gereken Ã¶nemli ÅŸey AssemblyScript yardÄ±mcÄ± kÃ¼tÃ¼phanemiz (npm modÃ¼lÃ¼ olarak daÄŸÄ±tÄ±lÄ±r) `matchstick-as`'den iÅŸleri iÃ§e aktardÄ±ÄŸÄ±mÄ±z. Repositoriyi [burada](https://github.com/LimeChain/matchstick-as) bulabilirsiniz. `matchstick-as` bize yararlÄ± test yÃ¶ntemleri saÄŸlar ve ayrÄ±ca test bloklarÄ± oluÅŸturmak iÃ§in kullanacaÄŸÄ±mÄ±z `test()` iÅŸlevini tanÄ±mlar. Geri kalanÄ± oldukÃ§a aÃ§Ä±k - ÅŸÃ¶yle olur:

- Ä°lk durumumuzu ayarlÄ±yor ve bir Ã¶zel Gravatar varlÄ±ÄŸÄ± ekliyoruz;
- `createNewGravatarEvent()` fonksiyonunu kullanarak verileriyle birlikte iki `NewGravatar`r olay nesnesini tanÄ±mlÄ±yoruz;
- `handleNewGravatars()` yÃ¶ntemlerimizi bu olaylar iÃ§in Ã§aÄŸÄ±rÄ±yoruz ve Ã¶zel olay listemizi geÃ§iyoruz;
- Depo durumunu doÄŸruluyoruz. Bu nasÄ±l Ã§alÄ±ÅŸÄ±r? - Bir varlÄ±k tÃ¼rÃ¼ ve kimliÄŸinin benzersiz bir kombinasyonunu geÃ§iriyoruz. ArdÄ±ndan, bu varlÄ±kta belirli bir alanÄ± kontrol ediyoruz ve beklediÄŸimiz deÄŸeri almasÄ±nÄ± saÄŸlÄ±yoruz. Hem depoya eklediÄŸimiz ilk Gravatar VarlÄ±ÄŸÄ± iÃ§in hem de iÅŸleyici iÅŸlevi Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda eklenen iki Gravatar varlÄ±ÄŸÄ± iÃ§in bunu yapÄ±yoruz;
- Ve son olarak `clearStore()` kullanarak depoyu temizliyoruz, bÃ¶ylece bir sonraki testimiz temiz ve boÅŸ bir depo nesnesiyle baÅŸlayabilir. Ä°stediÄŸimiz kadar test bloÄŸu tanÄ±mlayabiliriz.

Ä°ÅŸte baÅŸardÄ±n - ilk testimizi oluÅŸturduk! ğŸ‘

Åimdi testlerimizi Ã§alÄ±ÅŸtÄ±rmak iÃ§in subgraph kÃ¶k klasÃ¶rÃ¼nÃ¼zde ÅŸunu Ã§alÄ±ÅŸtÄ±rmanÄ±z yeterlidir:

`graph test Gravity`

Ve her ÅŸey yolunda giderse aÅŸaÄŸÄ±dakiyle karÅŸÄ±laÅŸacaksÄ±nÄ±z:

![Matchstick "TÃ¼m testler geÃ§ildi!" diyor](/img/matchstick-tests-passed.png)

## Ã‡ok rastlanan test senaryolarÄ±

### Belirli bir durumla depoyu doldurma

KullanÄ±cÄ±lar bilinen bir varlÄ±k kÃ¼mesiyle depoyu doldurabilirler. AÅŸaÄŸÄ±daki Ã¶rnek depoyu Gravatar varlÄ±ÄŸÄ±yla baÅŸlatmak iÃ§in kullanÄ±labilir:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Olayla bir eÅŸleÅŸtirme fonksiyonu Ã§aÄŸÄ±rmak

KullanÄ±cÄ±, depoya baÄŸlÄ± bir eÅŸleÅŸtirme fonksiyonuna Ã¶zel bir olay oluÅŸturabilir ve onu iletebilir:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### TÃ¼m eÅŸitlemeleri olay fikstÃ¼rleriyle Ã§aÄŸÄ±rmak

KullanÄ±cÄ±lar test fikstÃ¼rleriyle eÅŸleÅŸtirmeleri Ã§aÄŸÄ±rabilirler.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Kontrat Ã§aÄŸrÄ±larÄ±nÄ± mocklama

KullanÄ±cÄ±lar sÃ¶zleÅŸme Ã§aÄŸrÄ±larÄ±nÄ± mocklayabilir:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

GÃ¶sterildiÄŸi gibi, bir sÃ¶zleÅŸme Ã§aÄŸrÄ±sÄ±nÄ± mocklamak ve bir dÃ¶nÃ¼ÅŸ deÄŸeri sabitlemek iÃ§in kullanÄ±cÄ±, bir sÃ¶zleÅŸme adresi, iÅŸlev adÄ±, iÅŸlev imzasÄ±, bir argÃ¼man dizisi ve elbette dÃ¶nÃ¼ÅŸ deÄŸerini saÄŸlamalÄ±dÄ±r.

KullanÄ±cÄ±lar ayrÄ±ca fonksiyon geri Ã§evirilerinide mocklayabilirler:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### IPFS dosyalarÄ±nÄ± mocklama (Matchstick 0.4.1'den)

KullanÄ±cÄ±lar `mockIpfsFile(hash, filePath)` fonksiyonunu kullanarak IPFS dosyalarÄ±nÄ± mocklama yeteneÄŸine sahiptirler. Fonksiyon, ilk argÃ¼manÄ± IPFS dosya hash/yol'u ve ikinci argÃ¼manÄ± yerel bir dosyanÄ±n yolu olmak Ã¼zere iki argÃ¼man kabul eder.

NOT: `ipfs.map/ipfs.mapJSON`'u test ederken matchstck'in bunu algÄ±lamasÄ± iÃ§in geri Ã§aÄŸrÄ±ma iÅŸlevinin test dosyasÄ±ndan dÄ±ÅŸa aktarÄ±lmasÄ± gerekiyor, Ã¶rneÄŸin aÅŸaÄŸÄ±daki test Ã¶rneÄŸindeki `processGravatar()` fonksiyonu gibi:

`.test.ts` dosyasÄ±:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Matchstck'in algÄ±lamasÄ± iÃ§in ipfs.map() geri Ã§aÄŸrÄ±sÄ±nÄ± dÄ±ÅŸa aktarÄ±n
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` dosyasÄ±:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// ipfs.map geri Ã§aÄŸrÄ±sÄ±
export function processGravatar(value: JSONValue, userData: Value): void {
  // Ä°ÅŸlem yapmayla ilgili ayrÄ±ntÄ±lar iÃ§in JSONValue belgelerine bakÄ±n
  // JSON deÄŸerleri ile
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Geri Ã§aÄŸrÄ±lar ayrÄ±ca varlÄ±klar oluÅŸturabilir
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// ipfs.cat'i Ã§aÄŸÄ±ran fonksiyon
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Depo durumunu doÄŸrulama

KullanÄ±cÄ±lar, varlÄ±klarÄ± doÄŸrulayarak deponun nihai (veya orta) durumunu doÄŸrulayabilirler. Bunun iÃ§in, kullanÄ±cÄ± bir VarlÄ±k tÃ¼rÃ¼, bir VarlÄ±ÄŸÄ±n belirli bir kimliÄŸi, o VarlÄ±ktaki bir alanÄ±n adÄ± ve alanÄ±n beklenen deÄŸerini saÄŸlamalÄ±dÄ±r. HÄ±zlÄ±ca bir Ã¶rneÄŸe bakalÄ±m:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

assert.fieldEquals () fonksiyonunu Ã§alÄ±ÅŸtÄ±rmak, verilen alanÄ±n verilen beklenen deÄŸere karÅŸÄ± eÅŸitliÄŸini kontrol edecektir. DeÄŸerler eÅŸit **DEÄÄ°LSE** test baÅŸarÄ±sÄ±z olacak ve bir hata mesajÄ± verecektir. Aksi takdirde, test baÅŸarÄ±lÄ± bir ÅŸekilde geÃ§ecektir.

### Olay Ã¼st verileriyle etkileÅŸim

KullanÄ±cÄ±lar `newMockEvent()` fonksiyonunu kullanarak ethereum.Event dÃ¶ndÃ¼rebilen varsayÄ±lan iÅŸlem Ã¼st verilerini kullanabilir. AÅŸaÄŸÄ±daki Ã¶rnek, Olay nesnesindeki bu alanlara nasÄ±l okuma/yazma yapabileceÄŸinizi gÃ¶sterir:

```typescript
// Okuma
let logType = newGravatarEvent.logType

// Yazma
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### DeÄŸiÅŸken eÅŸitliÄŸini doÄŸrulama

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Bir varlÄ±ÄŸÄ±n depoda olmadÄ±ÄŸÄ±nÄ±(**not**) doÄŸrulama

KullanÄ±cÄ±lar, bir varlÄ±ÄŸÄ±n depoda olmadÄ±ÄŸÄ±nÄ± doÄŸrulayabilirler. Bu fonksiyon, bir varlÄ±k tÃ¼rÃ¼ ve bir kimlik alÄ±r. EÄŸer varlÄ±k gerÃ§ekten depoda ise, test ilgili bir hata mesajÄ± vererej baÅŸarÄ±sÄ±z olacaktÄ±r. Fonksiyonun nasÄ±l kullanÄ±lacaÄŸÄ±na dair hÄ±zlÄ±ca bir Ã¶rneÄŸe bakalÄ±m:

```typescript
assert.notInStore('Gravatar', '23')
```

### TÃ¼m maÄŸazayÄ± veya tÃ¼m maÄŸazadan tek varlÄ±klarÄ± yazdÄ±rma (hata ayÄ±klama amaÃ§lÄ±)

Bu yardÄ±mcÄ± fonksiyon kullanÄ±larak deponun tamamÄ± konsola yazdÄ±rÄ±labilir:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

SÃ¼rÃ¼m 0.6.0 itibarÄ±yla, `logStore` tÃ¼retilmiÅŸ alanlarÄ± yazdÄ±rmaz. Bunun yerine kullanÄ±cÄ±lar yeni `logEntity` fonksiyonunu kullanabilir. Elbette ki `logEntity`, yalnÄ±zca tÃ¼retilmiÅŸ alanlara sahip olanlarÄ± deÄŸil, herhangi bir varlÄ±ÄŸÄ± yazdÄ±rmak iÃ§in kullanÄ±labilir. `logEntity`, varlÄ±k tÃ¼rÃ¼nÃ¼, varlÄ±k kimliÄŸini ve ilgili tÃ¼retilmiÅŸ varlÄ±klarÄ± yazdÄ±rmak isteyip istemediÄŸinizi belirten bir `showRelated` bayraÄŸÄ±nÄ± alÄ±r.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### Beklenen baÅŸarÄ±sÄ±zlÄ±k

KullanÄ±cÄ±lar, shouldFail bayraÄŸÄ±nÄ± test() fonksiyonlarÄ±nda kullanarak beklenen test baÅŸarÄ±sÄ±zlÄ±klarÄ±na sahip olabilirler:

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Test, shouldFail = true olarak iÅŸaretlenirse ama BAÅARISIZ olmazsa, bu kayÄ±tlarda bir hata olarak gÃ¶rÃ¼necek ve test bloÄŸu baÅŸarÄ±sÄ±z olacaktÄ±r. AyrÄ±ca, with shouldFail = false (the default state) olarak iÅŸaretlenirse, test yÃ¼rÃ¼tÃ¼cÃ¼sÃ¼ Ã§Ã¶kecektir.

### KayÄ±t tutma

Birim testlerinde Ã¶zel kayÄ±t tutmanÄ±n eÅŸitlemelerdeki kayÄ±t tutmaktan tamamen aynÄ±dÄ±r. Fark, gÃ¼nlÃ¼k nesnesinin graph-ts yerine matchstick-as'dan iÃ§e aktarÄ±lmasÄ± gerektmesidir. Ä°ÅŸte tÃ¼m kritik olmayan kayÄ±t tÃ¼rleriyle ilgili basit bir Ã¶rnek:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

KullanÄ±cÄ±lar ayrÄ±ca ÅŸu ÅŸekilde kritik bir hatayÄ± simÃ¼le edebilirler:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Kritik hatalarÄ± kayÄ±t altÄ±na almak, testlerin yÃ¼rÃ¼tÃ¼lmesini durduracak ve her ÅŸeyi mahvedecektir. SonuÃ§ta, kodunuzun daÄŸÄ±tÄ±mda kritik kayÄ±tlarÄ± iÃ§ermediÄŸinden emin olmak istiyoruz ve bunun olmasÄ± durumunda hemen fark etmeniz gerekiyor.

### TÃ¼retilmiÅŸ alanlarÄ±n test edilmesi

TÃ¼retilmiÅŸ alanlarÄ± test etme Ã¶zelliÄŸi, belirli bir varlÄ±kta bir alan belirleyip, bu varlÄ±ktan tÃ¼retilmiÅŸ bir alan iÃ§eriyoren baÅŸka bir varlÄ±ÄŸÄ±n otomatik olarak gÃ¼ncellenmesini saÄŸlayan bir Ã¶zelliktir.

SÃ¼rÃ¼m `0.6.0` Ã¶ncesinde, tÃ¼retilmiÅŸ varlÄ±klarÄ±a varlÄ±k alanlarÄ±/Ã¶zellikleri olarak eriÅŸerek ÅŸu ÅŸekilde ulaÅŸmak mÃ¼mkÃ¼ndÃ¼:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

SÃ¼rÃ¼m `0.6.0` itibarÄ±yla bu iÅŸlem, graph-nodeâ€™un `loadRelated` fonksiyonu kullanÄ±larak yapÄ±lmaktadÄ±r. TÃ¼retilmiÅŸ varlÄ±klara, iÅŸleyicilerdekiyle aynÄ± ÅŸekilde eriÅŸilebilir.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### `loadInBlock`'u Test Etme

SÃ¼rÃ¼m `0.6.0` itibarÄ±yla, kullanÄ±cÄ±lar `loadInBlock` iÅŸlevini `mockInBlockStore` kullanarak test edebilir, bu sayede blok Ã¶nbelleÄŸindeki varlÄ±klarÄ± simÃ¼le edebilirler.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('entity.loadInBlock() metodunu kullanarak mevcut bloktaki Ã¶nbellek depodan varlÄ±ÄŸÄ± alabilir', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test('VarlÄ±k mevcut blokta yoksa entity.loadInBlock() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda null dÃ¶ndÃ¼rÃ¼r', () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Dinamik Veri KaynaklarÄ±nÄ±n Test Edilmesi

Dinamik veri kaynaklarÄ±nÄ±n test edilmesi dataSource ad alanÄ±nÄ±n `context()`, `address()` ve `network()` fonksiyonlarÄ±nÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸerlerinin mocklanmasÄ±yla yapÄ±labilir. Bu fonksiyonlar ÅŸu anda ÅŸunlarÄ± dÃ¶ndÃ¼rmektedir: `context()` - boÅŸ bir varlÄ±k dÃ¶ndÃ¼rÃ¼r (DataSourceContext), `address()` - `0x0000000000000000000000000000000000000000` dÃ¶ndÃ¼rÃ¼r, `network()` - `mainnet` dÃ¶ndÃ¼rÃ¼r. `create(...)` ve `createWithContext(...)` fonksiyonlarÄ± hiÃ§bir ÅŸey yapmamak iÃ§in mocklanmÄ±ÅŸtÄ±r bu nedenle testlerde Ã§aÄŸrÄ±lmalarÄ± gerekmez. DÃ¶nÃ¼ÅŸ deÄŸerlerinde yapÄ±lacak deÄŸiÅŸiklikler `matchstick-as`'deki (version 0.3.0+)`dataSourceMock` ad alanÄ±nÄ±n fonksiyonlarÄ±yla yapÄ±labilir.

AÅŸaÄŸÄ±daki Ã¶rnekte:

Ã–ncelikle aÅŸaÄŸÄ±daki olay iÅŸleyicisine sahibiz (veri kaynaÄŸÄ± mocklamasÄ±nÄ± gÃ¶stermek iÃ§in kasÄ±tlÄ± olarak amaÃ§ deÄŸiÅŸikliÄŸi):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

ArdÄ±ndan, dataSourceMock ad alanÄ±ndaki yÃ¶ntemlerden birini kullanarak tÃ¼m veri kaynaÄŸÄ± fonksiyonlarÄ± iÃ§in yeni bir geri dÃ¶nÃ¼ÅŸ deÄŸeri ayarlayan testi gÃ¶rÃ¼yoruz:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

dataSourceMock.resetValues()'in en sonda Ã§aÄŸrÄ±ldÄ±ÄŸÄ±na dikkat edin. Bunun nedeni deÄŸerler deÄŸiÅŸtirildiÄŸinde hatÄ±rlanÄ±r ve varsayÄ±lan deÄŸerlere geri dÃ¶nmek istiyorsanÄ±z sÄ±fÄ±rlanmalarÄ± gerekir.

### Dinamik veri kaynaÄŸÄ± oluÅŸturulmasÄ±nÄ±n test edilmesi

SÃ¼rÃ¼m `0.6.0` itibarÄ±yla, yeni bir veri kaynaÄŸÄ±nÄ±n bir ÅŸablonu temel alarak oluÅŸturulup oluÅŸturulmadÄ±ÄŸÄ±nÄ± test etmek mÃ¼mkÃ¼ndÃ¼r. Bu Ã¶zellik hem ethereum/sÃ¶zleÅŸme hem de dosya/ipfs ÅŸablonlarÄ±nÄ± destekler. Bunun iÃ§in dÃ¶rt fonksiyon bulunmaktadÄ±r:

- `assert.dataSourceCount(templateName, expectedCount)` belirli bir ÅŸablondan beklenen veri kaynaÄŸÄ± sayÄ±sÄ±nÄ± doÄŸrulamak iÃ§in kullanÄ±labilir
- `assert.dataSourceExists(templateName, address/ipfsHash)` belirli bir ÅŸablondan belirtilen kimliÄŸe sahip (bu kimlik sÃ¶zleÅŸme adresi veya IPFS dosya hashâ€™i olabilir) bir veri kaynaÄŸÄ±nÄ±n oluÅŸturulmuÅŸ olduÄŸunu doÄŸrular
- `logDataSources(templateName)`, belirtilen ÅŸablonda bulunan tÃ¼m veri kaynaklarÄ±nÄ± hata ayÄ±klama amacÄ±yla konsola yazdÄ±rÄ±r
- `readFile(path)`, bir IPFS dosyasÄ±nÄ± temsil eden JSON dosyasÄ±nÄ± okur ve iÃ§eriÄŸi Bytes olarak dÃ¶ndÃ¼rÃ¼r

#### `ethereum/contract` ÅŸablonlarÄ±nÄ±n test edilmesi

```typescript
test('ethereum/sÃ¶zleÅŸme dataSource oluÅŸturma Ã¶rneÄŸi', () => {
  // GraphTokenLockWallet ÅŸablonundan oluÅŸturulmuÅŸ veri kaynaÄŸÄ± olmadÄ±ÄŸÄ±nÄ± doÄŸrula
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A adresiyle yeni bir GraphTokenLockWallet veri kaynaÄŸÄ± oluÅŸtur
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // datSource oluÅŸturulduÄŸunu doÄŸrula
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Ä°kinci dataSource'u baÄŸlamÄ±yla ekle
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Åimdi 2 veri kaynaÄŸÄ± olduÄŸunu doÄŸrula
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" adresine sahip bir veri kaynaÄŸÄ±nÄ±n oluÅŸturulduÄŸunu doÄŸrula
  // `Address` tÃ¼rÃ¼ Ã§Ã¶zÃ¼mlendiÄŸinde kÃ¼Ã§Ã¼k harfe dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼ÄŸÃ¼nden, doÄŸrulama yaparken adresi tamamen kÃ¼Ã§Ã¼k harf olarak geÃ§melisiniz
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### `logDataSource` Ã§Ä±ktÄ±sÄ± Ã¶rneÄŸi

```bash
ğŸ›   {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
}
```

#### `dosya/ipfs` ÅŸemalarÄ±nÄ± test etme

AkÄ±llÄ± sÃ¶zleÅŸme dinamik veri kaynaklarÄ±na benzer ÅŸekilde kullanÄ±cÄ±lar, test dosyasÄ± veri kaynaklarÄ±nÄ± ve bunlarÄ±n iÅŸleyicilerini test edebilirler

##### `subgraph.yaml` Ã¶rneÄŸi

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### `schema.graphql` Ã¶rneÄŸi

```graphql
"""
Kilitli GRT tutan Token Kilit CÃ¼zdanlarÄ±
"""
type TokenLockMetadata @entity {
  "Token kilit cÃ¼zdanÄ±nÄ±n adresi"
  id: ID!
  "Serbest bÄ±rakma programÄ±nÄ±n baÅŸlangÄ±Ã§ zamanÄ±"
  startTime: BigInt!
  "Serbest bÄ±rakma programÄ±nÄ±n bitiÅŸ zamanÄ±"
  endTime: BigInt!
  "BaÅŸlangÄ±Ã§ zamanÄ± ile bitiÅŸ zamanÄ± arasÄ±ndaki periyot sayÄ±sÄ±"
  periods: BigInt!
  "Serbest bÄ±rakmalarÄ±n baÅŸladÄ±ÄŸÄ± zaman"
  releaseStartTime: BigInt!
}
```

##### `metadata.json` Ã¶rneÄŸi

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Ä°ÅŸleyici Ã¶rneÄŸi

```typescript
export function handleMetadata(content: Bytes): void {
  // dataSource.stringParams() File Veri KaynaÄŸÄ± CID'sini dÃ¶ndÃ¼rÃ¼r
  // stringParam() iÅŸleyici testinde taklit edilecektir
  // daha fazla bilgi iÃ§in https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  process - files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Test Ã¶rneÄŸi

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('dosya/ipfs veri kaynaÄŸÄ± oluÅŸturma Ã¶rneÄŸi', () => {
  // ipfsHash + ipfs dosya yolu kullanÄ±larak veri kaynaÄŸÄ± CID'si oluÅŸturulur
  // Ã–rneÄŸin QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // OluÅŸturulan CID kullanÄ±larak yeni bir dataSource oluÅŸturulur
  GraphTokenLockMetadata.create(CID)

  // dataSource oluÅŸturulduÄŸunu doÄŸrula
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Åimdi dataSource metadatasÄ±nÄ± ve spesifik olarak dataSource.stringParam()'Ä± taklit etmemiz gerekiyor
  // dataSource.stringParams aslÄ±nda dataSource.address() deÄŸerini kullanÄ±r, bu yÃ¼zden  matchstick-as kÃ¼tÃ¼phanesinden aldÄ±ÄŸÄ±mÄ±z dataSourceMock ile adresi taklit edeceÄŸiz
  // Ä°lk olarak deÄŸerleri sÄ±fÄ±rlayÄ±p ardÄ±ndan dataSourceMock.setAddress() ile CID'yi atayacaÄŸÄ±z
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)

  // Åimdi dataSource iÅŸleyicisine geÃ§irmek iÃ§in Bytes oluÅŸturmalÄ±yÄ±z
  // Bunun yerel bir json dosyasÄ±nÄ± okuyan ve iÃ§eriÄŸini Bytes olarak dÃ¶ndÃ¼ren readFile fonksiyonunu kullanÄ±yoruz
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Åimdi bir TokenLockMetadata'nÄ±n oluÅŸturulup oluÅŸturulmadÄ±ÄŸÄ±nÄ± test edeceÄŸiz
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Test KapsamÄ±

Subgraph geliÅŸtiricileri **Matchstick'i** kullanarak, yazÄ±lan birim testlerinin test kapsamÄ±nÄ± hesaplayacak bir komut dosyasÄ± Ã§alÄ±ÅŸtÄ±rabilirler.

Test kapsama aracÄ± derlenmiÅŸ test `wasm` ikililerini alÄ±r ve bunlarÄ± daha sonra `subgraph.yaml` dosyasÄ±nda tanÄ±mlanan iÅŸlevlerin Ã§aÄŸrÄ±lÄ±p Ã§aÄŸrÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in kolayca incelenebilen `wat` dosyalarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Kod kapsamÄ± (ve bir bÃ¼tÃ¼n olarak test) AssemblyScript ve WebAssembly'de Ã§ok erken aÅŸamalarda olduÄŸundan, **Matchstick** dallanma kapsamÄ±nÄ± kontrol edemez. Bunun yerine, belirli bir iÅŸleyici Ã§aÄŸrÄ±lmÄ±ÅŸsa, bunun iÃ§in olay/fonksiyonun uygun ÅŸekilde taklit edildiÄŸi savÄ±na gÃ¼veniyoruz.

### Ã–n KoÅŸullar

**Matchstick** tarafÄ±ndan saÄŸlanan test kapsama fonksiyonlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in Ã¶nceden hazÄ±rlamanÄ±z gereken birkaÃ§ ÅŸey bulunmaktadÄ±r:

#### Ä°ÅŸleyicilerinizi dÄ±ÅŸa aktarÄ±n

**Matchstick**'in hangi iÅŸleyicilerin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmesi iÃ§in, bu iÅŸleyicilerin **test file**'dan dÄ±ÅŸa aktarÄ±lmasÄ± gerekir. Mesela, bizim Ã¶rneÄŸimizde gravity.test.ts dosyamÄ±zda aÅŸaÄŸÄ±daki iÅŸleyici iÃ§e aktarÄ±lÄ±r:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

Bu fonksiyonun gÃ¶rÃ¼nÃ¼r olmasÄ± iÃ§in (**adÄ±yla** `wat` dosyasÄ±na dahil edilmesi iÃ§in) ayrÄ±ca onuda ÅŸÃ¶yle dÄ±ÅŸa aktarmamÄ±z gerekmektedir:

```typescript
export { handleNewGravatar }
```

### KullanÄ±ÅŸ

Her ÅŸey hazÄ±r olduÄŸunda, test kapsama aracÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in basitÃ§e ÅŸunu Ã§alÄ±ÅŸtÄ±rÄ±n:

```sh
graph test -- -c
```

AyrÄ±ca `package.json` dosyanÄ±za ÅŸu ÅŸekilde Ã¶zel bir kapsama(`coverage`) komutu ekleyebilirsiniz:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Bu, kapsama aracÄ±nÄ± Ã§alÄ±ÅŸtÄ±racak ve terminalde buna benzer bir ÅŸey gÃ¶receksiniz:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 ï¸
Reading generated test modules... ğŸ”ï¸

Generating coverage report ğŸ“

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Tutulan kayÄ±t Ã§Ä±ktÄ±sÄ±nda test Ã§alÄ±ÅŸma sÃ¼resi

Tutulan kayÄ±t Ã§Ä±ktÄ±sÄ± test Ã§alÄ±ÅŸma sÃ¼resini iÃ§erir. Ä°ÅŸte buna bir Ã¶rnek:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Ã‡ok rastlanan derleyici hatalarÄ±

> Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined

Bu hata kodunuzda `console.log` kullandÄ±ÄŸÄ±nÄ±z anlamÄ±na gelir. Bu komut AssemblyScript tarafÄ±ndan desteklenmez. LÃ¼tfen [Logging API](/subgraphs/developing/creating/graph-ts/api/#logging-api)'yi kullanmayÄ± dÃ¼ÅŸÃ¼nÃ¼n.

> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
>
> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

ArgÃ¼manlardaki uyumsuzluk, `graph-ts` ve `matchstick-as` arasÄ±ndaki uyumsuzluktan kaynaklanÄ±r. Bu gibi sorunlarÄ± dÃ¼zeltmenin en iyi yolu her ÅŸeyi en son yayÄ±nlanan sÃ¼rÃ¼me gÃ¼ncellemektir.

## Ek Kaynaklar

For any additional support, check out this [demo subgraph repo using Matchstick](https://github.com/LimeChain/demo-subgraph#readme_).

## Geribildirim

Soru, geri bildirim, Ã¶zellik istekleri veya sadece iletiÅŸim kurmak istiyorsanÄ±z en iyi yer Matchstick iÃ§in ayrÄ±lmÄ±ÅŸ bir kanal olan ğŸ”¥| unit-testing kanalÄ±na sahip olduÄŸumuz The Graph Discord'udur.
