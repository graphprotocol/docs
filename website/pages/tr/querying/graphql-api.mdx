---
title: GraphQL API
---

Bu kılavuz, Graph Protokolü için kullanılan GraphQL sorgu API'ını açıklar.

## Sorgular

Subgraph şemanızda `Entities` adlı türleri tanımlarsınız. Her `Entity` türü için, üst düzey `Query` türünde bir `entity` ve `entities` alanı oluşturulur. Graph kullanılırken `query` öğesinin `graphql` sorgusunun en üstüne eklenmesi gerekmediğini unutmayın.

### Örnekler

Şemanızda tanımlanan tek bir `token` varlığını sorgulayın:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> **Not:** Tek bir varlık için sorgulama yaparken `id` alanı zorunludur ve bir dize olmalıdır.

Tüm `Token` varlıklarını sorgulayın:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Sıralama

Bir koleksiyonu sorgularken, belirli bir niteliğe göre sıralamak için `orderBy` parametresi kullanılabilir. Ayrıca, sıralama yönünü belirtmek için `orderDirection` kullanılabilir; artan için `asc` veya azalan için `desc`.

#### Örnek

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### İç içe varlık sıralaması için örnek

Graph Düğümü [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0)'dan itibaren varlıklar iç içe geçmiş varlıklar bazında sıralanabilir.

Aşağıdaki örnekte, tokenleri sahiplerinin adına göre sıralıyoruz:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> Şu anda, `@entity` ve `@derivedFrom` alanlarında tek seviye derinliğindeki `String` veya `ID` tiplerine göre sıralama yapabilirsiniz. Ne yazık ki, [tek seviye derinliğindeki varlıklarda arayüzlere göre sıralama](https://github.com/graphprotocol/graph-node/pull/4058), diziler ve iç içe geçmiş varlıklar olan alanlara göre sıralama henüz desteklenmemektedir.

### Sayfalandırma

Bir koleksiyonu sorgularken, koleksiyonun başından itibaren sayfalama yapmak için `first` parametresi kullanılabilir. Varsayılan sıralama düzeninin oluşturma zamanına göre değil, artan alfanümerik düzende ID'ye göre olduğunu belirtmekte fayda var.

Ayrıca, `skip` parametresi varlıkları atlamak ve sayfalandırmak için kullanılabilir. örn. `first:100` ilk 100 varlığı gösterir ve `first:100, skip:100` sonraki 100 varlığı gösterir.

Sorgular genellikle kötü performans gösterdiğinden çok büyük `skip` değerleri kullanmaktan kaçınmalıdır. Çok sayıda öğeyi almak için, son örnekte gösterildiği gibi bir özniteliğe dayalı olarak varlıklar arasında sayfa açmak çok daha idealdir.

#### `first`'ün kullanımına örnek

İlk 10 tokeni sorgulayın:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

Bir koleksiyonun ortasındaki varlık gruplarını sorgulamak için `skip` parametresi, koleksiyonun başından başlayarak belirli sayıda varlığı atlamak üzere `first` parametresi ile birlikte kullanılabilir.

#### `first` ve `skip`'in kullanımına örnek

10 `Token` varlığını sorgulayın, bunları koleksiyonun başlangıcından itibaren 10 sıra kaydırın:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### `first` ve `id_ge`'nin kullanımına örnek

Bir istemcinin çok sayıda varlığı alması gerekiyorsa, sorguları bir niteliğe dayandırmak ve bu niteliğe göre filtrelemek çok daha performanslıdır. Örneğin, bir istemci bu sorguyu kullanarak çok sayıda token alabilir:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

İlk seferinde, sorguyu `lastID = ""` ile gönderecek ve sonraki istekler için `lastID`'yi önceki istekteki son varlığın `id` niteliğine ayarlayacaktır. Bu yaklaşım, artan `skip` değerleri kullanmaktan önemli ölçüde daha iyi performans gösterecektir.

### Filtreleme

Sorgularınızda `where` parametresini kullanarak farklı özellikler için filtreleme yapabilirsiniz. `where` parametresi içerisinde birden fazla değer için filtreleme yapabilirsiniz.

#### `where`'in kullanımına örnek

`failed` ile sonuçlanan sorgu zorlukları:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Değer karşılaştırması için `_gt`, `_lte` gibi son ekler kullanabilirsiniz:

#### Aralık filtreleme için örnek

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Blok filtreleme için örnek

Varlıkları `_change_block(number_gte: Int)` ile de filtreleyebilirsiniz. Bu, belirtilen blok içinde veya sonrasında güncellenen varlıkları filtreler.

Örneğin bu, son yoklamanızdan bu yana yalnızca değişen varlıkları almak istiyorsanız yararlı olabilir. Ya da alternatif olarak, subgraph'ınızda varlıkların nasıl değiştiğini araştırmak veya hata ayıklamak için yararlı olabilir (bir blok filtresiyle birleştirilirse, yalnızca belirli bir blokta değişen varlıkları izole edebilirsiniz).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### İç içe varlık filtreleme örneği

İç içe geçmiş varlıklar temelinde filtreleme, `_` son ekine sahip alanlarda mümkündür.

Bu, yalnızca alt düzey varlıkları sağlanan koşulları karşılayan varlıkları getirmek istiyorsanız yararlı olabilir.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Mantıksal operatörler

Graph Düğümü'nün [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) sürümüne göre, birden fazla parametreyi aynı `where` argümanında gruplayabilirsiniz. Bu, sonuçları birden fazla kritere göre filtrelemek için `and` veya `or` operatörlerini kullanmanıza olanak tanır.

##### `AND` Operatörü

Aşağıdaki örnekte, `outcome` değeri `succeeded` olan ve `number` değeri `100`'den büyük veya buna eşit olan zorlukları filtreliyoruz.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Syntactic sugar:** Yukarıdaki sorguyu, virgülle ayrılmış bir alt ifade geçirerek, `and` operatörünü kaldırarak basitleştirebilirsiniz.
> 
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### `OR` Operatörü

Aşağıdaki örnekte, `outcome` değeri `succeeded` olan veya `number` değeri `100` yada daha büyük olan zorlukları filtreliyoruz.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Not**: Sorguları oluştururken, `or` operatörünü kullanmanın performans üzerindeki etkisini göz önünde bulundurmak önemlidir. `or` arama sonuçlarını genişletmek için yararlı bir araç olsa da, önemli maliyetleri de olabilir. `or` ile ilgili temel sorunlardan biri, sorguların yavaşlamasına neden olabilmesidir. Bunun nedeni, `or` operatörünün veritabanının birden fazla dizini taramasını gerektirmesidir ve bu da zaman alıcı bir işlem olabilir. Bu sorunlardan kaçınmak için, geliştiricilerin mümkün olduğunda or yerine and operatörlerini kullanmaları önerilir. Bu, daha hassas filtreleme sağlar ve daha hızlı, daha doğru sorgulara yol açabilir.

#### Tüm Filtreler

Parametre eklerinin tam listesi:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Lütfen bazı eklentilerin yalnızca belirli tipler için desteklendiğini unutmayın. Örneğin, `Boolean` yalnızca `_not`, `_in` ve `not_in` desteği sağlar, ancak `_` yalnızca nesne ve arayüz tipleri için kullanılabilir.

Ayrıca, aşağıdaki global filtreler `where` argümanının bir parçası olarak kullanılabilir:

```gr
_change_block(number_gte: Int)
```

### Zaman yolculuğu sorguları

Varlıklarınızın durumunu yalnızca varsayılan olan en son blok için değil, aynı zamanda geçmişteki rastgele bir blok için de sorgulayabilirsiniz. Bir sorgunun gerçekleşmesi gereken blok, sorguların üst düzey alanlarına bir `block` bağımsız değişkeni eklenerek blok numarası veya blok karması ile belirtilebilir.

Böyle bir sorgunun sonucu zaman içinde değişmeyecektir, yani belirli bir geçmiş blokta sorgu yapmak, ne zaman yürütülürse yürütülsün aynı sonucu verecektir, ancak zincirin başına çok yakın bir blokta sorgu yaptığınız zaman, bu bloğun ana zincirde olmadığı ortaya çıkarsa ve zincir yeniden düzenlenirse sonuç değişebilir. Bir blok nihai olarak kabul edildiğinde takdirde, sorgunun sonucu değişmeyecektir.

Lütfen şunu göz önünde bulundurun ki mevcut uygulama hala belirli sınırlamalara tabidir ve bu garantiyi ihlal edebilir. Uygulama her zaman verilen bir blok hash değerinin ana zincirde olup olmadığını ya da henüz kesinleştirilmemiş bir blok için blok hash değeri ile yapılan sorgunun, sorgu ile eş zamanlı olarak gerçekleşen bir blok yeniden düzenlemesi tarafından etkilenebileceğini bilemeyebilir. Ancak bu durum, blok kesinleştirildiğinde ve ana zincirde bulunduğu biliniyorsa, blok hash değeri ile yapılan sorguların sonuçlarını etkilemez. [Bu sorun](https://github.com/graphprotocol/graph-node/issues/1405), bu sınırlamaların ayrıntılarını detaylı bir şekilde açıklamaktadır.

#### Örnek

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Bu sorgu, 8.000.000 numaralı bloğun işlenmesinden hemen sonra var oldukları şekliyle `Challenge` varlıklarını ve bunlarla ilişkili `Application` varlıklarını döndürür.

#### Örnek

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Bu sorgu, verilen hash ile bloğun işlenmesinden hemen sonra var olan şekliyle `Challenge` varlıklarını ve bunlarla ilişkili `Application` varlıklarını döndürür.

### Tam Metin Arama Sorguları

Tam metin arama sorgu alanları, subgraph şemasına eklenebilen ve özelleştirilebilen etkileyici bir metin arama API'si sağlar. Subgraph'ınıza tam metin araması eklemek için [Tam Metin Arama Alanlarını Tanımlama](/developing/creating-a-subgraph#defining-fulltext-search-fields) bölümüne göz atın.

Tam metin arama sorgularının kullanması gereken bir zorunlu alanı vardır, bu alan `text` adını taşır ve arama terimlerini sağlamak için kullanılır. Bu `text` arama alanında kullanılmak üzere birkaç özel tam metin operatörü mevcuttur.

Tam metin arama operatörleri:

| Sembol      | Operatör    | Tanımlama                                                                                                                             |
| ----------- | ----------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `&`     | `And`       | Birden fazla arama terimini, sağlanan tüm terimleri içeren varlıklar için bir filtrede birleştirmek için kullanılır                   |
| &#x7c;      | `Or`        | Or, işleciyle ayrılmış birden çok arama terimi içeren sorgular, sağlanan terimlerden herhangi biriyle eşleşen tüm varlıkları döndürür |
| `<->` | `Follow by` | İki kelime arasındaki mesafeyi belirtir.                                                                                              |
| `:*`        | `Prefix`    | Ön eki eşleşen kelimeleri bulmak için önek arama terimini kullanın (2 karakter gereklidir.)                                           |

#### Örnekler

`or` operatörünü kullanan bu sorgu, tam metin alanlarında "anarchism" veya "crumpet" varyasyonları bulunan blog varlıklarını filtreleyecektir.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

`follow by` operatörü, tam metin belgelerinde belirli bir mesafe uzaklıktaki kelimeleri belirtir. Aşağıdaki sorgu "decentralize" ve ardından "philosophy" kelimelerinin geçtiği tüm blogları döndürür

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Daha karmaşık filtreler oluşturmak için tam metin operatörlerini birleştirin. Bu örnek sorgu, bir pretext arama işleci ile bir follow by işlecini birleştirerek "lou" ile başlayan ve ardından "music" ile devam eden sözcükleri içeren tüm blog varlıklarıyla eşleşecektir.

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Validasyon

Graph Düğümü, [graphql-js referans uygulamasını](https://github.com/graphql/graphql-js/tree/main/src/validation) temel alan [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules)'yi kullanarak aldığı GraphQL sorgularının [spesifikasyon tabanlı](https://spec.graphql.org/October2021/#sec-Validation) doğrulamasını gerçekleştirir. Bir doğrulama kuralını geçemeyen sorgular standart bir hata ile sonuçlanır. Daha fazla bilgi için [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation)'i ziyaret edin.

## Şema

Veri kaynağınızın şeması, sorgulamak için kullanılabilen varlık tipleri, değerler ve ilişkiler [GraphQL Arayüz Tanımlama Dili (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System) aracılığıyla tanımlanır.

GraphQL şemaları genellikle `queries`, `subscriptions` ve `mutations` için root tipleri tanımlar. Graph yalnızca `queries` destekler. Subgraph'ınız için root `Query` tipi, subgraph bildiriminize dahil edilen GraphQL şemasından otomatik olarak oluşturulur.

> **Not:** API'miz mutations tipini açığa çıkarmaz çünkü geliştiricilerin uygulamalarından doğrudan temelindeki blok zincire karşı işlemleri gerçekleştirmeleri beklenir.

### Varlıklar

Şemanızda `@entity` yönergeleri bulunan tüm GraphQL türleri varlık olarak değerlendirilir ve bir `ID` alanına sahip olmalıdır.

> **Not:** Şu anda, şemanızdaki tüm tiplerin bir `@entity` yönergesine sahip olması gerekmektedir. İlerleyen zamanlarda, `@entity` yönergesi olmadan tanımlanan tipleri değer nesneleri olarak ele alacağız, ancak bu henüz desteklenmemektedir.

### Subgraph Üst Verisi

Tüm subgraphlar, subgraph üst verisine erişim sağlayan otomatik olarak oluşturulmuş bir `_Meta_` nesnesine sahiptir. Bu aşağıdaki gibi sorgulanabilir:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

Eğer bir blok belirtilirse, üst veri o blokla ilgilidir; belirtilmezse en son dizinlenen blok dikkate alınır. Eğer belirtilirse, blok subgraph başlangıç bloğundan sonra olmalıdır ve en son indekslenen bloğa eşit veya daha küçük olmalıdır.

`deployment` eşsiz bir kimliktir ve `subgraph.yaml` dosyasının IPFS CID'sine karşılık gelir.

`block` en son blok hakkında bilgi sağlar (`_meta`'ya aktarılan blok kısıtlamalarını dikkate alarak):

- hash: bloğun hash'i
- number: blok numarası
- timestamp: varsa, bloğa ait timestamp (bu şu anda yalnızca EVM ağlarını indeksleyen subgraph'ler için kullanılabilir)

`hasIndexingErrors` ifadesi, subgraph'ın önceki bazı bloklarda indeksleme hatalarıyla karşılaşıp karşılaşmadığını belirleyen bir boolean değeridir
