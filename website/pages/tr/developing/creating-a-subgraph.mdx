---
title: Subgraph Oluşturma
---

Subgraph, verileri bir blok zincirinden çıkarır, işler ve GraphQL aracılığıyla kolayca sorgulanabilmesi için depolar.

![Subgraph Tanımlama](/img/defining-a-subgraph.png)

Subgraph tanımı birkaç dosyadan oluşmaktadır:

- `subgraph.yaml`: Subgraph manifest'ini içeren bir YAML dosyası

- `schema.graphql`: Subgraph içinde depolanan verileri ve GraphQL üzerinden nasıl sorgulayacağınızı tanımlayan bir GraphQL şeması

- `AssemblyScript Mappings`: Olay verilerinden şemanızda tanımlanan varlıklara çeviri yapan [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) kodu (örneğin bu öğretici içerikte `mapping.ts`)

> Subgraph'ınızı Graph'ın merkeziyetsiz ağında kullanmak için [API anahtarı oluşturmanız gerekir](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key). Ayrıca subgraph'ınıza en az [10,000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network) [sinyal eklemeniz](/network/curating/#how-to-signal) önerilir.

Manifest dosyasının içeriği hakkında detaylı bilgilere girmeden önce, bir subgraph oluşturmak ve dağıtmak için ihtiyacınız olan [Graph CLI](https://github.com/graphprotocol/graph-cli)'yi yüklemeniz gereklidir.

## Graph CLI'ı Yükleyin

Grafik CLI, JavaScriptle yazılmıştır ve kullanmak için `yarn` veya `npm` kurmanız gerekir; aşağıdaki içerik yarn yüklediğinizi varsaymaktadır.

`Yarn`'a sahip olduğunuzda, Grafik CLI'yi çalıştırarak yükleyin

**Yarn ile kurulum:**

```bash
yarn global add @graphprotocol/graph-cli
```

**Npm ile kurulum:**

```bash
npm install -g @graphprotocol/graph-cli
```

Kurulduktan sonra `graph init` komutu, mevcut bir sözleşmeden veya örnek bir subgraph'ten yeni bir subgraph projesi oluşturmak için kullanılabilir. Bu komut, `graph init --product subgraph-studio`'yi geçerek Subgraph Stüdyo'da bir subgraph oluşturmak için kullanılabilir. Halihazırda tercih ettiğiniz ağa konuşlandırılmış bir akıllı sözleşmeniz varsa, bu sözleşmeden yeni bir subgraph'i önyüklemek başlamak için iyi bir yol olabilir.

## Mevcut Bir Sözleşmeden

Aşağıdaki komut, mevcut bir sözleşmenin tüm olaylarını indeksleyen bir subgraph oluşturur. Sözleşme ABI'sini Etherscan'dan almaya çalışır ve yerel bir dosya yolu istemeye geri döner. İsteğe bağlı argümanlardan herhangi biri eksikse, sizi etkileşimli bir formdan geçirir.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>`, Subgraph Studio'daki subgraph kimliğidir ve subgraph ayrıntıları sayfanızda bulunabilir.

## Örnek Bir Subgraph'dan

`Graph init`'in desteklediği ikinci mod, örnek bir subgraph'dan yeni bir proje oluşturmayı destekler. Aşağıdaki komut bunu yapar:

```sh
graph init --studio <SUBGRAPH_SLUG>
```

Örnek subgraph, kullanıcı avatarlarını yöneten ve avatarlar oluşturulduğunda veya güncellendiğinde `NewGravatar` veya `UpdateGravatar` olaylarını yayınlayan Dani Grant'in Gravity sözleşmesine dayanmaktadır. Subgraph, bu olayları `Gravatar` varlıklarını Graph Node depolama alanına yazarak ve bunların olaylara göre güncellenmesini sağlayarak işler. Aşağıdaki bölümlerde, bu örnek için subgraph manifest'ini oluşturan dosyaların üzerinden geçilecektir.

## Mevcut Bir Subgraph'a Yeni veriKaynakları(dataSources) Ekleme

`v0.31.0` 'dan itibaren, `graph-cli`, var olan bir subgraph'a `graph add` komutu aracılığıyla yeni veriKaynakları(dataSources) eklemeyi destekler.

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Seçenekler:

      --abi <path>              Sözleşme ABI'sinin yolu (varsayılan: Etherscan'dan indir)
      --contract-name           Sözleşme adı (varsayılan: Contract)
      --merge-entities          Aynı ada sahip varlıkların birleştirilip birleştirilmeyeceği (varsayılan: false)
      --network-file <path>     Ağ yapılandırma dosyası yolu (varsayılan: "./networks.json")
```

`add` komutu, ABI'yi Etherscan'den getirecektir (`--abi` seçeneğiyle bir ABI yolu belirtilmedikçe) ve tıpkı `graph init` komutunun şemayı güncelleyerek ve eşleştirerek bir `dataSource` `--from-contract` oluşturması gibi yeni bir `dataSource` oluşturacaktır.

`--merge-entities` seçeneği, geliştiricinin `entity` ve `event` ad çakışmalarını nasıl ele alacağını belirler:

- `true` ise: yeni `dataSource` mevcut `eventHandlers` & `entities`'i kullanmalıdır.
- `false` ise: `${dataSourceName}{EventName}` ile yeni bir entity(varlık) & event handler(olay işleyicisi) oluşturulmalıdır.

Sözleşme `adresi`, ilgili ağ için `networks.json`'a yazılacaktır.

> **Not:** Etkileşimli cli kullanırken, `graph init` başarıyla çalıştırdıktan sonra yeni bir `dataSource` eklemeniz istenecektir.

## Subgraph Manifestosu

Subgraph manifest'i `subgraph.yaml`, subgraph'ınız tarafından indekslenen akıllı sözleşmeleri, bu sözleşmelerdeki hangi olaylara dikkat edileceğini ve olay verilerinin Graph Node'un depoladığı ve sorgulamasına izin verdiği varlıklarla nasıl eşleneceğini tanımlar. Subgraph manifestlerinin tüm özelliklerini [burada](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md) bulabilirsiniz.

Örnek subgraph için `subgraph.yaml` şöyledir:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

Manifest için güncellenmesi gereken önemli girdiler şunlardır:

- `description`: Subgraph'ın ne olduğuna dair insanlar tarafından okunabilir bir açıklama. Bu açıklama, subgraph Barındırma Servisine dağıtıldığında Graph Gezgini tarafından görüntülenir.

- `repository`: Subgraph manifest'inin bulunabileceği havuz URL'si. Ayrıca Graph Gezgini tarafından da görüntülenir.

- `features`: kullanılan tüm [özellik(feature)](#experimental-features) adlarının bir listesi.

- `dataSources.source`: Subgraph kaynaklarının olduğu akıllı sözleşmenin adresi ve kullanılacak akıllı sözleşmenin ABI'si. Adres isteğe bağlıdır; atlanması, tüm sözleşmelerden eşleşen olayları dizine eklemeyi sağlar.

- `dataSources.source.startBlock`: veri kaynağının indekslemeye başladığı isteğe bağlı blok numarası. Çoğu durumda, sözleşmenin oluşturulduğu bloğun kullanılmasını öneririz.

- `dataSources.mapping.entities`: veri kaynağının depoya yazdığı varlıklar. Her varlık için şema, schema.graphql dosyasında tanımlanır.

- `dataSources.mapping.abis`: kaynak sözleşmesinin yanı sıra eşleştirmelerde içeriden etkileşimde bulunduğunuz diğer akıllı sözleşmeler için bir veya daha fazla isimlendirilmiş ABI dosyası.

- `dataSources.mapping.eventHandlers`: bu subgraph'ın tepki verdiği akıllı sözleşme olaylarını ve bu olayları depodaki varlıklara dönüştüren eşleştirme içindeki işleyicileri —./src/mapping.ts örnekte— listeler.

- `dataSources.mapping.callHandlers`: bu subgraph'ın tepki verdiği akıllı sözleşme fonksiyonlarını ve fonksiyon çağrılarına giriş ve çıkışları depodaki varlıklara dönüştüren eşleştirmedeki işleyicileri listeler.

- `dataSources.mapping.blockHandlers`: Bu subgraph'ın tepki verdiği blokları ve zincire bir blok eklendiğinde çalışacak eşleştirmedeki işleyicileri listeler. Filtre olmadan, blok işleyici her blokta çalıştırılacaktır. Opsiyonel bir çağrı filtresi, işleyiciye bir `filter` alan ile `kind: call` eklenerek sağlanabilir. Bu, blok veri kaynağı sözleşmesine en az bir çağrı içeriyorsa yanlızca işleyiciyi çalıştırır.

Bir subgraph birden fazla akıllı sözleşmeden veri indeksleyebilir. `dataSources` dizisine indekslenmesi gereken veriden her kontrata bir giriş ekleyin.

Bir bloktaki veri kaynağı için tetikleyiciler şu işlemlerle sıralanır:

1. Olay ve çağrı tetikleyicileri, öncelikle bloktaki işlem indeksine göre sıralanır.
2. Aynı işlemdeki olay ve çağrı tetikleyicileri, bir kurala göre sıralanır: önce olay tetikleyicileri, ardından çağrı tetikleyicileri olmak üzere her tür manifest'te tanımlandıkları sıraya göre sıralanır.
3. Blok tetikleyicileri, olay ve çağrı tetikleyicilerinden sonra manifest'te tanımlandıkları sırada göre çalıştırılır.

Bu sıralama kuralları değişebilir.

### ABI'leri Alma

ABI dosya(lar)ı sözleşme(ler) inizle uygun olmalıdır. ABI dosyalarını edinmek için birkaç yol vardır:

- Kendi projenizi oluşturuyorsanız, muhtemelen en güncel ABI'lerinize erişiminiz olacaktır.
- Herkese açık bir proje için bir alt grafik oluşturuyorsanız, projeyi bilgisayarınıza indirerek [`truffle compile`](https://truffleframework.com/docs/truffle/overview) veya derlemek için solc kullanarak ABI'yi alabilirsiniz.
- ABI'yi ayrıca [Etherscan](https://etherscan.io/)'de de bulabilirsiniz, ancak bu her zaman güvenilir değildir çünkü yüklenen ABI güncelliğini yitirmiş olabilir. Doğru ABI'ye sahip olduğunuzdan emin olun, aksi takdirde subgraph çalıştırma başarısız olacaktır.

## GraphQL Şeması

Subgraph'ınızın şeması `schema.graphql` dosyasındadır. GraphQL şemaları, GraphQL arayüzü tanımlama dili kullanılarak tanımlanır. Daha önce bir GraphQL şeması yazmadıysanız, GraphQL tipi sisteme yönelik bu içeriği kontrol etmeniz önerilir. GraphQL şema referans belgeleri [GraphQL API](/querying/graphql-api) bölümünde bulunabilir.

## Varlıkları Tanımlama

Varlıkları tanımlamadan önce, bir adım geri atıp verilerinizin nasıl yapılandırıldığını ve bağlantılı olduğunu düşünmek önemlidir. Tüm sorgular, altgrafik şemasında tanımlandığı şekilde veri modeline ve altgrafik tarafından dizine alınan varlıklara karşı yapılacaktır. Bu nedenle, subgraph şemasını dapp'iniz için ihtiyaçlarınıza uygun şekilde tanımlamanız iyi bir yaklaşım olacaktır. Varlıkları olaylar veya işlevler yerine "veri içeren nesneler" olarak farzetmek faydalı olabilir.

Graph ile `schema.graphql`'de basitçe varlık türlerini tanımlarsınız ve Graph Düğümü bu varlık türünün tek bir örneğini ve koleksiyonunu sorgulamak için üst düzey alanlar oluşturur. Bir varlık olarak kabul edilmesi gereken her tür, `@entity` yönergesi ile işaretlenmelidir. Varsayılan olarak varlıklar değişkendir, yani eşlemeler mevcut varlıkları yükleyebilir, değiştirebilir ve o varlığın yeni bir sürümünü depolayabilir. Değişebilirlik bir bedelle gelir ve örneğin zincirden kelimesi kelimesine çıkarılan verileri içerdiklerinden dolayı asla değiştirilmeyecekleri bilinen varlık türleri için, bunları `@entity(immutable: true)` ile değişmez olarak işaretlenmesi önerilir. Eşleştirmeler, değişiklikler varlığın oluşturulduğu aynı blokta gerçekleştiği sürece değişmez varlıklarda değişiklik yapabilir. Değişmez varlıklar çok daha hızlı yazılıp sorgulanabilir, bu nedenle mümkün olduğunca kullanılmalıdır.

### İyi Bir Örnek

Aşağıdaki `Gravatar` varlığı, bir Gravatar nesnesi etrafında yapılandırılmıştır ve bir varlığın nasıl tanımlanabileceğine iyi bir örnektir.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Kötü Bir Örnek

Aşağıdaki `GravatarAccepted` ve `GravatarDeclined` örnek varlıkları olayları temel alır. Olayların veya fonksiyon çağrılarının varlıklara birebir eşlenmesi önerilmez.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Opsiyonel ve Zorunlu Alanlar

Varlık alanları zorunlu veya opsiyonel olarak tanımlanabilir. Zorunlu alanlar şemada `!` ile belirtilir. Eğer zorunlu bir alan eşleştirme işlemi sırasında ayarlanmazsa, alanı sorgularken şu hatayı alırsınız:

```
Null value resolved for non-null field 'name'
```

Her varlık türü bir `id` alanına sahip olmalıdır ve bu alan `Bytes!` veya `String!` türünde olmalıdır. Genellikle, `id` insan tarafından okunabilir metin içeriyorsa `Bytes!` kullanılması önerilir çünkü `Bytes!` türündeki id'leri olan varlıklar, `String!` `id`'leri olanlardan daha hızlı yazılıp sorgulanabilir. `id` alanı birincil anahtar olarak hizmet eder ve aynı türdeki tüm varlıklar arasında benzersiz olması gerekir. Tarihi nedenlerden dolayı, `ID!` türü de kabul edilir ve `String!` ile eşanlamlıdır.

Bazı varlık türleri için `id`, iki diğer varlığın id'lerinden oluşturulur; bunu `concat` kullanarak yapmak mümkündür, örneğin `let id = left.id.concat(right.id)`, `sol(left)` ve `sağ(right)` id'lerinden id'yi oluşturmak için kullanılır. Benzer şekilde, var olan bir varlığın id'si ve sayıcı `sayısı(count)`kullanarak bir id oluşturmak için `let id = left.id.concatI32(count)` kullanılabilir. Birleştirme işleminin, `sol(left)`'in bu tür tüm varlıklar için aynı uzunlukta olduğu sürece benzersiz id'ler üretmesi garanti edilir, örneğin `left.id`'nin bir `Address` olması.

### Gömülü Skaler(Scalar) Türler

#### GraphQL'in Desteklediği Skalerler

GraphQL API'mizde aşağıdaki skalerleri destekliyoruz:

| Tür             | Tanım                                                                                                                                                                                                |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Baytlar`       | Byte dizisi, onaltılık bir dizgi olarak temsil edilir. Ethereum hash değerleri ve adresleri için yaygın olarak kullanılır.                                                                           |
| `Dizgi(String)` | `string` değerleri için skaler. Null karakterleri desteklenmez ve otomatik olarak kaldırılır.                                                                                                        |
| `Boolean`       | `boolean` değerleri için skaler.                                                                                                                                                                     |
| `Int`           | GraphQL özellikleri, `Int`'in 32 bayt boyutunda olduğunu tanımlar.                                                                                                                                   |
| `BigInt`        | Büyük tamsayılar. Ethereum'un `uint32`, `int64`, `uint64`, ..., `uint256` türleri için kullanılır. Not: `int32`, `uint24` veya `int8` gibi `uint32`'nin altındaki her şey `i32`olarak temsil edilir. |
| `BigDecimal`    | `BigDecimal` Yüksek hassasiyetli ondalık sayılar, bir anlamlı ve bir üsle temsil edilir. Üs aralığı -6143 ila +6144 arasındadır. 34 anlamlı rakama yuvarlanır.                                       |

#### Numaralandırmalar

Ayrıca bir şema içinde numaralandırmalar da oluşturabilirsiniz. Numaralandırmalar aşağıdaki sözdizimine sahiptir:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Numaralandırma şemada tanımlandıktan sonra, bir varlık üzerinde numaralandırma alanını ayarlamak için numaralandırma değerinin dizgi gösterimini kullanabilirsiniz Örneğin, önce varlığınızı tanımlayarak ve ardından alanı `entity.tokenStatus = "SecondOwner"` ile ayarlayarak `tokenStatus`'u `SecondOwner` olarak ayarlayabilirsiniz. Aşağıdaki örnek, Token varlığının bir numaralandırma alanıyla nasıl görüneceğini göstermektedir:

Numaralandırma yazmakla alakalı daha fazla ayrıntıyı [GraphQL belgelerinde](https://graphql.org/learn/schema/) bulabilirsiniz.

#### Varlık İlişkileri

Bir varlık, şemanızdaki bir veya daha fazla başka varlıkla ilişkili olabilir. Bu ilişkiler, sorgularınızda çaprazlanabilir. Graph'taki ilişkiler tek yönlüdür. İki yönlü ilişkileri simüle etmek, ilişkinin herhangi biri "son" üzerinde tek yönlü bir ilişki tanımlayarak mümkündür.

İlişkiler, belirtilen türün başka bir varlığın türü olması dışında, diğer tüm alanlarda olduğu gibi varlıklar üzerinde tanımlanır.

#### Bire Bir İlişkiler

Bir `TransactionReceipt` varlık türüyle isteğe bağlı bire bir ilişkiye sahip bir `İşlem(Transaction)` varlık türü tanımlayın:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### Birden Çoğa İlişkiler

Bir Token varlık türü ile zorunlu birden çoğa ilişkisi olan bir `TokenBalance` varlık türü tanımlayın:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Tersine Aramalar

Ters aramalar, `@derivedFrom` alanı aracılığıyla bir varlıkta tanımlanabilir. Bu, varlık üzerinde sorgulanabilecek ancak eşleştirme API'si aracılığıyla manuel olarak ayarlanamayacak bir sanal alan oluşturur. Aksine, diğer varlık üzerinde tanımlanan ilişkiden türetilir. Bu ilişkiler için, genellikle ilişkinin her iki tarafını da depolamak anlamsızdır ve hem indeksleme hem de sorgu performansı, sadece bir tarafta depolanması ve diğerinde türetilmesi durumunda daha iyi olacaktır.

Birden çoğa ilişkileriiçin, ilişki her zaman 'birden' tarafında depolanmalı ve her zaman 'çoğa' tarafında türetilmelidir. İlişkinin 'çoğa' tarafında bir dizi varlık depolamak yerine bu şekilde saklanması, subgraph indeksleme ve sorgulaması adına önemli ölçüde daha iyi performans sağlayacaktır. Genel olarak, varlık dizilerini depolamaktan mümkün olduğunca sakınılması gerekmektedir.

#### Örnek

Bir token bakiyelerini token'den erişilebilir hale getirebiliriz. Bunun için bir `tokenBalances` alanı türetmemiz gerekir:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Çoktan Çoğa İlişkiler

Kullanıcıların her birinin birden çok kuruluşa mensup olabileceği gibi çoktan çoğa ilişkilerde, ilişkiyi modellemenin en basit fakat pek verimli olmayan yolu, ilişkide yer alan iki varlıkta da bir dizi olarak saklamaktır. İlişki simetrik ise, ilişkinin yalnızca bir tarafının saklanması gerekir ve diğer taraf türetilebilir.

#### Örnek

`User` varlık türünden `Organization` varlık türüne bir tersine arama tanımlayın. Aşağıdaki örnekte bu, `Organization` varlığı içindeki `members` özniteliğini arayarak elde edilir. Sorgularda, `User` üzerindeki `organizations` alanı, kullanıcının kimliğini(id) içeren tüm `Organization` varlıklarını bulmak suretiyle çözümlenir.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Bu ilişkiyi daha performanslı bir şekilde depolamanın yolu, bunu her `User`/`Organization` çifti için bir girişe sahip bir eşleştirme tablosu aracılığıyla yapmaktır. Şema olarak şu şekilde olabilir

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

Bu yaklaşım, örneğin kullanıcılar için kuruluşları almak için sorguların ek bir seviyeye inmesini gerektirir:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

Çoktan çoğa ilişkileri depolamanın daha ayrıntılı bu yolu, subgraph için depolanan veri miktarının azalmasına ve bu sonucunda genellikle indekslenmesi ve sorgulanması önemli ölçüde daha hızlı olan bir subgraph sağlayacaktır.

#### Şemaya notlar/yorumlar ekleme

GraphQL spesifikasyonuna göre, şema varlık özniteliklerinin üzerinde çift tırnak işaretleri `""` kullanarak yorumlar eklenebilir. Bu aşağıdaki örnekte gösterilmiştir:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## Tam Metinde Arama Alanlarını Tanımlama

Tam metinde arama sorguları, metin arama girdisine dayanarak varlıkları filtreler ve sıralar. Tam metin sorguları, sorgu metni girişini dizine alınmış metin verileriyle karşılaştırmadan önce köklere işleyerek benzer kelimeler için eşleşmeler döndürebilir.

Tam metin sorgusu tanımı, sorgu adı, metin alanlarını işlemek için kullanılan dil sözlüğü, sonuçları sıralamak için kullanılan sıralama algoritması ve aramaya dahil edilen alanları içerir. Her tam metin sorgusu birden fazla alana yayılabilir, ancak dahil edilen tüm alanlar tek bir varlık türünden olmalıdır.

Tam metin sorgusu eklemek için, GraphQL şemasına tam metin yönergesi içeren bir `_Schema_` türü ekleyin.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

`bandSearch` örnek alanı, `name`,`description` ve `bio` alanlarındaki metin belgelerine göre `Band` varlıklarını filtrelemek için sorgularda kullanılabilir. Tam metin arama API'si ve daha fazla örnek kullanımı için [GraphQL API - Sorgulama](/querying/graphql-api#queries)'ya geçin.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Özellik Yönetimi](#experimental-features):** `specVersion` `0.0.4` ve sonrasında, `fullTextSearch`, alt grafik bildiriminde `features` bölümü altında belirtilmelidir.

### Desteklenen diller

Farklı bir dil seçmek, tam metin arama API'sı üzerinde bazen az olsa da kesin bir etkiye sahip olacaktır. Tam metin sorgu alanı tarafından kapsanan alanlar, seçilen dile bağlı olarak incelenir, bu nedenle analiz ve arama sorguları tarafından üretilen sözlükbirimleri dilden dile değişir. Örneğin: desteklenen Türkçe sözlük kullanıldığında "token" kelimesi "toke" olarak kök alınırken, elbette İngilizce sözlük "token" olarak kök alacaktır.

Desteklenen dil sözlükleri:

| Kod   | Sözlük     |
| ----- | ---------- |
| yalın | Genel      |
| da    | Danca      |
| nl    | Flemenkçe  |
| en    | İngilizce  |
| fi    | Fince      |
| fr    | Fransızca  |
| de    | Almanca    |
| hu    | Macarca    |
| it    | İtalyanca  |
| no    | Norveççe   |
| pt    | Portekizce |
| ro    | Romence    |
| ru    | Rusça      |
| es    | İspanyolca |
| sv    | İsveççe    |
| tr    | Türkçe     |

### Algoritmaları Sıralama

Sonuçları sıralamak için desteklenen algoritmalar:

| Algoritma     | Tanım                                                                               |
| ------------- | ----------------------------------------------------------------------------------- |
| rank          | Sonuçları sıralamak için tam metin sorgusunun eşleştirme kalitesini (0-1) kullanın. |
| proximityRank | Rank'a benzer ancak eşleşmelerin benzerliğini de içerir.                            |

## Eşleştirmeleri Yazma

Eşlemeler, verileri belirli bir kaynaktan alır ve şemanızda tanımlanan varlıklara dönüştürür. Eşlemeler, WASM ([WebAssembly](https://webassembly.org/))'ye derlenebilen [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki) adlı bir [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) alt kümesinde yazılır. AssemblyScript, normal TypeScript'ten daha katıdır, ancak yine de tanıdık bir sözdizimi sağlar.

`subgraph.yaml`'da `mapping.eventHandlers` altında tanımlanan her olay işleyicisi için, aynı isimde dışa aktarılmış bir fonksiyon oluşturun. Her işleyici, işlenen olayın adına karşılık gelen bir türde `event` adında tek bir parametre kabul etmelidir.

Örnek subgraph'ta,`src/mapping.ts` dosyası `NewGravatar` ve `UpdatedGravatar` olayları için işleyiciler içerir:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

İlk işleyici, `NewGravatar` olayını alır ve karşılık gelen olay parametrelerini kullanarak varlık alanlarını dolduran `new Gravatar(event.params.id.toHex())` ile yeni bir `Gravatar` varlığı oluşturur. Bu varlık örneği, `event.params.id.toHex()` kimlik değeri olan `gravatar` değişkeni tarafından temsil edilir.

İkinci işleyici, mevcut `Gravatar`'ı Graph Düğümü deposundan yüklemeye çalışır. Henüz mevcut değilse, talep üzerine oluşturulur. Varlık daha sonra `gravatar.save()` kullanılarak mağazaya geri kaydedilmeden önce yeni olay parametreleriyle eşleşecek şekilde güncellenir.

### Yeni Varlıklar Oluşturmak için Önerilen Kimlikler(IDs)

Her varlığın aynı türdeki tüm varlıklar arasında benzersiz olan bir `id`'si olması gerekir. Bir varlığın `id` değeri, varlık oluşturulduğunda belirlenir. Aşağıda, yeni varlıklar oluştururken hesaba katılması gereken bazı önerilen `id` değerleri verilmiştir. NOT: `id` değeri bir `dizgi` olmalıdır.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

Graph Düğümü deposuyla etkileşim için yardımcı programlar, akıllı sözleşme verileri ve varlıklarını işlemek için kolaylık sağlaması açısından [Graph Typescript Kütüphanesi](https://github.com/graphprotocol/graph-ts)'ni sunuyoruz. `mapping.ts`'de `@graphprotocol/graph-ts` 'yi içe aktararak bu kitaplığı eşleştirmelerinizde kullanabilirsiniz.

## Kod Oluşturma

Akıllı sözleşmeler, olaylar ve varlıklarla çalışmayı kolay ve tip güvenli hale getirmek amacıyla Graph CLI, subgraph'ın GraphQL şemasından ve veri kaynaklarında bulunan sözleşme ABI'lerinden AssemblyScript türleri oluşturabilir.

Bununla yapılır

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

ancak çoğu durumda, subgraphlar zaten `package.json` aracılığıyla önceden yapılandırılmıştır, bu nedenle aşağıdakilerden birini çalıştırarak aynı sonucu elde etmek mümkündür:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

Bu, `subgraph.yaml`'da belirtilen ABI dosyalarındaki her akıllı sözleşme için bir AssemblyScript sınıfı oluşturacak ve bu sözleşmeleri eşleştirmelerle belirli adreslere bağlamanıza ve işlenen bloğa karşı salt okunur sözleşme yöntemlerini çağırmanıza olanak tanıyacaktır. Ayrıca, her sözleşme olayı için bir sınıf oluşturacak ve olay parametrelerine kolay erişim sağlayacak, ayrıca olayın kaynaklandığı blok ve işlemi sağlayacaktır. Tüm bu tipler `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts` dosyasına yazılmaktadır. Örnek subgraph'ta, bu `generated/Gravity/Gravity.ts` olur, böylece eşleştirmelerin bu tipleri iç aktarmasına izin verilir.

```javascript
import {
  // Kontrat sınıfı:
  Gravity,
  // Olayların sınıfları:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

Bunun yanı sıra, subgraph'taki GraphQL şemasında bulunan her varlık türü için bir sınıf oluşturulur. Bu sınıflar, tip güvenli varlık yükleme, varlık alanlarına okuma ve yazma erişimi sağlar ve ayrıca bir `save()` yöntemi ile varlıkları depoya yazarlar. Tüm varlık sınıfları `<OUTPUT_DIR>/schema.ts`'ye yazılır, böylece eşleştirmeler şu şekilde bunları içe aktarabilir

```javascript
import { Gravatar } from '../generated/schema'
```

> **Not:** Kod oluşturma, GraphQL şemasındaki veya manifeste dahil edilen ABI'lerdeki her değişiklikten sonra tekrar yapılmalıdır. Ayrıca, subgraph oluşturulmadan önce en az bir kez yapılmalıdır.

Kod oluşturma, `src/mapping.ts`'deki eşleştirme kodunuzu kontrol etmez. Subgraph'ınızı Graph Gezginine dağıtmadan önce bunu kontrol etmek isterseniz, `yarn build` çalıştırabilir ve TypeScript derleyicisinin bulabileceği herhangi bir sözdizimi hatasını düzeltebilirsiniz.

## Veri Kaynağı Şablonları

EVM uyumlu akıllı sözleşmelerdeki yaygın bir model, bir sözleşmenin her birinin kendi durumu ve olayı olan rastgele sayıda başka sözleşmeler oluşturduğu, yönettiği veya bunlara atıfta bulunduğu kayıt defteri veya fabrika sözleşmelerinin kullanılmasıdır.

Bu alt sözleşmelerin adresleri önceden bilinebilir veya bilinmeyebilir ve bu sözleşmelerin çoğu zaman içinde oluşturulabilir ve/veya eklenebilir. Bu nedenle, bu gibi durumlarda tek bir veri kaynağı veya sabit sayıda veri kaynağı tanımlamak imkansızdır ve daha dinamik bir yaklaşıma ihtiyaç vardır: _data source templates_.

### Ana Sözleşme için Veri Kaynağı

İlk olarak, ana sözleşme için düzenli bir veri kaynağı tanımlarsınız. Aşağıdaki örnek, [Uniswap](https://uniswap.org) borsa(exchange) factory sözleşmesi için basitleştirilmiş bir veri kaynağı göstermektedir. `NewExchange(address,address)` olay işleyicisine dikkat edin. Bu, factory sözleşmesi tarafından zincir üstünde yeni bir takas sözleşmesi oluşturulduğunda yayınlanır.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Dinamik Olarak Oluşturulan Sözleşmeler için Veri Kaynağı Şablonları

Ardından, manifest'e _veri kaynağı şablonları_ eklersiniz. Bunlar, `source` altında önceden tanımlanmış bir sözleşme adresi olmayan düzenli veri kaynaklarıyla aynıdır. Genellikle, ana sözleşme tarafından yönetilen veya başvurulan her alt-sözleşme türü için bir şablon tanımlarsınız.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Bir Veri Kaynağı Şablonunun Örneklenmesi

Son adımda, ana sözleşme eşleştirmesini güncelleyerek bir şablondan dinamik bir veri kaynağı örneği oluşturursunuz. Bu örnekte, ana sözleşme eşlemesini değiştirerek `Exchange` şablonunu içe aktarır ve yeni takas sözleşmesini dizine almak için `Exchange.create(address)` yöntemini çağırırsınız.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Borsayı indekslemeye başlayın; "event.params.exchange"
  // yeni borsa sözleşmesinin adresi
  Exchange.create(event.params.exchange)
}
```

> **Not:** Yeni bir veri kaynağı, oluşturulduğu blok ve tüm takip eden bloklar için yalnızca çağrıları ve olayları işleyecektir, ancak önceki bloklarda bulunan geçmiş verileri işlemeyecektir.
> 
> Eğer önceki bloklar, yeni veri kaynağı için ilgili veri içeriyorsa, o veriyi indekslemek için sözleşmenin mevcut durumunu okuyarak ve yeni veri kaynağı oluşturulurken o zaman dilimindeki durumu temsil eden varlıklar oluşturarak yapmak en iyisidir.

### Veri Kaynağı Bağlamı

Veri kaynağı bağlamları, bir şablonu anında özelleştirmek için ek yapılandırma geçişine izin verir. Örneğimizde, borsalar belirli bir alım-satım çifti ile ilişkilendirilir ve bu bilgi `NewExchange` olayına dahil edilir. Bu bilgi, oluşturulan veri kaynağına şöyle aktarılabilir:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

`Exchange` şablonunun eşleştirmesi içinde, bağlama şu şekilde erişilebilir:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Tüm değer tipleri için `setString` ve `getString` gibi ayarlayıcılar ve alıcılar vardır.

## Başlangıç Blokları

`startBlock`, veri kaynağının indekslemeye başlayacağı zincirdeki hangi bloktan başlayacağını belirlemenize olanak tanıyan isteğe bağlı bir ayarlamadır. Başlangıç bloğunu belirlemek, veri kaynağının ilgisiz olabilecek potansiyel milyonlarca bloğu atlamasına olanak tanır. Tipik olarak, bir subgraph geliştiricisi, veri kaynağı akıllı sözleşmesinin oluşturulduğu bloğa `startBlock` ayarlar.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Not:** Sözleşme oluşturma bloğu hızlı bir şekilde Etherscan'da aranabilir:
> 
> 1. Arama çubuğuna adresini girerek sözleşmeyi arayın.
> 2. `Contract Creator` bölümünde oluşturma işlemi hash'ına tıklayın.
> 3. İşlem detayları sayfasını yükleyin ve bu sözleşme için başlangıç bloğunu bulacaksınız.

## Çağrı İşleyicileri

Etkinliğin bir sözleşmenin durumunda ilgili değişiklikleri toplamak için etkili bir yol sağlamasıyla birlikte, birçok sözleşme gaz maliyetlerini optimize etmek için günlük oluşturmaktan kaçınır. Bu durumlarda, bir subgraph veri kaynağı sözleşmesine yapılan çağrılara abone olabilir. Bunun için, işlev imzasına ve bu işlevi işleyecek eşleme işleyicisine başvurularak çağrı işleyicileri tanımlanır. Bu çağrıları işlemek için eşleme işleyicisi, `ethereum.Call` olarak adlandırılan ve çağrıya ilişkin yazılım girdileri ve çıktıları olan bir argüman alır. İşlem'in çağrı zincirinin herhangi bir derinliğinde yapılan çağrılar eşleştirmeyi tetikleyecektir, bu sayede veri kaynağı sözleşmesi aracılığıyla proxy sözleşmeleri aracılığıyla gerçekleştirilen faaliyetler yakalanabilir.

Çağrı işleyicileri yalnızca iki durumdan birinde tetiklenir: belirtilen işlevin sözleşme tarafından değil, başka bir hesap tarafından çağrılması durumunda veya Solidity'de harici olarak işaretlenip aynı sözleşmenin başka bir işlevinin bir parçası olarak çağrılması durumunda yalnızca tetiklenir.

> **Not:** Çağrı işleyicileri şu anda Parity izleme API'sine bağlıdır. BNB zinciri ve Arbitrum gibi bazı ağlar bu API'yı desteklemez. Bu ağlardan birini indeksleyen bir subgraph, bir veya daha fazla çağrı işleyicisi içeriyorsa senkronizasyon başlatılmaz. Subgraph geliştiricileri bunun yerine etkinlik işleyicilerini kullanmalıdır. Bunlar çağrı işleyicilerinden çok daha performanslıdır ve her EVM ağı tarafından desteklenir.

### Bir Çağrı İşleyici Tanımlama

Manifestinizde bir çağrı işleyicisi tanımlamak için sadece abone olmak istediğiniz veri kaynağı altında bir `callHandlers` dizisi ekleyin.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`function`, çağrıları filtrelemek için normalleştirilmiş işlev imzasıdır. `handler` özelliği, veri kaynağı sözleşmesinde hedef işlev çağrıldığında yürütmek istediğiniz işlevin adıdır.

### Eşleştirme fonksiyonu

Her çağrı işleyicisi, çağrılan işlevin adına karşılık gelen bir tipe sahip tek bir parametre alır. Yukarıdaki örnek subgraphta eşleme, `createGravatar` işlevi çağrıldığında ve bir `CreateGravatarCall` parametresi olarak alındığında işleyici içerir:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

`handleCreateGravatar` fonksiyonu, `@graphprotocol/graph-ts` tarafından sağlanan `ethereum.Call` alt sınıfı olan ve çağrının yazılmış girdileri ve çıktıları içeren yeni bir `CreateGravatarCall`'u alır. `CreateGravatarCall` türü, `graph codegen` çalıştırıldığında sizin için oluşturulur.

## Blok İşleyicileri

Bir subgraph, sözleşme olaylarına veya işlev çağrılarına abone olmanın yanı sıra, zincire yeni bloklar eklendikçe verilerini güncellemek isteyebilir. Bu işlemi gerçekleştirmek için a subgraph, her blok sonrasında veya önceden tanımlanmış bir filtreye uygun bloklardan sonra bir işlev çalıştırabilir.

### Desteklenen Filtreler

```yaml
filter:
  kind: call
```

_Tanımlanan işleyici, işleyicinin altında tanımlandığı sözleşmeye (veri kaynağı) çağrı içeren her blok için bir kez çağrılacaktır._

> **Not:** `call` filtresi şu anda Parity izleme API'sine bağlıdır. BNB zinciri ve Arbitrum gibi bazı ağlar bu API'yi desteklemez. Bu ağlardan birini indeksleyen bir subgraph, `call` filtresi olan bir veya daha fazla blok işleyici içeriyorsa, senkronizasyona başlatılmaz.

Bir blok işleyicisi için filtre olmaması, işleyicinin her blok için çağrılacağı anlamına gelir. Bir veri kaynağı, her filtre türü için yalnızca bir blok işleyicisi içerebilir.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### Eşleştirme fonksiyonu

Eşleştirme fonksiyonu, argümanı olarak yalnızca bir `ethereum.Block` alacaktırr. Olaylar için eşleştirme işlevleri gibi, bu işlev depodaki mevcut subgraph varlıklarına erişebilir, akıllı sözleşmeleri çağırabilir ve varlıkları oluşturabilir veya güncelleyebilir.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## Anonim Olaylar

Solidity'de anonim olayları işlemek gerekiyorsa, örnekte olduğu gibi, olayın topic 0'ını sağlayarak bunu başarabilirsiniz:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

Bir olay, yalnızca imza ve topic 0 eşleştiğinde tetiklenir. Varsayılan olarak `topic0`, olay imzasının hash değerine eşittir.

## Olay İşleyicilerinde İşlem Makbuzları

`specVersion` `0.0.5` ve `apiVersion` `0.0.7`'den itibaren olay işleyicileri, onları yayınlayan işlemin makbuzuna erişebilir.

Bunun için olay işleyicileri, subgraph manifest dosyasında isteğe bağlı ve varsayılan olarak false olan yeni `receipt: true` anahtarını kullanarak belirtilmelidir.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

İşleyici işlevi içinde, makbuz `Event.receipt` alanında erişilebilir. Manifestte makbuz(`receipt`) anahtarı `false` olarak ayarlandığında veya atlandığında, `null` bir değer döndürülür.

## Deneysel özellikler

`specVersion` `0.0.4`'ten itibaren subgraph özellikleri, manifest dosyasının en üst düzeyindeki özellikler(`features`) bölümünde, aşağıdaki tabloda listelendiği gibi `camelCase` adlarıyla açıkça belirtilmelidir:

| Özellik                                                      | İsim                                                |
| ------------------------------------------------------------ | --------------------------------------------------- |
| [Ölümcül Olmayan Hatalar](#non-fatal-errors)                 | `nonFatalErrors`                                    |
| [Tam Metin Arama](#defining-fulltext-search-fields)          | `fullTextSearch`                                    |
| [Grafting](#grafting-onto-existing-subgraphs)                | `grafting`                                          |
| [Ethereum Sözleşmelerinde IPFS](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` or `nonDeterministicIpfs` |

Örneğin, bir subgraph Tam Metin Arama(**Full-Text Search**) ve Ölümcül Olmayan Hatalar(**Non-fatal Errors**) özelliklerini kullanıyorsa, özellikler(`features`) alanı manifestte şöyle olmalıdır:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Bir özelliği bildirmeden kullanmanın, alt grafik dağıtımı sırasında bir **validation error**'a yol açacağını, ancak bir özellik bildirilmiş ancak kullanılmamışsa herhangi bir hata oluşmayacağını unutmayın.

### Ethereum Sözleşmelerinde IPFS

IPFS'yi Ethereum ile birleştirerek yaygın bir kullanım durumu, zincir üstünde tutmanın maliyetli olacağı verileri IPFS'te depolamak ve IPFS hash değerine Ethereum sözleşmelerinde referans vermektir.

Bu tür IPFS hash değerleri verildiğinde, subgraphlar `ipfs.cat` ve `ipfs.map` kullanarak IPFS'ten ilgili dosyaları okuyabilir. Bunu güvenilir bir şekilde yapmak için, Barındırılan hizmet([hosted service](https://thegraph.com/hosted-service)) IPFS düğümü bunları indeksleme sırasında bulabilecek kadar yüksek erişilebilirliğe sahip bir IPFS düğümüne sabitlenmelidir.

> **Not:** Graph Ağı henüz `ipfs.cat` ve `ipfs.map`'i desteklemiyor ve geliştiricilerin bu işlevselliği kullanarak subgraphları Studio aracılığıyla ağa dağıtması önerilmez.

> **[Özellik Yönetimi](#experimental-features): ** `ipfsOnEthereumContracts`, subgraph manifestinde özellikler(`features`) altında bildirilmelidir. EVM dışı zincirler için, aynı amaç için `nonDeterministicIpfs` takma adı da kullanılabilir.

When running a local Graph Node, the `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` environment variable must be set in order to index subgraphs using this experimental functionality.

### Ölümcül Olmayan Hatalar

Halihazırda senkronize edilmiş subgraphlarda indeksleme hataları varsayılan olarak subgraph başarısız olmasına ve senkronizasyonun durmasına neden olur. Hatalara rağmen senkronizasyonun devam etmesi için subgraphlar, hata tetikleyen işleyicinin yapılan değişikliklerini yok sayarak yapılandırılabilir. Bu, subgraph yazarlarının subgraphlarını düzeltmeleri için zaman kazandırırken, sorguların en son blokta sunulmaya devam etmesini sağlar, ancak hata nedeniyle sonuçlar tutarsız olabilir. Bazı hatalar hala her zaman ölümcül olacaktır. Ölümcül olmaması için hatanın belirlenmiş olması gerekmektedir.

> **Not:** Graph Ağı, henüz ölümcül olmayan hataları desteklemiyor ve geliştiricilerin bu işlevselliği kullanarak subgraphları Studio aracılığıyla ağa dağıtması önerilmez.

Ölümcül olmayan hataların etkinleştirilmesi, subgraph manifestinde aşağıdaki özellik bayrağının ayarlanmasını gerektirir:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

Sorgu, `subgraphError` argümanı aracılığıyla potansiyel tutarsızlıklarla sorgulama yapmak için de seçilebilir. Subgraph'ta hataların atlandığını kontrol etmek için `_meta`'yı sorgulamak da önerilir, örnekte olduğu gibi:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

Subgraph bir hatayla karşılaşırsa bu sorgu, hem verileri hem de `"indexing_error"` mesajıyla birlikte bir graphql hatasını döndürecektir, örnekte olduğu gibi:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Mevcut Subgraph'ta Grafting

Bir subgraph ilk olarak dağıtıldığında, ilgili zincirin başlangıç bloğundan (veya her veri kaynağı için belirlenen `startBlock`'tan) olayları indekslemeye başlar. Bazı durumlarda, mevcut bir subgraph'tan verilerin yeniden kullanılması ve çok daha sonraki bir blokta indekslemeye başlanması yararlı olabilir. Bu indeksleme yöntemi _Grafting_ olarak adlandırılır. Grafting, örneğin, eşleştirmelerdeki basit hataları hızlı bir şekilde geçmek veya bir subgraph başarısız olduktan sonra geçici olarak tekrar çalıştırmak için kullanışlıdır.

Bir subgraph temel bir subgraph üzerine graft edildiğinde, `subgraph.yaml`'daki subgraph belirtimi en üst düzeyde bir `graft` bloğu içerir:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

Manifesti `graft` bloğu içeren bir subgraph dağıtıldığında, Graph Düğümü verilen bloğa(`block`) kadar olan temel`base` subgraph verilerini kopyalar ve ardından yeni subgraph'a o bloktan devam eder. Temel subgraph, hedef Graph Düğüm örneğinde mevcut olmalı ve en azından verilen bloka kadar indekslemiş olmalıdır. Bu kısıtlama nedeniyle, graftlema yalnızca geliştirme sırasında veya acil durumlarda, eşdeğer graftlanmamış bir subgraph oluşturmaya hız kazandırmak için kullanılmalıdır.

Because grafting copies rather than indexes base data, it is much quicker to get the subgraph to the desired block than indexing from scratch, though the initial data copy can still take several hours for very large subgraphs. While the grafted subgraph is being initialized, the Graph Node will log information about the entity types that have already been copied.

The grafted subgraph can use a GraphQL schema that is not identical to the one of the base subgraph, but merely compatible with it. It has to be a valid subgraph schema in its own right, but may deviate from the base subgraph's schema in the following ways:

- It adds or removes entity types
- It removes attributes from entity types
- It adds nullable attributes to entity types
- It turns non-nullable attributes into nullable attributes
- It adds values to enums
- It adds or removes interfaces
- It changes for which entity types an interface is implemented

> **[Feature Management](#experimental-features):** `grafting` must be declared under `features` in the subgraph manifest.

## File Data Sources

File data sources are a new subgraph functionality for accessing off-chain data during indexing in a robust, extendable way, starting with IPFS.

> This also lays the groundwork for deterministic indexing of off-chain data, as well as the potential introduction of arbitrary HTTP-sourced data.

### Overview

Rather than fetching files "in line" during handler exectuion, this introduces templates which can be spawned as new data sources for a given file identifier. These new data sources fetch the files, retrying if they are unsuccessful, running a dedicated handler when the file is found.

This is similar to the [existing data source templates](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates), which are used to dynamically create new chain-based data sources.

> This replaces the existing `ipfs.cat` API

### Upgrade guide

#### Update `graph-ts` and `graph-cli`

File data sources requires graph-ts >=0.29.0 and graph-cli >=0.33.1

#### Add a new entity type which will be updated when files are found

File data sources cannot access or update chain-based entities, but must update file specific entities.

This may mean splitting out fields from existing entities into separate entities, linked together.

Original combined entity:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

New, split entity:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

If the relationship is 1:1 between the parent entity and the resulting file data source entity, the simplest pattern is to link the parent entity to a resulting file entity by using the IPFS CID as the lookup. Get in touch on Discord if you are having difficulty modelling your new file-based entities!

> You can use [nested filters](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) to filter parent entities on the basis of these nested entities.

#### Add a new templated data source with `kind: file/ipfs`

This is the data source which will be spawned when a file of interest is identified.

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> Şu anda `abis` gerekli olsa da, dosya veri kaynaklarından sözleşmeleri çağırmak mümkün değildir

Dosya veri kaynağı, varlıklar(`entities`) altında etkileşimde bulunacağı tüm varlık türlerini özellikle belirtmelidir. Daha fazla ayrıntı için sınırlamalara([limitations](#Limitations)) bakın.

#### Dosyaları işlemek için yeni bir işleyici oluşturun

Bu işleyici, bulunduğunda dosyanın içeriği olacak ve daha sonra işlenebilecek bir `Bytes` parametresini kabul etmelidir. Bu genellikle, `graph-ts` yardımcıları ([dökümantasyon](https://thegraph.com/docs/en/developing/assemblyscript-api/#json-api)) ile işlenebilen bir JSON dosyası olacaktır.

Dosyanın okunabilir bir dize olarak CID'sine `dataSource` aracılığıyla şu şekilde erişilebilir:

```typescript
const cid = dataSource.stringParam()
```

Example handler:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### Gerektiğinde dosya veri kaynakları oluşturun

Artık zincir tabanlı işleyicilerin yürütülmesi sırasında dosya veri kaynakları oluşturabilirsiniz:

- Otomatik olarak oluşturulmuş şablonları(`templates`) içe aktarın
- cid'in geçerli bir IPFS içerik tanımlayıcısı olduğu bir eşleştirme içinden `TemplateName.create(cid: string)` öğesini çağırın

> Şu anda Graph Düğümü, [v0 ve v1 içerik tanımlayıcılarını](https://docs.ipfs.tech/concepts/content-addressing/), ve dizinli içerik tanımlayıcılarını desteklemektedir. (örneğin `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`)

Örnek:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//Bu örnek kod, bir Crypto coven subgraph'ı içindir. Yukarıdaki ipfs hash'ı, tüm kripto NFT'leri için token üst verilerine sahip bir dizindir.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //Bu, tek bir Crypto coven NFT için üst verilere giden bir yol oluşturur. Dizini "/" + dosya adı + ".json" ile birleştirir.

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

Bu, Graph Node'un yapılandırılmış IPFS uç noktasını sorgulayarak yeni bir dosya veri kaynağı oluşturacak ve bulunamazsa tekrar deneyecek. Dosya bulunduğunda, dosya veri kaynağı işleyicisi yürütülecektir.

Bu örnek, ana `Token` varlığı ile sonuç `TokenMetadata` varlığı arasındaki arama olarak CID'i kullanmaktadır.

> Bu, daha önce bir subgraph geliştiricisi'nin `ipfs.cat(CID)` çağrısını yaparak dosyayı aldığı noktadır

Tebrikler, dosya veri kaynaklarını kullanıyorsunuz!

#### Subgraph'ınızı dağıtma

Artık subgraph'ınızı oluşturabilir(`build`) ve herhangi bir Graph Düğümüne >=v0.30.0-rc.0 dağıtabilirsiniz(`deploy`).

#### Sınırlamalar

Dosya veri kaynağı işleyicileri ve varlıkları yürütüldüklerinde belirleyici olmaları ve zincir tabanlı veri kaynaklarının bozulmasını önlemeleri için, diğer alt grafik varlıklarından izole edilir,. Açıkça şunlardır:

- Dosya Veri Kaynakları tarafından oluşturulan varlıklar değiştirilemez ve güncellenemez
- Dosya Veri Kaynağı işleyicileri, diğer dosya veri kaynaklarından varlıklara erişemez
- Dosya Veri Kaynaklarıyla ilişkili varlıklara zincir tabanlı işleyicilerden erişilemez

> Bu kısıtlama çoğu kullanım durumu için sorun oluşturmamalıdır, ancak bazı durumlarda karmaşıklıklığa sebep olabilir. Dosya tabanlı verilerinizi bir subgraph'ta modellemekte zorluk yaşarsanız, lütfen Discord üzerinden bizimle iletişime geçin!

Ek olarak, zincir üstü bir veri kaynağı veya başka bir dosya veri kaynağı olsun, bir dosya veri kaynağından veri kaynakları oluşturmak mümkün değildir. Bu kısıtlama gelecekte kaldırılabilir.

#### Best practices

If you are linking NFT metadata to corresponding tokens, use the metadata's IPFS hash to reference a Metadata entity from the Token entity. Save the Metadata entity using the IPFS hash as an ID.

You can use [DataSource context](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) when creating File Data Sources to pass extra information which will be available to the File Data Source handler.

If you have entities which are refreshed multiple times, create unique file-based entities using the IPFS hash & the entity ID, and reference them using a derived field in the chain-based entity.

> We are working to improve the above recommendation, so queries only return the "most recent" version

#### Known issues

File data sources currently require ABIs, even though ABIs are not used ([issue](https://github.com/graphprotocol/graph-cli/issues/961)). Workaround is to add any ABI.

Handlers for File Data Sources cannot be in files which import `eth_call` contract bindings, failing with "unknown import: `ethereum::ethereum.call` has not been defined" ([issue](https://github.com/graphprotocol/graph-cli/issues/4309)). Workaround is to create file data source handlers in a dedicated file.

#### Examples

[Crypto Coven Subgraph migration](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### References

[GIP File Data Sources](https://forum.thegraph.com/t/gip-file-data-sources/2721)
