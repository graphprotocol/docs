---
title: AssemblyScript API'si
---

> Not: Eğer `graph-cli`/`graph-ts` `0.22.0`, sürümünden önce bir subgraph oluşturduysanız, eski bir AssemblyScript sürümünü kullanıyorsunuz demektir. [`Taşıma Rehberi`](/release-notes/assemblyscript-migration-guide) adlı rehbere bakmanızı öneririz

Bu sayfa subgraph eşleştirmelerini yazarken bullanılabilen yerleşik API'leri belgelemektedir. Hazır olarak iki çeşit API mevcuttur:

- [Graph TypeScript kütüphanesi](https://github.com/graphprotocol/graph-ts) (`graph-ts`) ve
- `graph codegen` tarafından subgraph dosyalarından oluşturulan kod.

Ayrıca, [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) ile uyumlu oldukları sürece diğer kütüphaneler de bağlılıklar(dependencies) olarak ekleyebilirsiniz. Bu, eşleştirmelerin yazıldığı dil olduğundan, [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki), dil ve standart kütüphane özellikleri için iyi bir kaynaktır.

## Kurulum

[`graph init`](/developing/creating-a-subgraph) ile oluşturulan subgraph'lar, önceden yapılandırılmış bağlılıklarla birlikte gelir. Bu bağlılıkları yüklemek için yapılması gereken tek şey aşağıdaki komutlardan birini çalıştırmaktır:

```sh
yarn install # Yarn
npm install  # NPM
```

Subgraph sıfırdan oluşturulduysa, Graph TypeScript kütüphanesini bir bağlılık olarak yüklemek için aşağıdaki iki komuttan biri kullanılabilir:

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## API Referansı

`@graphprotocol/graph-ts` kütüphanesi, aşağıdaki API'leri sağlamaktadır:

- Ethereum akıllı sözleşmeleri, olaylar, bloklar, işlemler ve Ethereum değerleriyle çalışmak için bir `Ethereum` API'si.
- Graph Düğüm deposundan varlıkları yüklemek ve kaydetmek için bir `store` API'si.
- Graph Düğüm çıktısına ve Graph Gezgini'ne mesaj yazmak için bir `log` API'si.
- IPFS'den dosya yüklemek için bir `ipfs` API'si.
- JSON verilerini ayrıştırmak için bir `json` API'si.
- Kriptografik fonksiyonları kullanmak için bir `crypto` API'si.
- Ethereum, JSON, GraphQL ve AssemblyScript gibi farklı tip sistemler arası çeviri yapmak için düşük seviyeli yazılımlar.

### Sürümler

Subgraph manifestindeki `apiVersion`, belirli bir subgraph için Graph Düğümü tarafından çalıştırılan eşleme API sürümünü belirtir. Mevcut eşleme API sürümü.'dır.

| Sürüm | Sürüm Notları                                                                                                                                                                                                                                                                               |
|:-----:| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0.0.7 | Ethereum tiplerine `TransactionReceipt` ve `Log` sınıfları eklendi<br />Ethereum Olay nesnesine `receipt` alanı eklendi                                                                                                                                                               |
| 0.0.6 | Ethereum Transaction nesnesine `nonce` alanı eklendi<br />Ethereum Block nesnesine `baseFeePerGas` eklendi                                                                                                                                                                            |
| 0.0.5 | AssemblyScript sürümü 0.19.10'a yükseltildi (bu, bozulmalara neden olan değişiklikleri içerir, lütfen [`Taşıma Rehberi'ne`](/release-notes/assemblyscript-migration-guide) göz atın)<br />`ethereum.transaction.gasUsed`, `ethereum.transaction.gasLimit` olarak yeniden adlandırıldı |
| 0.0.4 | Ethereum SmartContractCall nesnesine `functionSignature` alanı eklendi                                                                                                                                                                                                                      |
| 0.0.3 | Ethereum Call nesnesine `from` alanı eklendi<br />`etherem.call.address`, `ethereum.call.to` olarak yeniden adlandırıldı                                                                                                                                                              |
| 0.0.2 | Ethereum Transaction nesnesine `input` alanı eklendi                                                                                                                                                                                                                                        |

### Dahili Türler

AssemblyScript'e dahil edilmiş olan temel türler hakkındaki belgeler, [AssemblyScript wiki'de](https://github.com/AssemblyScript/assemblyscript/wiki/Types). bulunabilir.

Aşağıdaki ek türler, `@graphprotocol/graph-ts` tarafından sağlanmaktadır.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray`, bir `u8` dizisini temsil etmektedir.

_Yapıcı Metodlar_

- `fromI32(x: i32): ByteArray` - `x`'i baytlara ayırır.
- `fromHexString(hex: string): ByteArray` - Girdi uzunluğu çift olmalıdır. `0x` ön eki isteğe bağlıdır.

_Tip dönüşümleri_

- `toHexString(): string` - Başına `0x` eklenmiş bir onaltılık dizgiye gönüştürür.
- `toString(): string` - Bayrları bir UTF-8 dizesi olarak yorumlar.
- `toBase58(): string` - Baytları bir base58 dizgisine kodlar.
- `toU32(): u32` - Baytları önemli bayt'ın en sağda olduğu(little-endian) bir `u32` sıralaması olarak yorumlar. Taşma durumunda hata verir.
- `toI32(): i32` - Bayt dizisini önemli bayt'ın en sağda olduğu bir `i32` sıralaması olarak yorumlar. Taşma durumunda hata verir.

_Operatörler_

- `equals(y: ByteArray): bool` – `x == y` şeklinde yazılabilir.
- `concat(other: ByteArray) : ByteArray` - `this`'in hemen ardından gelen `other`'dan oluşan yeni bir `ByteArray` döndürür
- `concatI32(other: i32) : ByteArray` - `other`'ın bayt temsiline takiben `this`'ten oluşan yeni `ByteArray` döndürür

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal`, arbitrary precision ondalık sayıları temsil etmek için kullanılır.

> Not: [Dahili olarak](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal`, 34 ondalık basamağı destekleyen [IEEE-754 decimal128 kayan nokta formatında](https://en.wikipedia.org/wiki/Decimal128_floating-point_format) saklanır. Bu `BigDecimal`'in Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) veya benzeri uyarlamalar gibi 34 basamakdan daha geniş yayılabilen sabit nokta tiplerini temsil etmek için uygun olmadığı anlamına gelir.

_Yapıcı Metodlar_

- `constructor(bigInt: BigInt)` – `BigInt`'ten `BigDecimal` oluşturur.
- `static fromString(s: string): BigDecimal` – Ondalık bir dizeyi ayrıştırır.

_Tip dönüşümleri_

- `toString(): string` – ondalık dizeye yazdırır.

_Matematik_

- `plus(y: BigDecimal): BigDecimal` – `x + y` şeklinde yazılabilir.
- `minus(y: BigDecimal): BigDecimal` – `x - y` şeklinde yazılabilir.
- `times(y: BigDecimal): BigDecimal` – `x * y` şeklinde yazılabilir.
- `div(y: BigDecimal): BigDecimal` – `x / y` şeklinde yazılabilir.
- `equals(y: BigDecimal): bool` – `x == y` şeklinde yazılabilir.
- `notEqual(y: BigDecimal): bool` – `x != y` şeklinde yazılabilir.
- `lt(y: BigDecimal): bool` – `x < y` şeklinde yazılabilir.
- `le(y: BigDecimal): bool` – `x <= y` şeklinde yazılabilir.
- `gt(y: BigDecimal): bool` – `x > y` şeklinde yazılabilir.
- `ge(y: BigDecimal): bool` – `x >= y` şeklinde yazılabilir.
- `neg(): BigDecimal` - `-x` şeklinde yazılabilir.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` büyük tamsayıları temsil etmek için kullanılır. Bu, `uint32`'den `uint256`'ya ve `int64`'den `int256`'ya kadarki Ethereum değerlerini içerir. `uint32`, `uint24` veya `int8` gibi `uint32` altındaki her şey `i32` olarak temsil edilir.

`BigInt` sınıfı aşağıdaki API'yi içerir:

_Yapıcı Metodlar_

- `BigInt.fromI32(x: i32): BigInt` – `i32`'den `BigInt` oluşturur.
- `BigInt.fromString(s: string): BigInt`– Bir dizgiden `BigInt` çözümler.
- `BigInt.fromUnsignedBytes(x: Bytes): BigInt` – `baytları` işaretsiz, önemli bayt'ın sağda olduğu(little-endian) tamsayı olarak yorumlar. Girdiniz önemli bayt'ın solda olduğu(big-endian) ise önce `.reverse()`'ü çağırın.
- `BigInt.fromSignedBytes(x: Bytes): BigInt` – `baytları` işaretli, önemli bayt'ın sağda olduğu(little-endian) tamsayı olarak yorumlar. Girdiniz önemli bayt'ın solda olduğu(big-endian) ise önce `.reverse()`'ü çağırın.

  _Tip dönüşümleri_

- `x.toHex(): string` – `BigInt`'ı onaltılık karakter dizgisine dönüştürür.
- `x.toString(): string` – `BigInt`'ı ondalık sayı dizgisine dönüştürür.
- `x.toI32(): i32` – `BigInt`'i bir `i32` olarak döndürür; değer `i32`'ye sığmazsa başarısız olur. Önce `x.isI32()` kontrolünü yapmak mantıklı olur.
- `x.toBigDecimal(): BigDecimal` - kesir kısmı olmayan bir ondalık sayıya dönüştürür.

_Matematik_

- `x.plus(y: BigInt): BigInt` – `x + y` şeklinde yazılabilir.
- `x.minus(y: BigInt): BigInt` – `x - y` şeklinde yazılabilir.
- `x.times(y: BigInt): BigInt` – `x * y` şeklinde yazılabilir.
- `x.div(y: BigInt): BigInt` – `x / y` şeklinde yazılabilir.
- `x.mod(y: BigInt): BigInt` – `x % y` şeklinde yazılabilir.
- `x.equals(y: BigInt): bool` – `x == y` şeklinde yazılabilir.
- `x.notEqual(y: BigInt): bool` – `x != y` şeklinde yazılabilir.
- `x.lt(y: BigInt): bool` – `x < y` şeklinde yazılabilir.
- `x.le(y: BigInt): bool` – `x <= y` şeklinde yazılabilir.
- `x.gt(y: BigInt): bool` – `x > y` şeklinde yazılabilir.
- `x.ge(y: BigInt): bool` – `x >= y` şeklinde yazılabilir.
- `x.neg(): BigInt` – `-x` şeklinde yazılabilir.
- `x.divDecimal(y: BigDecimal): BigDecimal` – ondalık sonuç veren, ondalıkla bölme işlemi yapar.
- `x.isZero(): bool` – Sayının sıfır olup olmadığını kontrol etmek için kullanılır.
- `x.isI32(): bool` –Sayının `i32`'ye sığıp sığmayacağını kontrol eder.
- `x.abs(): BigInt` – Mutlak değerini alır.
- `x.pow(exp: u8): BigInt` – Üs alma işlemi yapar.
- `bitOr(x: BigInt, y: BigInt): BigInt` – `x | y` şeklinde yazılabilir.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – `x & y` şeklinde yazılabilir.
- `leftShift(x: BigInt, bits: u8): BigInt` – `x << y` şeklinde yazılabilir.
- `rightShift(x: BigInt, bits: u8): BigInt` – `x >> y` şeklinde yazılabilir.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap`, anahtar-değer çiftlerini depolamak için kullanılabilir. Bu [örneği](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51) inceleyin.

`TypedMap` sınıfı API'si şunlardır:

- `new TypedMap<K, V>()` – `K` türündeki anahtarlar ve `T` türündeki değerlerle boş bir harita oluşturur
- `map.set(key: K, value: V): void` – `key` değerini `value` olarak ayarlar
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – bir `key` için anahar-değer çiftini döndürür veya `key` haritada mevcut değilse `null` olarak döndürür
- `map.get(key: K): V | null` – bir `key` için değeri döndürür veya `key` haritada yoksa `null` olarak döndürür
- `map.isSet(key: K): bool` – `key` haritada mevcutsa `true`, değilse `false` döndürür

#### Baytlar

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`Bytes`, belli bir uzunluğa sahip olmayan bayt dizilerini temsil etmek için kullanılır. Bu, Ethereum'un `bytes`, `bytes32` vb. türlerini içerir.

`Bytes` sınıfı AssemblyScript'in [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) sınıfını genişletir ve `Uint8Array` işlevlerini desteklemenin yanı sıra aşağıdaki yeni yöntemleride destekler:

_Yapıcı Metodlar_

- `fromHexString(hex: string) : Bytes` - Çift sayıda onaltılık basamaktan oluşması gereken `hex` dizgisini `ByteArray`'a dönüştürür. `hex` dizgisi isteğe bağlı olarak `0x` ile başlayabilir
- `fromI32(i: i32) : Bytes` - `i`'yi bayt dizisine dönüştürür

_Tip dönüşümleri_

- `b.toHex()` – dizideki baytları temsil eden onaltılık bir dizgi döndürür
- `b.toString()` – dizideki baytları bir evrensel kod karakter dizgisine dönüştürür
- `b.toBase58()` – bir Ethereum Bytes değerini base58 kodlamasına dönüştürür (IPFS hash'larında kullanılır)

_Operatörler_

- `b.concat(other: Bytes) : Bytes` - doğrudan `this` ve ardından `other`'dan oluşan yeni `Bytes` döndürür
- `b.concatI32(other: i32) : ByteArray` - `other`'ın bayt temsiline takiben `this`'ten oluşan yeni `Bytes` döndürür

#### Adres(Address)

```typescript
import { Address } from '@graphprotocol/graph-ts'
```

`Address`, Ethereum `adres` değerlerini temsil etmek için `Baytları` genişletir.

`Baytlar` API'si üzerine aşağıdaki metod'u ekler:

- `Address.fromString(s: string): Address` – onaltılık bir dizgiden `Adres` oluşturur
- `Address.fromBytes(b: Bytes): Address` – tam olarak 20 bayt uzunluğunda olması gereken `b`'den bir `Adres` oluşturur. Daha az veya daha fazla bayt içeren bir değerin iletilmesi hatayla sonuçlanır

### Store API

```typescript
import { store } from '@graphprotocol/graph-ts'
```

`Store` API, varlıkları Graph Düğüm deposuna yüklenmesi, kaydedilmesi ve depodan kaldırılmasına olanak tanır.

Depoya yazılan varlıklar, GraphQL şemasında tanımlanan `@entity` türleriyle bire bir eşlenir. Bunlarla çalışmayı kolaylaştırmak için [Graph CLI](https://github.com/graphprotocol/graph-cli) tarafından sağlanan `graph codegen` komutu, şema alanları için özellik geliştirici ve ayarlayıcı olan; bu unsurları yükleme ve kaydetme yöntemlerine sahip `Entity` türünden alt sınıfları olan unsur sınıflarını oluşturur.

#### Unsurların Oluşturulması

Aşağıdaki, Ethereum olaylarından varlıklar oluşturmak için yaygın bir modeldir.

```typescript
// ERC20 ABI'dan oluşturulan Transfer olay sınıfını içe aktarın
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// GraphQL şemasından oluşturulan Transfer varlık türünü içe aktarın
import { Transfer } from '../generated/schema'

// Transfer olayı işleyicisi
export function handleTransfer(event: TransferEvent): void {
  // İşlem hash'ını olay kimliği olarak kullanarak bir Transfer varlığı oluşturun
  let id = event.transaction.hash
  let transfer = new Transfer(id)
  
  // Olay parametrelerini kullanarak varlığın özelliklerini ayarlayın
  transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount
  
  // Varlığı depoya kaydedin
  transfer.save()
  }
```

Zincir işleme sırasında bir `Transfer` olayıyla karşılaşılması durumunda, bu üretilen `Transfer` türü kullanılarak (varlık türüyle bir adlandırma çakışmasını önlemek amacıyla burada `TransferEvent` olarak adlandırılmıştır) `handleTransfer` olay işleyicisine iletilir. Bu tür, olayın ana işlemi ve parametreleri gibi verilere erişimi sağlar.

Çakışmaları önlemek için her varlık benzersiz bir kimliğe sahip olmalıdır. Genellikle olay parametreleri, kullanılabilecek benzersiz bir tanımlayıcı içerir. Not: Kimlik olarak işlem hash'ını kullanmak aynı işlemdeki başka hiçbir olayın bu hash'ı kullanarak kimlik olarak varlık oluşturmayacağını varsayar.

#### Depodan varlık yükleme

Bir varlık mevcutsa aiağıdaki kod kullanılarak depodan yüklenebilir:

```typescript
let id = event.transaction.hash // veya kimlik(ID) nasıl oluşturulmuşsa
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Transfer varlığı önceki gibi kullanılır
```

Varlığın depoda mevcut olmaması durumunda `yükleme` metodu `Transfer | null` türünde bir değer döndürür. Bu nedenle değeri kullanmadan önce `null` durumunu kontrol etmek gerekebilir.

> **Not:** Varlıkların yüklenmesi, yalnızca eşleştirmede yapılan değişiklikler bir varlığın önceki verilerine bağlıysa gereklidir. Mevcut varlıkları güncellemenin iki yolu için bir sonraki bölüme bakın.

#### Bir blok içinde oluşturulan varlıkları arama

`graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 ve `@graphprotocol/graph-cli` v0.49.0 sürümlerinden itibaren `loadInBlock` yöntemi tüm varlık türlerinde kullanılabilir.

Store API, mevcut blokta oluşturulan veya güncellenen varlıkların alınmasını kolaylaştırır. Bunun için tipik bir durum, bir işleyicinin zincir üzerindeki bir etkinlikten bir İşlem oluşturması ve daha sonraki bir işleyicinin varsa bu işleme erişmek istemesidir. İşlemin mevcut olmadığı durumda, subgraph sadece varlığın mevcut olmadığını öğrenmek için veritabanına gitmek zorunda kalacaktır; eğer subgraph yazarı varlığın aynı blokta yaratılmış olması gerektiğini zaten biliyorsa, loadInBlock kullanmak bu veritabanı gidiş gelişini önler. Bazı subgraphlar için, bu kaçırılan aramalar indeksleme süresine önemli ölçüde katkıda bulunabilir.

```typescript
let id = event.transaction.hash // veya ID nasıl oluşturulurmuşsa
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Transfer varlığını daha önce olduğu gibi kullanın
```

> Not: Verilen blokta oluşturulmuş bir varlık yoksa, depoda verilen ID'ye sahip bir varlık olsa bile `loadInBlock` `null` değerini döndürür.

#### Türetilmiş varlıkları arama

`graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 ve `@graphprotocol/graph-cli` v0.51.0 sürümlerinden itibaren `loadRelated` yöntemi kullanılabilir.

Bu, türetilmiş varlık alanlarının bir olay işleyicisi içinden yüklenmesini sağlar. Örneğin, aşağıdaki şema göz önüne alındığında:

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

Aşağıdaki kod, `Holder` varlığının türetildiği `Token` varlığını yükleyecektir:

```typescript
let holder = Holder.load('test-id')
// Load the Token entities associated with a given holder
let tokens = holder.tokens.load()
```

#### Mevcut varlıkları güncelleme

Mevcut bir varlığı güncellemenin iki yolu vardır:

1. Örneğin `Transfer.load(id)` ile varlığu yükleyin, varlığın özelliklerini belirleyin ve daha sonra `.save()` yöntemini kullanarak depoya geri kaydedin.
2. Örneğin `new Transfer(id)` ile kolayca varlık oluşturun, verlığın özelliklerini belirleyin ve daha sonra `.save()` yöntemini kullanarak depoya kaydedin. Varlık mevcutsa, değişiklikler mevcut varlığın üzerine kaydedilir.

Oluşturulan özellik ayarlayıcılar sayesinde çoğu durumda özellikerin değiştirilmesi kolaydır:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Ayrıca aşağıdaki iki talimattan biriyle özellikleri kaldırmakta mümkündür:

```typescript
transfer.from.unset()
transfer.from = null
```

Bu örneğin GraphQL'de `!` olmadan tanımlanan özellikler gibi sadece isteğe bağlı özelliklerde çalışır. İki örnek `owner: Bytes` veya `amount: BigInt` olabilir.

Dizi özelliklerini güncelleme biraz daha karmaşıktır, çünkü bir varlıkta bir diziyi almak, o dizinin bir kopyasını oluşturur. Bu, dizilerin değiştirildikten sonra açıkça yeniden ayarlanması gerektiği anlamına gelir. Aşağıdakiler `entity`'nin bir `numbers: [BigInt!]!`'a sahip olduğunu varsayar.

```typescript
// Bu işe yaramaz
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// Bu çalışır
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Depodan varlık kaldırma

Şu anda oluşturulan türler aracılığıyla bir varlığı kaldırmanın yolu yoktur. Bunun yerine, bir varlığın kaldırılması varlık türünün adının ve kimliğinin `store.remove`'a iletilmesini gerektirir:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API'si, akıllı sözleşmelere, genel durum değişkenlerine, sözleşme fonksiyonlarına, olaylara, işlemlere, bloklara ve Ethereum verilerinin kodlama/çözme işlemlerine erişim sağlar.

#### Ethereum Türleri İçin Destek

Varlıkla gibi, `graph codegen` oluşturma, bir subgraph'ta kullanılan tüm akıllı sözleşme ve olaylar için sınıflar oluşturur. Bunun için, ABI dosyalarının subgraph manifestindeki veri kaynağı bir parçası olması gerekir. Genellikle, ABI dosyaları `abis/` klasöründe saklanır.

Oluşturulan sınıflarla Ethereum türleri ile [gömülü türler](#built-in-types) arasındaki dönüşümler arka planda gerçekleştirilir, böylece subgraph yazarları bununla ilgilenmek zorunda kalmazlar.

Aşağıdaki örnek bunu açıklar. Aşağıdaki gibi bir subgraph şeması verildiğinde

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

ve Ethereum'da bir `Transfer(address,address,uint256)` olay imzası olduğunda `address`, `address` ve `uint256` türündeki `from`, `to` ve `amount` değerleri `address` ve `BigInt`'e dönüştürülür, böylece `Transfer` varlığının `Bytes!` ve `BigInt!` özelliklerine aktarılabilir:

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### Olaylar ve Blok/İşlem Verileri

Önceki örneklerdeki `Transfer` olayı gibi olay işleyicilerine iletilen Ethereum olayları, yalnızca olay parametrelerine değil, aynı zamanda ilişkili işlemlerine ve parçası oldukları bloğa da erişim sağlar. Aşağıdaki veriler `event` örneklerinden elde edilebilir (bu sınıflar, `graph-ts`'de bulunan `ethereum` modülünün bir parçasıdır):

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Akıllı Sözleşme Durumuna Erişim

`Graph codegen` tarafından oluşturulan kod subgraph'ta kullanılan akıllı sözleşmeler için sınıflar da içerir. Bunlar, geçerli blokta sözleşmenin genel durum değişkenlerine ve çağrı işlevlerine erişmek için kullanılabilir.

Yaygın bir model, bir olayın kaynaklandığı sözleşmeye erişmektir. Bu, aşağıdaki kodla elde edilir:

```typescript
// Oluşturulan sözleşme sınıfı ve Transfer olayı sınıfını içe aktarın
import { ERC20Contract, Transfer as TransferEvent } from '../generated/ERC20Contract/ERC20Contract'
// Oluşturulan varlık sınıfını içe aktarın
import { Transfer } from '../generated/schema'

export function handleTransfer(event: TransferEvent) {
  // Sözleşmeyi olayı yayınlayan adresle bağlayın
  let contract = ERC20Contract.bind(event.address)

  //  Durum değişkenlerine ve işlevlere erişmek için çağrı yapın
  let erc20Symbol = contract.symbol()
}
```

Burada `Transfer`, varlık türüyle bir isim çakışmasını önlemek için `TransferEvent` olarak yeniden adlandırılmıştır

Ethereum üzerindeki `ERC20Contract`, `symbol` adlı genel sadece okunabilir bir işleve sahip olduğu sürece, `.symbol()` ile çağrılabilir. Genel durum değişkenleri için aynı ada sahip bir yöntem otomatik olarak oluşturulur.

Subgraph parçası olan diğer tüm sözleşmelerde oluşturulan koddan içe aktarılabilir ve geçerli bir adrese bağlanabilir.

#### Geri Dönen Çağrıları Yönetme

Sözleşmenizin sadece okunur yöntemleri geri dönebilirse, o zaman `try_` önekiyle oluşturulan sözleşme metodunu çağırarak bunu halletmelisiniz. Örneğin, Gravity sözleşmesi `gravatarToOwner` metodunu kullanıma sunar. Bu kod bu yöntemde bir geri dönüşü işleyebilir:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

Bir Geth veya Infura istemcisine bağlı bir Graph düğümünün tüm geri dönüşleri algılamayabileceğini unutmayın, bu durumda Parity istemcisine bağlı bir Graph düğümü kullanmanızı öneririz.

#### ABI Kodlama/Çözme

Veriler, `ethereum` modülündeki `encode` ve `decode` işlevleri kullanılarak Ethereum'un ABI kodlama formatına göre kodlanabilir ve kodu çözülebilir.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

Daha fazla bilgi için:

- [ABI Spesifikasyonu](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- [Rust kütüphanesi/CLI](https://github.com/rust-ethereum/ethabi) kodlama/çözme
- Daha [karmaşık bir örnek](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Logging API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

`Log` API, Subgraph'ların Graph Gezgini'nin yanı sıra Graph Düğüm standart çıktısına bilgi kaydetmesine izin verir. Mesajlar, farklı günlük seviyelerde kaydedilebilir. Argümandan günlük mesajları oluşturmak için basit bir biçim dizgi sözdizimi sağlanmıştır.

`Log` API'si aşağıdaki fonksiyonları içerir:

- `log.debug(fmt: string, args: Array<string>): void` - hata ayıklama mesajı kaydeder.
- `log.info(fmt: string, args: Array<string>): void` - bilgilendirici mesaj kaydeder.
- `log.warning(fmt: string, args: Array<string>): void` - uyarı mesajı kaydeder.
- `log.error(fmt: string, args: Array<string>): void` - hata mesajı kaydeder.
- `log.critical(fmt: string, args: Array<string>): void` – kritik bir mesaj kaydeder _ve_ subgraph'ı sonlandırır.

`Log` API, bir biçim dizgisi ve bir dizi dizgisi değeri alır. Ardından yer tutucuları dizi'den gelen dizgi değerleriyle değiştirir. İlk `{}` yer tutucusu dizi içindeki ilk değerle, ikinci `{}` yer tutucusu ikinci değerle değiştirilir ve bu böyle devam eder.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Bir veya daha fazla değerin loglanması

##### Tek bir değerin loglanması

Aşağıdaki örnekte, "A" dizgi değeri, loglanmadan önce `['A']` olacak şekilde bir diziye geçirilir:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Mevcut bir diziden tek bir girişi loglama

Aşağıdaki örnekte, bağımsız değişken dizisi üç değer içermesine rağmen dizinin yalnızca ilk değeri loglanır.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler: "My value is: A"  ('log.info'ya üç değer iletilmiş olsa da)
  log.info('My value is: {}', myArray)
}
```

#### Mevcut bir diziden birden çok girişi kaydetme

Argümanlar dizisindeki her giriş, log mesajı dizesinde kendi yer tutucusu `{}`i gerektirir. Aşağıdaki örnek, log mesajında üç yer tutucu `{}` içerir. Bu nedenle, `myArray` içindeki üç değerin tümü loglanır.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler: "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Mevcut bir diziden belirli bir girişi loglama

Dizide belirli bir değeri görüntülemek için dizinlenmiş değer bulunmalıdır.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Olay bilgilerinin loglanması

Aşağıdaki örnek, bir olaydan blok numarasını, blok hash'ını ve işlem hash'ını loglar:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Akıllı sözleşmeler zaman zaman IPFS dosyaları zincir üstüde tuttururlar. Bu, eşleştirmelerin IPFS hash'larını almasına ve IPFS'ten ilgili dosyaları okumasına olanak tanır. Dosya verileri `Bayt` olarak döndürülür, bu da genellikle daha fazla işlem gerektirir, örneğin bu sayfanın sonlarında belgelenen `json` API ile.

IPFS hash'ı veya yolu verildiğinde, bir dosyayı IPFS'den okuma şu şekilde yapılır:

```typescript
// Bunu eşleştirmedeki bir olay işleyicinin içine koyun
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
gibi yollar
// bu dizinlerdeki dosyaları içerenler de desteklenir
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

**Note:** `ipfs.cat` şu anda belirli değildir. Dosya, istek zaman aşımına uğramadan önce IPFS ağından alınamazsa, `null` değeri döndürür. Bu nedenle, sonucun `null` olup olmadığını her zaman kontrol etmek önemlidir.

Ayrıca, `ipfs.map` ile daha büyük dosyaları akış şeklinde işlemek mümkündür. Fonksiyon durumunu değiştirmek için bir IPFS dosyasının hash veya yolunu, bir geri çağrı adını veya işaretini bekler:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // İşlem yapmayla ilgili ayrıntılar için JSONValue belgelerine bakın
  // JSON değerleri ile
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Geri çağırmalar da varlık oluşturabilir
  let newItem = new Item(id)
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Set parent to "parentId"
  newitem.save()
}

// Bunu eşleştirmedeki bir olay işleyicisinin içine koyun
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Alternatif olarak `ipfs.mapJSON` kullanın
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

Şu anda desteklenen tek bayrak, `ipfs.map`'e iletilmesi gereken `json` bayrağıdır. Bu `json` bayrağıyla IPFS dosyası, her satıra bir değer olmak üzere bir dizi JSON değerinden oluşmalıdır. `ipfs.map` çağrısı, dosyadaki her satırı okur, seriyi bir `JSONValue` olarak ters seriler ve her biri için geri çağrıyı çağırır. Geri çağrı daha sonra `JSONValue`'dan veri depolamak için varlık işlemlerini kullanabilir. Varlık değişiklikleri, yalnızca `ipfs.map` adlı işleyici başarıyla tamamlandığında saklanır; bu arada bellekte tutulurlar ve bu nedenle `ipfs.map`'in işleyebileceği dosyanın boyutu sınırlıdır.

Başarılı olduğunda, `ipfs.map`, `void` değerini döndürür. Geri çağırmanın herhangi bir çağrısı hataya neden olursa, `ipfs.map`'i çağıran işleyici durdurulur ve subgraph başarısız olarak işaretlenir.

### Kripto(Crypto) API'si

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

`Crypto` API'si, eşleştirmelerde kullanılmak üzere kriptografik işlevlerin kullanımını sağlar. Şu anda sadece bir tane vardır:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON verileri `json` API'si kullanılarak ayrıştırılabilir:

- `json.fromBytes(data: Bytes): JSONValue` – geçerli bir UTF-8 sekansı olarak yorumlanan bir `Baytlar` dizisindeki JSON verilerini ayrıştırır
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – `json.fromBytes` güvenli versiyonudur ve ayrıştırma başarısız olursa bir hata varyantı döndürür
- `json.fromString(data: string): JSONValue` – geçerli bir UTF-8 `Dizgisi`'nden JSON verilerini ayrıştırır
- `json.try_fromString(data: string): Result<JSONValue, boolean>` – `json.fromString` güvenli versiyonudur ve ayrıştırma başarısız olursa bir hata varyantı döndürür

`JSONValue` sınıfı, rastgele bir JSON belgesinden değerleri çekmek için bir yol sağlar. JSON değerleri booleanlar, sayı, dizi ve daha fazlası olabileceğinden `JSONValue`, bir değerin türünü kontrol etmek için bir `kind` özelliğiyle birlikte gelir:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

Ek olarak, değerin `null` olup olmadığını kontrol etmek için bir yöntem vardır:

- `value.isNull(): boolean`

Bir değerin türü belirli olduğunda, aşağıdaki yöntemlerden biri kullanılarak [gömüşü türe](#built-in-types) dönüştürülebilir:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (ve daha sonra `JSONValue`'yu yukarıdaki 5 yöntemden biriyle dönüştürün)

### Tip Dönüşümleri Referansı

| Kaynak(lar)         | Hedef                | Dönüşüm fonksiyonu           |
| ------------------- | -------------------- | ---------------------------- |
| Adres(Address)      | Baytlar(Bytes)       | yok                          |
| Adres(Address)      | Dizgi                | s.toHexString()              |
| BigDecimal          | Dizgi                | s.toString()                 |
| BigInt              | BigDecimal           | s.toBigDecimal()             |
| BigInt              | Dizgi (onaltılık)    | s.toHexString() or s.toHex() |
| BigInt              | Dizgi (Evrensel Kod) | s.toString()                 |
| BigInt              | i32                  | s.toI32()                    |
| Boolean             | Boolean              | yok                          |
| Baytlar (işaretli)  | BigInt               | BigInt.fromSignedBytes(s)    |
| Baytlar (işaretsiz) | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Baytlar             | Dizgi (onaltılık)    | s.toHexString() or s.toHex() |
| Baytlar             | Dizgi (Evrensel Kod) | s.toString()                 |
| Baytlar             | Dizgi (base58)       | s.toBase58()                 |
| Baytlar             | i32                  | s.toI32()                    |
| Baytlar             | u32                  | s.toU32()                    |
| Baytlar             | JSON                 | json.fromBytes(s)            |
| int8                | i32                  | yok                          |
| int32               | i32                  | yok                          |
| int32               | BigInt               | BigInt.fromI32(s)            |
| uint24              | i32                  | yok                          |
| int64 - int256      | BigInt               | yok                          |
| uint32 - uint256    | BigInt               | yok                          |
| JSON                | boolean              | s.toBool()                   |
| JSON                | i64                  | s.toI64()                    |
| JSON                | u64                  | s.toU64()                    |
| JSON                | f64                  | s.toF64()                    |
| JSON                | BigInt               | s.toBigInt()                 |
| JSON                | dizgi                | s.toString()                 |
| JSON                | Dizi                 | s.toArray()                  |
| JSON                | Nesne                | s.toObject()                 |
| Dizgi               | Adres                | Address.fromString(s)        |
| Baytlar             | Adres                | Address.fromBytes(s)         |
| Dizgi               | BigInt               | BigInt.fromString(s)         |
| Dizgi               | BigDecimal           | BigDecimal.fromString(s)     |
| Dizgi (onaltılık)   | Baytlar              | ByteArray.fromHexString(s)   |
| String (UTF-8)      | Baytlar              | ByteArray.fromUTF8(s)        |

### Veri Kaynağı Meta Verileri

`dataSource` ad alanı aracılığıyla, işleyiciyi çağıran veri kaynağının sözleşme adresini, ağını ve bağlamını inceleyebilirsiniz:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Varlık ve VeriKaynağıBağlamı

Temel `Entity` sınıfı ve alt `DataSourceContext` sınıfı, alanları dinamik olarak ayarlamak ve almak için yardımcı programlara sahiptir:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### DataSourceContext in Manifest

The `context` section within `dataSources` allows you to define key-value pairs that are accessible within your subgraph mappings. The available types are `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, and `BigInt`.

Here is a YAML example illustrating the usage of various types in the `context` section:

```yaml
dataSources:
  - kind: ethereum/contract
    name: ContractName
    network: mainnet
    context:
      bool_example:
        type: Bool
        data: true
      string_example:
        type: String
        data: 'hello'
      int_example:
        type: Int
        data: 42
      int8_example:
        type: Int8
        data: 127
      big_decimal_example:
        type: BigDecimal
        data: '10.99'
      bytes_example:
        type: Bytes
        data: '0x68656c6c6f'
      list_example:
        type: List
        data:
          - type: Int
            data: 1
          - type: Int
            data: 2
          - type: Int
            data: 3
      big_int_example:
        type: BigInt
        data: '1000000000000000000000000'
```

- `Bool`: Specifies a Boolean value (`true` or `false`).
- `String`: Specifies a String value.
- `Int`: Specifies a 32-bit integer.
- `Int8`: Specifies an 8-bit integer.
- `BigDecimal`: Specifies a decimal number. Must be quoted.
- `Bytes`: Specifies a hexadecimal string.
- `List`: Specifies a list of items. Each item needs to specify its type and data.
- `BigInt`: Specifies a large integer value. Must be quoted due to its large size.

This context is then accessible in your subgraph mapping files, enabling more dynamic and configurable subgraphs.

### Genel AssemblyScript Sorunları

Subgraph geliştirme sırasında sıkça karşılaşılan genel [AssemblyScript](https://github.com/AssemblyScript/assemblyscript)sorunları bulunmaktadır. Bunlar hata ayıklama zorluğunda farklılık gösterse de, bunların farkında olmak yardımcı olabilir. Aşağıda bu sorunların kapsamlı olmayan bir listesi bulunmaktadır:

- `Özel(Private)` sınıf değişkenleri [AssembyScript](https://www.assemblyscript.org/status.html#language-features)'de kullanımı mecburi değildir. Sınıf değişkenlerini doğrudan sınıf nesnesinden değiştirilmekten korumanın bir yolu yoktur.
- Kapsam, [closure fonksiyonu](https://www.assemblyscript.org/status.html#on-closures) tarafından devralınmaz, yani closure fonksiyonları dışında tanımlanan değişkenler kullanılamaz. [Geliştirici Öne Çıkanları #3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s)'teki açıklama.
