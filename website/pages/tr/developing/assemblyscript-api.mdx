---
title: AssemblyScript API'si
---

> Not: Eğer `graph-cli`/`graph-ts` `0.22.0`, sürümünden önce bir subgraph oluşturduysanız, eski bir AssemblyScript sürümünü kullanıyorsunuz demektir. [`Taşıma Rehberi`](/release-notes/assemblyscript-migration-guide) adlı rehbere bakmanızı öneririz

Bu sayfa subgraph eşleştirmelerini yazarken bullanılabilen yerleşik API'leri belgelemektedir. Hazır olarak iki çeşit API mevcuttur:

- [Graph TypeScript kütüphanesi](https://github.com/graphprotocol/graph-ts) (`graph-ts`) ve
- code generated from subgraph files by `graph codegen`.

Ayrıca, [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) ile uyumlu oldukları sürece diğer kütüphaneler de bağlılıklar(dependencies) olarak ekleyebilirsiniz. Bu, eşleştirmelerin yazıldığı dil olduğundan, [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki), dil ve standart kütüphane özellikleri için iyi bir kaynaktır.

## Kurulum

[`graph init`](/developing/creating-a-subgraph) ile oluşturulan subgraph'lar, önceden yapılandırılmış bağlılıklarla birlikte gelir. Bu bağlılıkları yüklemek için yapılması gereken tek şey aşağıdaki komutlardan birini çalıştırmaktır:

```sh
yarn install # Yarn
npm install  # NPM
```

Subgraph sıfırdan oluşturulduysa, Graph TypeScript kütüphanesini bir bağlılık olarak yüklemek için aşağıdaki iki komuttan biri kullanılabilir:

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## API Referansı

`@graphprotocol/graph-ts` kütüphanesi, aşağıdaki API'leri sağlamaktadır:

- Ethereum akıllı sözleşmeleri, olaylar, bloklar, işlemler ve Ethereum değerleriyle çalışmak için bir `Ethereum` API'si.
- Graph Düğüm deposundan varlıkları yüklemek ve kaydetmek için bir `store` API'si.
- Graph Düğüm çıktısına ve Graph Gezgini'ne mesaj yazmak için bir `log` API'si.
- IPFS'den dosya yüklemek için bir `ipfs` API'si.
- JSON verilerini ayrıştırmak için bir `json` API'si.
- Kriptografik fonksiyonları kullanmak için bir `crypto` API'si.
- Ethereum, JSON, GraphQL ve AssemblyScript gibi farklı tip sistemler arası çeviri yapmak için düşük seviyeli yazılımlar.

### Sürümler

The `apiVersion` in the subgraph manifest specifies the mapping API version which is run by Graph Node for a given subgraph.

| Sürüm | Sürüm Notları                                                                                                                                                                                                                                                                               |
|:-----:| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0.0.7 | Ethereum tiplerine `TransactionReceipt` ve `Log` sınıfları eklendi<br />Ethereum Olay nesnesine `receipt` alanı eklendi                                                                                                                                                               |
| 0.0.6 | Ethereum Transaction nesnesine `nonce` alanı eklendi<br />Ethereum Block nesnesine `baseFeePerGas` eklendi                                                                                                                                                                            |
| 0.0.5 | AssemblyScript sürümü 0.19.10'a yükseltildi (bu, bozulmalara neden olan değişiklikleri içerir, lütfen [`Taşıma Rehberi'ne`](/release-notes/assemblyscript-migration-guide) göz atın)<br />`ethereum.transaction.gasUsed`, `ethereum.transaction.gasLimit` olarak yeniden adlandırıldı |
| 0.0.4 | Ethereum SmartContractCall nesnesine `functionSignature` alanı eklendi                                                                                                                                                                                                                      |
| 0.0.3 | Ethereum Call nesnesine `from` alanı eklendi<br />`etherem.call.address`, `ethereum.call.to` olarak yeniden adlandırıldı                                                                                                                                                              |
| 0.0.2 | Ethereum Transaction nesnesine `input` alanı eklendi                                                                                                                                                                                                                                        |

### Dahili Türler

AssemblyScript'e dahil edilmiş olan temel türler hakkındaki belgeler, [AssemblyScript wiki'de](https://github.com/AssemblyScript/assemblyscript/wiki/Types). bulunabilir.

Aşağıdaki ek türler, `@graphprotocol/graph-ts` tarafından sağlanmaktadır.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray`, bir `u8` dizisini temsil etmektedir.

_Construction_

- `fromI32(x: i32): ByteArray` - `x`'i baytlara ayırır.
- `fromHexString(hex: string): ByteArray` - Girdi uzunluğu çift olmalıdır. `0x` ön eki isteğe bağlıdır.

_Tip dönüşümleri_

- `toHexString(): string` - Başına `0x` eklenmiş bir onaltılık dizgiye gönüştürür.
- `toString(): string` - Bayrları bir UTF-8 dizesi olarak yorumlar.
- `toBase58(): string` - Baytları bir base58 dizgisine kodlar.
- `toU32(): u32` - Baytları önemli bayt'ın en sağda olduğu(little-endian) bir `u32` sıralaması olarak yorumlar. Taşma durumunda hata verir.
- `toI32(): i32` - Bayt dizisini önemli bayt'ın en sağda olduğu bir `i32` sıralaması olarak yorumlar. Taşma durumunda hata verir.

_Operatörler_

- `equals(y: ByteArray): bool` – `x == y` şeklinde yazılabilir.
- `concat(other: ByteArray) : ByteArray` - `this`'in hemen ardından gelen `other`'dan oluşan yeni bir `ByteArray` döndürür
- `concatI32(other: i32) : ByteArray` - `other`'ın bayt temsiline takiben `this`'ten oluşan yeni `ByteArray` döndürür

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal`, arbitrary precision ondalık sayıları temsil etmek için kullanılır.

> Not: [Dahili olarak](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal`, 34 ondalık basamağı destekleyen [IEEE-754 decimal128 kayan nokta formatında](https://en.wikipedia.org/wiki/Decimal128_floating-point_format) saklanır. Bu `BigDecimal`'in Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) veya benzeri uyarlamalar gibi 34 basamakdan daha geniş yayılabilen sabit nokta tiplerini temsil etmek için uygun olmadığı anlamına gelir.

_Construction_

- `constructor(bigInt: BigInt)` – `BigInt`'ten `BigDecimal` oluşturur.
- `static fromString(s: string): BigDecimal` – Ondalık bir dizeyi ayrıştırır.

_Tip dönüşümleri_

- `toString(): string` – ondalık dizeye yazdırır.

_Matematik_

- `plus(y: BigDecimal): BigDecimal` – `x + y` şeklinde yazılabilir.
- `minus(y: BigDecimal): BigDecimal` – `x - y` şeklinde yazılabilir.
- `times(y: BigDecimal): BigDecimal` – `x * y` şeklinde yazılabilir.
- `div(y: BigDecimal): BigDecimal` – `x / y` şeklinde yazılabilir.
- `equals(y: BigDecimal): bool` – `x == y` şeklinde yazılabilir.
- `notEqual(y: BigDecimal): bool` – `x != y` şeklinde yazılabilir.
- `lt(y: BigDecimal): bool` – `x < y` şeklinde yazılabilir.
- `le(y: BigDecimal): bool` – `x <= y` şeklinde yazılabilir.
- `gt(y: BigDecimal): bool` – `x > y` şeklinde yazılabilir.
- `ge(y: BigDecimal): bool` – `x >= y` şeklinde yazılabilir.
- `neg(): BigDecimal` - `-x` şeklinde yazılabilir.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` büyük tamsayıları temsil etmek için kullanılır. Bu, `uint32`'den `uint256`'ya ve `int64`'den `int256`'ya kadarki Ethereum değerlerini içerir. `uint32`, `uint24` veya `int8` gibi `uint32` altındaki her şey `i32` olarak temsil edilir.

`BigInt` sınıfı aşağıdaki API'yi içerir:

_Construction_

- `BigInt.fromI32(x: i32): BigInt` – `i32`'den `BigInt` oluşturur.
- `BigInt.fromString(s: string): BigInt`– Bir dizgiden `BigInt` çözümler.
- `BigInt.fromUnsignedBytes(x: Bytes): BigInt` – `baytları` işaretsiz, önemli bayt'ın sağda olduğu(little-endian) tamsayı olarak yorumlar. Girdiniz önemli bayt'ın solda olduğu(big-endian) ise önce `.reverse()`'ü çağırın.
- `BigInt.fromSignedBytes(x: Bytes): BigInt` – `baytları` işaretli, önemli bayt'ın sağda olduğu(little-endian) tamsayı olarak yorumlar. Girdiniz önemli bayt'ın solda olduğu(big-endian) ise önce `.reverse()`'ü çağırın.

  _Tip dönüşümleri_

- `x.toHex(): string` – `BigInt`'ı onaltılık karakter dizgisine dönüştürür.
- `x.toString(): string` – `BigInt`'ı ondalık sayı dizgisine dönüştürür.
- `x.toI32(): i32` – `BigInt`'i bir `i32` olarak döndürür; değer `i32`'ye sığmazsa başarısız olur. Önce `x.isI32()` kontrolünü yapmak mantıklı olur.
- `x.toBigDecimal(): BigDecimal` - kesir kısmı olmayan bir ondalık sayıya dönüştürür.

_Matematik_

- `x.plus(y: BigInt): BigInt` – `x + y` şeklinde yazılabilir.
- `x.minus(y: BigInt): BigInt` – `x - y` şeklinde yazılabilir.
- `x.times(y: BigInt): BigInt` – `x * y` şeklinde yazılabilir.
- `x.div(y: BigInt): BigInt` – `x / y` şeklinde yazılabilir.
- `x.mod(y: BigInt): BigInt` – `x % y` şeklinde yazılabilir.
- `x.equals(y: BigInt): bool` – `x == y` şeklinde yazılabilir.
- `x.notEqual(y: BigInt): bool` – `x != y` şeklinde yazılabilir.
- `x.lt(y: BigInt): bool` – `x < y` şeklinde yazılabilir.
- `x.le(y: BigInt): bool` – `x <= y` şeklinde yazılabilir.
- `x.gt(y: BigInt): bool` – `x > y` şeklinde yazılabilir.
- `x.ge(y: BigInt): bool` – `x >= y` şeklinde yazılabilir.
- `x.neg(): BigInt` – `-x` şeklinde yazılabilir.
- `x.divDecimal(y: BigDecimal): BigDecimal` – ondalık sonuç veren, ondalıkla bölme işlemi yapar.
- `x.isZero(): bool` – Sayının sıfır olup olmadığını kontrol etmek için kullanılır.
- `x.isI32(): bool` –Sayının `i32`'ye sığıp sığmayacağını kontrol eder.
- `x.abs(): BigInt` – Mutlak değerini alır.
- `x.pow(exp: u8): BigInt` – Üs alma işlemi yapar.
- `bitOr(x: BigInt, y: BigInt): BigInt` – `x | y` şeklinde yazılabilir.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – `x & y` şeklinde yazılabilir.
- `leftShift(x: BigInt, bits: u8): BigInt` – `x << y` şeklinde yazılabilir.
- `rightShift(x: BigInt, bits: u8): BigInt` – `x >> y` şeklinde yazılabilir.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap`, anahtar-değer çiftlerini depolamak için kullanılabilir. Bu [örneği](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51) inceleyin.

`TypedMap` sınıfı API'si şunlardır:

- `new TypedMap<K, V>()` – `K` türündeki anahtarlar ve `T` türündeki değerlerle boş bir harita oluşturur
- `map.set(key: K, value: V): void` – `key` değerini `value` olarak ayarlar
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – bir `key` için anahar-değer çiftini döndürür veya `key` haritada mevcut değilse `null` olarak döndürür
- `map.get(key: K): V | null` – bir `key` için değeri döndürür veya `key` haritada yoksa `null` olarak döndürür
- `map.isSet(key: K): bool` – `key` haritada mevcutsa `true`, değilse `false` döndürür

#### Baytlar

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`Bytes`, belli bir uzunluğa sahip olmayan bayt dizilerini temsil etmek için kullanılır. Bu, Ethereum'un `bytes`, `bytes32` vb. türlerini içerir.

`Bytes` sınıfı AssemblyScript'in [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) sınıfını genişletir ve `Uint8Array` işlevlerini desteklemenin yanı sıra aşağıdaki yeni yöntemleride destekler:

_Construction_

- `fromHexString(hex: string) : Bytes` - Çift sayıda onaltılık basamaktan oluşması gereken `hex` dizgisini `ByteArray`'a dönüştürür. `hex` dizgisi isteğe bağlı olarak `0x` ile başlayabilir
- `fromI32(i: i32) : Bytes` - `i`'yi bayt dizisine dönüştürür

_Tip dönüşümleri_

- `b.toHex()` – dizideki baytları temsil eden onaltılık bir dizgi döndürür
- `b.toString()` – dizideki baytları bir evrensel kod karakter dizgisine dönüştürür
- `b.toBase58()` – bir Ethereum Bytes değerini base58 kodlamasına dönüştürür (IPFS hash'larında kullanılır)

_Operatörler_

- `b.concat(other: Bytes) : Bytes` - doğrudan `this` ve ardından `other`'dan oluşan yeni `Bytes` döndürür
- `b.concatI32(other: i32) : ByteArray` - `other`'ın bayt temsiline takiben `this`'ten oluşan yeni `Bytes` döndürür

#### Address

```typescript
import { Address } from '@graphprotocol/graph-ts'
```

`Address`, Ethereum `adres` değerlerini temsil etmek için `Baytları` genişletir.

`Baytlar` API'si üzerine aşağıdaki metod'u ekler:

- `Address.fromString(s: string): Address` – onaltılık bir dizgiden `Adres` oluşturur
- `Address.fromBytes(b: Bytes): Address` – tam olarak 20 bayt uzunluğunda olması gereken `b`'den bir `Adres` oluşturur. Daha az veya daha fazla bayt içeren bir değerin iletilmesi hatayla sonuçlanır

### Store API

```typescript
import { store } from '@graphprotocol/graph-ts'
```

`Store` API, varlıkları Graph Düğüm deposuna yüklenmesi, kaydedilmesi ve depodan kaldırılmasına olanak tanır.

Depoya yazılan varlıklar, GraphQL şemasında tanımlanan `@entity` türleriyle bire bir eşlenir. Bunlarla çalışmayı kolaylaştırmak için [Graph CLI](https://github.com/graphprotocol/graph-cli) tarafından sağlanan `graph codegen` komutu, şema alanları için özellik geliştirici ve ayarlayıcı olan; bu unsurları yükleme ve kaydetme yöntemlerine sahip `Entity` türünden alt sınıfları olan unsur sınıflarını oluşturur.

#### Unsurların Oluşturulması

Aşağıdaki, Ethereum olaylarından varlıklar oluşturmak için yaygın bir modeldir.

```typescript
// Import the Transfer event class generated from the ERC20 ABI
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// Import the Transfer entity type generated from the GraphQL schema
import { Transfer } from '../generated/schema'

// Transfer event handler
export function handleTransfer(event: TransferEvent): void {
  // Create a Transfer entity, using the transaction hash as the entity ID
  let id = event.transaction.hash
  let transfer = new Transfer(id)

  // Set properties on the entity, using the event parameters
  transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Save the entity to the store
  transfer.save()
}
```

Zincir işleme sırasında bir `Transfer` olayıyla karşılaşılması durumunda, bu üretilen `Transfer` türü kullanılarak (varlık türüyle bir adlandırma çakışmasını önlemek amacıyla burada `TransferEvent` olarak adlandırılmıştır) `handleTransfer` olay işleyicisine iletilir. Bu tür, olayın ana işlemi ve parametreleri gibi verilere erişimi sağlar.

Çakışmaları önlemek için her varlık benzersiz bir kimliğe sahip olmalıdır. Genellikle olay parametreleri, kullanılabilecek benzersiz bir tanımlayıcı içerir. Not: Kimlik olarak işlem hash'ını kullanmak aynı işlemdeki başka hiçbir olayın bu hash'ı kullanarak kimlik olarak varlık oluşturmayacağını varsayar.

#### Depodan varlık yükleme

Bir varlık mevcutsa aiağıdaki kod kullanılarak depodan yüklenebilir:

```typescript
let id = event.transaction.hash // veya kimlik(ID) nasıl oluşturulmuşsa
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Transfer varlığı önceki gibi kullanılır
```

Varlığın depoda mevcut olmaması durumunda `yükleme` metodu `Transfer | null` türünde bir değer döndürür. Bu nedenle değeri kullanmadan önce `null` durumunu kontrol etmek gerekebilir.

> **Not:** Varlıkların yüklenmesi, yalnızca eşleştirmede yapılan değişiklikler bir varlığın önceki verilerine bağlıysa gereklidir. Mevcut varlıkları güncellemenin iki yolu için bir sonraki bölüme bakın.

#### Bir blok içinde oluşturulan varlıkları arama

`graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 ve `@graphprotocol/graph-cli` v0.49.0 sürümlerinden itibaren `loadInBlock` yöntemi tüm varlık türlerinde kullanılabilir.

Store API, mevcut blokta oluşturulan veya güncellenen varlıkların alınmasını kolaylaştırır. Bunun için tipik bir durum, bir işleyicinin zincir üzerindeki bir etkinlikten bir İşlem oluşturması ve daha sonraki bir işleyicinin varsa bu işleme erişmek istemesidir. İşlemin mevcut olmadığı durumda, subgraph sadece varlığın mevcut olmadığını öğrenmek için veritabanına gitmek zorunda kalacaktır; eğer subgraph yazarı varlığın aynı blokta yaratılmış olması gerektiğini zaten biliyorsa, loadInBlock kullanmak bu veritabanı gidiş gelişini önler. Bazı subgraphlar için, bu kaçırılan aramalar indeksleme süresine önemli ölçüde katkıda bulunabilir.

```typescript
let id = event.transaction.hash // veya ID nasıl oluşturulurmuşsa
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Transfer varlığını daha önce olduğu gibi kullanın
```

> Not: Verilen blokta oluşturulmuş bir varlık yoksa, depoda verilen ID'ye sahip bir varlık olsa bile `loadInBlock` `null` değerini döndürür.

#### Türetilmiş varlıkları arama

`graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 ve `@graphprotocol/graph-cli` v0.51.0 sürümlerinden itibaren `loadRelated` yöntemi kullanılabilir.

Bu, türetilmiş varlık alanlarının bir olay işleyicisi içinden yüklenmesini sağlar. Örneğin, aşağıdaki şema göz önüne alındığında:

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

Aşağıdaki kod, `Holder` varlığının türetildiği `Token` varlığını yükleyecektir:

```typescript
let holder = Holder.load('test-id')
// Load the Token entity that the Holder entity was derived from
let token = holder.tokens.load()
```

#### Mevcut varlıkları güncelleme

Mevcut bir varlığı güncellemenin iki yolu vardır:

1. Örneğin `Transfer.load(id)` ile varlığu yükleyin, varlığın özelliklerini belirleyin ve daha sonra `.save()` yöntemini kullanarak depoya geri kaydedin.
2. Örneğin `new Transfer(id)` ile kolayca varlık oluşturun, verlığın özelliklerini belirleyin ve daha sonra `.save()` yöntemini kullanarak depoya kaydedin. Varlık mevcutsa, değişiklikler mevcut varlığın üzerine kaydedilir.

Oluşturulan özellik ayarlayıcılar sayesinde çoğu durumda özellikerin değiştirilmesi kolaydır:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Ayrıca aşağıdaki iki talimattan biriyle özellikleri kaldırmakta mümkündür:

```typescript
transfer.from.unset()
transfer.from = null
```

Bu örneğin GraphQL'de `!` olmadan tanımlanan özellikler gibi sadece isteğe bağlı özelliklerde çalışır. İki örnek `owner: Bytes` veya `amount: BigInt` olabilir.

Dizi özelliklerini güncelleme biraz daha karmaşıktır, çünkü bir varlıkta bir diziyi almak, o dizinin bir kopyasını oluşturur. Bu, dizilerin değiştirildikten sonra açıkça yeniden ayarlanması gerektiği anlamına gelir. Aşağıdakiler `entity`'nin bir `numbers: [BigInt!]!`'a sahip olduğunu varsayar.

```typescript
// Bu işe yaramaz
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// Bu çalışır
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Depodan varlık kaldırma

Şu anda oluşturulan türler aracılığıyla bir varlığı kaldırmanın yolu yoktur. Bunun yerine, bir varlığın kaldırılması varlık türünün adının ve kimliğinin `store.remove`'a iletilmesini gerektirir:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API'si, akıllı sözleşmelere, genel durum değişkenlerine, sözleşme fonksiyonlarına, olaylara, işlemlere, bloklara ve Ethereum verilerinin kodlama/çözme işlemlerine erişim sağlar.

#### Ethereum Türleri İçin Destek

Varlıkla gibi, `graph codegen` oluşturma, bir subgraph'ta kullanılan tüm akıllı sözleşme ve olaylar için sınıflar oluşturur. Bunun için, ABI dosyalarının subgraph manifestindeki veri kaynağı bir parçası olması gerekir. Genellikle, ABI dosyaları `abis/` klasöründe saklanır.

Oluşturulan sınıflarla Ethereum türleri ile [gömülü türler](#built-in-types) arasındaki dönüşümler arka planda gerçekleştirilir, böylece subgraph yazarları bununla ilgilenmek zorunda kalmazlar.

Aşağıdaki örnek bunu açıklar. Aşağıdaki gibi bir subgraph şeması verildiğinde

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

ve Ethereum'da bir `Transfer(address,address,uint256)` olay imzası olduğunda `address`, `address` ve `uint256` türündeki `from`, `to` ve `amount` değerleri `address` ve `BigInt`'e dönüştürülür, böylece `Transfer` varlığının `Bytes!` ve `BigInt!` özelliklerine aktarılabilir:

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### Olaylar ve Blok/İşlem Verileri

Önceki örneklerdeki `Transfer` olayı gibi olay işleyicilerine iletilen Ethereum olayları, yalnızca olay parametrelerine değil, aynı zamanda ilişkili işlemlerine ve parçası oldukları bloğa da erişim sağlar. Aşağıdaki veriler `event` örneklerinden elde edilebilir (bu sınıflar, `graph-ts`'de bulunan `ethereum` modülünün bir parçasıdır):

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Akıllı Sözleşme Durumuna Erişim

`Graph codegen` tarafından oluşturulan kod subgraph'ta kullanılan akıllı sözleşmeler için sınıflar da içerir. Bunlar, geçerli blokta sözleşmenin genel durum değişkenlerine ve çağrı işlevlerine erişmek için kullanılabilir.

Yaygın bir model, bir olayın kaynaklandığı sözleşmeye erişmektir. Bu, aşağıdaki kodla elde edilir:

```typescript
// Import the generated contract class and generated Transfer event class
import { ERC20Contract, Transfer as TransferEvent } from '../generated/ERC20Contract/ERC20Contract'
// Import the generated entity class
import { Transfer } from '../generated/schema'

export function handleTransfer(event: TransferEvent) {
  // Bind the contract to the address that emitted the event
  let contract = ERC20Contract.bind(event.address)

  // Access state variables and functions by calling them
  let erc20Symbol = contract.symbol()
}
```

Burada `Transfer`, varlık türüyle bir isim çakışmasını önlemek için `TransferEvent` olarak yeniden adlandırılmıştır

Ethereum üzerindeki `ERC20Contract`, `symbol` adlı genel sadece okunabilir bir işleve sahip olduğu sürece, `.symbol()` ile çağrılabilir. Genel durum değişkenleri için aynı ada sahip bir yöntem otomatik olarak oluşturulur.

Subgraph parçası olan diğer tüm sözleşmelerde oluşturulan koddan içe aktarılabilir ve geçerli bir adrese bağlanabilir.

#### Geri Dönen Çağrıları Yönetme

Sözleşmenizin sadece okunur yöntemleri geri dönebilirse, o zaman `try_` önekiyle oluşturulan sözleşme metodunu çağırarak bunu halletmelisiniz. Örneğin, Gravity sözleşmesi `gravatarToOwner` metodunu kullanıma sunar. Bu kod bu yöntemde bir geri dönüşü işleyebilir:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

Bir Geth veya Infura istemcisine bağlı bir Graph düğümünün tüm geri dönüşleri algılamayabileceğini unutmayın, bu durumda Parity istemcisine bağlı bir Graph düğümü kullanmanızı öneririz.

#### ABI Kodlama/Çözme

Veriler, `ethereum` modülündeki `encode` ve `decode` işlevleri kullanılarak Ethereum'un ABI kodlama formatına göre kodlanabilir ve kodu çözülebilir.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

Daha fazla bilgi için:

- [ABI Spesifikasyonu](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- [Rust kütüphanesi/CLI](https://github.com/rust-ethereum/ethabi) kodlama/çözme
- Daha [karmaşık bir örnek](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Logging API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

`Log` API, Subgraph'ların Graph Gezgini'nin yanı sıra Graph Düğüm standart çıktısına bilgi kaydetmesine izin verir. Mesajlar, farklı günlük seviyelerde kaydedilebilir. Argümandan günlük mesajları oluşturmak için basit bir biçim dizgi sözdizimi sağlanmıştır.

`Log` API'si aşağıdaki fonksiyonları içerir:

- `log.debug(fmt: string, args: Array<string>): void` - hata ayıklama mesajı kaydeder.
- `log.info(fmt: string, args: Array<string>): void` - bilgilendirici mesaj kaydeder.
- `log.warning(fmt: string, args: Array<string>): void` - uyarı mesajı kaydeder.
- `log.error(fmt: string, args: Array<string>): void` - hata mesajı kaydeder.
- `log.critical(fmt: string, args: Array<string>): void` – kritik bir mesaj kaydeder _ve_ subgraph'ı sonlandırır.

`Log` API, bir biçim dizgisi ve bir dizi dizgisi değeri alır. Ardından yer tutucuları dizi'den gelen dizgi değerleriyle değiştirir. İlk `{}` yer tutucusu dizi içindeki ilk değerle, ikinci `{}` yer tutucusu ikinci değerle değiştirilir ve bu böyle devam eder.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Bir veya daha fazla değerin loglanması

##### Tek bir değerin loglanması

Aşağıdaki örnekte, "A" dizgi değeri, loglanmadan önce `['A']` olacak şekilde bir diziye geçirilir:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Mevcut bir diziden tek bir girişi loglama

Aşağıdaki örnekte, bağımsız değişken dizisi üç değer içermesine rağmen dizinin yalnızca ilk değeri loglanır.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler: "My value is: A"  ('log.info'ya üç değer iletilmiş olsa da)
  log.info('My value is: {}', myArray)
}
```

#### Mevcut bir diziden birden çok girişi kaydetme

Argümanlar dizisindeki her giriş, log mesajı dizesinde kendi yer tutucusu `{}`i gerektirir. Aşağıdaki örnek, log mesajında üç yer tutucu `{}` içerir. Bu nedenle, `myArray` içindeki üç değerin tümü loglanır.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler: "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Mevcut bir diziden belirli bir girişi loglama

Dizide belirli bir değeri görüntülemek için dizinlenmiş değer bulunmalıdır.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Görüntüler : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Olay bilgilerinin loglanması

Aşağıdaki örnek, bir olaydan blok numarasını, blok hash'ını ve işlem hash'ını loglar:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Akıllı sözleşmeler zaman zaman IPFS dosyaları zincir üstüde tuttururlar. Bu, eşleştirmelerin IPFS hash'larını almasına ve IPFS'ten ilgili dosyaları okumasına olanak tanır. Dosya verileri `Bayt` olarak döndürülür, bu da genellikle daha fazla işlem gerektirir, örneğin bu sayfanın sonlarında belgelenen `json` API ile.

IPFS hash'ı veya yolu verildiğinde, bir dosyayı IPFS'den okuma şu şekilde yapılır:

```typescript
// Put this inside an event handler in the mapping
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Paths like `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// that include files in directories are also supported
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

**Note:** `ipfs.cat` şu anda belirli değildir. Dosya, istek zaman aşımına uğramadan önce IPFS ağından alınamazsa, `null` değeri döndürür. Bu nedenle, sonucun `null` olup olmadığını her zaman kontrol etmek önemlidir.

Ayrıca, `ipfs.map` ile daha büyük dosyaları akış şeklinde işlemek mümkündür. Fonksiyon durumunu değiştirmek için bir IPFS dosyasının hash veya yolunu, bir geri çağrı adını veya işaretini bekler:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Callbacks can also created entities
  let newItem = new Item(id)
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Set parent to "parentId"
  newitem.save()
}

// Put this inside an event handler in the mapping
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Alternatively, use `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

The only flag currently supported is `json`, which must be passed to `ipfs.map`. With the `json` flag, the IPFS file must consist of a series of JSON values, one value per line. The call to `ipfs.map` will read each line in the file, deserialize it into a `JSONValue` and call the callback for each of them. The callback can then use entity operations to store data from the `JSONValue`. Entity changes are stored only when the handler that called `ipfs.map` finishes successfully; in the meantime, they are kept in memory, and the size of the file that `ipfs.map` can process is therefore limited.

On success, `ipfs.map` returns `void`. If any invocation of the callback causes an error, the handler that invoked `ipfs.map` is aborted, and the subgraph is marked as failed.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

The `crypto` API makes a cryptographic functions available for use in mappings. Right now, there is only one:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON data can be parsed using the `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array interpreted as a valid UTF-8 sequence
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – safe version of `json.fromBytes`, it returns an error variant if the parsing failed
- `json.fromString(data: string): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(data: string): Result<JSONValue, boolean>` – safe version of `json.fromString`, it returns an error variant if the parsing failed

The `JSONValue` class provides a way to pull values out of an arbitrary JSON document. Since JSON values can be booleans, numbers, arrays and more, `JSONValue` comes with a `kind` property to check the type of a value:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

In addition, there is a method to check if the value is `null`:

- `value.isNull(): boolean`

When the type of a value is certain, it can be converted to a [built-in type](#built-in-types) using one of the following methods:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (and then convert `JSONValue` with one of the 5 methods above)

### Type Conversions Reference

| Source(s)           | Destination          | Conversion function          |
| ------------------- | -------------------- | ---------------------------- |
| Address             | Baytlar              | yok                          |
| Adres(Address)      | String               | s.toHexString()              |
| BigDecimal          | String               | s.toString()                 |
| BigInt              | BigDecimal           | s.toBigDecimal()             |
| BigInt              | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt              | Dizgi (Evrensel Kod) | s.toString()                 |
| BigInt              | i32                  | s.toI32()                    |
| Boolean             | Boolean              | yok                          |
| Baytlar (işaretli)  | BigInt               | BigInt.fromSignedBytes(s)    |
| Baytlar (işaretsiz) | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Baytlar             | Dizgi (onaltılık)    | s.toHexString() or s.toHex() |
| Baytlar             | Dizgi (Evrensel Kod) | s.toString()                 |
| Baytlar             | Dizgi (base58)       | s.toBase58()                 |
| Baytlar             | i32                  | s.toI32()                    |
| Baytlar             | u32                  | s.toU32()                    |
| Baytlar             | JSON                 | json.fromBytes(s)            |
| int8                | i32                  | yok                          |
| int32               | i32                  | yok                          |
| int32               | BigInt               | BigInt.fromI32(s)            |
| uint24              | i32                  | yok                          |
| int64 - int256      | BigInt               | yok                          |
| uint32 - uint256    | BigInt               | yok                          |
| JSON                | boolean              | s.toBool()                   |
| JSON                | i64                  | s.toI64()                    |
| JSON                | u64                  | s.toU64()                    |
| JSON                | f64                  | s.toF64()                    |
| JSON                | BigInt               | s.toBigInt()                 |
| JSON                | string               | s.toString()                 |
| JSON                | Dizi                 | s.toArray()                  |
| JSON                | Nesne                | s.toObject()                 |
| String              | Adres                | Address.fromString(s)        |
| Baytlar             | Adres                | Address.fromBytes(s)         |
| String              | BigInt               | BigInt.fromString(s)         |
| String              | BigDecimal           | BigDecimal.fromString(s)     |
| Dizgi (onaltılık)   | Baytlar              | ByteArray.fromHexString(s)   |
| String (UTF-8)      | Baytlar              | ByteArray.fromUTF8(s)        |

### Veri Kaynağı Meta Verileri

`dataSource` ad alanı aracılığıyla, işleyiciyi çağıran veri kaynağının sözleşme adresini, ağını ve bağlamını inceleyebilirsiniz:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Varlık ve VeriKaynağıBağlamı

Temel `Entity` sınıfı ve alt `DataSourceContext` sınıfı, alanları dinamik olarak ayarlamak ve almak için yardımcı programlara sahiptir:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### Genel AssemblyScript Sorunları

Subgraph geliştirme sırasında sıkça karşılaşılan genel [AssemblyScript](https://github.com/AssemblyScript/assemblyscript)sorunları bulunmaktadır. Bunlar hata ayıklama zorluğunda farklılık gösterse de, bunların farkında olmak yardımcı olabilir. Aşağıda bu sorunların kapsamlı olmayan bir listesi bulunmaktadır:

- `Özel(Private)` sınıf değişkenleri [AssembyScript](https://www.assemblyscript.org/status.html#language-features)'de kullanımı mecburi değildir. Sınıf değişkenlerini doğrudan sınıf nesnesinden değiştirilmekten korumanın bir yolu yoktur.
- Kapsam, [closure fonksiyonu](https://www.assemblyscript.org/status.html#on-closures) tarafından devralınmaz, yani closure fonksiyonları dışında tanımlanan değişkenler kullanılamaz. [Geliştirici Öne Çıkanları #3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s)'teki açıklama.
