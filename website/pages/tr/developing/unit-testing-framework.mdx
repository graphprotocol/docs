---
title: Birim Testi Framework'Ã¼
---

Matchstick, [LimeChain](https://limechain.tech/) tarafÄ±ndan geliÅŸtirilen, subgraph geliÅŸtiricilerinin eÅŸleÅŸtirme mantÄ±klarÄ±nÄ± bir korumalÄ± alan ortamÄ±nda test etmelerine ve subgraphlarÄ±nÄ± gÃ¼venle daÄŸÄ±tmalarÄ±na olanak tanÄ±yan bir birim testi framework'Ã¼dÃ¼r!

## Buradan BaÅŸlayÄ±n

### BaÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¼kleyin

Test yardÄ±mcÄ± yÃ¶ntemlerini kullanmak ve testleri Ã§alÄ±ÅŸtÄ±rmak iÃ§in aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¼klemeniz gerekecektir:

```sh
yarn add --dev matchstick-as
```

â— `graph-node`, PostgreSQL'ye baÄŸlÄ±dÄ±r, bu nedenle henÃ¼z yÃ¼klemediyseniz PostgreSQL yÃ¼klemeniz gerekecektir. AÅŸaÄŸÄ±daki komutlarÄ± kullanmanÄ±zÄ± ÅŸiddetle tavsiye ediyoruz, Ã§Ã¼nkÃ¼ baÅŸka bir ÅŸekilde eklemeniz beklenmedik hatalara neden olabilir!

#### MacOS

Postgres yÃ¼kleme komutu:

```sh
brew install postgresql
```

En son libpq.5.lib'e bir sembolik baÄŸ oluÅŸturun. _Bu dizini Ã¶nce oluÅŸturmanÄ±z gerekebilir_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Postgres yÃ¼kleme komutu (daÄŸÄ±tÄ±mÄ±nÄ±za baÄŸlÄ± olarak deÄŸiÅŸir):

```sh
sudo apt install postgresql
```

### WSL (Linux iÃ§in Windows Alt Sistemleri)

Matchstick'i WSL'de Docker yaklaÅŸÄ±mÄ± ve ikili yaklaÅŸÄ±mÄ± kullanarak kullanabilirsiniz. WSL biraz alengirli olabileceÄŸinden, aÅŸaÄŸÄ±daki gibi sorunlarla karÅŸÄ±laÅŸÄ±rsanÄ±z birkaÃ§ ipucu verelim

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

yada

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

LÃ¼tfen daha yeni bir Node.js sÃ¼rÃ¼mÃ¼nde olduÄŸunuzdan emin olun. graph-cli artÄ±k **v10.19.0**'Ä± desteklemiyor ve bu sÃ¼rÃ¼m, hala WSL'deki yeni Ubuntu gÃ¶rÃ¼ntÃ¼lerinin varsayÄ±lan sÃ¼rÃ¼mÃ¼dÃ¼r. Ã–rneÄŸin, Matchstick'in **v18.1.0** ile WSL'de Ã§alÄ±ÅŸtÄ±ÄŸÄ± doÄŸrulandÄ±, **nvm** aracÄ±lÄ±ÄŸÄ±yla veya global Node.js'inizi gÃ¼ncelleyerek buna geÃ§ebilirsiniz. Nodejs'nizi gÃ¼ncelledikten sonra `node_modules`'Ä± silmeyi ve `node_modules`'u tekrar Ã§alÄ±ÅŸtÄ±rmayÄ± unutmayÄ±n! Daha sonra, **libpq** yÃ¼klÃ¼ olduÄŸundan emin olun, bunu Ã§alÄ±ÅŸtÄ±rarak yapabilirsiniz

```
sudo apt-get install libpq-dev
```

Son olarak, `graph test`'i kullanmayÄ±n (global graph-cli yÃ¼klemenizi kullanmaktadÄ±r ve bazÄ± nedenlerden dolayÄ± ÅŸu anda WSL'de bozuk gibi gÃ¶rÃ¼nÃ¼yor), bunun yerine `yarn test` veya `npm run test` kullanÄ±n (bu, proje dÃ¼zeyindeki yerel graph-cli Ã¶rneÄŸini kullanacaktÄ±r, bu da harika Ã§alÄ±ÅŸÄ±r). Bunun iÃ§in tabiki `package.json` dosyanÄ±zda bir `"test"` script'i olmasÄ± gerektiÄŸini unutmayÄ±n, bunun gibi basit bir ÅŸey olabilir

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### KullanÄ±ÅŸ

**Matchstick**'i subgraph proje'nizde kullanmak iÃ§in sadece bir terminal aÃ§Ä±n, proje'nizin kÃ¶k(root) klasÃ¶rÃ¼ne gidin ve basitÃ§e `graph test [options] <datasource>` - komutunu Ã§alÄ±ÅŸtÄ±rÄ±n - bu en son **Matchstick** ikili dosyasÄ±nÄ± indirir ve belirtilen testi veya test klasÃ¶rÃ¼ndeki tÃ¼m testleri Ã§alÄ±ÅŸtÄ±rÄ±r (verikaynaÄŸÄ± bayraÄŸÄ± belirtilmezse mevcut tÃ¼m testler).

### CLI seÃ§enekleri

Bu, test klasÃ¶rÃ¼ndeki tÃ¼m testleri Ã§alÄ±ÅŸtÄ±racaktÄ±r:

```sh
graph test
```

Bu, gravity.test.ts adÄ±nda bir testi ve/veya gravity adÄ±nda bir klasÃ¶rdeki tÃ¼m testleri Ã§alÄ±ÅŸtÄ±racaktÄ±r:

```sh
graph test gravity
```

Bu sadece belirtilen test dosyasÄ±nÄ± Ã§alÄ±ÅŸtÄ±racaktÄ±r:

```sh
graph test path/to/file.test.ts
```

**SeÃ§enekler:**

```sh
-c, --coverage                Testleri kapsama modunda Ã§alÄ±ÅŸtÄ±rÄ±r
-d, --docker                  Testleri bir docker konteynerinde Ã§alÄ±ÅŸtÄ±rÄ±r (Not: Subgraph kÃ¶k klasÃ¶rÃ¼nden Ã§alÄ±ÅŸtÄ±rÄ±n)
-f,  --force                   Ä°kili: Ä°kilinin yeniden indirilmesini saÄŸlar. Docker: Dockerfile'Ä±n yeniden indirilmesi ve docker gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼n yeniden oluÅŸturulmasÄ±.
-h, --help                    KullanÄ±m bilgilerini gÃ¶sterir
-l, --logs                    Ä°ÅŸletim sistemi, CPU modeli ve indirme URL'si hakkÄ±nda konsola gÃ¼nlÃ¼k bilgilerini yazar (hata ayÄ±klama amaÃ§lÄ±dÄ±r)
-r, --recompile               Testlerin yeniden derlenmesini zorlar
-v, --version <tag>           Ä°ndirmek/kullanmak istediÄŸiniz rust ikilisinin sÃ¼rÃ¼mÃ¼nÃ¼ seÃ§menize yarar
```

### Docker

`graph-cli 0.25.2`'den itibaren `graph test` `-d` bayraÄŸÄ± ile `matchstick`'i bir docker konteynerinde Ã§alÄ±ÅŸtÄ±rmayÄ± desteklemektedir. Docker uygulamasÄ±, [bind mount](https://docs.docker.com/storage/bind-mounts/) kullandÄ±ÄŸÄ±ndan, `graph test -d` komutu her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda docker gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ yeniden oluÅŸturmak zorunda deÄŸildir. Alternatif olarak, [matchstick](https://github.com/LimeChain/matchstick#docker-) deposundan docker'Ä± manuel olarak Ã§alÄ±ÅŸtÄ±rmak iÃ§in talimatlarÄ± izleyebilirsiniz.

â— Daha Ã¶nce `graph test` Ã§alÄ±ÅŸtÄ±rdÄ±ysanÄ±z, docker build sÄ±rasÄ±nda aÅŸaÄŸÄ±daki hatayla karÅŸÄ±laÅŸabilirsiniz:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

Bu durumda, kÃ¶k klasÃ¶r iÃ§inde bir `.dockerignore` dosyasÄ± oluÅŸturun ve `node_modules/binary-install-raw/bin`'i ekleyin

### YapÄ±landÄ±rma

Matchstick, `matchstick.yaml` yapÄ±landÄ±rma dosyasÄ± aracÄ±lÄ±ÄŸÄ±yla Ã¶zel testler, kÃ¼tÃ¼phaneler ve manifest yolunu kullanacak ÅŸekilde yapÄ±landÄ±rÄ±labilir:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Demo subgraph

[Demo Subgraph repo](https://github.com/LimeChain/demo-subgraph)sunu klonlayarak bu kÄ±lavuzdaki Ã¶rnekleri deneyebilir ve ve istediÄŸinizi yapabilirsiniz

### Ã–ÄŸretici videolar

AyrÄ±ca, "["How to use Matchstick to write unit tests for your subgraphs"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)" konulu video serisine gÃ¶z atabilirsiniz

## Tests structure

_**IMPORTANT: The test structure described below depens on `matchstick-as` version >=0.5.0**_

### describe()

`describe(name: String , () => {})` - Bir test grubunu tanÄ±mlar.

**_Notlar:_**

- _AÃ§Ä±klamalar zorunlu deÄŸildir. Hala test() fonksiyonunu describe() bloklarÄ±nÄ±n dÄ±ÅŸÄ±nda kullanabilirsiniz_

Ã–rnek:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

Ä°Ã§ iÃ§e `describe()` Ã¶rneÄŸi:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Bir test durumu tanÄ±mlar. test() fonksiyonunu describe() bloklarÄ± iÃ§inde veya baÄŸÄ±msÄ±z olarak kullanabilirsiniz.

Ã–rnek:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

yada

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Dosyadaki tÃ¼m testlerden Ã¶nce bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `beforeAll`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun baÅŸÄ±nda Ã§alÄ±ÅŸÄ±r.

Ã–rnekler:

`beforeAll` iÃ§indeki kod, dosyadaki _tÃ¼m_ testlerden Ã¶nce bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

`beforeAll` iÃ§indeki kod, ilk describe bloÄŸundaki tÃ¼m testlerden Ã¶nce bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = â€œFirst Gravatarâ€
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Dosyadaki tÃ¼m testlerden sonra bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `afterAll`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun sonunda Ã§alÄ±ÅŸÄ±r.

Ã–rnek:

`afterAll` iÃ§indeki kod, dosyadaki _tÃ¼m_ testlerden sonra bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

`afterAll` iÃ§indeki kod, ilk describe bloÄŸundaki tÃ¼m testlerden sonra bir kez Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Her testten Ã¶nce bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `beforeEach`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun her testinden Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

Ã–rnekler: `beforeEach` iÃ§indeki kod, her testten Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

`beforeEach` iÃ§indeki kod, yalnÄ±zca o describe bloÄŸundaki her testten Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // displayName'i 1. Gravatar olarak gÃ¼ncellemesi gereken kod

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // imageUrl'yi https://www.gravatar.com/avatar/0x0 olarak deÄŸiÅŸtirmesi gereken kod

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Her testten sonra bir kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±r. `afterEach`, `describe` bloklarÄ±nÄ±n iÃ§inde tanÄ±mlanÄ±rsa, o `describe` bloÄŸunun her testinden sonra Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

Ã–rnekler:

`afterEach` iÃ§indeki kod, her testten sonra Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // displayName'i 1. Gravatar olarak gÃ¼ncellemesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // imageUrl'yi https://www.gravatar.com/avatar/0x0 olarak deÄŸiÅŸtirmesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

`afterEach` iÃ§indeki kod, yalnÄ±zca o describe bloÄŸundaki her testten sonra Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // displayName'i 1. Gravatar olarak gÃ¼ncellemesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // imageUrl'yi https://www.gravatar.com/avatar/0x0 olarak deÄŸiÅŸtirmesi gereken kod

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## AÃ§Ä±klamalar

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

As of version 0.6.0, asserts support custom error messages as well

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id should be 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value should equal 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar should not be in store')
assert.addressEquals(Address.zero(), Address.zero(), 'Address should be zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes should be equal')
assert.i32Equals(2, 2, 'I32 should equal 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt should equal 1')
assert.booleanEquals(true, true, 'Boolean should be true')
assert.stringEquals('1', '1', 'String should equal 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arrays should be equal')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuples should be equal',
)
assert.assertTrue(true, 'Should be true')
assert.assertNull(null, 'Should be null')
assert.assertNotNull('not null', 'Should be not null')
assert.entityCount('Gravatar', 1, 'There should be 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet template should have one data source')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet should have a data source for zero address',
)
```

## Bir Birim Testi YazÄ±n

[Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts)'taki Gravatar Ã¶rneklerini kullanarak nasÄ±l basit bir birim test gÃ¶rÃ¼neceÄŸini gÃ¶relim.

AÅŸaÄŸÄ±daki iÅŸleyici fonksiyonuna sahip olduÄŸumuzu varsayarsak (iki yardÄ±mcÄ± iÅŸlevle birlikte):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Ã–nce projemizde bir test dosyasÄ± oluÅŸturmamÄ±z gerekiyor. Bunun nasÄ±l gÃ¶rÃ¼nebileceÄŸine dair bir Ã¶rnek:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Bir test varlÄ±ÄŸÄ± oluÅŸturun ve bunu depoya baÅŸlangÄ±Ã§ durumu olarak kaydedin (isteÄŸe baÄŸlÄ±)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Mock etkinlikleri oluÅŸturun
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Az Ã¶nce oluÅŸturduÄŸumuz olaylarÄ± geÃ§iren Ã§aÄŸrÄ± eÅŸleÅŸtirme fonksiyonlarÄ±
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Deponun durumunu doÄŸrulayÄ±n
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Bir sonraki testi temiz bir sayfa Ã¼zerinde baÅŸlatmak iÃ§in depoyu boÅŸaltÄ±n
  clearStore()
})

test('Next test', () => {
  //...
})
```

Analiz edilecek Ã§ok fazla ÅŸey var! Ã–ncelikle fark etmemiz gereken Ã¶nemli ÅŸey AssemblyScript yardÄ±mcÄ± kÃ¼tÃ¼phanemiz (npm modÃ¼lÃ¼ olarak daÄŸÄ±tÄ±lÄ±r) `matchstick-as`'den iÅŸleri iÃ§e aktardÄ±ÄŸÄ±mÄ±z. Repositoriyi [burada](https://github.com/LimeChain/matchstick-as) bulabilirsiniz. `matchstick-as` bize yararlÄ± test yÃ¶ntemleri saÄŸlar ve ayrÄ±ca test bloklarÄ± oluÅŸturmak iÃ§in kullanacaÄŸÄ±mÄ±z `test()` iÅŸlevini tanÄ±mlar. Geri kalanÄ± oldukÃ§a aÃ§Ä±k - ÅŸÃ¶yle olur:

- Ä°lk durumumuzu ayarlÄ±yor ve bir Ã¶zel Gravatar varlÄ±ÄŸÄ± ekliyoruz;
- `createNewGravatarEvent()` fonksiyonunu kullanarak verileriyle birlikte iki `NewGravatar`r olay nesnesini tanÄ±mlÄ±yoruz;
- `handleNewGravatars()` yÃ¶ntemlerimizi bu olaylar iÃ§in Ã§aÄŸÄ±rÄ±yoruz ve Ã¶zel olay listemizi geÃ§iyoruz;
- Depo durumunu doÄŸruluyoruz. Bu nasÄ±l Ã§alÄ±ÅŸÄ±r? - Bir varlÄ±k tÃ¼rÃ¼ ve kimliÄŸinin benzersiz bir kombinasyonunu geÃ§iriyoruz. ArdÄ±ndan, bu varlÄ±kta belirli bir alanÄ± kontrol ediyoruz ve beklediÄŸimiz deÄŸeri almasÄ±nÄ± saÄŸlÄ±yoruz. Hem depoya eklediÄŸimiz ilk Gravatar VarlÄ±ÄŸÄ± iÃ§in hem de iÅŸleyici iÅŸlevi Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda eklenen iki Gravatar varlÄ±ÄŸÄ± iÃ§in bunu yapÄ±yoruz;
- Ve son olarak `clearStore()` kullanarak depoyu temizliyoruz, bÃ¶ylece bir sonraki testimiz temiz ve boÅŸ bir depo nesnesiyle baÅŸlayabilir. Ä°stediÄŸimiz kadar test bloÄŸu tanÄ±mlayabiliriz.

Ä°ÅŸte baÅŸardÄ±n - ilk testimizi oluÅŸturduk! ğŸ‘

Åimdi testlerimizi Ã§alÄ±ÅŸtÄ±rmak iÃ§in subgraph kÃ¶k klasÃ¶rÃ¼nÃ¼zde ÅŸunu Ã§alÄ±ÅŸtÄ±rmanÄ±z yeterlidir:

`graph test Gravity`

Ve her ÅŸey yolunda giderse aÅŸaÄŸÄ±dakiyle karÅŸÄ±laÅŸacaksÄ±nÄ±z:

![Matchstick "TÃ¼m testler geÃ§ildi!" diyor](/img/matchstick-tests-passed.png)

## Ã‡ok rastlanan test senaryolarÄ±

### Belirli bir durumla depoyu doldurma

KullanÄ±cÄ±lar bilinen bir varlÄ±k kÃ¼mesiyle depoyu doldurabilirler. AÅŸaÄŸÄ±daki Ã¶rnek depoyu Gravatar varlÄ±ÄŸÄ±yla baÅŸlatmak iÃ§in kullanÄ±labilir:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Olayla bir eÅŸleÅŸtirme fonksiyonu Ã§aÄŸÄ±rmak

KullanÄ±cÄ±, depoya baÄŸlÄ± bir eÅŸleÅŸtirme fonksiyonuna Ã¶zel bir olay oluÅŸturabilir ve onu iletebilir:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### TÃ¼m eÅŸitlemeleri olay fikstÃ¼rleriyle Ã§aÄŸÄ±rmak

KullanÄ±cÄ±lar test fikstÃ¼rleriyle eÅŸleÅŸtirmeleri Ã§aÄŸÄ±rabilirler.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Kontrat Ã§aÄŸrÄ±larÄ±nÄ± mocklama

KullanÄ±cÄ±lar sÃ¶zleÅŸme Ã§aÄŸrÄ±larÄ±nÄ± mocklayabilir:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

GÃ¶sterildiÄŸi gibi, bir sÃ¶zleÅŸme Ã§aÄŸrÄ±sÄ±nÄ± mocklamak ve bir dÃ¶nÃ¼ÅŸ deÄŸeri sabitlemek iÃ§in kullanÄ±cÄ±, bir sÃ¶zleÅŸme adresi, iÅŸlev adÄ±, iÅŸlev imzasÄ±, bir argÃ¼man dizisi ve elbette dÃ¶nÃ¼ÅŸ deÄŸerini saÄŸlamalÄ±dÄ±r.

KullanÄ±cÄ±lar ayrÄ±ca fonksiyon geri Ã§evirilerinide mocklayabilirler:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### IPFS dosyalarÄ±nÄ± mocklama (Matchstick 0.4.1'den)

KullanÄ±cÄ±lar `mockIpfsFile(hash, filePath)` fonksiyonunu kullanarak IPFS dosyalarÄ±nÄ± mocklama yeteneÄŸine sahiptirler. Fonksiyon, ilk argÃ¼manÄ± IPFS dosya hash/yol'u ve ikinci argÃ¼manÄ± yerel bir dosyanÄ±n yolu olmak Ã¼zere iki argÃ¼man kabul eder.

NOT: `ipfs.map/ipfs.mapJSON`'u test ederken matchstck'in bunu algÄ±lamasÄ± iÃ§in geri Ã§aÄŸrÄ±ma iÅŸlevinin test dosyasÄ±ndan dÄ±ÅŸa aktarÄ±lmasÄ± gerekiyor, Ã¶rneÄŸin aÅŸaÄŸÄ±daki test Ã¶rneÄŸindeki `processGravatar()` fonksiyonu gibi:

`.test.ts` dosyasÄ±:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Matchstck'in algÄ±lamasÄ± iÃ§in ipfs.map() geri Ã§aÄŸrÄ±sÄ±nÄ± dÄ±ÅŸa aktarÄ±n
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` dosyasÄ±:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// ipfs.map geri Ã§aÄŸrÄ±sÄ±
export function processGravatar(value: JSONValue, userData: Value): void {
  // Ä°ÅŸlem yapmayla ilgili ayrÄ±ntÄ±lar iÃ§in JSONValue belgelerine bakÄ±n
  // JSON deÄŸerleri ile
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Geri Ã§aÄŸrÄ±lar ayrÄ±ca varlÄ±klar oluÅŸturabilir
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// ipfs.cat'i Ã§aÄŸÄ±ran fonksiyon
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Depo durumunu doÄŸrulama

KullanÄ±cÄ±lar, varlÄ±klarÄ± doÄŸrulayarak deponun nihai (veya orta) durumunu doÄŸrulayabilirler. Bunun iÃ§in, kullanÄ±cÄ± bir VarlÄ±k tÃ¼rÃ¼, bir VarlÄ±ÄŸÄ±n belirli bir kimliÄŸi, o VarlÄ±ktaki bir alanÄ±n adÄ± ve alanÄ±n beklenen deÄŸerini saÄŸlamalÄ±dÄ±r. HÄ±zlÄ±ca bir Ã¶rneÄŸe bakalÄ±m:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

assert.fieldEquals () fonksiyonunu Ã§alÄ±ÅŸtÄ±rmak, verilen alanÄ±n verilen beklenen deÄŸere karÅŸÄ± eÅŸitliÄŸini kontrol edecektir. DeÄŸerler eÅŸit **DEÄÄ°LSE** test baÅŸarÄ±sÄ±z olacak ve bir hata mesajÄ± verecektir. Aksi takdirde, test baÅŸarÄ±lÄ± bir ÅŸekilde geÃ§ecektir.

### Olay Ã¼st verileriyle etkileÅŸim

KullanÄ±cÄ±lar `newMockEvent()` fonksiyonunu kullanarak ethereum.Event dÃ¶ndÃ¼rebilen varsayÄ±lan iÅŸlem Ã¼st verilerini kullanabilir. AÅŸaÄŸÄ±daki Ã¶rnek, Olay nesnesindeki bu alanlara nasÄ±l okuma/yazma yapabileceÄŸinizi gÃ¶sterir:

```typescript
// Okuma
let logType = newGravatarEvent.logType

// Yazma
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### DeÄŸiÅŸken eÅŸitliÄŸini doÄŸrulama

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Bir varlÄ±ÄŸÄ±n depoda olmadÄ±ÄŸÄ±nÄ±(**not**) doÄŸrulama

KullanÄ±cÄ±lar, bir varlÄ±ÄŸÄ±n depoda olmadÄ±ÄŸÄ±nÄ± doÄŸrulayabilirler. Bu fonksiyon, bir varlÄ±k tÃ¼rÃ¼ ve bir kimlik alÄ±r. EÄŸer varlÄ±k gerÃ§ekten depoda ise, test ilgili bir hata mesajÄ± vererej baÅŸarÄ±sÄ±z olacaktÄ±r. Fonksiyonun nasÄ±l kullanÄ±lacaÄŸÄ±na dair hÄ±zlÄ±ca bir Ã¶rneÄŸe bakalÄ±m:

```typescript
assert.notInStore('Gravatar', '23')
```

### Printing the whole store, or single entities from it (for debug purposes)

Bu yardÄ±mcÄ± fonksiyon kullanÄ±larak deponun tamamÄ± konsola yazdÄ±rÄ±labilir:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

As of version 0.6.0, `logStore` no longer prints derived fields, instead users can use the new `logEntity` function. Of course `logEntity` can be used to print any entity, not just ones that have derived fields. `logEntity` takes the entity type, entity id and a `showRelated` flag to indicate if users want to print the related derived entities.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### Beklenen baÅŸarÄ±sÄ±zlÄ±k

KullanÄ±cÄ±lar, shouldFail bayraÄŸÄ±nÄ± test() fonksiyonlarÄ±nda kullanarak beklenen test baÅŸarÄ±sÄ±zlÄ±klarÄ±na sahip olabilirler:

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Test, shouldFail = true olarak iÅŸaretlenirse ama BAÅARISIZ olmazsa, bu kayÄ±tlarda bir hata olarak gÃ¶rÃ¼necek ve test bloÄŸu baÅŸarÄ±sÄ±z olacaktÄ±r. AyrÄ±ca, with shouldFail = false (the default state) olarak iÅŸaretlenirse, test yÃ¼rÃ¼tÃ¼cÃ¼sÃ¼ Ã§Ã¶kecektir.

### KayÄ±t tutma

Birim testlerinde Ã¶zel kayÄ±t tutmanÄ±n eÅŸitlemelerdeki kayÄ±t tutmaktan tamamen aynÄ±dÄ±r. Fark, gÃ¼nlÃ¼k nesnesinin graph-ts yerine matchstick-as'dan iÃ§e aktarÄ±lmasÄ± gerektmesidir. Ä°ÅŸte tÃ¼m kritik olmayan kayÄ±t tÃ¼rleriyle ilgili basit bir Ã¶rnek:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

KullanÄ±cÄ±lar ayrÄ±ca ÅŸu ÅŸekilde kritik bir hatayÄ± simÃ¼le edebilirler:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Kritik hatalarÄ± kayÄ±t altÄ±na almak, testlerin yÃ¼rÃ¼tÃ¼lmesini durduracak ve her ÅŸeyi mahvedecektir. SonuÃ§ta, kodunuzun daÄŸÄ±tÄ±mda kritik kayÄ±tlarÄ± iÃ§ermediÄŸinden emin olmak istiyoruz ve bunun olmasÄ± durumunda hemen fark etmeniz gerekiyor.

### TÃ¼retilmiÅŸ alanlarÄ±n test edilmesi

Testing derived fields is a feature which allows users to set a field on a certain entity and have another entity be updated automatically if it derives one of its fields from the first entity.

Before version `0.6.0` it was possible to get the derived entities by accessing them as entity fields/properties, like so:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

As of version `0.6.0`, this is done by using the `loadRelated` function of graph-node, the derived entities can be accessed the same way as in the handlers.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Testing `loadInBlock`

As of version `0.6.0`, users can test `loadInBlock` by using the `mockInBlockStore`, it allows mocking entities in the block cache.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Can use entity.loadInBlock() to retrieve entity from cache store in the current block', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Returns null when calling entity.loadInBlock() if an entity doesn't exist in the current block", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Dinamik Veri KaynaklarÄ±nÄ±n Test Edilmesi

Dinamik veri kaynaklarÄ±nÄ±n test edilmesi dataSource ad alanÄ±nÄ±n `context()`, `address()` ve `network()` fonksiyonlarÄ±nÄ±n geri dÃ¶nÃ¼ÅŸ deÄŸerlerinin mocklanmasÄ±yla yapÄ±labilir. Bu fonksiyonlar ÅŸu anda ÅŸunlarÄ± dÃ¶ndÃ¼rmektedir: `context()` - boÅŸ bir varlÄ±k dÃ¶ndÃ¼rÃ¼r (DataSourceContext), `address()` - `0x0000000000000000000000000000000000000000` dÃ¶ndÃ¼rÃ¼r, `network()` - `mainnet` dÃ¶ndÃ¼rÃ¼r. `create(...)` ve `createWithContext(...)` fonksiyonlarÄ± hiÃ§bir ÅŸey yapmamak iÃ§in mocklanmÄ±ÅŸtÄ±r bu nedenle testlerde Ã§aÄŸrÄ±lmalarÄ± gerekmez. DÃ¶nÃ¼ÅŸ deÄŸerlerinde yapÄ±lacak deÄŸiÅŸiklikler `matchstick-as`'deki (version 0.3.0+)`dataSourceMock` ad alanÄ±nÄ±n fonksiyonlarÄ±yla yapÄ±labilir.

AÅŸaÄŸÄ±daki Ã¶rnekte:

Ã–ncelikle aÅŸaÄŸÄ±daki olay iÅŸleyicisine sahibiz (veri kaynaÄŸÄ± mocklamasÄ±nÄ± gÃ¶stermek iÃ§in kasÄ±tlÄ± olarak amaÃ§ deÄŸiÅŸikliÄŸi):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

ArdÄ±ndan, dataSourceMock ad alanÄ±ndaki yÃ¶ntemlerden birini kullanarak tÃ¼m veri kaynaÄŸÄ± fonksiyonlarÄ± iÃ§in yeni bir geri dÃ¶nÃ¼ÅŸ deÄŸeri ayarlayan testi gÃ¶rÃ¼yoruz:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

dataSourceMock.resetValues()'in en sonda Ã§aÄŸrÄ±ldÄ±ÄŸÄ±na dikkat edin. Bunun nedeni deÄŸerler deÄŸiÅŸtirildiÄŸinde hatÄ±rlanÄ±r ve varsayÄ±lan deÄŸerlere geri dÃ¶nmek istiyorsanÄ±z sÄ±fÄ±rlanmalarÄ± gerekir.

### Testing dynamic data source creation

As of version `0.6.0`, it is possible to test if a new data source has been created from a template. This feature supports both ethereum/contract and file/ipfs templates. There are four functions for this:

- `assert.dataSourceCount(templateName, expectedCount)` can be used to assert the expected count of data sources from the specified template
- `assert.dataSourceExists(templateName, address/ipfsHash)` asserts that a data source with the specified identifier (could be a contract address or IPFS file hash) from a specified template was created
- `logDataSources(templateName)` prints all data sources from the specified template to the console for debugging purposes
- `readFile(path)` reads a JSON file that represents an IPFS file and returns the content as Bytes

#### Testing `ethereum/contract` templates

```typescript
test('ethereum/contract dataSource creation example', () => {
  // Assert there are no dataSources created from GraphTokenLockWallet template
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // Create a new GraphTokenLockWallet datasource with address 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Add a second dataSource with context
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert there are now 2 dataSources
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // Assert that a dataSource with address "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" was created
  // Keep in mind that `Address` type is transformed to lower case when decoded, so you have to pass the address as all lower case when asserting if it exists
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### Example `logDataSource` output

```bash
ğŸ›   {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
}
```

#### Testing `file/ipfs` templates

Similarly to contract dynamic data sources, users can test test file datas sources and their handlers

##### Example `subgraph.yaml`

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### Example `schema.graphql`

```graphql
"""
Token Lock Wallets which hold locked GRT
"""
type TokenLockMetadata @entity {
  "The address of the token lock wallet"
  id: ID!
  "Start time of the release schedule"
  startTime: BigInt!
  "End time of the release schedule"
  endTime: BigInt!
  "Number of periods between start time and end time"
  periods: BigInt!
  "Time when the releases start"
  releaseStartTime: BigInt!
}
```

##### Example `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Example handler

```typescript
export function handleMetadata(content: Bytes): void {
  // dataSource.stringParams() returns the File DataSource CID
  // stringParam() will be mocked in the handler test
  // for more info https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Example test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () => {
  // Generate the dataSource CID from the ipfsHash + ipfs path file
  // For example QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // Create a new dataSource using the generated CID
  GraphTokenLockMetadata.create(CID)

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Now we have to mock the dataSource metadata and specifically dataSource.stringParam()
  // dataSource.stringParams actually uses the value of dataSource.address(), so we will mock the address using dataSourceMock from  matchstick-as
  // First we will reset the values and then use dataSourceMock.setAddress() to set the CID
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)

  // Now we need to generate the Bytes to pass to the dataSource handler
  // For this case we introduced a new function readFile, that reads a local json and returns the content as Bytes
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Now we will test if a TokenLockMetadata was created
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Test KapsamÄ±

Subgraph geliÅŸtiricileri **Matchstick'i** kullanarak, yazÄ±lan birim testlerinin test kapsamÄ±nÄ± hesaplayacak bir komut dosyasÄ± Ã§alÄ±ÅŸtÄ±rabilirler.

Test kapsama aracÄ± derlenmiÅŸ test `wasm` ikililerini alÄ±r ve bunlarÄ± daha sonra `subgraph.yaml` dosyasÄ±nda tanÄ±mlanan iÅŸlevlerin Ã§aÄŸrÄ±lÄ±p Ã§aÄŸrÄ±lmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in kolayca incelenebilen `wat` dosyalarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Kod kapsamÄ± (ve bir bÃ¼tÃ¼n olarak test) AssemblyScript ve WebAssembly'de Ã§ok erken aÅŸamalarda olduÄŸundan, **Matchstick** dallanma kapsamÄ±nÄ± kontrol edemez. Bunun yerine, belirli bir iÅŸleyici Ã§aÄŸrÄ±lmÄ±ÅŸsa, bunun iÃ§in olay/fonksiyonun uygun ÅŸekilde taklit edildiÄŸi savÄ±na gÃ¼veniyoruz.

### Ã–n KoÅŸullar

**Matchstick** tarafÄ±ndan saÄŸlanan test kapsama fonksiyonlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in Ã¶nceden hazÄ±rlamanÄ±z gereken birkaÃ§ ÅŸey bulunmaktadÄ±r:

#### Ä°ÅŸleyicilerinizi dÄ±ÅŸa aktarÄ±n

**Matchstick**'in hangi iÅŸleyicilerin Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmesi iÃ§in, bu iÅŸleyicilerin **test file**'dan dÄ±ÅŸa aktarÄ±lmasÄ± gerekir. Mesela, bizim Ã¶rneÄŸimizde gravity.test.ts dosyamÄ±zda aÅŸaÄŸÄ±daki iÅŸleyici iÃ§e aktarÄ±lÄ±r:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

Bu fonksiyonun gÃ¶rÃ¼nÃ¼r olmasÄ± iÃ§in (**adÄ±yla** `wat` dosyasÄ±na dahil edilmesi iÃ§in) ayrÄ±ca onuda ÅŸÃ¶yle dÄ±ÅŸa aktarmamÄ±z gerekmektedir:

```typescript
export { handleNewGravatar }
```

### KullanÄ±ÅŸ

Her ÅŸey hazÄ±r olduÄŸunda, test kapsama aracÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in basitÃ§e ÅŸunu Ã§alÄ±ÅŸtÄ±rÄ±n:

```sh
graph test -- -c
```

AyrÄ±ca `package.json` dosyanÄ±za ÅŸu ÅŸekilde Ã¶zel bir kapsama(`coverage`) komutu ekleyebilirsiniz:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Bu, kapsama aracÄ±nÄ± Ã§alÄ±ÅŸtÄ±racak ve terminalde buna benzer bir ÅŸey gÃ¶receksiniz:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 ï¸
Reading generated test modules... ğŸ”ï¸

Generating coverage report ğŸ“

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Tutulan kayÄ±t Ã§Ä±ktÄ±sÄ±nda test Ã§alÄ±ÅŸma sÃ¼resi

Tutulan kayÄ±t Ã§Ä±ktÄ±sÄ± test Ã§alÄ±ÅŸma sÃ¼resini iÃ§erir. Ä°ÅŸte buna bir Ã¶rnek:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Ã‡ok rastlanan derleyici hatalarÄ±

> Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined

Bu, AssemblyScript tarafÄ±ndan desteklenmeyen `console.log`'u kullandÄ±ÄŸÄ±nÄ±z anlamÄ±na gelmektedir. LÃ¼tfen [Logging API](/developing/assemblyscript-api/#logging-api) kullanmayÄ± dÃ¼ÅŸÃ¼nÃ¼n

> ERROR TS2554: Expected ? arguments, but got ?.
> 
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
> 
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
> 
> ERROR TS2554: Expected ? arguments, but got ?.
> 
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
> 
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

ArgÃ¼manlardaki uyumsuzluk, `graph-ts` ve `matchstick-as` arasÄ±ndaki uyumsuzluktan kaynaklanÄ±r. Bu gibi sorunlarÄ± dÃ¼zeltmenin en iyi yolu her ÅŸeyi en son yayÄ±nlanan sÃ¼rÃ¼me gÃ¼ncellemektir.

## Geribildirim

Soru, geri bildirim, Ã¶zellik istekleri veya sadece iletiÅŸim kurmak istiyorsanÄ±z en iyi yer Matchstick iÃ§in ayrÄ±lmÄ±ÅŸ bir kanal olan ğŸ”¥| unit-testing kanalÄ±na sahip olduÄŸumuz The Graph Discord'udur.
