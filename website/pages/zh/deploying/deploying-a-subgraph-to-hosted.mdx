---
title: 将子图部署到托管服务上
---

如果您尚未查看，请先查看如何编写组成 [子图清单](/developing/creating-a-subgraph#the-subgraph-manifest) 的文件以及如何安装 [Graph CLI](https://github.com/graphprotocol/graph-cli) 为您的子图生成代码。 现在，让我们将您的子图部署到托管服务上。

## 创建托管服务帐户

在使用托管服务之前，请先在我们的托管服务中创建一个帐户。 为此，您将需要一个 [Github](https://github.com/) 帐户；如果您还没有，您需要先创建一个账户。 然后，导航到 [托管服务](https://thegraph.com/hosted-service/), 单击 _'使用 Github 注册'_ 按钮并完成 Github 的授权流程。

## 存储访问令牌

创建帐户后，导航到您的 [仪表板](https://thegraph.com/hosted-service/dashboard)。 复制仪表板上显示的访问令牌并运行 `graph auth --product hosted-service <ACCESS_TOKEN>`。 这会将访问令牌存储在您的计算机上。 如果您不需要重新生成访问令牌，您就只需要这样做一次。

## 在托管服务上创建子图

在部署子图之前，您需要在 The Graph Explorer 中创建它。 转到 [仪表板](https://thegraph.com/hosted-service/dashboard) ，单击 _'添加子图'_ 按钮，并根据需要填写以下信息:

**图像** - 选择要用作子图的预览图和缩略图的图像。

**子图名称** - 子图名称连同下面将要创建的子图帐户名称，将定义用于部署和 GraphQL 端点的`account-name/subgraph-name`样式名称。 _此字段以后无法更改。_

**帐户** - 创建子图的帐户。 这可以是个人或组织的帐户。 _以后不能在帐户之间移动子图。_

**副标题** - 将出现在子图卡中的文本。

**描述** - 子图的描述，在子图详细信息页面上可见。

**GitHub URL** - 存储在 GitHub 上的子图代码的链接。

**隐藏** - 打开此选项可隐藏 Graph Explorer 中的子图。

保存新子图后，您会看到一个屏幕，其中包含有关如何安装 Graph CLI、如何为新子图生成脚手架以及如何部署子图的帮助信息。 前面两部分在[定义子图](/developing/defining-a-subgraph)中进行了介绍。

## 在托管服务上部署子图

一旦部署您的子图，您使用`yarn build` 命令构建的子图文件将被上传到 IPFS，并告诉 Graph Explorer 开始使用这些文件索引您的子图。

您可以通过运行 `yarn deploy`来部署子图。

部署子图后，Graph Explorer 将切换到显示子图的同步状态。 根据需要从历史以太坊区块中提取的数据量和事件数量的不同，从创世区块开始，同步操作可能需要几分钟到几个小时。 一旦 Graph 节点从历史区块中提取了所有数据，子图状态就会切换到`Synced`。 当新的以太坊区块出现时，Graph 节点将继续按照子图的要求检查这些区块的信息。

## 重新部署子图

更改子图定义后，例如：修复实体映射中的一个问题，再次运行上面的 `yarn deploy` 命令可以部署新版本的子图。 子图的任何更新都需要 Graph 节点再次从创世块开始重新索引您的整个子图。

如果您之前部署的子图仍处于`Syncing`状态，系统则会立即将其替换为新部署的版本。 如果之前部署的子图已经完全同步，Graph 节点会将新部署的版本标记为`Pending Version`，在后台进行同步，只有在新版本同步完成后，才会用新的版本替换当前部署的版本。 这样做可以确保在新版本同步时您仍然有子图可以使用。

## Deploying the subgraph to multiple Ethereum networks

In some cases, you will want to deploy the same subgraph to multiple Ethereum networks without duplicating all of its code. The main challenge that comes with this is that the contract addresses on these networks are different.

### graph-cli >=0.29.0

From version `0.29.0` the `build` command accepts two new options:

```sh
graph build [options] [<subgraph-manifest>]

Options:

      ...
      --network <name>          Network to use from networks.json
      --network-file <path>     Networks file (default: "./networks.json")
```

You can use the `--network` option to specify a network configuration from a `json` standard file (defaults to `networks.json`) to easily update your subgraph during development.

**Note:** The `init` command will now auto-generate a `networks.json` based on the provided information. You will then be able to update existing or add additional networks.

If you don't have a `networks.json` file, you'll need to manually create one with the follwing structure:

```json
{
    "network1": { // the network name
        "dataSource1": { // the dataSource name
            "address": "0xabc...", // the contract address (optional)
            "startBlock": 123456 // the startBlock (optional)
        },
        "dataSource2": {
            "address": "0x123...",
            "startBlock": 123444
        }
    },
    "network2": {
        "dataSource1": {
            "address": "0x987...",
            "startBlock": 123
        },
        "dataSource2": {
            "address": "0xxyz..",
            "startBlock": 456
        }
    },
    ...
}
```

**Note:** You don't have to specify any of the `templates` (if you have any) in the config file, only the `dataSources`. If there are any `templates` declared in the `subgraph.yaml` file, their network will be automatically updated to the one specified with the `--network` option.

Now, let's assume you want to be able to deploy your subgraph to the `mainnet` and `goerli` networks, and this is your `subgraph.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x123...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

This is what your networks config file should look like:

```json
{
  "mainnet": {
    "Gravity": {
      "address": "0x123..."
    }
  },
  "goerli": {
    "Gravity": {
      "address": "0xabc..."
    }
  }
}
```

Now we can run the following command:

```sh
# Using default networks.json file
yarn build --network goerli

# Using custom named file
yarn build --network goerli --network-file path/to/config
```

The `build` command will update your `subgraph.yaml` with the `goerli` configuration and then re-compile the subgraph. Your `subgraph.yaml` file now should look like this:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: goerli
    source:
      address: '0xabc...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

Now you are ready to `yarn deploy`

### graph-cli \<0.29.0

One solution for older graph-cli versions that allows to parameterize aspects like contract addresses is to generate parts of it using a templating system like [Mustache](https://mustache.github.io/) or [Handlebars](https://handlebarsjs.com/).

To illustrate this approach, let's assume a subgraph should be deployed to mainnet and Goerli using different contract addresses. You could then define two config files providing the addresses for each network:

```json
{
  "network": "mainnet",
  "address": "0x123..."
}
```

and

```json
{
  "network": "goerli",
  "address": "0xabc..."
}
```

Along with that, you would substitute the network name and addresses in the manifest with variable placeholders `{{network}}` and `{{address}}` and rename the manifest to e.g. `subgraph.template.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

In order generate a manifest to either network, you could add two additional commands to `package.json` along with a dependency on `mustache`:

```json
{
  ...
  "scripts": {
    ...
    "prepare:mainnet": "mustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
    "prepare:goerli": "mustache config/goerli.json subgraph.template.yaml > subgraph.yaml"
  },
  "devDependencies": {
    ...
    "mustache": "^3.1.0"
  }
}
```

To deploy this subgraph for mainnet or Goerli you would now simply run one of the two following commands:

```sh
# Mainnet:
yarn prepare:mainnet && yarn deploy

# Goerli:
yarn prepare:goerli && yarn deploy
```

A working example of this can be found [here](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759).

**Note:** This approach can also be applied more complex situations, where it is necessary to substitute more than contract addresses and network names or where generating mappings or ABIs from templates as well.

## Checking subgraph health

If a subgraph syncs successfully, that is a good sign that it will continue to run well forever. However, new triggers on the chain might cause your subgraph to hit an untested error condition or it may start to fall behind due to performance issues or issues with the node operators.

Graph Node exposes a graphql endpoint which you can query to check the status of your subgraph. On the Hosted Service, it is available at `https://api.thegraph.com/index-node/graphql`. On a local node it is available on port `8030/graphql` by default. The full schema for this endpoint can be found [here](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql). Here is an example query that checks the status of the current version of a subgraph:

```graphql
{
  indexingStatusForCurrentVersion(subgraphName: "org/subgraph") {
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      chainHeadBlock {
        number
      }
      latestBlock {
        number
      }
    }
  }
}
```

This will give you the `chainHeadBlock` which you can compare with the `latestBlock` on your subgraph to check if it is running behind. `synced` informs if the subgraph has ever caught up to the chain. `health` can currently take the values of `healthy` if no errors ocurred, or `failed` if there was an error which halted the progress of the subgraph. In this case you can check the `fatalError` field for details on this error.

## Subgraph archive policy

The Hosted Service is a free Graph Node indexer. Developers can deploy subgraphs indexing a range of networks, which will be indexed, and made available to query via graphQL.

To improve the performance of the service for active subgraphs, the Hosted Service will archive subgraphs which are inactive.

**A subgraph is defined as "inactive" if it was deployed to the Hosted Service more than 45 days ago, and if it has received 0 queries in the last 30 days.**

Developers will be notified by email if one of their subgraphs has been marked as inactive 7 days before it is removed. If they wish to "activate" their subgraph, they can do so by making a query in their subgraph's Hosted Service graphQL playground. Developers can always redeploy an archived subgraph if it is required again.
