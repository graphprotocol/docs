---
title: Estrutura de Testes de Unidades
---

O Matchstick √© uma estrutura de testes de unidades, desenvolvida pela [LimeChain](https://limechain.tech/), que permite que programadores de subgraph testem a sua l√≥gica de mapeamento num ambiente de sandbox e lancem os seus subgraphs com confian√ßa!

## Como Come√ßar

### Depend√™ncias de instala√ß√£o

Para usar os m√©todos de test helper e executar os testes, instale as seguintes depend√™ncias:

```sh
yarn add --dev matchstick-as
```

‚ùó O `graph-node` depende do PostgreSQL, ent√£o se ainda n√£o o tens, precisa instal√°-lo. Recomendamos fortemente usar os comandos abaixo, pois adicion√°-lo de qualquer outra maneira pode causar erros inesperados!

#### MacOS

Comando de instala√ß√£o do Postgres:

```sh
brew install postgresql
```

Crie um symlink ao √∫ltimo libpq.5.lib _Voc√™ pode precisar criar este diret√≥rio primeiro_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Comando de instala√ß√£o do Postgres (depende da sua distro):

```sh
sudo apt install postgresql
```

### WSL (Windows Subsystem for Linux)

Pode usar o Matchstick no WSL tanto com a abordagem do Docker quanto com a abordagem bin√°ria. Como o WSL pode ser um pouco complicado, aqui est√£o algumas dicas caso encontre problemas

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

ou

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Tenha ci√™ncia que est√° em uma vers√£o mais recente do Node.js. O graph-cli n√£o apoia mais a **v10.19.0**, que ainda √© a vers√£o padr√£o para novas imagens de Ubuntu no WSL. Por exemplo, se o Matchstick √© confirmado como funcional no WSL com a **v18.1.0**, pode trocar para essa vers√£o atrav√©s do **nvm** ou ao atualizar o seu Node.js global. N√£o se esque√ßa de apagar o `node_modules` e executar o `npm install` novamente ap√≥s atualizar o seu nodejs! Depois, garanta que tem o **libpq** instalado. Pode fazer isto ao executar

```
sudo apt-get install libpq-dev
```

E finalmente, n√£o use o `graph test` (que usa a sua instala√ß√£o global do graph-cli, e por alguma raz√£o, parece n√£o funcionar no WSL no momento). Em vez disto, use o `yarn test` ou o `npm run test` (que usar√° a inst√¢ncia local do graph-cli; esta funciona muito bem). Para isto, obviamente precisaria de um script `test` no seu arquivo `package.json`, que pode ser algo simples como

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.30.0",
    "@graphprotocol/graph-ts": "^0.27.0",
    "matchstick-as": "^0.5.0"
  }
}
```

### Uso

Para usar o **Matchstick** no seu projeto de subgraph, basta abrir um terminal, navegar √† pasta raiz do seu projeto e executar `graph test [options] <datasource>` ‚Äî este baixa o bin√°rio mais recente do **Matchstick**, e executa o teste especificado, ou todos os testes especificados em uma pasta de teste (ou todos os testes existentes se n√£o for especificado nenhum flag de fontes de dados).

### Op√ß√µes de CLI

Isto executar√° todos os testes na pasta-teste:

```sh
graph test
```

Isto executar√° um teste chamado gravity.test.ts e/ou todos os testes dentro de uma pasta chamada gravity:

```sh
graph test gravity
```

Isto s√≥ executar√° esse arquivo de teste espec√≠fico:

```sh
graph test path/to/file.test.ts
```

**Op√ß√µes:**

```sh
-c, --coverage                Executa os testes em modo de cobertura
-d, --docker                  Executa os testes em um docker container (Nota: Favor executar da pasta raiz do subgraph)
-f  --force                   Bin√°rio: Baixa o bin√°rio novamente. Docker: Baixa o Dockerfile novamente e reconstroi a imagem do docker.
-h, --help                    Mostra informa√ß√µes de uso
-l, --logs                    Mostra no console informa√ß√µes sobre o sistema operacional, modelo de CPU, e URL de download (para prop√≥sitos de debugging)
-r, --recompile               For√ßa os testes a serem recompilados
-v, --version <tag>           Escolhe a vers√£o do bin√°rio rust que voc√™ deseja baixar/usar
```

### Docker

Desde o `graph-cli 0.25.2`, o comando `graph test` apoia a execu√ß√£o do `matchstick` em um container docker com a flag `-d`. A implementa√ß√£o do docker utiliza o [bind mount](https://docs.docker.com/storage/bind-mounts/) para que n√£o precise reconstruir a imagem do docker toda vez que o comando `graph test -d` √© executado. Alternativamente, siga as instru√ß√µes do reposit√≥rio do [matchstick](https://github.com/LimeChain/matchstick#docker-) para executar o docker manualmente.

‚ùó Caso j√° tenha executado o `graph test` anteriormente, pode encontrar o seguinte erro durante a constru√ß√£o do docker:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

Neste caso, crie um `.dockerignore` na pasta raiz e adicione `node_modules/binary-install-raw/bin`

### Configura√ß√£o

O Matchstick pode ser configurado para usar um caminho personalizado de tests, libs e manifest atrav√©s do arquivo de configura√ß√£o `matchstick.yaml`:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Subgraph de demonstra√ß√£o

Podes experimentar e experimentar com os exemplos deste guia ao clonar a repo do [Subgraph de Demonstra√ß√£o](https://github.com/LimeChain/demo-subgraph)

### Tutoriais de v√≠deo

Tamb√©m pode conferir a s√©rie em v√≠deo sobre ["Como usar o Matchstick para escrever testes de unidade para os seus subgraphs"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Estrutura de testes (>=0.5.0)

_**Importante: Exige o matchstick-as >=0.5.0**_

### describe()

`describe(name: String , () => {})` ‚Äî Define um grupo de teste.

**_Notas:_**

- _Describes (descri√ß√µes) n√£o s√£o obrigat√≥rias. Ainda pode usar o test() da maneira antiga, fora dos blocos describe()_

Exemplo:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

Exemplo aninhado de `describe()`:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` ‚Äî Define um caso de teste. Pode usar o test() em blocos describe() ou de maneira independente.

Exemplo:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

ou

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Executa um bloco de c√≥digo antes de quaisquer dos testes no arquivo. Se o `beforeAll` for declarado dentro de um bloco `describe`, ele √© executado no come√ßo daquele bloco `describe`.

Exemplos:

O c√≥digo dentro do `beforeAll` ser√° executado uma vez antes de _todos_ os testes no arquivo.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

O c√≥digo antes do `beforeAll` ser√° executado uma vez antes de todos os testes no primeiro bloco describe

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Executa um bloco de c√≥digo depois de todos os testes no arquivo. Se o `afterAll` for declarado dentro de um bloco `describe`, ele ser√° executado no final daquele bloco `describe`.

Exemplo:

O c√≥digo dentro do `afterAll` ser√° executado uma vez depois de _todos_ os testes no arquivo.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

O c√≥digo dentro do `afterAll` ser√° executado uma vez depois de todos os testes no bloco describe

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Executa um bloco de c√≥digo antes de cada teste no arquivo. Se o `beforeEach` for declarado dentro de um bloco `describe`, ele ser√° executado antes de cada teste naquele bloco `describe`.

Exemplos: O c√≥digo dentro do `beforeEach` ser√° executado antes de cada teste.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

O c√≥digo antes do `beforeEach` ser√° executado antes de cada teste no describe

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Executa um bloco de c√≥digo depois de cada teste no arquivo. Se o `afterEach` for declarado dentro de um bloco `describe`, ser√° executado ap√≥s cada teste naquele bloco `describe`.

Exemplos:

O c√≥digo dentro do `afterEach` ser√° executado ap√≥s cada teste.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

O c√≥digo dentro do `afterEach` ser√° executado ap√≥s cada teste naquele describe

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Asserts

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

## Como Escrever um Teste de Unidade

Vamos ver como um simples teste de unidade pareceria, com os exemplos do Gravatar no [Subgraph de Demonstra√ß√£o](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

Suponhamos que temos a seguinte fun√ß√£o de handler (com duas fun√ß√µes de helper para facilitar):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Primeiro, devemos criar um arquivo de teste no nosso projeto. Este √© um exemplo de como ele pode ficar:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Cria uma entidade de teste e salve-a no armazenamento como um estado inicial (opcional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Cria eventos falsos
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Chama fun√ß√µes de mapeamento ao passar os eventos que acabamos de criar
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Afirma o estado do armazenamento
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Limpa o armazenamento para come√ßar o pr√≥ximo teste do zero
  clearStore()
})

test('Next test', () => {
  //...
})
```

Quanta coisa! Primeiro, note que estamos a impoortar coisas do `matchstick-as`, nossa biblioteca de helper do AssemblyScript (distribu√≠da como um m√≥dulo npm). Pode encontrar o reposit√≥rio [aqui](https://github.com/LimeChain/matchstick-as). `matchstick-as` nos d√° alguns m√©todos de teste √∫teis e define a fun√ß√£o `test()`, que usaremos para construir os nossos blocos de teste. O resto √© bem simples ‚Äî veja o que acontece:

- Configuramos nosso estado inicial e adicionamos uma entidade de Gravatar personalizada;
- Definimos dois eventos `NewGravatar` com os seus dados, usando a fun√ß√£o `createNewGravatarEvent()`;
- Chamamos m√©todos de handlers para estes eventos ‚Äî `handleNewGravatars()` e passamos a lista dos nossos eventos personalizados;
- Garantimos o estado da loja. Como isto funciona? ‚Äî Passamos uma combina√ß√£o do tipo e da id da Entidade. Depois conferimos um campo espec√≠fico naquela Entidade e garantimos que ela tem o valor que esperamos que tenha. Estamos a fazer isto tanto para a Entidade Gravatar inicial adicionada ao armazenamento, quanto para as duas entidades Gravatar adicionadas ao chamar a fun√ß√£o de handler;
- E por √∫ltimo ‚Äî limpamos o armazenamento com `clearStore()`, para que o nosso pr√≥ximo teste comece com um objeto de armazenamento novo em folha. Podemos definir quantos blocos de teste quisermos.

Prontinho ‚Äî criamos o nosso primeiro teste! üëè

Para executar os nossos testes, basta apenas executar o seguinte na pasta raiz do seu subgraph:

`graph test Gravity`

E se tudo der certo, deve receber a seguinte resposta:

![Matchstick diz "All tests passed!" (Todos os testes passados!)](/img/matchstick-tests-passed.png)

## Cen√°rios de teste comuns

### Como hidratar o armazenamento com um certo estado

Os utilizadores podem hidratar o armazenamento com um conjunto conhecido de entidades. Aqui est√° um exemplo para inicializar o armazenamento com uma entidade Gravatar:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Como chamar uma fun√ß√£o de mapeamento com um evento

Um utilizador pode criar um evento personalizado e pass√°-lo a uma fun√ß√£o de mapeamento ligada ao armazenamento:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Como chamar todos os mapeamentos com fixa√ß√µes de eventos

Os utilizadores podem chamar os mapeamentos com fixa√ß√µes de teste.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Como simular chamadas de contratos

Os utilizadores podem simular chamadas de contratos:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Como demonstrado, para simular uma chamada de contrato e conseguir um valor de retorno de linha-dura, o utilizador deve fornecer um endere√ßo de contrato, nome de fun√ß√£o, assinatura de fun√ß√£o, arranjo de argumentos ‚Äî e claro, o valor de retorno.

Os utilizadores tamb√©m podem simular regressos de fun√ß√µes:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Como simular arquivos IPFS (do matchstick 0.4.1)

Os utilizadores podem simular arquivos IPFS com a fun√ß√£o `mockIpfsFile(hash, filePath)`. A fun√ß√£o aceita dois argumentos: o primeiro √© o hash/caminho do arquivo IPFS, e o segundo √© o caminho a um arquivo local.

NOTA: Ao testar o `ipfs.map/ipfs.mapJSON`, a fun√ß√£o de callback deve ser exportada do arquivo de teste para que o matchstick o detete, como a fun√ß√£o `processGravatar()` no exemplo de teste abaixo:

Arquivo `.test.ts`:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Exporta o callback do ipfs.map() para que o matchstick o detete
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

Arquivo `utils.ts`:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// callback do ipfs.map
export function processGravatar(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Callbacks tamb√©m podem criar entidades
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// fun√ß√£o que chama o ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Como afirmar o estado do armazenamento

Os utilizadores podem afirmar o estado final (ou parcial) do armazenamento atrav√©s de entidades de afirma√ß√£o. Para isto, o utilizador precisa fornecer um tipo de Entidade, a ID espec√≠fica de uma Entidade, o nome de um campo naquela Entidade, e o valor esperado do campo. Aqui vai um exemplo r√°pido:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

A fun√ß√£o assert.fieldEquals() conferir√° a igualdade do campo dado contra o valor dado esperado. O teste acabar√° em erro, com mensagem correspondente, caso os valores **N√ÉO** sejam iguais. Caso contr√°rio, o teste ter√° √™xito.

### Como interagir com metadados de Eventos

Os utilizadores podem usar metadados-padr√£o de transa√ß√µes, que podem ser retornados como um ethereum.Event com a fun√ß√£o `newMockEvent()`. O seguinte exemplo mostra como pode ler/escrever a estes campos no objeto de Evento:

```typescript
// Leitura
let logType = newGravatarEvent.logType

// Escrita
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Como afirmar a igualdade das vari√°veis

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Como afirmar que uma Entidade **n√£o** est√° no armazenamento

Os utilizadores podem afirmar que uma entidade n√£o existe no armazenamento. A fun√ß√£o toma um tipo e uma id de entidade. Caso a entidade esteja, de facto, na loja, o teste acabar√° em erro, com uma mensagem de erro relevante. Veja um exemplo r√°pido de como usar esta funcionalidade:

```typescript
assert.notInStore('Gravatar', '23')
```

### Como imprimir o armazenamento completo (para fins de debug)

Pode imprimir o armazenamento inteiro na consola com esta fun√ß√£o de helper:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

### Falhas esperadas

Os utilizadores podem encontrar falhas esperadas, com o flag shouldFail nas fun√ß√µes `test()`:

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Caso o teste seja marcado com `shouldFail = true` mas N√ÉO falhe, isto ser√° mostrado como um erro nos logs e o bloco de teste n√£o ter√° √™xito. E se for marcado com `shouldFail = false` (o estado normal), o executor de teste travar√°.

### Logging

Ter logs personalizados nos testes de unidade √© a mesma coisa que logar nos mapeamentos. A diferen√ßa √© que o objeto do log deve ser importado do matchstick-as, em vez do graph-ts. Aqui vai um exemplo simples com todos os tipos de log n√£o-cr√≠ticos:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Os utilizadores tamb√©m podem simular uma falha cr√≠tica, como no seguinte:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Logar erros cr√≠ticos interromper√° a execu√ß√£o dos testes e causar√° um desastre. Afinal, queremos ter certeza que o seu c√≥digo n√£o tenha logs cr√≠ticos no lan√ßamento; perceberia imediatamente se isto acontecer.

### Como testar campos derivados

Testar campos derivados √© um recurso que (como o exemplo abaixo mostra) permite ao utilizador configurar um campo em uma certa entidade e atualizar outra imediatamente, se ela derivar um de seus campos da primeira entidade. √â importante notar que a primeira entidade deve ser recarregada enquanto a atualiza√ß√£o autom√°tica acontece no armazenamento do rust, do qual o c√≥digo em AssemblyScript √© agn√≥stico.

```typescript
test('Derived fields example test', () => {
  let mainAccount = new GraphAccount('12')
  mainAccount.save()
  let operatedAccount = new GraphAccount('1')
  operatedAccount.operators = ['12']
  operatedAccount.save()
  let nst = new NameSignalTransaction('1234')
  nst.signer = '12'
  nst.save()

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  mainAccount = GraphAccount.load('12')!

  assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
  assert.stringEquals('1', mainAccount.operatorOf[0])
})
```

### Como testar fontes de dados din√¢micas

Testar fontes de dados din√¢micas pode ser feito ao falsificar o valor de retorno das fun√ß√µes `context()`, `address()` e `network()` do namespace do dataSource. Estas fun√ß√µes atualmente retornam o seguinte: `context()` ‚Äî retorna uma entidade vazia (DataSourceContext), `address()` ‚Äî retorna `0x0000000000000000000000000000000000000000`, `network()` ‚Äî retorna `mainnet`. As fun√ß√µes `create(...)` e `createWithContext(...)` s√£o falsificadas para n√£o terem uso, para que n√£o precisem ser chamadas nos teste. D√° para mudar os valores de retorno podem atrav√©s das fun√ß√µes do namespace `dataSourceMock` no `matchstick-as` (vers√£o 0.3.0+).

Exemplo abaixo:

Primeiro temos o seguinte handler de eventos (que foi apropriado intencionalmente para demonstrar a falsifica√ß√£o de fontes de dados):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

E ent√£o, temos o teste que usa um dos m√©todos do namespace dataSourceMock para determinar um novo valor de retorno para todas as fun√ß√µes do dataSource:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Note que o `dataSourceMock.resetValues()` √© chamado no final. Isto √© porque os valores s√£o lembrados quando mudados, e devem ser reconfigurados caso queira voltar aos valores padr√£o.

## Cobertura de Testes

Com o **Matchstick**, os programadores de subgraph podem executar um script que calcula a cobertura de teste das unidades de teste escritas.

A ferramenta de cobertura de testes pega os bin√°rios de teste `wasm` compilados e os converte a arquivos `wat`, que podem ent√£o ser facilmente vistoriados para ver se os handlers definidos em `subgraph.yaml` foram chamados ou n√£o. Como a cobertura de c√≥digo (e os testes em geral) est√° em estado primitivo no AssemblyScript e WebAssembly, o **Matchstick** n√£o pode procurar por coberturas de branch. Em vez disto, presumimos que se um handler foi chamado, o evento/a fun√ß√£o correspondente j√° passou por testes com √™xito.

### Pr√©-requisitos

Para executar a funcionalidade da cobertura de teste providenciada no **Matchstick**, precisa preparar algumas coisas com anteced√™ncia:

#### Exportar seus handlers

Para que o **Matchstick** confira quais handlers s√£o executados, estes handlers devem ser exportados do **arquivo de teste** primeiro. No nosso exemplo, temos o seguinte handler a ser importado no nosso arquivo gravity.test.ts:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

Para que essa fun√ß√£o seja vis√≠vel (para ser inclu√≠da no arquivo `wat` **por nome**) tamb√©m precisamos export√°-la assim:

```typescript
export { handleNewGravatar }
```

### Uso

Assim que tudo estiver pronto, para executar a ferramenta de cobertura de testes, basta:

```sh
graph test -- -c
```

Tamb√©m pode adicionar um comando `coverage` personalizado ao seu arquivo `package.json`, assim:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Isto executar√° a ferramenta de cobertura. Ver√°s algo parecido com isto no terminal:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 Ô∏è
Reading generated test modules... üîéÔ∏è

Generating coverage report üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Dura√ß√£o do teste na sa√≠da do log

A sa√≠da do log inclui a dura√ß√£o do teste. Veja um exemplo:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Erros comuns do compilador

> `Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined`

Isto significa que usou o `console.log` no seu c√≥digo, que n√£o √© apoiado pelo AssemblyScript. Considere usar a [API de Logging](/developing/assemblyscript-api/#logging-api)

> `ERROR TS2554: Expected ? arguments, but got ?.`
> 
> `return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);`
> 
> `in ~lib/matchstick-as/assembly/defaults.ts(18,12)`
> 
> `ERROR TS2554: Expected ? arguments, but got ?.`
> 
> `return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);`
> 
> `in ~lib/matchstick-as/assembly/defaults.ts(24,12)`

A diferen√ßa nos argumentos √© causada pela diferen√ßa no `graph-ts` e no `matchstick-as`. Problemas como este s√£o melhor resolvidos ao atualizar tudo para a vers√£o mais recente.

## Feedback

Caso tenha qualquer pergunta, opini√£o, pedidos de recursos, ou s√≥ quer entrar em contacto, venha para o Discord do The Graph ‚Äî l√°, temos um canal dedicado ao Matchstick, chamado üî•| unit-testing.
