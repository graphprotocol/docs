---
title: Como criar um Subgraph
---

Um subgraph extrai dados de uma blockchain, os processa e os armazena para poderem ser consultados facilmente via GraphQL.

![Como definir um Subgraph](/img/defining-a-subgraph.png)

A definição de subgraph consiste de alguns arquivos:

- `subgraph.yaml`: um arquivo YAML que contém o manifest do subgraph

- `schema.graphql`: um schema GraphQL que define quais dados são armazenados para o seu subgraph, e como consultá-los em query via GraphQL

- `AssemblyScript Mappings`: código em [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) que traduz dos dados de eventos às entidades definidas no seu schema (por ex., `mapping.ts` neste tutorial)

> Para poder usar o seu subgraph na rede descentralizada do The Graph, [crie uma chave API](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key). Recomendamos [adicionar sinais](/network/curating/#how-to-signal) ao seu subgraph com pelo menos [10.000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network).

Antes de se aprofundar nos conteúdos do arquivo manifest, instale o [Graph CLI](https://github.com/graphprotocol/graph-cli), que será necessário para construir e adicionar um subgraph.

## Como instalar o Graph CLI

O Graph CLI é escrito em JavaScript, e só pode ser usado após instalar o `yarn` ou o `npm`; vamos supor que tens o yarn daqui em diante.

Quando tiver o `yarn`, instale o Graph CLI com o seguinte

**Instalação com o yarn:**

```bash
yarn global add @graphprotocol/graph-cli
```

**Instalação com o npm:**

```bash
npm install -g @graphprotocol/graph-cli
```

Instalado, o comando `graph init` pode preparar um novo projeto de subgraph, seja de um contrato existente ou de um exemplo de subgraph. Este comando serve para criar um subgraph no Subgraph Studio ao passar o `graph init --product subgraph-studio`. Se já tem um contrato inteligente lançado na mainnet do Ethereum ou uma de suas testnets, inicializar um novo subgraph daquele contrato pode ser um bom começo.

## De um Contrato Existente

O seguinte comando cria um subgraph que indexa todos os eventos de um contrato existente. Ele tenta buscar a ABI de contrato do Etherscan e resolve solicitar um local de arquivo. Se quaisquer dos argumentos opcionais estiverem a faltar, ele levará-te a um formulário interativo.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

O `<SUBGRAPH_SLUG>` é a ID do seu subgraph no Subgraph Studio, visível na página dos detalhes do seu subgraph.

## De um Exemplo de Subgraph

O segundo modo que o `graph init` apoia é criar um projeto a partir de um exemplo de subgraph. O seguinte comando faz isso:

```sh
graph init --studio <SUBGRAPH_SLUG>
```

O subgraph de exemplo é baseado no contrato Gravity por Dani Grant, que administra avatares de usuários e emite eventos `NewGravatar` ou `UpdateGravatar` sempre que avatares são criados ou atualizados. O subgraph lida com estes eventos ao escrever entidades `Gravatar` ao armazenamento do Graph Node e garantir que estes são atualizados de acordo com os eventos. As seguintes seções lidarão com os arquivos que compõem o manifest do subgraph para este exemplo.

## Como Adicionar Novos dataSources para um Subgraph Existente

Desde a `v0.31.0`, o `graph-cli` apoia a adição de novos dataSources para um subgraph existente, através do comando `graph add`.

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Opções:

      --abi <path>              Caminho à ABI do contrato (padrão: baixar do Etherscan)
      --contract-name           Nome do contrato (padrão: Contract)
      --merge-entities          Se fundir ou não entidades com o mesmo nome (padrão: false)
      --network-file <path>     Caminho ao arquivo de configuração das redes (padrão: "./networks.json")
```

O comando `add` pegará a ABI do Etherscan (a não ser que um caminho para a ABI seja especificado com a opção `--abi`), e criará um novo `dataSource` da mesma maneira que o comando `graph init` cria um `dataSource` `--from-contract`, a atualizar o schema e os mapeamentos de acordo.

A opção `--merge entities` identifica como o programador gostaria de lidar com nomes de conflito em `entity` e `event`:

- Se for `true`: o novo `dataSource` deve usar `eventHandlers` & `entities` existentes.
- Se for `false`: um novo handler de entidades & eventos deve ser criado com `${dataSourceName}{EventName}`.

O endereço (`address`) será escrito ao `networks.json` para a rede relevante.

> **Nota:** Quando usar a cli interativa, após executar o `graph init` com êxito, receberá uma solicitação para adicionar um novo `dataSource`.

## O Manifest do Subgraph

O manifest do subgraph `subgraph.yaml` define os contratos inteligentes indexados pelo seu subgraph; a quais eventos destes contratos prestar atenção; e como mapear dados de eventos a entidades que o Graph Node armazena e permite queries. Veja a especificação completa para manifests de subgraph [aqui](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

Para o subgraph de exemplo, o `subgraph.yaml` é:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

As entradas importantes para atualizar para o manifest são:

- `description`: uma descrição legível a humanos do que é o subgraph. Esta descrição é exibida pelo Graph Explorer quando o subgraph é lançado ao Serviço Hospedado.

- `repository`: a URL do repositório onde está o manifest do subgraph. Isto também é exibido pelo Graph Explorer.

- `features`: uma lista de todos os nomes de [feature](#experimental-features) usados.

- `dataSources.source`: o endereço do contrato inteligente que abastece o subgraph, e a ABI do contrato inteligente a ser usada. O endereço é opcional; omiti-lo permite indexar eventos correspondentes de todos os contratos.

- `dataSources.source.startBlock`: o número opcional do bloco de onde a fonte de dados começa a indexar. Em muitos casos, sugerimos usar o bloco em que o contrato foi criado.

- `dataSources.mapping.entities`: as entidades que a fonte de dados escreve ao armazenamento. O schema para cada entidade é definido no arquivo schema.graphql.

- `dataSources.mapping.abis`: um ou mais arquivos ABI nomeados para o contrato-fonte, além de quaisquer outros contratos inteligentes com os quais interage de dentro dos mapeamentos.

- `dataSources.mapping.eventHandlers`: lista os eventos de contratos inteligentes aos quais este subgraph reage, e os handlers no mapping — ./src/mapping.ts no exemplo — que transformam estes eventos em entidades no armazenamento.

- `dataSources.mapping.callHandlers`: lista as funções de contratos inteligentes aos quais este subgraph reage, e os handlers no mapping que transformam as entradas e saídas para chamadas de função em entidades no armazenamento.

- `dataSources.mapping.blockHandlers`: lista os blocos aos quais este subgraph reage, e handlers no mapeamento quando um bloco é atrelado à chain. Sem um filtro, o handler de blocos será executado em todo bloco. Um filtro de chamada opcional pode ser fornecido ao adicionar um campo `filter` com `kind: call` no handler. Isto só executará o handler se o bloco conter no mínimo uma chamada ao contrato da fonte de dados.

Um único subgraph pode indexar dados de vários contratos inteligentes. Adicione uma entrada para cada contrato cujos dados devem ser indexados ao arranjo `dataSources`.

Os gatilhos para uma fonte de dados dentro de um bloco são ordenados com o seguinte processo:

1. Gatilhos de evento e chamada são, primeiro, ordenados por índice de transação no bloco.
2. Gatilhos de evento e chamada dentro da mesma transação são ordenados a usar uma convenção: primeiro, gatilhos de evento, e depois, de chamada, cada tipo a respeitar a ordem em que são definidos no manifest.
3. Gatilhos de blocos são executados após gatilhos de evento e chamada, na ordem em que são definidos no manifest.

Estas regras de organização estão sujeitas à mudança.

### Como Obter as ABIs

Os arquivos da ABI devem combinar com o(s) seu(s) contrato(s). Há algumas maneiras de obter estes arquivos:

- Caso construa o seu próprio projeto, provavelmente terá acesso às suas ABIs mais recentes.
- Caso construa uma subgraph para um projeto público, pode baixar aquele projeto no seu computador e construir a ABI ao usar o comando [`truffle compile`](https://truffleframework.com/docs/truffle/overview) ou compilar com solc.
- Também pode achar a ABI no [Etherscan](https://etherscan.io/), mas isto nem sempre é confiável, pois a ABI exibida lá pode estar ultrapassada. Tenha certeza que tem a ABI certa, senão, pode haver um erro ao executar o seu subgraph.

## O Schema GraphQL

O schema para o seu subgraph está no arquivo `schema.graphql`. Schemas de GraphQL são definidos usando a linguagem de definição GraphQL. Se você nunca tiver escrito um schema nesta linguagem, confira este preparatório no sistema de tipos do GraphQL. A documentação de referência para schemas em GraphQL está na seção [API GraphQL](/querying/graphql-api).

## Como Definir Entidades

Antes de definir entidades, é important parar para pensar sobre como os seus dados são estruturados e ligados. Todas as consultas serão feitas perante o modelo de dados definido no schema do subgraph e as entidades indexadas pelo subgraph. Portanto, é bom definir o schema do subgraph de uma forma que atenda as necessidades do seu dApp. Pode ser conveniente imaginar entidades como "objetos a conter dados", ao invés de eventos ou funções.

Com o The Graph, pode simplesmente definir tipos de entidade no `schema.graphql`; assim, o Graph Node gerará campos de nível alto para fazer queries de instâncias únicas e coleções daquele tipo de entidade. Cada tipo que deve ser uma entidade tem de ser anotado com uma diretiva `@entity`. As entidades são mutáveis, o que significa que os mapeamentos podem carregar entidades existentes, modificá-las e armazenar novas versões delas. A mutabilidade vem com um preço; por exemplo, para tipos de entidade que claramente não podem ser alterados por conter dados extraídos exatamente da chain, é recomendado marcá-los como imutáveis com `@entity(immutable: true)`. Entidades imutáveis podem ser alteradas com mapeamentos, desde que as alterações aconteçam no mesmo bloco em que a entidade foi criada. Entidades imutáveis são muito mais rápidas de escrever e consultar, e então devem ser usadas sempre que possível.

### Bom Exemplo

A entidade `Gravatar` embaixo é estruturada em torno de um objeto Gravatar, e é um bom exemplo de como pode ser definida uma entidade.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Mau Exemplo

As entidades `GravatarAccepted` e `GravatarDeclined` abaixo têm base em torno de eventos. Não é recomendado mapear eventos ou chamadas de função a entidades identicamente.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Campos Opcionais e Obrigatórios

Campos de entidade podem ser definidos como obrigatórios ou opcionais. Os obrigatórios são indicados no schema pelo código `!`. Se um campo obrigatório não for determinado no mapeamento, receberá este erro ao consultar o campo:

```
Null value resolved for non-null field 'name'
```

Cada entidade deve ter um campo `id`, que deve ser do tipo `Bytes!` ou `String!`. Geralmente é melhor usar `Bytes!` — a não ser que o `id` tenha texto legível para humanos, já que entidades com as ids `Bytes!` são mais fáceis de escrever e consultar como aquelas com um `id` `String!`. O campo `id` serve como a chave primária, e deve ser singular entre todas as entidades do mesmo tipo. Por razões históricas, o tipo `ID!` também é aceito, como um sinônimo de `String!`.

Para alguns tipos de entidade, o `id` é construído das id's de duas outras entidades; isto é possível com o `concat`, por ex., `let id = left.id.concat(right.id)` para formar a id a partir das id's de `left` e `right`. Da mesma forma, para construir uma id a partir da id de uma entidade existente e um contador `count`, pode ser usado o `let id = left.id.concatI32(count)`. Isto garante a concatenação a produzir id's únicas enquanto o comprimento do `left` for o mesmo para todas as tais entidades; por exemplo, porque o `left.id` é um `Address` (endereço).

### Tipos Embutidos de Escalar

#### Escalares Apoiados pelo GraphQL

Nós apoiamos os seguintes escalares na nossa API do GraphQL:

| Tipo | Descrição |
| --- | --- |
| `Bytes` | Arranjo de bytes, representado como string hexadecimal. Usado frequentemente por hashes e endereços no Ethereum. |
| `String` | Escalar para valores `string`. Caracteres nulos são removidos automaticamente. |
| `Boolean` | Escalar para valores `boolean`. |
| `Int` | A especificação do GraphQL define que o `Int` tem um tamanho de 32 bytes. |
| `BigInt` | Números inteiros grandes. Usados para os tipos `uint32`, `int64`, `uint64`, ..., `uint256` do Ethereum. Nota: Tudo abaixo de `uint32`, como `int32`, `uint24` ou `int8` é representado como `i32`. |
| `BigDecimal` | `BigDecimal` Decimais de alta precisão representados como um significando e um exponente. O alcance de exponentes é de -6143 até +6144. Arredondado para 34 dígitos significantes. |

#### Enums

Também pode criar enums dentro de um schema. Enums têm a seguinte sintaxe:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Quando o enum for definido no schema, pode usar a representação do string do valor enum para determinar um campo enum numa entidade. Por exemplo, pode implantar o `tokenStatus` no `SecondOwner` ao definir primeiro a sua entidade e depois determinar o campo com `entity.tokenStatus = "SecondOwner"`. O exemplo abaixo demonstra como ficaria a entidade do Token com um campo enum:

Veja mais detalhes sobre a escrita de enums na [documentação do GraphQL](https://graphql.org/learn/schema/).

#### Relacionamentos de Entidades

Uma entidade pode ter relacionamentos com uma ou mais entidades no seu schema; estes podem ser tratados nas suas consultas. Os relacionamentos no The Graph são unidirecionais, e é possível simular relacionamentos bidirecionais ao definir um relacionamento unidirecional em cada "lado" do relacionamento projetado.

Relacionamentos são definidos em entidades como qualquer outro campo, sendo que o tipo especificado é o de outra entidade.

#### Relacionamentos Um-com-Um

Defina um tipo de entidade `Transaction` com um relacionamento um-com-um opcional, com um tipo de entidade `TransactionReceipt`:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### Relacionamentos Um-com-Vários

Defina um tipo de entidade `TokenBalance` com um relacionamento um-com-vários, exigido com um tipo de entidade Token:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Buscas Reversas

Buscas reversas podem ser definidas em uma entidade pelo campo `@derivedFrom`. Isto cria um campo virtual na entidade, que pode ser consultado, mas não pode ser configurado manualmente pela API de mapeamentos. Em vez disto, ele é derivado do relacionamento definido na outra entidade. Para tais relacionamentos, raramente faz sentido armazenar ambos os lados do relacionamento, e tanto o indexing quanto o desempenho dos queries melhorarão quando apenas um lado for armazenado, e o outro derivado.

Para relacionamentos um-com-vários, o relacionamento sempre deve ser armazenado no lado 'um', e o lado 'vários' deve sempre ser derivado. Armazenar o relacionamento desta maneira, em vez de armazenar um arranjo de entidades no lado 'vários', melhorará dramaticamente o desempenho para o indexing e os queries no subgraph. Em geral, evite armazenar arranjos de entidades enquanto for prático.

#### Exemplo

Podemos fazer os saldos para um token acessíveis a partir do mesmo token ao derivar um campo `tokenBalances`:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Relacionamentos Vários-com-Vários

Para relacionamentos vários-com-vários, como um conjunto de utilizadores em que cada um pertence a qualquer número de organizações, o relacionamento é mais simplesmente — mas não mais eficientemente — modelado como um arranjo em cada uma das duas entidades envolvidas. Se o relacionamento for simétrico, apenas um lado do relacionamento precisa ser armazenado, e o outro lado pode ser derivado.

#### Exemplo

Defina uma busca reversa a partir de um tipo de entidade `User` para um tipo de entidade `Organization`. No exemplo abaixo, isto é feito ao buscar pelo atributo `members` a partir de dentro da entidade `Organization`. Em queries, o campo `organizations` no `User` será resolvido ao encontrar todas as entidades `Organization` que incluem a ID do utilizador.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Uma maneira mais eficiente para armazenar este relacionamento é com uma mesa de mapeamento que tem uma entrada para cada par de `User` / `Organization`, com um schema como

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

Esta abordagem requer que os queries desçam a um nível adicional para retirar, por exemplo, as organizações para utilizadores:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # isto é uma entidade UserOrganization
      organization {
        name
      }
    }
  }
}
```

Esta maneira mais elaborada de armazenar relacionamentos vários-com-vários armazenará menos dados para o subgraph, portanto, o subgraph ficará muito mais rápido de indexar e consultar.

#### Como adicionar comentários ao schema

Pela especificação do GraphQL, é possível adicionar comentários acima de atributos de entidade do schema com aspas duplas `""`. Isto é ilustrado no exemplo abaixo:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## Como Definir Campos de Busca Fulltext

Buscas fulltext filtram e ordenam entidades baseadas num texto inserido. Queries fulltext podem retornar resultados para palavras semelhantes ao processar o texto inserido antes de compará-los aos dados do texto indexado.

Uma definição de query fulltext inclui: o nome do query, o dicionário do idioma usado para processar os campos de texto, o algoritmo de ordem usado para ordenar os resultados, e os campos incluídos na busca. Todo query fulltext pode ter vários campos, mas todos os campos incluídos devem ser de um único tipo de entidade.

Para adicionar um query fulltext, inclua um tipo `_Schema_` com uma diretiva fulltext no schema em GraphQL.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

O exemplo `bandSearch` serve, em queries, para filtrar entidades `Band` baseadas nos documentos de texto nos campos `name`, `description` e `bio`. Confira a página [API GraphQL - Consultas](/querying/graphql-api#queries) para uma descrição da API de busca fulltext e mais exemplos de uso.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Gestão de Características](#experimental-features):** A partir do `specVersion` `0.0.4` em diante, o `fullTextSearch` deve ser declarado sob a seção `features` no manifest do subgraph.

### Idiomas apoiados

Escolher um idioma diferente terá um efeito definitivo, porém às vezes sutil, na API da busca fulltext. Campos cobertos por um campo de query fulltext serão examinados no contexto do idioma escolhido, para que os lexemas produzidos pela análise e pelos queries de busca variem de idioma para idioma. Por exemplo: ao usar o dicionário turco, "token" é abreviado para "toke" enquanto, claro, o dicionário em inglês o categorizará como "token".

Dicionários apoiados:

| Código | Dicionário  |
| ------ | ----------- |
| simple | Geral       |
| da     | Dinamarquês |
| nl     | Holandês    |
| en     | Inglês      |
| fi     | Finlandês   |
| fr     | Francês     |
| de     | Alemão      |
| hu     | Húngaro     |
| it     | Italiano    |
| no     | Norueguês   |
| pt     | Português   |
| ro     | Romeno      |
| ru     | Russo       |
| es     | Espanhol    |
| sv     | Sueco       |
| tr     | Turco       |

### Algoritmos de Ordem

Algoritmos apoiados para a organização de resultados:

| Algoritmo     | Descrição                                                                         |
| ------------- | --------------------------------------------------------------------------------- |
| rank          | Organiza os resultados pela qualidade da correspondência (0-1) da busca fulltext. |
| proximityRank | Parecido com o rank, mas também inclui a proximidade das correspondências.        |

## Como Escrever Mapeamentos

Os mapeamentos tomam dados de uma fonte particular e os transformam em entidades que são definidas dentro do seu schema. São escritos em um subconjunto do [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) chamado [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki), que pode ser compilado ao WASM ([WebAssembly](https://webassembly.org/)). O AssemblyScript é mais rígido que o TypeScript normal, mas rende uma sintaxe familiar.

Para cada handler de evento definido no `subgraph.yaml` sob o `mapping.eventHandlers`, crie uma função exportada de mesmo nome. Cada handler deve aceitar um único parâmetro chamado `event` com um tipo a corresponder ao nome do evento sendo lidado.

No subgraph de exemplo, o `src/mapping.ts` contém handlers para os eventos `NewGravatar` e `UpdatedGravatar`:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

O primeiro handler toma um evento `NewGravatar` e cria uma nova entidade `Gravatar` com o `new Gravatar(event.params.id.toHex())`, e assim popula os campos da entidade com os parâmetros de evento correspondentes. Esta instância da entidade é representada pelo variável `gravatar`, com um valor de id de `event.params.id.toHex()`.

O segundo handler tenta carregar o `Gravatar` do armazenamento do Graph Node. Se ele ainda não existe, ele é criado por demanda. A entidade é então atualizada para corresponder aos novos parâmetros de evento, antes de ser devolvida ao armazenamento com `gravatar.save()`.

### IDs Recomendadas para Criar Novas Entidades

Toda entidade deve ter uma `id` original entre todas as entidades do mesmo tipo. O valor do `id` de uma entidade é determinado quando ela é criada. Abaixo estão alguns valores recomendados de `id` para considerar ao criar novas entidades. NOTA: O valor da `id` deve ser um `string`.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

Nós fornecemos a [Biblioteca do Graph Typescript](https://github.com/graphprotocol/graph-ts), que contém utilidades para interagir com o armazenamento do Graph Node e conveniências para gerir entidades e dados de contratos inteligentes. Pode usar esta biblioteca nos seus mapeamentos importando o `@graphprotocol/graph-ts` no `mapping.ts`.

## Geração de Código

Para tornar mais fácil e seguro a tipos o trabalho com contratos inteligentes, eventos e entidades, o Graph CLI pode gerar tipos de AssemblyScript a partir do schema GraphQL do subgraph e das ABIs de contratos incluídas nas fontes de dados.

Isto é feito com

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

mas geralmente, os subgraphs já são pré-configurados através do `package.json` para alcançar o mesmo com a execução de um dos seguintes:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

Isto gerará uma classe de AssemblyScript para todo contrato inteligente nos arquivos ABI mencionados no `subgraph.yaml`, permitindo ligar estes contratos a endereços específicos nos mapeamentos e chamar métodos de contratos de apenas-leitura contra o bloco a ser processado. Também gerará uma classe para todo evento de contrato para fornecer acesso fácil a parâmetros de eventos, assim como ao bloco e a transação dos quais o evento originou. Todos estes tipos são escritos para `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts`. No subgraph de exemplo, isto seria o `generated/Gravity/Gravity.ts`, permitindo que estes tipos sejam importados com mapeamentos.

```javascript
import {
  // Classe do contrato:
  Gravity,
  // Classes de eventos:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

Além disto, uma classe é gerada para cada tipo de entidade no schema GraphQL do subgraph. Estas classes rendem carregamento, acesso de leitura e escritura para campos de entidades com segurança de tipos, além de um método `save()` para escrever entidades ao armazenamento. Todas as classes de entidades são escritas no `<OUTPUT_DIR>/schema.ts`, permitindo que os mapeamentos as importem com

```javascript
import { Gravatar } from '../generated/schema'
```

> **Nota:** A geração de códigos deve ser executada novamente após todas as mudanças ao schema GraphQL ou às ABIs incluídas no manifest. Ela também deve ser executada pelo menos uma vez antes de construir ou lançar o subgraph.

A geração de código não confere o seu código de mapeamento no `src/mapping.ts`. Se quiser conferir isto antes de tentar lançar o seu subgraph ao Graph Explorer, pode executar o `yarn build` e consertar quaisquer erros de sintaxe que o compilador TypeScript possa encontrar.

## Modelos de Fontes de Dados

Um padrão comum em contratos inteligentes compatíveis com EVMs é o uso de contratos de registro ou fábrica. Nisto, um contrato cria, gesta ou refere a um número arbitrário de outros contratos, cada um com o seu próprio estado e eventos.

Os endereços destes subcontratos podem ou não ser conhecidos imediatamente, e muitos destes contratos podem ser criados e/ou adicionados ao longo do tempo. É por isto que, em muitos casos, é impossível definir uma única fonte de dados ou um número fixo de fontes de dados, e é necessária uma abordagem mais dinâmica: _modelos de fontes de dados_.

### Fonte de Dados para o Contrato Principal

Primeiro, defina uma fonte de dados regular para o contrato principal. Abaixo está um exemplo simplificado de fonte de dados para o contrato de fábrica de trocas do [Uniswap](https://uniswap.org). Preste atenção ao handler de evento `NewExchange(address,address)`: é emitido quando um novo contrato de troca é criado on-chain pelo contrato de fábrica.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Modelos de Fontes de Dados para Contratos Criados Dinamicamente

Depois, adicione _modelos de fontes de dados_ ao manifest. Estes são idênticos a fontes de dados regulares, mas não têm um endereço de contrato predefinido sob `source`. Tipicamente, definiria um modelo para cada tipo de subcontrato gestado ou referenciado pelo contrato parente.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... outros campos de fonte para o contrato principal ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Como Instanciar um Modelo de Fontes de Dados

No passo final, atualize o seu mapeamento de contratos para criar uma instância dinâmica de fontes de dados de um dos modelos. Neste exemplo, mudarias o mapeamento do contrato principal para importar o modelo `Exchange` e chamar o método `Exchange.create(address)` nele, para começar a indexar o novo contrato de troca.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Comece a indexar a troca; `event.params.exchange` é o
  // endereço do novo contrato de troca
  Exchange.create(event.params.exchange)
}
```

> **Nota:** Uma nova fonte de dados só processará as chamadas e eventos para o bloco onde ele foi criado e todos os blocos a seguir. Porém, não serão processados dados históricos, por ex, contidos em blocos anteriores.
>
> Se blocos anteriores conterem dados relevantes à nova fonte, é melhor indexá-los ao ler o estado atual do contrato e criar entidades que representem aquele estado na hora que a nova fonte de dados for criada.

### Contextos de Fontes de Dados

Contextos de fontes de dados permitem passar configurações extras ao instanciar um template. Em nosso exemplo, vamos dizer que trocas são associadas com um par de trading particular, que é incluído no evento `NewExchange`. Essa informação pode ser passada na fonte de dados instanciada, como:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Dentro de um mapeamento do modelo `Exchange`, dá para acessar o contexto:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Há setters e getters como `setString` e `getString` para todos os tipos de valores.

## Blocos Iniciais

O `startBlock` é uma configuração opcional que permite-lhe definir de qual bloco na chain a fonte de dados começará a indexar. Determinar o bloco inicial permite que a fonte de dados potencialmente pule milhões de blocos irrelevantes. Tipicamente, um programador de subgraph configurará o `startBlock` ao bloco em que o contrato inteligente da fonte de dados foi criado.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Nota:** O bloco da criação do contrato pode ser buscado rapidamente no Etherscan:
>
> 1. Procure pelo contrato ao inserir o seu endereço na barra de busca.
> 2. Clique no hash da transação da criação na seção `Contract Creator`.
> 3. Carregue a página dos detalhes da transação, onde encontrará o bloco inicial para aquele contrato.

## Handlers de chamada

Enquanto os eventos provém uma forma eficiente de coletar mudanças relevantes ao estado de um contrato, muitos contratos evitam gerar logs para otimizar os custos de gas. Nestes casos, um subgraph pode se inscrever em chamadas feitas ao contrato da fonte de dados. Isto é alcançado ao definir handlers de calls que referenciam a assinatura da função, e o handler de mapeamento que processará chamadas para esta função. Para processar estas chamadas, o handler de mapeamento receberá um `ethereum.Call` como um argumento com as entradas digitadas e as saídas da chamada. Chamadas feitas a qualquer profundidade na cadeia de chamadas de uma transação irão engatilhar o mapeamento; assim, atividades com o contrato de fontes de dados serão capturados através de contratos de proxy.

Handlers de chamadas só serão ativados em um de dois casos: quando a função especificada é chamada por uma conta que não for do próprio contrato, ou quando ela é marcada como externa no Solidity e chamada como parte de outra função no mesmo contrato.

> **Nota:** Os handlers de chamada atualmente dependem da API de rastreamento do Parity. Certas redes, como Arbitrum e BNB Chain, não apoiam esta API. Se um subgraph que indexa uma destas redes conter um ou mais handlers de chamadas, ele não começará a sincronização. Os programadores de subgraph devem, em vez disto, usar handlers de eventos. Estes têm desempenho bem melhor que handlers de chamadas, e são apoiados em toda rede EVM.

### Como Definir um Handler de Chamada

Para definir um handler de chamada no seu manifest, apenas adicione um arranjo `callHandlers` sob a fonte de dados para a qual quer se inscrever.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

O `functionm` é a assinatura de função normalizada para filtrar chamadas. A propriedade `handler` é o nome da função no seu mapeamento que gostaria de executar quando a função-alvo é chamada no contrato da fonte de dados.

### Função de Mapeamento

Cada handler de chamadas toma um único parâmetro, que tem um tipo correspondente ao nome da função chamada. No exemplo de subgraph acima, o mapeamento contém um handler para quando a função `createGravatar` é chamada e recebe um `CreateGravatarCall` como argumento:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

A função `handleCreateGravatar` toma um novo `CreateGravatarCall` que é uma subclasse do `ethereum.Call`, fornecido pelo `@graphprotocol/graph-ts`, que inclui as entradas e saídas digitadas da chamada. O tipo `CreateGravatarCall` é gerado para ti quando executa o `graph codegen`.

## Handlers de Blocos

Além de se inscrever a eventos de contratos ou chamadas para funções, um subgraph também pode querer atualizar os seus dados enquanto novos blocos são afixados à chain. Para isto, um subgraph pode executar uma função após cada bloco, ou após blocos que correspondem a um filtro predefinido.

### Filtros Apoiados

```yaml
filter:
  kind: call
```

_O handler definido será chamado uma vez para cada bloco, que contém uma chamada ao contrato (fonte de dados) sob o qual o handler está definido._

> **Nota:** O filtro `call` atualmente depende da API de rastreamento do Parity. Certas redes, como Arbitrum e BNB Chain, não apoiam esta API. Se um subgraph que indexa uma destas redes conter um ou mais handlers de blocos com um filtro `call`, ele não começará a sincronização.

A ausência de um filtro para um handler de blocos garantirá que o handler seja chamado a todos os blocos. Uma fonte de dados só pode conter um handler de bloco para cada tipo de filtro.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### Função de Mapeamento

A função de mapeamento receberá um `ethereum.block` como o seu único argumento. Assim como funções de mapeamento para eventos, esta função pode acessar entidades existentes no armazenamento do subgraph, chamar contratos inteligentes e criar ou atualizar entidades.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## Eventos Anónimos

Caso precise processar eventos anónimos no Solidity, isto é possível ao fornecer o topic 0 do evento, como no seguinte exemplo:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

Um evento só será ativado quando a assinatura e o topic 0 corresponderem. `topic0` é igual ao hash da assinatura do evento.

## Recibos de Transação em Handlers de Eventos

A partir do `specVersion` `0.0.5` e `apiVersion` `0.0.7`, handlers de eventos podem ter acesso ao recibo para a transação que os emitiu.

Para fazer isto, os handlers de eventos devem ser declarados no manifest do subgraph com a nova chave `receipt: true`, sendo esta opcional e configurada normalmente para `false`.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

Dentro da função do handler, o recibo pode ser acessado no campo `Event.receipt`. Quando a chave `receipt` é configurada em `false`, ou omitida no manifest, um valor `null` será retornado em vez disto.

## Recursos experimentais

A partir do `specVersion` `0.0.4`, os recursos de subgraph devem ser explicitamente declarados na seção `features` no maior nível do arquivo de manifest com o seu nome em `camelCase`, como listado abaixo:

| Recurso                                                   | Nome                                                |
| --------------------------------------------------------- | --------------------------------------------------- |
| [Erros não-fatais](#non-fatal-errors)                     | `nonFatalErrors`                                    |
| [Busca fulltext](#defining-fulltext-search-fields)        | `fullTextSearch`                                    |
| [Enxertos](#grafting-onto-existing-subgraphs)             | `grafting`                                          |
| [IPFS em Contratos Ethereum](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` ou `nonDeterministicIpfs` |

Por exemplo, se um subgraph usa os recursos de **Busca Fulltext** e **Erros não-fatais**, o campo `features` no manifest deve ser:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Note que usar uma ferramenta sem declará-la causará um **erro de validação** durante o lançamento de um subgraph, mas não ocorrerá nenhum erro se um recurso for declarado sem ser usado.

### IPFS em Contratos Ethereum

Um caso de uso comum para a combinação do IPFS com o Ethereum é o armazenamento de dados no IPFS que seriam caros demais para manter on-chain, e referenciar o hash IPFS nos contratos do Ethereum.

Considerando tais hashes IPFS, os subgraphs podem ler os arquivos correspondentes do IPFS com `ipfs.cat` e `ipfs.map`. Para fazer isto de forma consistente, estes arquivos devem ser fixados em um node IPFS com alta disponibilidade, para que o node IPFS do [serviço hospedado](https://thegraph.com/hosted-service) possa encontrá-los durante a indexação.

> **Nota:** A rede do The Graph ainda não apoia `ipfs.cat` e `ipfs.map`, e os programadores não devem lançar subgraphs à rede pelo Studio com esta funcionalidade.

> **[Gerenciamento de Recursos](#experimental-features):** O `ipfsOnEthereumContracts` deve ser declarado sob `features` no manifest do subgraph. Para chains que não sejam EVM, o apelido `nonDeterministicIpfs` serve a mesma função.

Ao executar um Graph Node local, a variável `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` deve ser configurada para poder indexar subgraphs usando esta funcionalidade experimental.

### Erros não-fatais

Erros de indexação em subgraphs já sincronizados, por si próprios, farão que o subgraph falhe e pare de sincronizar. Os subgraphs podem, de outra forma, ser configurados a continuar a sincronizar na presença de erros, ao ignorar as mudanças feitas pelo handler que provocaram o erro. Isto dá tempo aos autores de subgraphs para corrigir seus subgraphs enquanto queries continuam a ser servidos perante o bloco mais recente, porém os resultados podem ser inconsistentes devido ao bug que causou o erro. Note que alguns erros ainda são sempre fatais. Para ser não-fatais, os erros devem ser confirmados como determinísticos.

> **Nota:** A rede do The Graph ainda não apoia erros não fatais, e os programadores não devem lançar subgraphs à rede pelo Studio por esta funcionalidade.

Permitir erros não fatais exige a configuração da seguinte feature flag no manifest do subgraph:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

A consulta também deve concordar em consultar dados que tenham possíveis inconsistências através do argumento `subgraphError`. Também vale consultar o `_meta` para verificar se o subgraph pulou erros, como no seguinte exemplo:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

Caso o subgraph encontre um erro, esse query retornará tanto os dados quanto o erro no graphql com a mensagem `"indexing_error"`. Veja neste exemplo de resposta:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Como Enxertar em Subgraphs Existentes

Quando um subgraph é lançado pela primeira vez, ele começa a indexar eventos no bloco gênese da chain correspondente (ou no `startBlock` definido com cada fonte de dados). Às vezes, há vantagem em reutilizar os dados de um subgraph existente e começar a indexar em um bloco muito mais distante. Este modo de indexar é chamado de _Enxerto_. O enxerto, por exemplo, serve para passar rapidamente por erros simples nos mapeamentos durante a programação, ou consertar temporariamente um subgraph existente após ele ter falhado.

Um subgraph é enxertado em um subgraph base quando um manifest de subgraph no `subgraph.yaml` contém um bloco `graft` no maior nível:

```yaml
description: ...
graft:
  base: Qm... # ID do subgraph base
  block: 7345624 # Número do bloco
```

Quando é lançado um subgraph cujo manifest contém um bloco `graft`, o Graph Node copiará os dados do subgraph `base` até, e inclusive, o `block` dado, e então continuará a indexar o novo subgraph a partir daquele bloco. O subgraph base deve existir na instância-alvo do Graph Node e ter indexado até, no mínimo, o bloco dado. Devido a esta restrição, o enxerto só deve ser usado durante a programação, ou em uma emergência para acelerar a produção de um subgraph não-enxertado equivalente.

Como o enxerto copia em vez de indexar dados base, dirigir o subgraph para o bloco desejado desta maneira é mais rápido que indexar do começo, mesmo que a cópia inicial dos dados ainda possa levar várias horas para subgraphs muito grandes. Enquanto o subgraph enxertado é inicializado, o Graph Node gravará informações sobre os tipos de entidade que já foram copiados.

O subgraph enxertado pode usar um schema GraphQL que não é idêntico ao schema do subgraph base, mas é apenas compatível com ele. Ele deve ser um schema válido no seu próprio mérito, mas pode desviar do schema do subgraph base nas seguintes maneiras:

- Ele adiciona ou remove tipos de entidade
- Ele retira atributos de tipos de identidade
- Ele adiciona atributos anuláveis a tipos de entidade
- Ele transforma atributos não anuláveis em atributos anuláveis
- Ele adiciona valores a enums
- Ele adiciona ou remove interfaces
- Ele muda para quais tipos de entidades uma interface é implementada

> **[Gerenciamento de Recursos](#experimental-features):** O `grafting` deve ser declarado sob `features` no manifest do subgraph.

## Fontes de Dados de Arquivos

Fontes de dados de arquivos são uma nova funcionalidade para acessar dados off-chain de uma maneira robusta e extensível durante a indexação, começando pelo IPFS.

> Isto também abre as portas para indexar dados off-chain de forma determinística, além de potencialmente introduzir dados arbitrários com fonte em HTTP.

### Visão geral

Em vez de buscar arquivos "em linha" durante a execução do handler, isto introduz modelos que podem ser colocados como novas fontes de dados para um identificador de arquivos. Estas novas fontes de dados pegam os arquivos e tentam novamente caso não obtenham êxito; quando o arquivo é encontrado, executam um handler dedicado.

Isto é parecido com os [modelos de fontes de dados existentes](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates), usados para criar novas fontes de dados baseadas em chains dinamicamente.

> Isto substitui a API `ipfs.cat` existente

### Upgrade guide

#### Atualizar `graph-ts` e `graph-cli`

O recurso de fontes de dados de arquivos exige o graph-ts >=0.29.0 e o graph-cli >=0.33.1

#### Adicionar um novo tipo de entidade que será atualizado quando os arquivos forem encontrados

Fontes de dados de arquivos não podem acessar ou atualizar entidades baseadas em chain, mas devem atualizar entidades específicas a arquivos.

Isto pode implicar separar campos de entidades existentes em entidades separadas, ligadas juntas.

Entidade combinada original:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

Entidade nova, separada:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

Se o relacionamento for perfeitamente proporcional entre a entidade parente e a entidade de fontes de dados de arquivos resultante, é mais simples ligar a entidade parente a uma entidade de arquivos resultante, com a CID IPFS como o assunto de busca. Se tiver dificuldades em modelar suas novas entidades baseadas em arquivos, pergunte no Discord!

> Podes usar [filtros aninhados](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) para filtrar entidades parentes na base destas entidades aninhadas.

#### Adicionar uma nova fonte de dado modelada com `kind: file/ipfs`

Esta é a fonte de dados que será gerada quando um arquivo de interesse for identificado.

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> Atualmente é obrigatório usar `abis`, mas não é possível chamar contratos de dentro de fontes de dados de arquivos

A fonte de dados de arquivos deve mencionar especificamente todos os tipos de entidades com os quais ela interagirá sob `entities`. Veja [as limitações](#Limitations) para mais detalhes.

#### Criar um novo handler para processar arquivos

Este handler deve aceitar um parâmetro `Bytes`, que consistirá dos conteúdos do arquivo; quando encontrado, este pode então ser acessado. Isto costuma ser um arquivo JSON, que pode ser processado com helpers `graph-ts` ([documentação](https://thegraph.com/docs/en/developing/assemblyscript-api/#json-api)).

A CID do arquivo como um string legível pode ser acessada através do `dataSource` a seguir:

```typescript
const cid = dataSource.stringParam()
```

Exemplo de handler:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### Gerar fontes de dados de arquivos quando for obrigatório

Agora pode criar fontes de dados de arquivos durante a execução de handlers baseados em chain:

- Importe o modelo do `templates` autogerado
- chame o `TemplateName.create(cid: string)` de dentro de um mapeamento, onde o cid é um identificador de conteúdo IPFS válido

> Atualmente, o Graph Node apoia [identificadores de conteúdo v0 e v1](https://docs.ipfs.tech/concepts/content-addressing/) e identificadores de conteúdo com diretórios (por ex. `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`)

Exemplo:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//Este exemplo de código é para um subgraph do Crypto Coven. O hash ipfs acima é um diretório com metadados de tokens para todos os NFTs do Crypto Coven.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //Isto cria um caminho aos metadados para um único NFT do Crypto Coven. Ele concatena o diretório com "/" + nome do arquivo + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

Isto criará uma fonte de dados de arquivos, que avaliará o ponto final IPFS configurado do Graph Node e tentará novamente caso não achá-lo. Quando o arquivo for localizado, o handler da fonte de dados de arquivos será executado.

Este exemplo usa a CID como a consulta entre a entidade parente `Token` e a entidade `TokenMetadata` resultante.

> Anteriormente, este era o ponto em que qual um programador de subgraph teria chamado o `ipfs.cat(CID)` para resgatar o arquivo

Parabéns, você está a usar fontes de dados de arquivos!

#### Como lançar os seus Subgraphs

Agora, pode construir (`build`) e lançar (`deploy`) seu subgraph a qualquer Graph Node >=v0.30.0-rc.0.

#### Limitações

Handlers e entidades de fontes de dados de arquivos são isolados de outras entidades de subgraph, o que garante que sejam determinísticos quando executados e que não haja contaminação de fontes de dados baseadas em chain. Especificamente:

- Entidades criadas por Fontes de Dados de Arquivos são imutáveis, e não podem ser atualizadas
- Handlers de Fontes de Dados de Arquivos não podem acessar entidades de outras fontes de dados de arquivos
- Entidades associadas com Fontes de Dados de Arquivos não podem ser acessadas por handlers baseados em chain

> Enquanto esta limitação pode não ser problemática para a maioria dos casos de uso, ela pode deixar alguns mais complexos. Se houver qualquer problema neste processo, por favor dê um alô via Discord!

Além disto, não é possível criar fontes de dados de uma fonte de dado de arquivos, seja uma on-chain ou outra fonte de dados de arquivos. Esta restrição poderá ser retirada no futuro.

#### Boas práticas

Caso ligue metadados de NFTs a tokens correspondentes, use o hash IPFS destes para referenciar uma entidade de Metadados da entidade do Token. Salve a entidade de Metadados a usar o hash IPFS como ID.

Pode usar o [contexto DataSource](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) ao criar Fontes de Dados de Arquivos para passar informações extras, que estarão disponíveis ao handler de Fontes de Dados de Arquivos.

Caso tenha entidades a ser atualizadas várias vezes, crie entidades únicas baseadas em arquivos utilizando o hash IPFS & o ID da entidade, e as referencie com um campo derivado na entidade baseada na chain.

> Estamos a melhorar a recomendação acima, para que os queries retornem apenas a versão "mais recente"

#### Problemas conhecidos

Atualmente, fontes de dados de arquivos requerem ABIs, apesar destas não serem usadas ([problema no GitHub](https://github.com/graphprotocol/graph-cli/issues/961)). A solução é adicionar qualquer ABI.

Handlers para Fontes de Dados de Arquvios não podem estar em arquivos que importam ligações de contrato `eth_call`, o que causa falhas com "unknown import: `ethereum::ethereum.call` has not been defined" ([problema no GitHub](https://github.com/graphprotocol/graph-cli/issues/4309)). A solução é criar handlers de fontes de dados de arquivos em um arquivo dedicado.

#### Exemplos

[Migração de subgraph do Crypto Coven](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### Referências

[Fontes de Dados de Arquivos GIP](https://forum.thegraph.com/t/gip-file-data-sources/2721)
