---
title: Como Substituir um Contrato e Manter a sua História com Enxertos
---

Neste guia, aprenda como construir e lançar novos subgraphs com o enxerto de subgraphs existentes.

## O que é Enxerto?

O processo de enxerto reutiliza os dados de um subgraph existente e o indexa em um bloco seguinte. Isto é útil durante o desenvolvimento para rapidamente superar erros simples nos mapeamentos, ou fazer um subgraph existente funcionar temporariamente após ele ter falhado. Ele também pode ser usado ao adicionar uma característica a um subgraph que demora para ser indexado do zero.

O subgraph enxertado pode usar um schema GraphQL que não é idêntico ao schema do subgraph base, mas é apenas compatível com ele. Ele deve ser um schema válido no seu próprio mérito, mas pode desviar do schema do subgraph base nas seguintes maneiras:

- Ele adiciona ou remove tipos de entidade
- Ele retira atributos de tipos de entidade
- Ele adiciona atributos anuláveis a tipos de entidade
- Ele transforma atributos não anuláveis em atributos anuláveis
- Ele adiciona valores a enums
- Ele adiciona ou remove interfaces
- Ele muda os tipos de entidades para qual implementar uma interface

Para mais informações, confira:

- [Enxertos](/developing/creating-a-subgraph#grafting-onto-existing-subgraphs)

Neste tutorial, cobriremos um caso de uso básico. Substituiremos um contrato existente com um contrato idêntico (com um novo endereço, mas o mesmo código). Depois, enxertaremos o subgraph existente ao subgraph "base" que rastreará o novo contrato.

## Notas Importantes sobre Enxertos ao Migrar Para a Graph Network

> **Caution**: It is recommended to not use grafting for subgraphs published to The Graph Network

### Qual a Importância Disto?

O enxerto é uma ferramenta poderosa que lhe permite "enxertar" um subgraph em outro — a fim de, efetivamente, transferir dados históricos do subgraph existente a uma nova versão. Enquanto isto é uma forma eficaz de preservar dados e poupar tempo de indexação, enxertos podem causar complexidades e possíveis problemas ao migrar de um ambiente hospedado até a rede descentralizada. Não é possível enxertar um subgraph da Graph Network de volta ao serviço hospedado ou ao Subgraph Studio.

### Boas práticas

**Migração Inicial**: na primeira publicação do seu subgraph à rede descentralizada, faça-o sem enxertos. Garanta que o subgraph está estável e que ele funciona como esperado.

**Atualizações Subsequentes**: quando o seu subgraph estiver ao vivo e estável na rede descentralizada, use o enxerto em versões futuras para suavizar a transição e preservar dados históricos.

Ao aderir a estas diretrizes, dá para minimizar riscos e garantir um processo de migração mais suave.

## Como Construir um Subgraph Existente

Building subgraphs is an essential part of The Graph, described more in depth [here](/quick-start/). To be able to build and deploy the existing subgraph used in this tutorial, the following repo is provided:

- [Exemplo de repo de subgraph](https://github.com/t-proctor/grafting-tutorial)

> Nota: O contrato usado no subgraph foi retirado do seguinte [Kit de Iniciante de Hackathon](https://github.com/schmidsi/hackathon-starterkit).

## Definição de Manifest de Subgraph

O manifest de subgraph `subgraph.yaml` identifica as fontes de dados para o subgraph, os gatilhos de interesse, e as funções que devem ser executadas em resposta a tais gatilhos. Veja abaixo um exemplo de um manifest de subgraph para uso prático:

```yaml
specVersion: 0.0.4
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: Lock
    network: goerli
    source:
      address: '0x4Ed995e775D3629b0566D2279f058729Ae6EA493'
      abi: Lock
      startBlock: 7674603
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Withdrawal
      abis:
        - name: Lock
          file: ./abis/Lock.json
      eventHandlers:
        - event: Withdrawal(uint256,uint256)
          handler: handleWithdrawal
      file: ./src/lock.ts
```

- A fonte de dados `Lock` é o abi e o endereço do contrato que receberemos ao compilar e lançar o contrato
- A rede deve corresponder a uma rede indexada a ser consultada. Como executamos na testnet Goerli, a rede é `goerli`
- A seção `mapping` define os gatilhos de interesse e as funções que devem ser executadas em resposta àqueles gatilhos. Neste caso, esperamos o evento `Withdrawal` e chamaremos a função `handleWithdrawal` quando o evento for emitido.

## Definição de Manifest de Enxertos

Enxertos exigem a adição de dois novos itens ao manifest do subgraph original:

```yaml
---
features:
  - grafting # feature name
graft:
  base: Qm... # subgraph ID of base subgraph
  block: 1502122 # block number
```

- `features:` is a list of all used [feature names](/developing/creating-a-subgraph/#experimental-features).
- `graft:` um mapa do subgraph `base` e o bloco que o enxertará. O `block` é o número do bloco de onde a indexação começará. O Graph então copiará os dados do subgraph base, até e incluindo o bloco dado, e então continuará a indexar o novo subgraph a partir daquele bloco.

Os valores `base` e `block` podem ser encontrados ao lançar dois subgraphs: um para a indexação base e um com o enxerto

## Como Lançar o Subgraph Base

1. Go to [Subgraph Studio](https://thegraph.com/studio/) and create a subgraph on Goerli testnet called `graft-example`
2. Siga as direções na seção `AUTH & DEPLOY` na página do seu subgraph, na pasta `graft-example` do repo
3. Ao terminar, verifique que o subgraph está a indexar corretamente. Se executar o seguinte comando no The Graph Playground

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Ele deve retornar algo assim:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      }
    ]
  }
}
```

Após verificar que o subgraph está a indexar corretamente, será possível atualizar rapidamente o subgraph com o enxerto.

## Como Lançar o Subgraph de Enxerto

O subgraph.yaml do substituto terá um novo endereço de contrato. Isto pode acontecer quando atualizar o seu dapp, relançar um contrato, etc.

1. Go to [Subgraph Studio](https://thegraph.com/studio/) and create a subgraph on Goerli testnet called `graft-replacement`
2. Create a new manifest. The `subgraph.yaml` for `graph-replacement` contains a different contract address and new information about how it should graft. These are the `block` of the [last event emitted](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) you care about by the old contract and the `base` of the old subgraph. The `base` subgraph ID is the `Deployment ID` of your original `graph-example` subgraph. You can find this in Subgraph Studio.
3. Siga as direções na seção `AUTH & DEPLOY` na página do seu subgraph, na pasta `graft-replacement` do repo
4. Ao terminar, verifique que o subgraph está a indexar corretamente. Se executar o seguinte comando no The Graph Playground

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Ele deve retornar algo como:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      },
      {
        "id": "0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3-22",
        "amount": "0",
        "when": "1664371512"
      }
    ]
  }
}
```

Pode-se ver que o subgraph `graft-replacement` indexa de dados mais antigos do `graph-example` e dados mais recentes do endereço do novo contrato. O contrato original emitiu dois eventos `Withdrawal`, [Event 1](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) e [Event 2](https://goerli.etherscan.io/address/0x4ed995e775d3629b0566d2279f058729ae6ea493). O novo contrato, em seguida, emitiu um código `Withdrawal`, [Event 3](https://goerli.etherscan.io/tx/0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3). As duas transações indexadas anteriormente, (Event 1 e 2) e a nova transação (Event 3) foram combinadas no subgraph `graft-replacement`.

Congrats! You have successfully grafted a subgraph onto another subgraph.

## Outros Recursos

Caso queira mais experiência com enxertos, veja alguns exemplos de contratos populares:

- [Curve](https://github.com/messari/subgraphs/blob/master/subgraphs/curve-finance/protocols/curve-finance/config/templates/curve.template.yaml)
- [ERC-721](https://github.com/messari/subgraphs/blob/master/subgraphs/erc721-metadata/subgraph.yaml)
- [Uniswap](https://github.com/messari/subgraphs/blob/master/subgraphs/uniswap-v3-forks/protocols/uniswap-v3/config/templates/uniswapV3Template.yaml),

To become even more of a Graph expert, consider learning about other ways to handle changes in underlying datasources. Alternatives like [Data Source Templates](/developing/creating-a-subgraph/#data-source-templates) can achieve similar results

> Nota: Grande parte do material deste artigo foi tirado do [artigo sobre o Arweave](/cookbook/arweave/)
