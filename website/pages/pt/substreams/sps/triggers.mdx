---
title: Gatilhos do Substreams
---

Com gatilhos personalizados, é possível enviar dados diretamente ao seu arquivo de mapeamentos e entidades do subgraph (assim como tabelas e campos), assim permitindo uso completo da camada do GraphQL. Para receber e processar esses dados no handler do seu subgraph, importe as definições do Protobuf emitidas pelo seu módulo do Substreams; isto garante uma gerência de dados eficiente e simplificada dentro da estrutura do subgraph.

> Nota: se já não tiver feito isso, visite um dos guias aqui para armar o seu primeiro projeto no Recipiente de Programação.

O código a seguir demonstra como definir uma função `handleTransactions` num handler de subgraph. Esta função recebe bytes brutos do Substreams como um parâmetro e os decodifica num objeto `Transactions`. Uma nova entidade de subgraph é criada para cada transação.

```tsx
export function handleTransactions(bytes: Uint8Array): void {
  let transactions = assembly.eth.transaction.v1.Transactions.decode(bytes.buffer).transactions // 1.
  if (transactions.length == 0) {
    log.info('No transactions found', [])
    return
  }

  for (let i = 0; i < transactions.length; i++) {
    // 2.
    let transaction = transactions[i]

    let entity = new Transaction(transaction.hash) // 3.
    entity.from = transaction.from
    entity.to = transaction.to
    entity.save()
  }
}
```

Você verá isto no arquivo `mappings.ts`:

1. Os bytes contendo dados do Substreams são descodificados no objeto `Transactions` gerado; este é usado como qualquer outro objeto AssemblyScript
2. Um loop sobre as transações
3. Uma nova entidade de subgraph é criada para cada transação

Para ver um exemplo detalhado de um subgraph baseado em gatilhos, [clique aqui](/substreams/sps/tutorial/).
