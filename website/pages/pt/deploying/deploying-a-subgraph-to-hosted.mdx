---
title: Como Lançar um Subgraph no Serviço Hospedado
---

> Hosted service endpoints will no longer be available after June 12th 2024. [Learn more](/sunrise).

This page explains how to deploy a subgraph to the hosted service. To deploy a subgraph you need to first install the [Graph CLI](https://github.com/graphprotocol/graph-tooling/tree/main/packages/cli). If you have not created a subgraph already, see [creating a subgraph](/developing/creating-a-subgraph).

## Create a hosted service account

Before using the hosted service, create an account in our hosted service. You will need a [Github](https://github.com/) account for that; if you don't have one, you need to create that first. Then, navigate to the [hosted service](https://thegraph.com/hosted-service/), click on the _'Sign up with Github'_ button, and complete Github's authorization flow.

## Como Armazenar o Token de Acesso

Após criar uma conta, navegue até o seu [painel de controle](https://thegraph.com/hosted-service/dashboard). Copie o token de acesso (access token) exibido no painel e execute `graph auth --product hosted-service <ACCESS_TOKEN>` para armazenar o token de acesso no seu computador. Isto só precisa ser feito uma vez, a não ser que tenha que gerar o token de acesso novamente.

## Create a Subgraph on the hosted service

Before deploying the subgraph, you need to create it in Graph Explorer. Go to the [dashboard](https://thegraph.com/hosted-service/dashboard) and click on the _Add Subgraph_ button and fill in the information below as appropriate:

**Image** (Imagem) — Selecione uma imagem para ser usada como foto de prévia e thumbnail (miniatura) para o subgraph.

**Subgraph Name** (Nome do Subgraph) — Defina o nome em `account-name/subgraph-name` a ser usado para lançamentos e pontos finais do GraphQL, além de nomear a conta sob a qual será criada o subgraph. _Este campo não pode ser alterado depois de pronto._

**Account** (Conta) — A conta sob a qual foi criado o subgraph. Pode ser uma conta de indivíduo ou organização. _Depois disto, não é possível movimentar subgraphs entre contas._

**Subtitle** (Subtítulo) — Texto que aparecerá em cards de subgraphs.

**Description** (Descrição) — Descrição do subgraph, visível na página de detalhes do mesmo.

**GitHub URL** — Atalho ao repositório do subgraph no GitHub.

**Hide** - Switching this on hides the subgraph in Graph Explorer.

After saving the new subgraph, you are shown a screen with help on how to install the Graph CLI, how to generate the scaffolding for a new subgraph, and how to deploy your subgraph. The first two steps were covered in the [Creating a Subgraph section](/developing/creating-a-subgraph/).

## Deploy a Subgraph on the hosted service

Deploying your subgraph will upload the subgraph files that you've built with `yarn build` to IPFS and tell Graph Explorer to start indexing your subgraph using these files.

Lance o subgraph com o comando `yarn deploy`

After deploying the subgraph, Graph Explorer will switch to showing the synchronization status of your subgraph. Depending on the amount of data and the number of events that need to be extracted from historical blocks, starting with the genesis block, syncing can take from a few minutes to several hours.

O estado do subgraph é mostrado como `Synced` (sincronizado) quando o Graph Node extrai todos os dados de blocos históricos. O Graph Node continuará a inspecionar blocos para o seu subgraph enquanto estes blocos são minerados.

## Como Relançar um Subgraph

Ao fazer mudanças à definição do seu subgraph — por exemplo, para resolver um problema nos mapeamentos de entidade — execute o comando `yarn deploy` novamente para lançar a versão atualizada do seu subgraph. Para atualizar um subgraph, o Graph Node sempre deve reindexá-lo por inteiro, novamente começando pelo bloco-gênese.

Se seu subgraph já lançado ainda estiver no estado `Syncing` (Sincronizando), ele será imediatamente substituído com a versão recém-lançada. Se o mesmo subgraph já estiver totalmente sincronizado, o Graph Node marcará a versão recém-lançada como a `Pending Version` (Versão Pendente), sincronizá-la no fundo, e substituir a versão atual com a nova apenas quando terminar a sincronização da versão nova. Isto garante que você tenha um subgraph para trabalhos enquanto a nova versão sincroniza.

## Como lançar o subgraph a várias redes

Em alguns casos, irá querer lançar o mesmo subgraph a várias redes sem duplicar o seu código completo. O grande desafio nisto é que os endereços de contrato nestas redes são diferentes.

### Como usar o graph-cli

Tanto o `graph build` (desde a `v0.29.0`) quanto o `graph deploy` (desde a `v0.32.0`) aceitam duas novas opções:

```sh
Options:

      ...
      --network <name>          Configuração de rede para usar no arquivo de config de redes
      --network-file <path>     Local do arquivo de config de redes (padrão: "./networks.json")
```

A opção `--network` serve para especificar uma configuração de rede a partir de um arquivo `json` (o comum é `networks.json`), para facilmente atualizar o seu subgraph durante a programação.

**Nota:** O comando `init` agora irá gerar um `networks.json` automaticamente, com base na informação fornecida. Daí, será possível atualizar redes existentes ou adicionar redes novas.

Caso não tenha um arquivo `networks.json`, precisará criar o mesmo manualmente, com a seguinte estrutura:

```json
{
    "network1": { // nome da rede
        "dataSource1": { // nome do dataSource
            "address": "0xabc...", // endereço do contrato (opcional)
            "startBlock": 123456 // bloco inicial (opcional)
        },
        "dataSource2": {
            "address": "0x123...",
            "startBlock": 123444
        }
    },
    "network2": {
        "dataSource1": {
            "address": "0x987...",
            "startBlock": 123
        },
        "dataSource2": {
            "address": "0xxyz..",
            "startBlock": 456
        }
    },
    ...
}
```

**Nota:** Não precisa especificar quaisquer dos `templates` (se tiver) no arquivo de configuração, apenas as `dataSources`. Se houver alguns `templates` declarados no arquivo `subgraph.yaml`, sua rede será automaticamente atualizada à especificada na opção `--network`.

Agora, vamos supor que quer lançar o seu subgraph às redes `mainnet` e `goerli`, e este é o seu `subgraph.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x123...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

O seu arquivo de config de redes deve ficar assim:

```json
{
  "mainnet": {
    "Gravity": {
      "address": "0x123..."
    }
  },
  "goerli": {
    "Gravity": {
      "address": "0xabc..."
    }
  }
}
```

Agora podemos executar um dos seguintes comandos:

```sh
# Usar o arquivo networks.json padrão
yarn build --network goerli

# Usar arquivo com nome personalizado
yarn build --network goerli --network-file local/do/config
```

O comando `build` atualizará o seu `subgraph.yaml` com a configuração `goerli` e depois recompilará o subgraph. O seu arquivo `subgraph.yaml` agora deve parecer com isto:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: goerli
    source:
      address: '0xabc...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

Agora está tudo pronto para executar o `yarn deploy`.

**Nota:** Como já levantado, desde o `graph-cli 0.32.0`, dá para executar diretamente o `yarn deploy` com a opção `--network`:

```sh
# Usar o arquivo networks.json padrão
yarn deploy --network goerli

# Usar um arquivo de nome personalizado
yarn deploy --network goerli --network-file local/do/config
```

### Como usar o template subgraph.yaml

Uma solução para versões mais antigas do graph-cli, que permite a parametrização de aspetos como endereços de contratos, é gerar partes dele com um sistema de templating como o [Mustache](https://mustache.github.io/) ou o [Handlebars](https://handlebarsjs.com/).

Para ilustrar este método, vamos supor que um subgraph deve ser lançado à mainnet e à Goerli, com uso de diferentes endereços de contratos. Então, daria para definir dois arquivos de config ao fornecer os endereços para cada rede:

```json
{
  "network": "mainnet",
  "address": "0x123..."
}
```

e

```json
{
  "network": "goerli",
  "address": "0xabc..."
}
```

Além disso, substituiria o nome da rede e os endereços no manifest com variáveis temporários `{{network}}` and `{{address}}` e renomearia o manifest a, por exemplo, `subgraph.template.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

Para poder gerar um manifest para uma rede, pode adicionar mais dois comandos ao `package.json` com uma dependência no `mustache`:

```json
{
  ...
  "scripts": {
    ...
    "prepare:mainnet": "mustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
    "prepare:goerli": "mustache config/goerli.json subgraph.template.yaml > subgraph.yaml"
  },
  "devDependencies": {
    ...
    "mustache": "^3.1.0"
  }
}
```

Para lançar este subgraph à mainnet ou à Goerli, só precisaria executar um dos seguintes comandos:

```sh
# Mainnet:
yarn prepare:mainnet && yarn deploy

# Goerli:
yarn prepare:goerli && yarn deploy
```

Veja um exemplo funcional disto [aqui](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759).

**Nota:** Este método também pode ser aplicado a situações mais complexas, onde é necessário substituir mais que endereços de contratos e nomes de redes, ou gerar mapeamentos e ABIs de templates também.

## Como conferir a saúde do subgraph

Se um subgraph for sincronizado com sucesso, isto indica que ele continuará a rodar bem para sempre. Porém, novos gatilhos na rede podem revelar uma condição de erro não testada, ou ele pode começar a se atrasar por problemas de desempenho ou com os operadores de nodes.

Graph Node exposes a graphql endpoint which you can query to check the status of your subgraph. On the hosted service, it is available at `https://api.thegraph.com/index-node/graphql`. On a local node, it is available on port `8030/graphql` by default. The full schema for this endpoint can be found [here](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql). Here is an example query that checks the status of the current version of a subgraph:

```graphql
{
  indexingStatusForCurrentVersion(subgraphName: "org/subgraph") {
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      chainHeadBlock {
        number
      }
      latestBlock {
        number
      }
    }
  }
}
```

Isto rendará o `chainHeadBlock`, que pode ser comparado com o `latestBlock` no seu subgraph para conferir se está atrasado. `synced` informa se o subgraph conseguiu alcançar a chain. `health` pode atualmente resgatar os valores de `healthy`, se não houver erros; ou `failed`, se algum erro tiver impedido o progresso do subgraph. Neste caso, verifique o campo `fatalError` para mais detalhes.

## Política de arquivamento de subgraphs no serviço hospedado

The hosted service is a free Graph Node Indexer. Developers can deploy subgraphs indexing a range of networks, which will be indexed, and made available to query via graphQL.

To improve the performance of the service for active subgraphs, the hosted service will archive subgraphs that are inactive.

**A subgraph is defined as "inactive" if it was deployed to the hosted service more than 45 days ago, and if it has received 0 queries in the last 45 days.**

Developers will be notified by email if one of their subgraphs has been marked as inactive 7 days before it is removed. If they wish to "activate" their subgraph, they can do so by making a query in their subgraph's hosted service graphQL playground. Developers can always redeploy an archived subgraph if it is required again.

## Política de arqivamento do Subgraph Studio

Quando é lançada uma nova versão de um subgraph, a anterior é arquivada (deletada do banco de dados do graph-node). Isto só acontece se a versão anterior não for editada na rede descentralizada do The Graph.

Quando uma versão de subgraph não é consultada por mais de 45 dias, esta é arquivada.

Todos os subgraphs afetados por esta política têm a opção de trazer de volta a versão em questão.
