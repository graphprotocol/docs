---
title: GraphQL API
---

Graph Protocol で使用される GraphQL Query API について説明します。

## クエリ

サブグラフのスキーマには、`Entities`と呼ばれるタイプが定義されています。各`Entity`タイプには、トップレベルの`Query`タイプに`entity`と`entities`フィールドが生成されます。なお、The Graph を使用する際には、`graphql`の`query` の先頭にクエリを含める必要はありません。

#### 例

スキーマで定義された 1 つの`Token`エンティティに対するクエリ。

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

**注:** 単一のエンティティをクエリする場合、`id`フィールドは必須で、文字列でなければなりません。

すべての`Token`エンティティをクエリする:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### ソート

コレクションをクエリする際、`orderBy`パラメータを使用して特定の属性でソートすることができます。また、`orderDirection`でソートの方向を指定することができ、`asc`は昇順、`desc`は降順となります。

#### 例

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

### ページネーション

コレクションを照会する際、`最初`のパラメータを使用して、コレクションの先頭からページングすることができます。なお、デフォルトのソート順は、作成時刻順ではなく、ID による英数字の昇順となっていることに注意してください。

例えば、`first:100`では最初の 100 個のエンティティを表示し、`first:100, skip:100`では次の 100 個のエンティティを表示することができます。

クエリは、非常に大きな`skip`値を使用すると、一般的にパフォーマンスが低下するため、避けるべきです。多数のアイテムを検索する場合は、最後の例で示すように、属性に基づいてエンティティをページングする方がはるかに良いでしょう。

#### 例

最初の 10 個のトークンを検索します:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

コレクションの途中にあるエンティティのグループを検索する場合は、 `skip`パラメータを`first`パラメータと組み合わせて使用し、コレクションの先頭から指定した数のエンティティをスキップすることができます。

#### 例

コレクションの先頭から 10 個ずつオフセットした 10 個の`Token`エンティティをクエリします。

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### 例

クライアントが多数のエンティティを取得する必要がある場合、属性に基づいてクエリを行い、その属性でフィルタリングする方がはるかにパフォーマンスが高くなります。たとえば、クライアントが大量のトークンを取得するには、次のようなクエリを使用します。

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

最初のリクエストでは`lastID = ""`でクエリを送信し、それ以降のリクエストでは`lastID`を前回のリクエストの最後のエンティティの `id`属性に設定することになります。この方法は、`skip`値を増やしていく方法に比べて格段にパフォーマンスが向上します。

### フィルタリング

クエリの`where`パラメータを使用して、さまざまなプロパティに対してフィルタリングすることができます。`where`パラメータ内の複数の値でフィルタリングできます。

#### 例

`失敗`結果を持つクエリの課題:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

値の比較には、`_gt`, `_lte`などの接尾語を使用できます:

#### 例

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

パラメータのサフィックスの全リスト:

```graphql
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_not_contains
_starts_with
_ends_with
_not_starts_with
_not_ends_with
```

接尾辞の中には、特定のタイプにしか対応していないものがあることにご注意ください。例えば、`Boolean`は`_not`, `_in`, `_not_in`のみサポートしています。

### タイムトラベルクエリ

エンティティの状態を、デフォルトである最新のブロックだけでなく、任意の過去のブロックに対してもクエリすることができます。クエリを実行するブロックは、ブロック番号またはブロックハッシュで指定できます。

ただし、Ethereum チェーンの先頭に非常に近いブロックにクエリを実行した場合、そのブロックがメインチェーンにないことが判明したり、チェーンが再編成されたりすると、結果が変わってしまう可能性があります。ブロックが最終的なものとみなされると、クエリ結果は変わりません。

なお、現在の実装には、これらの保証に反する可能性のある制限があります。あるブロックハッシュがメインチェーン上に全く存在しないことや、まだ最終的とは言えないブロックに対するブロックハッシュによるクエリ結果が、クエリと同時に実行されるブロック再編成の影響を受ける可能性があることを、実装では常に見分けることはできません。これらは、ブロックが最終的にメインチェーン上にあることがわかっている場合のブロックハッシュによるクエリの結果には影響しません。ここでは、 [この課題](https://github.com/graphprotocol/graph-node/issues/1405)について詳しく説明します。

#### 例

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

このクエリは、ブロック番号 8,000,000 を処理した直後の`Challenge`エンティティと、それに関連する`Application`エンティティを返します。

#### 例

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

このクエリは、`Challenge`エンティティとそれに関連する `Application`エンティティを、指定されたハッシュを持つブロックを処理した直後に存在した状態で返します。

### フルテキスト検索クエリ

フルテキスト検索クエリフィールドは、サブグラフスキーマに追加してカスタマイズできる、表現力豊かなテキスト検索 API を提供します。サブグラフにフルテキスト検索を追加するには、「[Defining Fulltext Search Fields](/developing/creating-a-subgraph#defining-fulltext-search-fields)」を参照してください。

フルテキスト検索クエリには、検索用語を入力するための`text`という 1 つの必須フィールドがあります。この`text`検索フィールドでは、いくつかの特別なフルテキストオペレーターが使用できます。

フルテキスト検索オペレーター:

| シンボル | オペレーター | 説明 |
| --- | --- | --- |
| `&` | `And` | 複数の検索語を組み合わせて、指定したすべての検索語を含むエンティティをフィルタリングします。 |
| &#x7c; | `Or` | 複数の検索語をオペレーターで区切って検索すると、指定した語のいずれかにマッチするすべてのエンティティが返されます。 |
| `<->` | `Follow by` | 2 つの単語の間の距離を指定します。 |
| `:*` | `Prefix` | プレフィックス検索語を使って、プレフィックスが一致する単語を検索します（2 文字必要） |

#### 例

`or` operator を使ったこのクエリは、フルテキスト・フィールドに "anarchism "または "crumpet "のバリエーションを持つブログ・エンティティにフィルタリングします。

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

`follow by` operator は、フルテキスト文書の中で特定の距離にある単語を指定します。次のクエリは、"decentralize "の後に "philosophy "が続くバリエーションを持つすべてのブログを返します。

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

fulltext operators を組み合わせて、より複雑なフィルタを作ることができます。pretext search operator と follow by を組み合わせると、この例のクエリは、「lou」で始まり「music」が続く単語を持つすべてのブログエンティティにマッチします。

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### エンティティ

データソースのスキーマ（クエリで利用可能なエンティティタイプ、値、リレーションシップ）は、 [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System)で定義されます。

## スキーマ

GraphQL スキーマは一般に、`クエリ`、`サブスクリプション`、`ミューテーション`のルートタイプを定義します。Graph は`クエリ`のみをサポートします。サブグラフのルートの`クエリ`タイプは、サブグラフのマニフェストに含まれる GraphQL スキーマから自動生成されます。

スキーマに`@entity`ディレクティブが含まれるすべての GraphQL タイプはエンティティとして扱われ、`ID`フィールドが必要です。

> **注:**開発者は自分のアプリケーションから基礎となるブロックチェーンに対して直接トランザクションを発行することが期待されているため、私たちの API はミューテーションを公開していません。

### エンティティ

スキーマに`@entity`ディレクティブが含まれるすべての GraphQL タイプはエンティティとして扱われ、`ID`フィールドが必要です。

> **注:**現在、スキーマ内のすべてのタイプに`@entity` ディレクティブが必要です。将来的には、`@entity` ディレクティブを持たないタイプをバリューオブジェクトとして扱う予定ですが、これはまだサポートされていません。
