---
title: Subgraph Best Practice 2 - Improve Indexing and Query Responsiveness By Using @derivedFrom
---

## TLDR

Les tableaux dans votre schéma peuvent vraiment ralentir les performances d'un subgraph lorsqu'ils dépassent des milliers d'entrées. Si possible, la directive `@derivedFrom` devrait être utilisée lors de l'utilisation des tableaux car elle empêche la formation de grands tableaux, simplifie les gestionnaires et réduit la taille des entités individuelles, améliorant considérablement la vitesse d'indexation et la performance des requêtes.

## Comment Utiliser la Directive `@derivedFrom`

Il vous suffit d'ajouter une directive `@derivedFrom` après votre tableau dans votre schéma. Comme ceci :

```graphql
comments: [Comment!]! @derivedFrom(field: "post")
```

`@derivedFrom` crée des relations efficaces de un à plusieurs, permettant à une entité de s'associer dynamiquement à plusieurs entités liées en fonction d'un champ dans l'entité liée. Cette approche élimine la nécessité pour les deux côtés de la relation de stocker des données dupliquées, rendant le subgraph plus efficace.

### Exemple de cas d'utilisation de `@derivedFrom`

Un exemple de tableau à croissance dynamique est une plateforme de blogs où un "Post" peut avoir de nombreux "Commentaires".

Let’s start with our two entities, `Post` and `Comment`

Without optimization, you could implement it like this with an array:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]!
}

type Comment @entity {
  id: Bytes!
  content: String!
}
```

Arrays like these will effectively store extra Comments data on the Post side of the relationship.

Here’s what an optimized version looks like using `@derivedFrom`:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]! @derivedFrom(field: "post")
}

type Comment @entity {
  id: Bytes!
  content: String!
  post: Post!
}
```

Just by adding the `@derivedFrom` directive, this schema will only store the “Comments” on the “Comments” side of the relationship and not on the “Post” side of the relationship. Arrays are stored across individual rows, which allows them to expand significantly. This can lead to particularly large sizes if their growth is unbounded.

This will not only make our subgraph more efficient, but it will also unlock three features:

1. We can query the `Post` and see all of its comments.

2. We can do a reverse lookup and query any `Comment` and see which post it comes from.

3. We can use [Derived Field Loaders](/subgraphs/developing/creating/graph-ts/api/#looking-up-derived-entities) to unlock the ability to directly access and manipulate data from virtual relationships in our subgraph mappings.

## Conclusion

Use the `@derivedFrom` directive in subgraphs to effectively manage dynamically growing arrays, enhancing indexing efficiency and data retrieval.

For a more detailed explanation of strategies to avoid large arrays, check out Kevin Jones' blog: [Best Practices in Subgraph Development: Avoiding Large Arrays](https://thegraph.com/blog/improve-subgraph-performance-avoiding-large-arrays/).

## Subgraph Best Practices 1-6

1. [Improve Query Speed with Subgraph Pruning](/subgraphs/cookbook/pruning/)

2. [Improve Indexing and Query Responsiveness by Using @derivedFrom](/subgraphs/cookbook/derivedfrom/)

3. [Improve Indexing and Query Performance by Using Immutable Entities and Bytes as IDs](/subgraphs/cookbook/immutable-entities-bytes-as-ids/)

4. [Improve Indexing Speed by Avoiding `eth_calls`](/subgraphs/cookbook/avoid-eth-calls/)

5. [Simplify and Optimize with Timeseries and Aggregations](/subgraphs/cookbook/timeseries/)

6. [Use Grafting for Quick Hotfix Deployment](/subgraphs/cookbook/grafting-hotfix/)
