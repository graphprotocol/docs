---
title: AssemblyScript Migration Guide
---

Jusqu'√† pr√©sent, les subgraphs utilisaient l'une des [premi√®res versions d'AssemblyScript](https://github.com/AssemblyScript/assemblyscript/tree/v0.6) (v0.6). Enfin, nous avons ajout√© la prise en charge du [le plus r√©cent disponible](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10)¬†! üéâ

Cela permettra aux d√©veloppeurs de subgraph d'utiliser les nouvelles fonctionnalit√©s du langage AS et de la biblioth√®que standard.

Ce guide s'applique √† toute personne utilisant `graph-cli`/`graph-ts` sous la version `0.22.0`. Si vous utilisez d√©j√† une version sup√©rieure (ou √©gale), vous utilisez d√©j√† la version `0.19.10` d'AssemblyScript üôÇ

> Remarque¬†: Depuis `0.24.0`, `graph-node` peut prendre en charge les deux versions, en fonction de la `apiVersion` sp√©cifi√©e dans le manifeste du subgraph.

## Fonctionnalit√©s

### Nouvelle fonctionnalit√©

- Les `TypedArray` peuvent d√©sormais √™tre construits √† partir de `ArrayBuffer` en utilisant les [nouvelle m√©thode statique `wrap`](https://www.assemblyscript.org/stdlib/typedarray.html#static-members) ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1))
- Nouvelles fonctions de biblioth√®que standard: `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare`and `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Ajout de la prise en charge de x instanceof GenericClass ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Ajout de `StaticArray<T>`, une variante de tableau plus efficace ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- Ajout de `Array<T>#flat` ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Impl√©mentation de `radix` argument on `Number#toString` ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- Ajout de la prise en charge des s√©parateurs dans les litt√©raux √† virgule flottante ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7))
- Ajout du support pour les fonctions de premi√®re classe ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0))
- Ajout des fonctions int√©gr√©es : `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- Implementation de `Array/TypedArray/String#at` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- Ajout de la prise en charge des cha√Ænes litt√©rales de mod√®le ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- Ajout de `encodeURI(Component)` et `decodeURI(Component)` ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- Ajout de `toString`, `toDateString` et `toTimeString` √† `Date` ([v0.18.29](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- Ajout de `toUTCString` pour `Date` ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- Ajout du type int√©gr√© `nonnull/NonNullable` ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### Optimizations

- Les fonctions `Math` telles que `exp`, `exp2`, `log`, `log2` et `pow` ont √©t√© remplac√©es par des variantes plus rapides ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- L√©g√®re optimisation de `Math.mod` ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- Mise en cache de plus d'acc√®s aux champs dans std Map et Set ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
- Optimiser pour des puissances de deux `ipow32/64` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### Autre

- Le type d'un litt√©ral de tableau peut d√©sormais √™tre d√©duit de son contenu ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Stdlib mis √† jour vers Unicode 13.0.0 ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))

## Comment mettre √† niveau ?

1. Modifiez vos mappages `apiVersion` dans `subgraph.yaml` en `0.0.6`¬†:

```yaml
...
dataSources:
  ...
    mapping:
      ...
      apiVersion: 0.0.6
      ...
```

2. Mettez √† jour le `graph-cli` que vous utilisez vers la version `derni√®re` en ex√©cutant¬†:

```bash
# si vous l'avez install√© globalement
npm install --global @graphprotocol/graph-cli@latest

# ou dans votre subgraph si vous l'avez comme d√©pendance de d√©veloppement
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. Faites de m√™me pour `graph-ts`, mais au lieu de l'installer globalement, enregistrez-le dans vos d√©pendances principales¬†:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. Suivez le reste du guide pour corriger les changements de langue.
5. Ex√©cutez `codegen` et `deploy` √† nouveau.

## Modifications radicales

### Nullability

Sur l'ancienne version d'AssemblyScript, vous pouviez cr√©er du code comme celui-ci¬†:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

Cependant, sur la version la plus r√©cente, comme la valeur est nullable, vous devez v√©rifier, comme ceci¬†:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` n'est plus nul
}
```

Ou forcez-le comme ceci¬†:

```typescript
let maybeValue = load()! // breaks in runtime if value is null

maybeValue.aMethod()
```

Si vous ne savez pas lequel choisir, nous vous recommandons de toujours utiliser la version s√©curis√©e. Si la valeur n'existe pas, vous souhaiterez peut-√™tre simplement effectuer une instruction if pr√©coce avec un retour dans votre gestionnaire de subgraph.

### Ombrage variable

Avant de pouvoir faire de l'[observation de variables](https://en.wikipedia.org/wiki/Variable_shadowing) et un code comme celui-ci fonctionnerait¬†:

```typescript
let a = 10
let b = 20
let a = a + b
```

Cependant, cela n'est plus possible et le compilateur renvoie cette erreur¬†:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

Vous devrez renommer vos variables en double si vous conservez une observation de variables.

### Comparaisons nulles

En effectuant la mise √† niveau sur votre subgraph, vous pouvez parfois obtenir des erreurs comme celles-ci¬†:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

Pour r√©soudre, vous pouvez simplement remplacer l'instruction `if` par quelque chose comme ceci¬†:

```typescript
  if (!decimals) {

  // ou bien

  if (decimals === null) {
```

La m√™me chose s'applique si vous faites != au lieu de ==.

### Casting

Auparavant, la mani√®re courante de faire du casting consistait simplement √† utiliser le mot-cl√© `as`, comme ceci¬†:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // equivalent to: <Uint8Array>byteArray
```

Cependant, cela ne fonctionne que dans deux sc√©narios¬†:

- Casting primitif (entre des types tels que `u8`, `i32`, `bool`¬†; par exemple¬†: `let b¬†: isize = 10¬†; b as usize`);
- Upcasting sur l'h√©ritage de classe (sous-classe ‚Üí superclasse)

Les Exemples:

```typescript
// primitive casting
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
//upcasting lors de l'h√©ritage de classe
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // √©quivalent √† : bytes as Uint8Array
```

Il existe deux sc√©narios dans lesquels vous souhaiterez peut-√™tre diffuser du contenu, mais l'utilisation de `as`/`<T>var` **n'est pas s√ªre**¬†:

- Downcasting sur l'h√©ritage de classe (superclasse ‚Üí sous-classe)
- Entre deux types qui partagent une superclasse

```typescript
//downcasting lors de l'h√©ritage de classe
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // plante √† l'ex√©cution :(
```

```typescript
// entre deux types qui partagent une superclasse
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // plante √† l'ex√©cution :(
```

Dans ces cas-l√†, vous pouvez utiliser la fonction `changetype<T>`¬†:

```typescript
//downcasting lors de l'h√©ritage de classe
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // fonctionne :)
```

```typescript
// entre deux types qui partagent une superclasse
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // fonctionne :)
```

Si vous souhaitez simplement supprimer la nullit√©, vous pouvez continuer √† utiliser l'op√©rateur `as` (ou `<T>variable`), mais assurez-vous de savoir que la valeur ne peut pas √™tre nulle. sinon √ßa va casser.

```typescript
// supprimer la possibilit√© de valeur nulle (nullability)
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // suppression s√ªre de null
}

let newBalance = new AccountBalance(balanceId)
```

Pour le cas de nullit√©, nous vous recommandons de jeter un ≈ìil √† la [fonctionnalit√© de v√©rification de la nullit√©](https://www.assemblyscript.org/basics.html#nullability-checks), cela rendra votre code plus propre üôÇ

Nous avons √©galement ajout√© quelques m√©thodes statiques suppl√©mentaires dans certains types pour faciliter la diffusion, √† savoir¬†:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### V√©rification de nullit√© avec acc√®s √† la propri√©t√©

Pour utiliser la [fonctionnalit√© de v√©rification de nullit√©](https://www.assemblyscript.org/basics.html#nullability-checks), vous pouvez utiliser soit les instructions `if`, soit l'op√©rateur ternaire (`?` et `:`) comme ce:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// ou

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

Cependant, cela ne fonctionne que lorsque vous effectuez le `if` / ternaire sur une variable, pas sur un acc√®s √† une propri√©t√©, comme ceci¬†:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // ne compile pas
```

Ce qui g√©n√®re cette erreur¬†:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Pour r√©soudre ce probl√®me, vous pouvez cr√©er une variable pour l'acc√®s √† cette propri√©t√© afin que le compilateur puisse effectuer la v√©rification magique de la nullit√©¬†:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // compile sans probl√®me :)
```

### Surcharge de l'op√©rateur avec acc√®s √† la propri√©t√©

Si vous essayez de additionner (par exemple) un type nullable (√† partir d'un acc√®s √† une propri√©t√©) avec un type non nullable, le compilateur AssemblyScript au lieu de donner une erreur de compilation avertissant que l'une des valeurs est nullable, il compile simplement silencieusement, donnant une chance pour que le code soit interrompu au moment de l'ex√©cution.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // donne une erreur de compilation concernant la nullit√©
let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // ne donne pas d'erreurs de compilation comme il se doit
```

Nous avons ouvert un probl√®me sur le compilateur AssemblyScript pour cela, mais pour l'instant, si vous effectuez ce type d'op√©rations dans vos mappages de subgraph, vous devez les modifier pour effectuer une v√©rification nulle avant.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // maintenant `n` est garanti comme √©tant un BigInt
```

### Value initialization

Si vous avez un code comme celui-ci¬†:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

Il sera compil√© mais s'arr√™tera au moment de l'ex√©cution, cela se produit parce que la valeur n'a pas √©t√© initialis√©e, alors assurez-vous que votre subgraph a initialis√© ses valeurs, comme ceci¬†:

```typescript
var value = new Type() // initialized
value.x = 10
value.y = 'content'
```

De plus, si vous avez des propri√©t√©s nullables dans une entit√© GraphQL, comme ceci¬†:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

Et vous avez un code similaire √† celui-ci¬†:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

Vous devrez vous assurer d'initialiser la valeur `total.amount`, car si vous essayez d'acc√©der √† la derni√®re ligne pour la somme, elle plantera. Donc soit vous l'initialisez d'abord¬†:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

Ou vous pouvez simplement modifier votre sch√©ma GraphQL pour ne pas utiliser de type nullable pour cette propri√©t√©, puis nous l'initialiserons √† z√©ro √† l'√©tape `codegen` üòâ

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest') // initialise d√©j√† les propri√©t√©s non-nullables
}

total.amount = total.amount + BigInt.fromI32(1)
```

### Initialisation de la propri√©t√© de classe

Si vous exportez des classes avec des propri√©t√©s qui sont d'autres classes (d√©clar√©es par vous ou par la biblioth√®que standard), comme ceci¬†:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

Le compilateur g√©n√©rera une erreur car vous devez soit ajouter un initialiseur pour les propri√©t√©s qui sont des classes, soit ajouter l'op√©rateur `!`¬†:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// ou

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// ou

export class Something {
  value!: Thing
}
```

### Initialisation du tableau

La classe `Array` accepte toujours un nombre pour initialiser la longueur de la liste, mais vous devez faire attention car des op√©rations comme `.push` augmenteront en fait la taille au lieu de l'ajouter au d√©but. , Par exemple:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // taille 6 :(
```

En fonction des types que vous utilisez, par exemple les types nullables, et de la mani√®re dont vous y acc√©dez, vous pourriez rencontrer une erreur d'ex√©cution comme celle-ci¬†:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

Pour r√©ellement pousser au d√©but, vous devez soit initialiser le `Array` avec une taille z√©ro, comme ceci¬†:

```typescript
let arr = new Array<string>(0) // []

arr.push('quelque chose') // ["quelque chose"]
```

Ou vous devriez le muter via index¬†:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'quelque chose' // ["quelque chose", "", "", "", ""]
```

### Sch√©ma GraphQL

Il ne s'agit pas d'une modification directe d'AssemblyScript, mais vous devrez peut-√™tre mettre √† jour votre fichier `schema.graphql`.

Vous ne pouvez d√©sormais plus d√©finir de champs dans vos types qui sont des listes non nullables. Si vous avez un sch√©ma comme celui-ci :

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something]! # n'est plus valide
}
```

Vous devrez ajouter un `!` au membre de type List, comme ceci¬†:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # valide
}
```

Cela a chang√© en raison des diff√©rences de nullit√© entre les versions d'AssemblyScript et est li√© au fichier `src/generated/schema.ts` (chemin par d√©faut, vous avez peut-√™tre modifi√© cela).

### Autre

- Alignement de `Map#set` et `Set#add` avec la sp√©cification, en retournant `this` ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Les tableaux n'h√©ritent plus d'ArrayBufferView, mais sont d√©sormais distincts ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Les classes initialis√©es √† partir de litt√©raux d'objet ne peuvent plus d√©finir de constructeur ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Le r√©sultat d'une op√©ration binaire `**` est d√©sormais le d√©nominateur commun entier si les deux op√©randes sont des entiers. Auparavant, le r√©sultat √©tait un float comme si vous appeliez `Math/f.pow` ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- Convertir `NaN` en `false` lors de la conversion en `bool` ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9))
- Lors du d√©calage d'une petite valeur enti√®re de type `i8`/`u8` ou `i16`/`u16`, seuls les 3 respectivement 4 les plus petits les bits significatifs de la valeur RHS affectent le r√©sultat, de la m√™me mani√®re que le r√©sultat d'un `i32.shl` n'est affect√© que par les 5 bits les moins significatifs de la valeur RHS. Exemple¬†: `someI8 << 8` produisait auparavant la valeur `0`, mais produit d√©sormais `someI8` en raison du masquage du RHS comme `8 & 7 = 0` (3 bits) ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0))
- Correction d'un bug des comparaisons de cha√Ænes relationnelles lorsque les tailles diff√®rent ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
