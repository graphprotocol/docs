---
title: Construction de subgraphs pour Arweave
---

> La prise en charge d'Arweave dans Graph Node et sur le service hébergé est en version bêta : veuillez nous contacter sur [Discord](https://discord.gg/graphprotocol) pour toute question sur la création de subgraphs Arweave !

Dans ce guide, vous apprendrez comment créer et déployer des subgraphs pour indexer la blockchain Arweave.

## Qu’est-ce qu’Arweave ?

Arweave est un protocole qui permet aux développeurs de stocker des données de façon permanente. C'est cette caractéristique qui constitue la principale différence entre Arweave et IPFS. En effet, IPFS n'a pas la caractéristique de permanence, et les fichiers stockés sur Arweave ne peuvent pas être modifiés ou supprimés.

Arweave a déjà construit de nombreuses bibliothèques pour intégrer le protocole dans plusieurs langages de programmation différents. Pour plus d'informations, vous pouvez consulter :

- [Arwiki](https://arwiki.wiki/#/en/main)
- [Ressources d'Arweave](https://www.arweave.org/build)

## À quoi servent les subgraphes d'Arweave ?

The Graph vous permet de créer des API ouvertes personnalisées appelées « subgraphes ». Les subgraphes sont utilisés pour indiquer aux indexeurs (gestionnaires de serveur) les données à indexer sur une blockchain et à enregistrer sur leurs serveurs afin que vous puissiez les interroger à tout moment à l'aide de [GraphQL](https://graphql.org/).

[Graph Node](https://github.com/graphprotocol/graph-node) est désormais capable d'indexer les données sur le protocole Arweave. L'intégration actuelle indexe uniquement Arweave en tant que blockchain (blocs et transactions), elle n'indexe pas encore les fichiers stockés.

## Construire un subgraph Arweave

Pour pouvoir créer et déployer des Arweave Subgraphs, vous avez besoin de deux packages :

1. Les versions supérieures à 0.30.2 du `@graphprotocol/graph-cli` - Il s'agit d'un outil caractérisé par l'utilisation de lignes de commandes pour construire et déployer des subgraphes. Cliquez [ici](https://www.npmjs.com/package/@graphprotocol/graph-cli) pour le télécharger en utilisant `npm`.
2. `@graphprotocol/graph-ts` version supérieure à 0.27.0 - Il s'agit d'une bibliothèque de types spécifiques aux subgraphs. [Cliquez ici](https://www.npmjs.com/package/@graphprotocol/graph-ts) pour télécharger en utilisant `npm`.

## Caractéristique des subgraphs

Il y a trois composants d'un subgraph :

### 1. Manifeste - `subgraph.yaml`

Définit les sources de données intéressantes et la manière dont elles doivent être traitées. Arweave est un nouveau type de source de données.

### 2. Schéma - `schema.graphql`

Vous définissez ici les données que vous souhaitez pouvoir interroger après avoir indexé votre subgraph à l'aide de GraphQL. Ceci est en fait similaire à un modèle pour une API, où le modèle définit la structure d'un corps de requête.

Les exigences relatives aux subgraphs Arweave sont couvertes par la [documentation existante](/developing/creating-a-subgraph/#the-graphql-schema).

### 3. Mappages AssemblyScript - `mapping.ts`

Il s'agit de la logique qui détermine comment les données doivent être récupérées et stockées lorsqu'une personne interagit avec les sources de données que vous interrogez. Les données sont traduites et stockées sur la base du schema que vous avez répertorié.

Lors du développement du subgraph, il y a deux commandes clés :

```
$ graph codegen # génère des types à partir du fichier de schéma identifié dans le manifeste
$ graph build # génère le Web Assembly à partir des fichiers AssemblyScript, et prépare tous les fichiers de subgraphes dans un dossier /build
```

## Définition du manifeste du subgraph

Le manifeste du subgraph `subgraph.yaml` identifie les sources de données pour le subgraph, les déclencheurs d'intérêt, et les fonctions qui doivent être exécutées en réponse à ces déclencheurs. Ci-dessous un exemple de manifeste pour un subgraph visant Arweave :

```yaml
version spec : 0.0.5
description : Indexation des blocs Arweave
schéma:
   fichier : ./schema.graphql # lien vers le fichier de schéma
les sources de données:
   - genre : arweave
     nom : arweave-blocks
     réseau : arweave-mainnet # Le Graph prend uniquement en charge Arweave Mainnet
     source:
       Owner: 'ID-OF-AN-OWNER' # La clé publique d'un portefeuille Arweave
       startBlock : 0 # réglez-le sur 0 pour démarrer l'indexation à partir de la genèse de la chaîne
     cartographie :
       Version API : 0.0.5
       langage : wasm/assemblyscript
       fichier : ./src/blocks.ts # lien vers le fichier avec les mappages Assemblyscript
       entités :
         - Bloc
         - Transaction
       gestionnaires de blocs :
         - handler: handleBlock # le nom de la fonction dans le fichier de mappage
       Gestionnaires de transactions :
         - handler: handleTx # le nom de la fonction dans le fichier de mappage
```

- Les subgraphs Arweave introduisent un nouveau type de source de données (`arweave`)
- Le réseau doit correspondre à un réseau sur le nœud d'hébergement The Graph. Pour le Service Hébergé, le mainnet d'Arweave est `arweave-mainnet`
- Les sources de données Arweave introduisent un champ source.owner facultatif, qui est la clé publique d'un portefeuille Arweave

Les sources de données Arweave prennent en charge deux types de gestionnaires :

- `blockHandlers` - Exécuté sur chaque nouveau bloc Arweave. Aucun source.owner n'est requis.
- `transactionHandlers` : exécuté sur chaque transaction dont le `source.owner` de la source de données est le propriétaire. Actuellement, un propriétaire est requis pour les `transactionHandlers`. Si les utilisateurs souhaitent traiter toutes les transactions, ils doivent fournir "" comme `source.owner`

> Source.owner peut être l’adresse du propriétaire ou sa clé publique.

> Les transactions sont les éléments constitutifs du permaweb Arweave et ce sont des objets créés par les utilisateurs finaux.

> Notez : les transactions [Bundlr](https://bundlr.network/) ne sont pas encore prises en charge.

## Définition d'un schéma

La définition du schéma décrit la structure de la base de données de subgraphs résultante et les relations entre les entités. Ceci est indépendant de la source de données d’origine. Vous trouverez plus de détails sur la définition du schéma de subgraph [ici](/developing/creating-a-subgraph/#the-graphql-schema).

## Cartographies AssemblyScript

Les gestionnaires pour le traitement des événements sont écrits en [AssemblyScript](https://www.assemblyscript.org/).

L'indexation Arweave introduit des types de données spécifiques à Arweave dans l'[API AssemblyScript](/developing/assemblyscript-api/).

```tsx
bloc de classe {
   horodatage : u64
   dernière cible : u64
   taille : u64
   indepHash : octets
   occasionnel : octets
   bloc précédent : octets
   diff : octets
   hachage : octets
   txRoot : octets
   txs : octets[]
   liste de portefeuilles : octets
   récompenseAddr : octets
   balises : Balise[]
   pool de récompenses : octets
   weaveSize : octets
   taille du bloc : octets
   cumulativeDiff : octets
   hashListMerkle : octets
   poa : Preuve d'accès
}

classe Transaction {
   format : u32
   identifiant : octets
   lastTx : octets
   propriétaire : octets
   balises : Balise[]
   cible : octets
   quantité : octets
   données : octets
   taille des données : octets
   dataRoot : octets
   signature : octets
   récompense : octets
}
```

Les gestionnaires de blocs reçoivent un `Block`, tandis que les transactions reçoivent un `Transaction`.

L'écriture des mappages d'un subgraph Arweave est très similaire à l'écriture des mappages d'un subgraph Ethereum. Pour plus d'informations, cliquez [ici](/developing/creating-a-subgraph/#writing-mappings).

## Déploiement d'un subgraph Arweave sur le service hébergé

Une fois votre subgraph créé sur le tableau de bord du service hébergé, vous pouvez le déployer à l'aide de la commande CLI `graph deploy`.

```bash
graph deploy --node https://api.thegraph.com/deploy/ --ipfs https://api.thegraph.com/ipfs/ --access-token <your-access-token>
```

## Interroger un subgraph d'Arweave

Le endpoint GraphQL pour les subgraphs d'Arweave est déterminé par la définition du schema, avec l'interface API existante. Veuillez consulter la [documentation de l'API GraphQL](/querying/graphql-api/) pour plus d'informations.

## Exemples de subgraphs

Voici un exemple de modèle subgraph :

- [Exemple de subgraph pour Arweave](https://github.com/graphprotocol/graph-tooling/tree/main/examples/arweave-blocks-transactions)

## Questions fréquemment posées

### Un subgraph peut-il indexer Arweave et d'autres chaînes ?

Non, un subgraph ne peut supporter que les sources de données d'une seule chaîne/réseau.

### Puis-je indexer les fichiers enregistrés sur Arweave ?

Actuellement, The Graph n'indexe Arweave qu'en tant que blockchain (ses blocs et ses transactions).

### Puis-je identifier les bundles de Bundlr dans mon subgraph ?

Cette fonction n'est pas prise en charge actuellement.

### Comment puis-je filtrer les transactions sur un compte spécifique ?

La source.owner peut être la clé publique de l'utilisateur ou l'adresse de son compte.

### Quel est le format de chiffrement actuel ?

Les données sont généralement transmises dans les mappages sous forme d'octets, qui, s'ils sont stockés directement, sont renvoyés dans le subgraph au format `hex` (ex. hachages de bloc et de transaction). Vous souhaiterez peut-être convertir vos mappages en un format `base64` ou `base64 URL` sécurisé, afin de correspondre à ce qui est affiché dans les explorateurs de blocs comme [Explorateur Arweave](https : //viewblock.io/arweave/).

La fonction d'assistance `bytesToBase64(bytes: Uint8Array, urlSafe: boolean): string` suivante peut être utilisée et sera ajoutée à `graph-ts` :

```
const base64Alphabet = [
     "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M ",
     "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z". ",
     "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m ",
     "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z ",
     "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64UrlAlphabet = [
     "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M ",
     "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z". ",
     "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m ",
     "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z ",
     "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
];

function bytesToBase64 (octets : Uint8Array, urlSafe : booléen) : chaîne {
     laisser alphabet = urlSafe ? base64UrlAlphabet : base64Alphabet;

     soit result = '', i: i32, l = bytes.length;
     pour (je = 2 ; je < l ; je += 3) {
         résultat += alphabet[octets[i - 2] >> 2];
         résultat += alphabet[((octets[i - 2] & 0x03) << 4) | (octets[i - 1] >> 4)] ;
         résultat += alphabet[((octets[i - 1] & 0x0F) << 2) | (octets[i] >> 6)] ;
         résultat += alphabet[octets[i] & 0x3F] ;
     }
     if (i === l + 1) { // 1 octet restant à écrire
         résultat += alphabet[octets[i - 2] >> 2];
         résultat += alphabet[(octets[i - 2] & 0x03) << 4];
         si (!urlSafe) {
             résultat += "==";
         }
     }
     if (!urlSafe && i === l) { // Il reste encore 2 octets à écrire
         résultat += alphabet[octets[i - 2] >> 2];
         résultat += alphabet[((octets[i - 2] & 0x03) << 4) | (octets[i - 1] >> 4)] ;
         résultat += alphabet[(octets[i - 1] & 0x0F) << 2];
         si (!urlSafe) {
             résultat += "=";
         }
     }
     renvoyer le résultat ;
}
```
