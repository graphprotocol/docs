---
title: API AssemblyScript
---

> Note: If you created a subgraph prior to `graph-cli`/`graph-ts` version `0.22.0`, then you're using an older version of AssemblyScript. It is recommended to review the [`Migration Guide`](/release-notes/assemblyscript-migration-guide).

Learn what built-in APIs can be used when writing subgraph mappings. There are two kinds of APIs available out of the box:

- The [Graph TypeScript library](https://github.com/graphprotocol/graph-tooling/tree/main/packages/ts) (`graph-ts`)
- Code generated from subgraph files by `graph codegen`

You can also add other libraries as dependencies, as long as they are compatible with [AssemblyScript](https://github.com/AssemblyScript/assemblyscript).

Since language mappings are written in AssemblyScript, it is useful to review the language and standard library features from the [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki).

## Référence API

The `@graphprotocol/graph-ts` library provides the following APIs:

- An `ethereum` API for working with Ethereum smart contracts, events, blocks, transactions, and Ethereum values.
- A `store` API to load and save entities from and to the Graph Node store.
- A `log` API to log messages to the Graph Node output and Graph Explorer.
- An `ipfs` API to load files from IPFS.
- A `json` API to parse JSON data.
- A `crypto` API to use cryptographic functions.
- Primitives de bas niveau pour traduire entre différents systèmes de types tels que Ethereum, JSON, GraphQL et AssemblyScript.

### Versions

The `apiVersion` in the subgraph manifest specifies the mapping API version which is run by Graph Node for a given subgraph.

| Version | Notes de version                                                                                                                                                                                                                              |
| :-----: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0.0.9  | Adds new host functions [`eth_get_balance`](#balance-of-an-address) & [`hasCode`](#check-if-an-address-is-a-contract-or-eoa)                                                                                                                  |
|  0.0.8  | Adds validation for existence of fields in the schema when saving an entity.                                                                                                                                                                  |
|  0.0.7  | Added `TransactionReceipt` and `Log` classes to the Ethereum types<br />Added `receipt` field to the Ethereum Event object                                                                                                                    |
|  0.0.6  | Added `nonce` field to the Ethereum Transaction object<br />Added `baseFeePerGas` to the Ethereum Block object                                                                                                                                |
|  0.0.5  | AssemblyScript upgraded to version 0.19.10 (this includes breaking changes, please see the [`Migration Guide`](/release-notes/assemblyscript-migration-guide))<br />`ethereum.transaction.gasUsed` renamed to `ethereum.transaction.gasLimit` |
|  0.0.4  | Added `functionSignature` field to the Ethereum SmartContractCall object                                                                                                                                                                      |
|  0.0.3  | Added `from` field to the Ethereum Call object<br />`etherem.call.address` renamed to `ethereum.call.to`                                                                                                                                      |
|  0.0.2  | Added `input` field to the Ethereum Transaction object                                                                                                                                                                                        |

### Types intégrés

Documentation on the base types built into AssemblyScript can be found in the [AssemblyScript wiki](https://www.assemblyscript.org/types.html).

The following additional types are provided by `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` represents an array of `u8`.

_Construction_

- `fromI32(x: i32): ByteArray` - Decomposes `x` into bytes.
- `fromHexString(hex: string): ByteArray` - Input length must be even. Prefixing with `0x` is optional.

_Conversions de type_

- `toHexString(): string` - Convertit en une chaîne de caractères hexadécimale ayant comme préfixe `0x`.
- `toString(): string` - Interprète les octets comme une chaîne UTF-8.
- toBase58(): string\` - Encode les octets en une chaîne de caractères de type base58.
- `toU32(): u32` - Interprète les octets comme un `u32` en little-endian. Envoie une exception en cas de dépassement.
- `toI32(): i32` - Interprète le tableau d'octets comme un `i32` en little-endian. Envoie une exception en cas de dépassement.

_Operateurs_

- `equals(y: ByteArray): bool` – peut être écrit comme `x == y`.
- `concat(other: ByteArray) : ByteArray` - renvoie un nouveau `ByteArray` constitué de `this` directement suivi par `other`
- `concatI32(other: i32) : ByteArray` - retourne un nouveau `ByteArray` constitué de `this` directement suivi par la représentation en octets de `other`

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal` est utilisé pour représenter des décimales à précision arbitraire.

> Remarque: [En interne](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar/bigdecimal.rs) `BigDecimal` est stocké au format [IEEE-754 décimal128 à virgule flottante](https://en.wikipedia.org/wiki/Decimal128_floating-point_format), qui supporte 34 chiffres significatifs. Cela rend `BigDecimal` inapproprié pour représenter des types à virgule fixe pouvant dépasser 34 chiffres, comme un Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) ou équivalent.

_Construction_

- `constructor(bigInt: BigInt)` – crée un `BigDecimal` à partir d'un `BigInt`.
- `static fromString(s: string): BigDecimal` – analyse à partir d'une chaîne de caractères décimaux.

_Conversions de type_

- `toString(): string` – affiche en une chaîne de caractères décimaux.

_Math_

- `plus(y: BigDecimal): BigDecimal` – peut être écrit comme `x + y`.
- `minus(y: BigDecimal): BigDecimal` – peut être écrit comme `x - y`.
- `times(y: BigDecimal): BigDecimal` – peut être écrit comme `x * y`.
- `div(y: BigDecimal): BigDecimal` – peut être écrit comme `x / y`.
- `equals(y: BigDecimal): bool` – peut être écrit comme `x == y`.
- `notEqual(y: BigDecimal): bool` – peut être écrit comme `x != y`.
- `lt(y: BigDecimal): bool` – peut être écrit comme `x < y`.
- `le(y: BigDecimal): bool` – peut être écrit comme `x <= y`.
- `gt(y: BigDecimal): bool` – peut être écrit comme `x > y`.
- `ge(y: BigDecimal): bool` – peut être écrit comme `x >= y`.
- `neg(): BigDecimal` - peut être écrit comme `-x`.

#### BigInt

```typescript
importer { BigInt } depuis '@graphprotocol/graph-ts'
```

`BigInt` est utilisé pour représenter de grands entiers. Cela inclut les valeurs Ethereum de type `uint32` à `uint256` et `int64` à`int256`. Tout ce qui est en dessous de `uint32`, tel que `int32`, `uint24` ou `int8` est représenté sous forme de `i32`.

La classe `BigInt` possède l'API suivante :

_Construction_

- `BigInt.fromI32(x: i32): BigInt` – crée un `BigInt` à partir d'un `i32`.

- `BigInt.fromString(s: string): BigInt`– Analyse un `BigInt` à partir d'une chaîne de caractères.

- `BigInt.fromUnsignedBytes(x: Bytes): BigInt` – Interprète `bytes` comme un entier non signé en little-endian. Si votre saisie est en big-endian, appelez d'abord `.reverse()`.

- `BigInt.fromSignedBytes(x: Bytes): BigInt` – Interprète `bytes` comme un entier signé en little-endian. Si votre saisie est en big-endian, appelez d'abord `.reverse()`.

  _Conversions de type_

- `x.toHex(): string` – transforme `BigInt` en une chaîne de caractères hexadécimaux.

- `x.toString(): string` – transforme`BigInt` en une chaîne de caractères de nombres décimaux.

- `x.toI32(): i32` – renvoie le `BigInt` comme un `i32`; échoue si la valeur ne rentre pas dans un `i32`. Il est conseillé de vérifier d'abord `x.isI32()`.

- `x.toBigDecimal(): BigDecimal` - convertit en un nombre décimal sans virgule.

_Math_

- `x.plus(y: BigInt): BigInt` – peut être écrit comme `x + y`.
- `x.minus(y: BigInt): BigInt` – peut être écrit comme `x - y`.
- `x.times(y: BigInt): BigInt` – peut être écrit comme `x * y`.
- `x.div(y: BigInt): BigInt` – peut être écrit comme `x / y`.
- `x.mod(y: BigInt): BigInt` – peut être écrit comme `x % y`.
- `x.equals(y: BigInt): bool` – peut être écrit comme `x == y`.
- `x.notEqual(y: BigInt): bool` – peut être écrit comme `x != y`.
- `x.lt(y: BigInt): bool` – peut être écrit comme `x < y`.
- `x.le(y: BigInt): bool` – can be written as `x <= y`.
- `x.gt(y: BigInt): bool` – can be written as `x > y`.
- `x.ge(y: BigInt): bool` – can be written as `x >= y`.
- `x.neg(): BigInt` – can be written as `-x`.
- `x.divDecimal(y: BigDecimal): BigDecimal` – divides by a decimal, giving a decimal result.
- `x.isZero(): bool` – Convenience for checking if the number is zero.
- `x.isI32(): bool` – Check if the number fits in an `i32`.
- `x.abs(): BigInt` – Absolute value.
- `x.pow(exp: u8): BigInt` – Exponentiation.
- `bitOr(x: BigInt, y: BigInt): BigInt` – can be written as `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – can be written as `x & y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – can be written as `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – can be written as `x >> y`.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap` can be used to store key-value pairs. See [this example](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

The `TypedMap` class has the following API:

- `new TypedMap<K, V>()` – creates an empty map with keys of type `K` and values of type `V`
- `map.set(key: K, value: V): void` – sets the value of `key` to `value`
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – returns the key-value pair for a `key` or `null` if the `key` does not exist in the map
- `map.get(key: K): V | null` – returns the value for a `key` or `null` if the `key` does not exist in the map
- `map.isSet(key: K): bool` – returns `true` if the `key` exists in the map and `false` if it does not

#### Octets

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`Bytes` is used to represent arbitrary-length arrays of bytes. This includes Ethereum values of type `bytes`, `bytes32`, etc.

The `Bytes` class extends AssemblyScript's [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) and this supports all the `Uint8Array` functionality, plus the following new methods:

_Construction_

- `fromHexString(hex: string) : Bytes` - Convert the string `hex` which must consist of an even number of hexadecimal digits to a `ByteArray`. The string `hex` can optionally start with `0x`
- `fromI32(i: i32) : Bytes` - Convert `i` to an array of bytes

_Conversions de type_

- `b.toHex()` – returns a hexadecimal string representing the bytes in the array
- `b.toString()` – converts the bytes in the array to a string of unicode characters
- `b.toBase58()` – turns an Ethereum Bytes value to base58 encoding (used for IPFS hashes)

_Operateurs_

- `b.concat(other: Bytes) : Bytes` - - return new `Bytes` consisting of `this` directly followed by `other`
- `b.concatI32(other: i32) : ByteArray` - return new `Bytes` consisting of `this` directly follow by the byte representation of `other`

#### Addresse

```typescript
import { Address } du '@graphprotocol/graph-ts'
```

`Address` extends `Bytes` to represent Ethereum `address` values.

It adds the following method on top of the `Bytes` API:

- `Address.fromString(s: string): Address` – creates an `Address` from a hexadecimal string
- `Address.fromBytes(b: Bytes): Address` – create an `Address` from `b` which must be exactly 20 bytes long. Passing in a value with fewer or more bytes will result in an error

### Store API

```typescript
import { store } from '@graphprotocol/graph-ts'
```

The `store` API allows to load, save and remove entities from and to the Graph Node store.

Entities written to the store map one-to-one to the `@entity` types defined in the subgraph's GraphQL schema. To make working with these entities convenient, the `graph codegen` command provided by the [Graph CLI](https://github.com/graphprotocol/graph-tooling/tree/main/packages/cli) generates entity classes, which are subclasses of the built-in `Entity` type, with property getters and setters for the fields in the schema as well as methods to load and save these entities.

#### Création d'entités

Ce qui suit est un modèle courant pour créer des entités à partir d’événements Ethereum.

```typescript
// Importer la classe Transfer générée à partir de l'ABI ERC20
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// Importer le type d'entité Transfer généré à partir du schéma GraphQL
import { Transfer } from '../generated/schema'

// Gestionnaire d'événement Transfer
export function handleTransfer(event: TransferEvent): void {
  // Créer une entité Transfer, en utilisant le hash de la transaction comme ID de l'entité
  let id = event.transaction.hash
  let transfer = new Transfer(id)

  // Définir les propriétés sur l'entité, en utilisant les paramètres de l'événement
  transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Sauvegarder l'entité dans le stockage
  transfer.save()
}
```

When a `Transfer` event is encountered while processing the chain, it is passed to the `handleTransfer` event handler using the generated `Transfer` type (aliased to `TransferEvent` here to avoid a naming conflict with the entity type). This type allows accessing data such as the event's parent transaction and its parameters.

Each entity must have a unique ID to avoid collisions with other entities. It is fairly common for event parameters to include a unique identifier that can be used.

> Note: Using the transaction hash as the ID assumes that no other events in the same transaction create entities with this hash as the ID.

#### Chargement d'entités depuis le magasin

Si une entité existe déjà, elle peut être chargée depuis le magasin avec les éléments suivants :

```typescript
let id = event.transaction.hash // ou selon la manière dont l'ID est construit
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Utiliser l'entité Transfer comme précédemment
```

As the entity may not exist in the store yet, the `load` method returns a value of type `Transfer | null`. It may be necessary to check for the `null` case before using the value.

> Note: Loading entities is only necessary if the changes made in the mapping depend on the previous data of an entity. See the next section for the two ways of updating existing entities.

#### Recherche d'entités créées dans un bloc

As of `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 and `@graphprotocol/graph-cli` v0.49.0 the `loadInBlock` method is available on all entity types.

The store API facilitates the retrieval of entities that were created or updated in the current block. A typical situation for this is that one handler creates a transaction from some on-chain event, and a later handler wants to access this transaction if it exists.

- In the case where the transaction does not exist, the subgraph will have to go to the database simply to find out that the entity does not exist. If the subgraph author already knows that the entity must have been created in the same block, using `loadInBlock` avoids this database roundtrip.
- For some subgraphs, these missed lookups can contribute significantly to the indexing time.

```typescript
let id = event.transaction.hash // ou de toute autre manière dont l'ID est construit
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Utiliser l'entité Transfer comme auparavant
```

> Note: If there is no entity created in the given block, `loadInBlock` will return `null` even if there is an entity with the given ID in the store.

#### Recherche d'entités dérivées

As of `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 and `@graphprotocol/graph-cli` v0.51.0 the `loadRelated` method is available.

Cela permet de charger des champs d'entités dérivés à partir d'un gestionnaire d'événements. Par exemple, étant donné le schéma suivant :

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

The following code will load the `Token` entity that the `Holder` entity was derived from:

```typescript
let holder = Holder.load('test-id')
// Charger les entités Token associées à un détenteur donné
let tokens = holder.tokens.load()
```

#### Mise à jour des entités existantes

Il existe deux manières de mettre à jour une entité existante :

1. Load the entity with e.g. `Transfer.load(id)`, set properties on the entity, then `.save()` it back to the store.
2. Simply create the entity with e.g. `new Transfer(id)`, set properties on the entity, then `.save()` it to the store. If the entity already exists, the changes are merged into it.

La modification des propriétés est simple dans la plupart des cas, grâce aux paramètres de propriétés générés :

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Il est également possible de supprimer des propriétés avec l'une des deux instructions suivantes :

```typescript
transfer.from.unset()
transfer.from = null
```

This only works with optional properties, i.e. properties that are declared without a `!` in GraphQL. Two examples would be `owner: Bytes` or `amount: BigInt`.

Updating array properties is a little more involved, as the getting an array from an entity creates a copy of that array. This means array properties have to be set again explicitly after changing the array. The following assumes `entity` has a `numbers: [BigInt!]!` field.

```typescript
// Cela ne fonctionnera pas
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// Cela fonctionnera
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Supprimer des entités du magasin

Il n'y a actuellement aucun moyen de supprimer une entité via les types générés. Au lieu de cela, la suppression d'une entité nécessite de passer le nom du type d'entité et l'ID de l'entité à `store.remove`:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

L'API Ethereum donne accès aux contrats intelligents, aux variables d'état public, aux fonctions de contrat, aux événements, aux transactions, aux blocs et aux données d'encodage/décodage Ethereum.

#### Prise en charge des types Ethereum

Comme pour les entités, `graph codegen` génère des classes pour tous les contrats intelligents et événements utilisés dans un subgraph. Pour cela, les ABIs des contrats doivent faire partie de la source de données dans le manifeste du subgraph. En général, les fichiers ABI sont stockés dans un dossier `abis/` .

Avec les classes générées, les conversions entre les types Ethereum et [les types intégrés](#built-in-types) se font en arrière-plan afin que les auteurs de subgraph n'aient pas à s'en soucier.

L’exemple suivant illustre cela. Étant donné un schéma de subgraph comme

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

et une signature d'événement `Transfer(address,address,uint256)` sur Ethereum, les valeurs `from`, `to` et`amount` de type `address`, `address` et `uint256` sont enverties en `Address` et `BigInt`, leur permettant d'être passées aux propriétés `Bytes!` et `BigInt!` de l'entité `Transfer` :

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### Événements et données de bloc/transaction

Les événements Ethereum passés aux gestionnaires d'événements, comme l'événement `Transfer` dans les exemples précédents, fournissent non seulement l'accès aux paramètres de l'événement, mais également à leur transaction parente et au bloc auquel ils appartiennent. Les données suivantes peuvent être obtenues à partir des instances d' `event` (ces classes font partie du module `ethereum` dans `graph-ts`):

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Accès à l'état du contrat intelligent

Le code généré par `graph codegen` inclut également des classes pour les contrats intelligents utilisés dans le subgraph. Celles-ci peuvent être utilisées pour accéder aux variables d'état publiques et appeler des fonctions du contrat au bloc actuel.

Un modèle courant consiste à accéder au contrat dont provient un événement. Ceci est réalisé avec le code suivant :

```typescript
// Importer la classe de contrat générée et la classe d'événement Transfer générée
import { ERC20Contract, Transfer as TransferEvent } from '../generated/ERC20Contract/ERC20Contract'
// Importer la classe d'entité générée
import { Transfer } from '../generated/schema'

export function handleTransfer(event: TransferEvent) {
  // Lier le contrat à l'adresse qui a émis l'événement
  let contract = ERC20Contract.bind(event.address)

  // Accéder aux variables d'état et aux fonctions en les appelant
  let erc20Symbol = contract.symbol()
}
```

`Transfer` est remplacé par `TransferEvent` ici pour éviter un conflit de nommage avec le type d'entité

Tant que le `ERC20Contract` sur Ethereum a une fonction publique en lecture seule appelée `symbol`, elle peut être appelée avec `.symbol()`. Pour les variables d'état publiques, une méthode du même nom est créée automatiquement.

Tout autre contrat faisant partie du subgraph peut être importé à partir du code généré et peut être lié à une adresse valide.

#### Gestion des appels retournés

Si les méthodes en lecture seule de votre contrat peuvent échouer, vous devez gérer cela en appelant la méthode de contrat générée préfixée par `try_`.

- Par exemple, le contrat Gravity expose la méthode `gravatarToOwner` . Ce code serait capable de gérer une erreur dans cette méthode :

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar a été annulé', [])
} else {
  let owner = callResult.value
}
```

> Note: A Graph node connected to a Geth or Infura client may not detect all reverts. If you rely on this, we recommend using a Graph Node connected to a Parity client.

#### Encodage/décodage ABI

Les données peuvent être encodées et décodées selon le format de codage ABI d'Ethereum en utilisant les fonctions `encode` et `decode` du module `ethereum`.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

Pour plus d'informations:

- [Spécifications ABI](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Encodage/décodage [bibliothèque Rust/CLI] (https://github.com/rust-ethereum/ethabi)
- Exemple [plus complexe](https://github.com/graphprotocol/graph-node/blob/08da7cb46ddc8c09f448c5ea4b210c9021ea05ad/tests/integration-tests/host-exports/src/mapping.ts#L86).

#### Solde d'une adresse

Le solde de jetons natifs d'une adresse peut être récupéré en utilisant le module `ethereum`. Cette fonctionnalité est disponible à partir de `apiVersion: 0.0.9` définie dans `subgraph.yaml`. La fonction `getBalance()` récupère le solde de l'adresse spécifiée à la fin du bloc où l'événement est déclenché.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

let address = Address.fromString('0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045')
let balance = ethereum.getBalance(address) // renvoie le solde en BigInt
```

#### Vérifier si une adresse est une adresse de contrat intelligent ou une adresse détenue par des personnes (EOA)

Pour vérifier si une adresse est une adresse de contrat intelligent ou une adresse détenue extérieurement (EOA), utilisez la fonction `hasCode()` du module `ethereum` qui retournera un `boolean`. Cette fonctionnalité est disponible à partir de `apiVersion: 0.0.9` qui est définie dans `subgraph.yaml`.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

let contractAddr = Address.fromString('0x2E645469f354BB4F5c8a05B3b30A929361cf77eC')
let isContract = ethereum.hasCode(contractAddr).inner // renvoie true

let eoa = Address.fromString('0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045')
let isContract = ethereum.hasCode(eoa).inner // renvoie false
```

### Logging API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

L'API `log` permet aux subgraphs d'enregistrer des informations sur la sortie standard de Graph Node ainsi que sur Graph Explorer. Les messages peuvent être enregistrés en utilisant différents niveaux de journalisation. Une syntaxe de chaîne de caractère de format de base est fournie pour composer des messages de journal à partir de l'argument.

L'API `log` inclut les fonctions suivantes :

- `log.debug(fmt: string, args: Array<string>): void` - enregistre un message de débogage.
- `log.info(fmt: string, args: Array<string>): void` - enregistre un message d'information.
- `log.warning(fmt: string, args: Array<string>): void` - enregistre un avertissement.
- `log.error(fmt: string, args: Array<string>): void` - enregistre un message d'erreur.
- `log.critical(fmt: string, args: Array<string>): void` – enregistre un message critique _et_ met fin au subgraph.

L'API `log` prend une chaîne de caractères de format et un tableau de valeurs de chaîne de caractères. Elle remplace ensuite les espaces réservés par les valeurs de chaîne de caractères du tableau. Le premier espace réservé `{}` est remplacé par la première valeur du tableau, le second `{}` est remplacé par la deuxième valeur, et ainsi de suite.

```typescript
log.info('Message à afficher : {}, {}, {}', [value.toString(), anotherValue.toString(), 'déjà une chaîne'])
```

#### Enregistrer une ou plusieurs valeurs

##### Enregistrer une seule valeur

Dans l'exemple ci-dessous, la valeur de chaîne de caractères "A" est passée dans un tableau pour devenir `['A']` avant d'être enregistrée:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Affiche : "Ma valeur est : A"
  log.info('Ma valeur est : {}', [myValue])
}
```

##### Journalisation d'une seule entrée à partir d'un tableau existant

Dans l'exemple ci-dessous, seule la première valeur du tableau d'arguments est journalisée, bien que le tableau contienne trois valeurs.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Affiche : "Ma valeur est : A"  (Même si trois valeurs sont passées à `log.info`)
  log.info('Ma valeur est : {}', myArray)
}
```

#### Journalisation de plusieurs entrées d'un tableau existant

Each entry in the arguments array requires its own placeholder `{}` in the log message string. The below example contains three placeholders `{}` in the log message. Because of this, all three values in `myArray` are logged.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Affiche : "Ma première valeur est : A, la deuxième valeur est : B, la troisième valeur est : C"
  log.info('Ma première valeur est : {}, la deuxième valeur est : {}, la troisième valeur est : {}', myArray)
}
```

##### Enregistrer une entrée spécifique à partir d'un tableau existant

Pour afficher une valeur spécifique dans le tableau, la valeur indexée doit être fournie.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Affiche : "Ma troisième valeur est C"
  log.info('Ma troisième valeur est : {}', [myArray[2]])
}
```

##### Journalisation des informations sur les événements

L'exemple ci-dessous enregistre le numéro de bloc, le hachage de bloc et le hachage de transaction d'un événement :

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Numéro de bloc : {}, hachage de bloc : {}, hachage de transaction : {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Smart contracts occasionally anchor IPFS files on chain. This allows mappings to obtain the IPFS hashes from the contract and read the corresponding files from IPFS. The file data will be returned as `Bytes`, which usually requires further processing, e.g. with the `json` API documented later on this page.

Étant donné un hachage ou un chemin IPFS, la lecture d'un fichier depuis IPFS se fait comme suit :

```typescript
// Mettez ceci à l'intérieur d'un gestionnaire d'événements dans le mapping
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Les chemins comme `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// qui incluent des fichiers dans des répertoires sont également pris en charge
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

**Note:** `ipfs.cat` is not deterministic at the moment. If the file cannot be retrieved over the IPFS network before the request times out, it will return `null`. Due to this, it's always worth checking the result for `null`.

It is also possible to process larger files in a streaming fashion with `ipfs.map`. The function expects the hash or path for an IPFS file, the name of a callback, and flags to modify its behavior:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // Voir la documentation JSONValue pour les détails sur le traitement
  // des valeurs JSON
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Les callbacks peuvent également créer des entités
  let newItem = new Item(id)
  newItem.title = title.toString()
  newItem.parent = userData.toString() // Définit le parent à "parentId"
  newItem.save()
}

// Mettez ceci à l'intérieur d'un gestionnaire d'événements dans le mapping
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Alternativement, utilisez `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

The only flag currently supported is `json`, which must be passed to `ipfs.map`. With the `json` flag, the IPFS file must consist of a series of JSON values, one value per line. The call to `ipfs.map` will read each line in the file, deserialize it into a `JSONValue` and call the callback for each of them. The callback can then use entity operations to store data from the `JSONValue`. Entity changes are stored only when the handler that called `ipfs.map` finishes successfully; in the meantime, they are kept in memory, and the size of the file that `ipfs.map` can process is therefore limited.

On success, `ipfs.map` returns `void`. If any invocation of the callback causes an error, the handler that invoked `ipfs.map` is aborted, and the subgraph is marked as failed.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

The `crypto` API makes a cryptographic functions available for use in mappings. Right now, there is only one:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON data can be parsed using the `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array interpreted as a valid UTF-8 sequence
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – safe version of `json.fromBytes`, it returns an error variant if the parsing failed
- `json.fromString(data: string): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(data: string): Result<JSONValue, boolean>` – safe version of `json.fromString`, it returns an error variant if the parsing failed

The `JSONValue` class provides a way to pull values out of an arbitrary JSON document. Since JSON values can be booleans, numbers, arrays and more, `JSONValue` comes with a `kind` property to check the type of a value:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

In addition, there is a method to check if the value is `null`:

- `value.isNull(): boolean`

When the type of a value is certain, it can be converted to a [built-in type](#built-in-types) using one of the following methods:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (and then convert `JSONValue` with one of the 5 methods above)

### Référence des conversions de types

| Source(s)            | Destination          | Conversion function          |
| -------------------- | -------------------- | ---------------------------- |
| Address              | Bytes                | none                         |
| Address              | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | none                         |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)    |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Bytes                | String (hexadecimal) | s.toHexString() or s.toHex() |
| Bytes                | String (unicode)     | s.toString()                 |
| Bytes                | String (base58)      | s.toBase58()                 |
| Bytes                | i32                  | s.toI32()                    |
| Bytes                | u32                  | s.toU32()                    |
| Bytes                | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | none                         |
| int32                | i32                  | none                         |
| int32                | BigInt               | BigInt.fromI32(s)            |
| uint24               | i32                  | none                         |
| int64 - int256       | BigInt               | none                         |
| uint32 - uint256     | BigInt               | none                         |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Address              | Address.fromString(s)        |
| Bytes                | Address              | Address.fromBytes(s)         |
| String               | BigInt               | BigInt.fromString(s)         |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Bytes                | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)        |

### Métadonnées de la source de données

You can inspect the contract address, network and context of the data source that invoked the handler through the `dataSource` namespace:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entité et DataSourceContext

The base `Entity` class and the child `DataSourceContext` class have helpers to dynamically set and get fields:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### DataSourceContext in Manifest

The `context` section within `dataSources` allows you to define key-value pairs that are accessible within your subgraph mappings. The available types are `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, and `BigInt`.

Here is a YAML example illustrating the usage of various types in the `context` section:

```yaml
dataSources:
  - kind: ethereum/contract
    name: ContractName
    network: mainnet
    context:
      bool_example:
        type: Bool
        data: true
      string_example:
        type: String
        data: 'hello'
      int_example:
        type: Int
        data: 42
      int8_example:
        type: Int8
        data: 127
      big_decimal_example:
        type: BigDecimal
        data: '10.99'
      bytes_example:
        type: Bytes
        data: '0x68656c6c6f'
      list_example:
        type: List
        data:
          - type: Int
            data: 1
          - type: Int
            data: 2
          - type: Int
            data: 3
      big_int_example:
        type: BigInt
        data: '1000000000000000000000000'
```

- `Bool`: Specifies a Boolean value (`true` or `false`).
- `String`: Specifies a String value.
- `Int`: Specifies a 32-bit integer.
- `Int8`: Specifies an 8-bit integer.
- `BigDecimal`: Specifies a decimal number. Must be quoted.
- `Bytes`: Specifies a hexadecimal string.
- `List`: Specifies a list of items. Each item needs to specify its type and data.
- `BigInt`: Specifies a large integer value. Must be quoted due to its large size.

Ce contexte est ensuite accessible dans vos fichiers de mappage de subgraphs, permettant des subgraphs plus dynamiques et configurables.
