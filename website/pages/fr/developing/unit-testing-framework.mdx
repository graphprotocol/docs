---
title: Cadre pour les tests unitaires
---

Matchstick est un cadre de test unitaire, d√©velopp√© par [LimeChain](https://limechain.tech/), qui permet aux d√©veloppeurs de subgraphs de tester leur logique de cartographie dans un environnement de type bac √† sable et de d√©ployer leurs subgraphs en toute confiance !

## D√©marrage

### Installer les d√©pendances

Pour utiliser les m√©thodes d'assistance aux tests et ex√©cuter les tests, vous devrez installer les d√©pendances suivantes¬†:

```sh
yarn add --dev matchstick-as
```

‚ùó `graph-node` d√©pend de PostgreSQL, donc si vous ne l'avez pas d√©j√†, vous devrez l'installer. Nous vous conseillons vivement d'utiliser les commandes ci-dessous, car l'ajouter d'une autre mani√®re peut provoquer des erreurs inattendues !

#### Le MacOS

Commande d'installation Postgres :

```sh
brew install postgresql
```

Cr√©ez un lien symbolique vers la derni√®re libpq.5.lib _Vous devrez peut-√™tre d'abord cr√©er ce r√©pertoire_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Commande d'installation de Postgres (d√©pend de votre distribution) :

```sh
sudo apt installer postgresql
```

### WSL (Syst√®me Windows pour Linux)

Vous pouvez utiliser Matchstick sur WSL en utilisant √† la fois l'approche Docker et l'approche binaire. Comme WSL peut √™tre un peu d√©licat, voici quelques conseils au cas o√π vous rencontreriez des probl√®mes tels que

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

ou bien

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Veuillez vous assurer que vous utilisez une version plus r√©cente de Node.js graph-cli qui ne prend plus en charge la **v10.19.0**, et qu'il s'agit toujours de la version par d√©faut pour le nouvel Ubuntu. images sur WSL. Par exemple, il est confirm√© que Matchstick fonctionne sur WSL avec **v18.1.0**, vous pouvez y acc√©der soit via **nvm** ou si vous mettez √† jour votre Node.js global. N'oubliez pas de supprimer `node_modules` et d'ex√©cuter √† nouveau `npm install` apr√®s avoir mis √† jour votre nodejs¬†! Ensuite, assurez-vous que **libpq** est install√©, vous pouvez le faire en ex√©cutant

```
sudo apt-get install libpq-dev
```

Et en conclussion, n'utilisez pas `graph test` (qui utilise votre installation globale de graph-cli et pour une raison quelconque, cela semble √™tre cass√© sur WSL actuellement), utilisez plut√¥t `yarn test` ou `npm run test` (cela utilisera l'instance locale de graph-cli au niveau du projet, qui fonctionne √† merveille). Pour cela, vous devez bien s√ªr avoir un script `"test"` dans votre fichier `package.json` qui peut √™tre quelque chose d'aussi simple que

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### Usage

Pour utiliser **Matchstick** dans votre projet de subgraph, il suffit d'ouvrir un terminal, de naviguer vers le dossier racine de votre projet et d'ex√©cuter simplement `graph test [options] <datasource>` - il t√©l√©charge le dernier binaire **Matchstick** et ex√©cute le test sp√©cifi√© ou tous les tests dans un dossier de test (ou tous les tests existants si aucun datasource flag n'est sp√©cifi√©).

### CLI options

Cette op√©ration permet d'ex√©cuter tous les tests contenus dans le dossier test :

```sh
graph test
```

Ceci lancera un test nomm√© gravity.test.ts et/ou tous les tests √† l'int√©rieur d'un dossier nomm√© gravity :

```sh
gravity graph test
```

Ce fichier de test sera le seul √† √™tre ex√©cut√© :

```sh
graph test path/to/file.test.ts
```

**Les Options¬†:**

```sh
-c, --coverage Ex√©cuter les tests en mode couverture
-d, --docker Ex√©cutez les tests dans un conteneur Docker (Remarque¬†: veuillez ex√©cuter √† partir du dossier racine du subgraph)
-f, --force Binary¬†: t√©l√©charge √† nouveau le binaire. Docker¬†: t√©l√©charge √† nouveau le fichier Docker et reconstruit l'image Docker.
-h, --help Afficher les informations d'utilisation
-l, --logs Enregistre dans la console des informations sur le syst√®me d'exploitation, le mod√®le de processeur et l'URL de t√©l√©chargement (√† des fins de d√©bogage)
-r, --recompile Force les tests √† √™tre recompil√©s
-v, --version <tag> Choisissez la version du binaire Rust que vous souhaitez t√©l√©charger/utiliser
```

### Docker

√Ä partir de `graph-cli 0.25.2`, la commande `graph test` prend en charge l'ex√©cution de `matchstick` dans un conteneur Docker avec le `-d</0. > drapeau. L'impl√©mentation de Docker utilise <a href="https://docs.docker.com/storage/bind-mounts/">bind mount</a> afin de ne pas avoir √† reconstruire l'image Docker √† chaque fois que la commande <code>graph test -d` est ex√©cut√©e. Vous pouvez √©galement suivre les instructions du r√©f√©rentiel [matchstick](https://github.com/LimeChain/matchstick#docker-) pour ex√©cuter Docker manuellement.

‚ùó `graph test -d` forces `docker run` to run with flag `-t`. This must be removed to run inside non-interactive environments (like GitHub CI).

‚ùó En cas d'ex√©cution pr√©alable de `graph test`, vous risquez de rencontrer l'erreur suivante lors de la construction de docker :

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

Dans ce cas, il faut cr√©er un `.dockerignore` dans le dossier racine et ajoutez `node_modules/binary-install-raw/bin`

### La Configuration

Matchstick peut √™tre configur√© pour utiliser des tests personnalis√©s, des biblioth√®ques et un chemin de manifeste via le fichier de configuration `matchstick.yaml`¬†:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Subgraph d√©monstration

Vous pouvez tester et jouer avec les exemples de ce guide en clonant le repo [Demo Subgraph](https://github.com/LimeChain/demo-subgraph)

### Tutoriels vid√©os

Vous pouvez √©galement consulter la s√©rie de vid√©os sur [¬´¬†comment utiliser Matchstick pour √©crire des tests unitaires pour vos subgraphs ¬ª](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Tests structure

_**IMPORTANT: The test structure described below depens on `matchstick-as` version >=0.5.0**_

### d√©crivez()

`describe(name: String , () => {})` - D√©finit un groupe de test.

**_Notez :_**

- _Les descriptions ne sont pas indispensable. Vous pouvez toujours utiliser test() √† l'ancienne, en dehors des blocs describe()_

L'exemple:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Devrait cr√©er une nouvelle entit√© Gravatar", () => {
    ...
  })
})
```

Exemple de `d√©crire ()` imbriqu√© :

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("Lorsque l'entit√© existe", () => {
    test("met √† jour l'entit√©", () => {
      ...
    })
  })

  describe("Lorsque l'entit√© n'existe pas", () => {
    test("il cr√©e une nouvelle entit√©y", () => {
      ...
    })
  })
})
```

---

### tester ()

`test(name: String, () =>, Should_fail: bool)` - D√©finit un sc√©nario de test. Vous pouvez utiliser test() √† l‚Äôint√©rieur des blocs d√©crire() ou ind√©pendamment.

L'exemple:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Devrait cr√©er une nouvelle entit√©", () => {
    ...
  })
})
```

ou bien

```typescript
test("handleNewGravatar() doit cr√©er une nouvelle entit√©", () => {
  ...
})


```

---

### avantTout()

Ex√©cute un bloc de code apr√®s tous les tests du fichier. Si `afterAll` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il est ex√©cut√© √† la fin de ce bloc `describe`.

Les Exemples:

Le code contenu dans `beforeAll` sera ex√©cut√© une fois avant les tests _all_ du fichier.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("Lorsque l'entit√© n'existe pas", () => {
  test("il devrait cr√©er un nouveau Gravatar avec l'id 0x1", () => {
    ...
  })
})

describe("Lorsque l'entit√© existe d√©j√†", () => {
  test("il devrait mettre √† jour le Gravatar avec l'id 0x0", () => {
    ...
  })
})
```

Le code contenu dans `beforeAll` sera ex√©cut√© une fois avant tous les tests du premier bloc de description

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "Premier Gravatar"
    gravatar.save()
    ...
  })

  test("met √† jour le Gravatar avec l'identifiant 0x0", () => {
    ...
  })

  test("cr√©e un nouveau Gravatar avec l'identifiant 0x1", () => ; {
    ...
  })
})
```

---

### afterAll()

Lance un bloc de code apr√®s tous les tests du fichier. Si `afterAll` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il s'ex√©cute √† la fin de ce bloc `describe`.

L'exemple:

Le code situ√© dans `afterAll` sera ex√©cut√© une fois apr√®s _all_ tests dans le fichier.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("cr√©e un Gravatar avec l'identifiant 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("met √† jour Gravatar avec l'identifiant 0x0", () => {
    ...
  })
})
```

Le code √† l'int√©rieur de `afterAll` s'ex√©cute une fois apr√®s tous les tests du premier bloc de description

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("Cr√©e une nouvelle entit√© avec l'identifiant 0x0", () => {
    ...
  })

  test("Cr√©e une nouvelle entit√© avec l'identifiant 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("Met √† jour le Gravatar avec l'identifiant 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Lance un bloc de code avant chaque test. Si `beforeEach` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il s'ex√©cute avant chaque test de ce bloc `describe`.

Exemples : Le code contenu dans `beforeEach` s'ex√©cute avant chaque test.

```typescript
importez { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

Ex√©cutez un bloc de code avant chaque test. Si `beforeEach` est d√©clar√© √† l'int√©rieur d'un bloc describe, il s'ex√©cute avant chaque test de ce bloc describe

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code qui devrait mettre √† jour le nom d'affichage √† 1 Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code qui devrait changer le imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Lance un bloc de code apr√®s chaque test. Si `afterEach` est d√©clar√© √† l'int√©rieur d'un bloc de `description`, il s'ex√©cute apr√®s chaque test de ce bloc de `description`.

Les Exemples:

Le code dans `afterEach` sera ex√©cut√© apr√®s chaque test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code qui devrait mettre √† jour le nom d'affichage √† 1 Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code qui devrait changer le imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Le code contenu dans `afterEach` ex√©cutera apr√®s chaque test dans cette description

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code qui devrait mettre √† jour le nom d'affichage √† 1 Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code qui devrait changer le imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Assertions

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

As of version 0.6.0, asserts support custom error messages as well

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id should be 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value should equal 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar should not be in store')
assert.addressEquals(Address.zero(), Address.zero(), 'Address should be zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes should be equal')
assert.i32Equals(2, 2, 'I32 should equal 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt should equal 1')
assert.booleanEquals(true, true, 'Boolean should be true')
assert.stringEquals('1', '1', 'String should equal 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arrays should be equal')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuples should be equal',
)
assert.assertTrue(true, 'Should be true')
assert.assertNull(null, 'Should be null')
assert.assertNotNull('not null', 'Should be not null')
assert.entityCount('Gravatar', 1, 'There should be 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet template should have one data source')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet should have a data source for zero address',
)
```

## √âcrire un test unitaire

Voyons √† quoi ressemblerait un test unitaire simple en utilisant les exemples Gravatar dans le [subgraph de d√©monstration](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

En supposant que nous disposions de la fonction de traitement suivante (ainsi que de deux fonctions d'aide pour nous faciliter la vie) :

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Nous devons tout d'abord cr√©er un fichier de test dans notre projet. Voici un exemple de ce √† quoi cela pourrait ressembler :

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Peut appeler des mappings avec des √©v√©nements personnalis√©s', () => {
  // Cr√©e une entit√© de test et l'enregistre dans le store comme √©tat initial (optionnel)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Cr√©e des √©v√©nements factices
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Appelle les fonctions de mapping en passant les √©v√©nements qu'on vient de cr√©er
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // V√©rifie l'√©tat du store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Vide le store afin de commencer le prochain test avec un √©tat propre
  clearStore()
})

test('Test suivant', () => {
  //...
})
```

Cela fait beaucoup √† d√©cortiquer ! Tout d'abord, une chose importante √† noter est que nous importons des choses de `matchstick-as`, notre biblioth√®que d'aide AssemblyScript (distribu√©e en tant que module npm). Vous pouvez trouver le d√©p√¥t [ici](https://github.com/LimeChain/matchstick-as). `matchstick-as` nous fournit des m√©thodes de test utiles et d√©finit √©galement la fonction `test()` que nous utiliserons pour construire nos blocs de test. Le reste est assez simple - voici ce qui se passe :

- Mettons en place notre √©tat initial et ajoutons une entit√© Gravatar personnalis√©e ;
- D√©finissons deux objets √©v√©nement `NewGravatar` avec leurs donn√©es, en utilisant la fonction `createNewGravatarEvent()` ;
- Appelons des m√©thodes de gestion pour ces √©v√©nements - `handleNewGravatars()` et nous passons la liste de nos √©v√©nements personnalis√©s ;
- Affirmons l'√©tat du magasin. Comment cela fonctionne-t-il ? - Nous passons une combinaison unique de type d'entit√© et d'identifiant. Ensuite, nous v√©rifions un champ sp√©cifique de cette entit√© et affirmons qu'il a la valeur que nous attendons. Nous faisons cela √† la fois pour l'entit√© Gravatar initiale que nous avons ajout√©e au magasin, ainsi que pour les deux entit√©s Gravatar qui sont ajout√©es lorsque la fonction de gestion est appel√©e ;
- Et enfin, Nettoyons le magasin √† l'aide de `clearStore()` afin que notre prochain test puisse commencer avec un objet magasin frais et vide. Nous pouvons d√©finir autant de blocs de test que nous le souhaitons.

Et voil√†, nous avons formul√© notre premier test ! üëè

Maintenant, afin d'ex√©cuter nos tests, il suffit d'ex√©cuter ce qui suit dans le dossier racine de votre subgraph :

`gravity graph test`

Et si tout se passe bien, vous devriez √™tre accueilli par ce qui suit¬†:

![Matchstick indiquant ¬´¬†Tous les tests sont r√©ussis !¬†¬ª](/img/matchstick-tests-passed.png)

## Sc√©narios de tests actuels

### L'Hydratation du magasin avec un certain √©tat

Les utilisateurs peuvent hydrater le magasin avec un ensemble connu d'entit√©s. Voici un exemple pour initialiser la boutique avec une entit√© Gravatar¬†:

```typescript
laissez gravatar = new Gravatar('entryId')
gravatar.save()
```

### Appel d'une fonction de cartographie avec un √©v√©nement

Un utilisateur peut cr√©er un √©v√©nement personnalis√© et le transmettre √† une fonction de cartographie li√©e au magasin¬†:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Appel de tous les mappages avec des projecteurs d'√©v√©nements

Les utilisateurs peuvent appeler les mappages avec des dispositifs de test.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Appels de contrat moqueurs

Les utilisateurs peuvent simuler des appels de contrat¬†:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Comme d√©montr√©, afin de se moquer d'un appel de contrat et d'obtenir une valeur de retour, l'utilisateur doit fournir une adresse de contrat, un nom de fonction, une signature de fonction, un tableau d'arguments et bien s√ªr ‚Äì la valeur de retour.

Utilisateurs peuvent √©galement simuler des annulations de fonctions :

```typescript
laissez contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
   .withArgs([ethereum.Value.fromAddress(contractAddress)])
   .reverts()
```

### Se moquer des fichiers IPFS (√† partir de Matchstick 0.4.1)

Les utilisateurs peuvent simuler les fichiers IPFS en utilisant la fonction `mockIpfsFile(hash, filePath)`. La fonction accepte deux arguments, le premier est le hachage/chemin du fichier IPFS et le second est le chemin d'acc√®s √† un fichier local.

NOTEZ : Lorsque vous testez `ipfs.map/ipfs.mapJSON`, la fonction de rappel doit √™tre export√©e du fichier de test afin que matchstck puisse la d√©tecter, comme la fonction `processGravatar()` dans l'exemple de test ci-dessous :

Fichier `.test.ts`¬†:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Exportation du callback ipfs.map() pour que matchstck le d√©tecte.
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

Fichier `utils.ts`¬†:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// rappel ipfs.map
export function processGravatar(value: JSONValue, userData: Value): void {
  // Consultez la documentation de JSONValue pour plus de d√©tails sur la fa√ßon de traiter les donn√©es.
  // avec JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Des entit√©s de rappel peuvent √©galement √™tre cr√©√©es
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// fonction qui appelle ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Affirmation de l'√©tat du magasin

Les utilisateurs sont en mesure d'affirmer l'√©tat final (ou interm√©diaire) du magasin via des entit√©s d'affirmation. Pour ce faire, l'utilisateur doit fournir un type d'entit√©, l'ID sp√©cifique d'une entit√©, le nom d'un champ sur cette entit√© et la valeur attendue du champ. Voici un exemple rapide:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

L'ex√©cution de la fonction assert.fieldEquals() v√©rifiera l'√©galit√© du champ donn√© par rapport √† la valeur attendue indiqu√©e. Le test √©chouera et un message d'erreur sera g√©n√©r√© si les valeurs sont **NON** √©gales. Sinon, le test r√©ussira.

### Interagir avec les m√©tadonn√©es d'√©v√©nement

Les utilisateurs peuvent utiliser les m√©tadonn√©es de transaction par d√©faut, qui peuvent √™tre renvoy√©es comme un ethereum. Event en utilisant la fonction `newMockEvent()`. L'exemple suivant montre comment vous pouvez lire/√©crire dans ces champs sur l'objet Event :

```typescript
// Lisez
let logType = newGravatarEvent.logType

// √âcrivez
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Affirmation de l'√©galit√© des variables

```typescript
assert.equals(ethereum.Value.fromString("bonjour"); ethereum.Value.fromString("bonjour"));
```

### Affirmez qu'une entit√© **n'existe pas** dans le magasin

Les utilisateurs peuvent affirmer qu'une entit√© n'existe pas dans le magasin. La fonction prend un type d'entit√© et un identifiant. Si l'entit√© se trouve effectivement dans le magasin, le test √©chouera avec un message d'erreur pertinent. Voici un exemple rapide de la fa√ßon d'utiliser cette fonctionnalit√©¬†:

```typescript
assert.notInStore('Gravatar', '23')
```

### Printing the whole store, or single entities from it (for debug purposes)

Vous pouvez imprimer l'int√©gralit√© du magasin sur la console √† l'aide de cette fonction d'assistance:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

As of version 0.6.0, `logStore` no longer prints derived fields, instead users can use the new `logEntity` function. Of course `logEntity` can be used to print any entity, not just ones that have derived fields. `logEntity` takes the entity type, entity id and a `showRelated` flag to indicate if users want to print the related derived entities.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### √âchec pr√©vu

Les utilisateurs peuvent s'attendre √† des √©checs de test, en utilisant l'indicateur ShouldFail sur les fonctions test()¬†:

```typescript
test(
   'Devrait g√©n√©rer une erreur',
   () => {
     lancer une nouvelle erreur()
   },
   vrai,
)
```

Si le test est marqu√© avec ShouldFail = true mais n'√©choue PAS, cela appara√Ætra comme une erreur dans les journaux et le bloc de test √©chouera. De plus, s'il est marqu√© avec ShouldFail = false (l'√©tat par d√©faut), l'ex√©cuteur de test plantera.

### Journal de bord

Avoir des journaux personnalis√©s dans les tests unitaires √©quivaut exactement √† la journalisation des mappages. La diff√©rence est que l'objet journal doit √™tre import√© depuis matchstick-as plut√¥t que graph-ts. Voici un exemple simple avec tous les types de journaux non critiques¬†:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Les utilisateurs peuvent √©galement simuler une panne critique, comme ceci¬†:

```typescript
test('Tout faire exploser', () => {
   log.critical('Boom!')
})
```

La journalisation des erreurs critiques arr√™tera l‚Äôex√©cution des tests et fera tout exploser. Apr√®s tout, nous voulons nous assurer que votre code ne contient pas de journaux critiques lors du d√©ploiement, et vous devriez le remarquer imm√©diatement si cela devait se produire.

### Tests d√©riv√©s

Testing derived fields is a feature which allows users to set a field on a certain entity and have another entity be updated automatically if it derives one of its fields from the first entity.

Before version `0.6.0` it was possible to get the derived entities by accessing them as entity fields/properties, like so:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

As of version `0.6.0`, this is done by using the `loadRelated` function of graph-node, the derived entities can be accessed the same way as in the handlers.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Testing `loadInBlock`

As of version `0.6.0`, users can test `loadInBlock` by using the `mockInBlockStore`, it allows mocking entities in the block cache.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Can use entity.loadInBlock() to retrieve entity from cache store in the current block', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Returns null when calling entity.loadInBlock() if an entity doesn't exist in the current block", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Tester les sources de donn√©es dynamiques

Le test des sources de donn√©es dynamiques peut √™tre effectu√© en simulant la valeur de retour des fonctions `context()`, `address()` et `network()` du Espace de noms dataSource. Ces fonctions renvoient actuellement les √©l√©ments suivants¬†: `context()` - renvoie une entit√© vide (DataSourceContext), `address()` - renvoie `0x000000000000000000000000000000000000000000`, ` network()` - renvoie `mainnet`. Les fonctions `create(...)` et `createWithContext(...)` sont simul√©es pour ne rien faire, elles n'ont donc pas du tout besoin d'√™tre appel√©es dans les tests. Les modifications des valeurs de retour peuvent √™tre effectu√©es via les fonctions de l'espace de noms `dataSourceMock` dans `matchstick-as` (version 0.3.0+).

L'exemple ci-dessous :

Nous avons d‚Äôabord le gestionnaire d‚Äô√©v√©nements suivant (qui a √©t√© intentionnellement r√©utilis√© pour pr√©senter la moquerie de la source de donn√©es)¬†:

```typescript
fonction d'exportation handleApproveTokenDestinations (√©v√©nement¬†: ApproveTokenDestinations)¬†: void {
   laissez tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())¬†!
   if (dataSource.network() == 'rinkeby') {
     tokenLockWallet.tokenDestinationsApproved = true
   }
   laissez contexte = dataSource.context()
   if (context.get('contextVal')!.toI32() > 0) {
     tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
   }
   tokenLockWallet.save()
}
```

Et puis nous avons le test utilisant l'une des m√©thodes de l'espace de noms dataSourceMock pour d√©finir une nouvelle valeur de retour pour toutes les fonctions dataSource¬†:

```typescript
importer { assert, test, newMockEvent, dataSourceMock } depuis 'matchstick-as/assembly/index'
importer { BigInt, DataSourceContext, Value } depuis '@graphprotocol/graph-ts'

importer { handleApproveTokenDestinations } depuis '../../src/token-lock-wallet'
importer { ApproveTokenDestinations } depuis '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
importer { TokenLockWallet } depuis '../../generated/schema'

test('Exemple moqueur simple de source de donn√©es', () => {
   laissez adresseString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
   let adresse = Adresse.fromString(addressString)

   laissez wallet = new TokenLockWallet (address.toHexString())
   portefeuille.save()
   laisser contexte = new DataSourceContext()
   contexte.set('contextVal', Value.fromI32(325))
   dataSourceMock.setReturnValues(addressString, 'rinkeby', contexte)
   let event = changetype<ApproveTokenDestinations>(newMockEvent())

   assert.assertTrue(!wallet.tokenDestinationsApproved)

   handleApproveTokenDestinations (√©v√©nement)

   portefeuille = TokenLockWallet.load(address.toHexString())¬†!
   assert.assertTrue(wallet.tokenDestinationsApproved)
   assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

   dataSourceMock.resetValues()
})
```

Notez que dataSourceMock.resetValues() est appel√© √† la fin. C'est parce que les valeurs sont m√©moris√©es lorsqu'elles sont modifi√©es et doivent √™tre r√©initialis√©es si vous voulez revenir aux valeurs par d√©faut.

### Testing dynamic data source creation

As of version `0.6.0`, it is possible to test if a new data source has been created from a template. This feature supports both ethereum/contract and file/ipfs templates. There are four functions for this:

- `assert.dataSourceCount(templateName, expectedCount)` can be used to assert the expected count of data sources from the specified template
- `assert.dataSourceExists(templateName, address/ipfsHash)` asserts that a data source with the specified identifier (could be a contract address or IPFS file hash) from a specified template was created
- `logDataSources(templateName)` prints all data sources from the specified template to the console for debugging purposes
- `readFile(path)` reads a JSON file that represents an IPFS file and returns the content as Bytes

#### Testing `ethereum/contract` templates

```typescript
test('ethereum/contract dataSource creation example', () => {
  // Assert there are no dataSources created from GraphTokenLockWallet template
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // Create a new GraphTokenLockWallet datasource with address 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Add a second dataSource with context
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert there are now 2 dataSources
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // Assert that a dataSource with address "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" was created
  // Keep in mind that `Address` type is transformed to lower case when decoded, so you have to pass the address as all lower case when asserting if it exists
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### Example `logDataSource` output

```bash
üõ†  {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
}
```

#### Testing `file/ipfs` templates

Similarly to contract dynamic data sources, users can test test file datas sources and their handlers

##### Example `subgraph.yaml`

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### Example `schema.graphql`

```graphql
"""
Token Lock Wallets which hold locked GRT
"""
type TokenLockMetadata @entity {
  "The address of the token lock wallet"
  id: ID!
  "Start time of the release schedule"
  startTime: BigInt!
  "End time of the release schedule"
  endTime: BigInt!
  "Number of periods between start time and end time"
  periods: BigInt!
  "Time when the releases start"
  releaseStartTime: BigInt!
}
```

##### Example `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Example handler

```typescript
export function handleMetadata(content: Bytes): void {
  // dataSource.stringParams() returns the File DataSource CID
  // stringParam() will be mocked in the handler test
  // for more info https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Example test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () => {
  // Generate the dataSource CID from the ipfsHash + ipfs path file
  // For example QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // Create a new dataSource using the generated CID
  GraphTokenLockMetadata.create(CID)

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Now we have to mock the dataSource metadata and specifically dataSource.stringParam()
  // dataSource.stringParams actually uses the value of dataSource.address(), so we will mock the address using dataSourceMock from  matchstick-as
  // First we will reset the values and then use dataSourceMock.setAddress() to set the CID
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)

  // Now we need to generate the Bytes to pass to the dataSource handler
  // For this case we introduced a new function readFile, that reads a local json and returns the content as Bytes
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Now we will test if a TokenLockMetadata was created
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Couverture de test

Gr√¢ce √† **Matchstick**, les d√©veloppeurs de subgraphs peuvent ex√©cuter un script qui calculera la couverture des tests unitaires √©crits.

L'outil de couverture de test prend les binaires de test `wasm` compil√©s et les convertit en fichiers `wat`, qui peuvent ensuite √™tre facilement inspect√©s pour voir si les gestionnaires d√©finis dans `subgraph .yaml` ont √©t√© appel√©s. √âtant donn√© que la couverture du code (et les tests dans leur ensemble) en sont √† leurs tout premiers stades dans AssemblyScript et WebAssembly, **Matchstick** ne peut pas v√©rifier la couverture des branches. Au lieu de cela, nous nous appuyons sur l'affirmation selon laquelle si un gestionnaire donn√© a √©t√© appel√©, l'√©v√©nement/la fonction correspondant a √©t√© correctement simul√©.

### Conditions pr√©alables

Pour ex√©cuter la fonctionnalit√© de couverture de test fournie dans **Matchstick**, vous devez pr√©parer quelques √©l√©ments au pr√©alable¬†:

#### Exportez vos gestionnaires

Pour que **Matchstick** v√©rifie quels gestionnaires sont ex√©cut√©s, ces gestionnaires doivent √™tre export√©s √† partir du **fichier de test**. Ainsi, par exemple, dans notre exemple, dans notre fichier gravitation.test.ts, nous avons le gestionnaire suivant en cours d'importation¬†:

```typescript
importez { handleNewGravatar } from '../../src/gravity'
```

Pour que cette fonction soit visible (pour qu'elle soit incluse dans le fichier `wat` **par son nom**), nous devons √©galement l'exporter, comme ceci¬†:

```typescript
exportez { handleNewGravatar }
```

### Usage

Une fois tout configur√©, pour ex√©cuter l'outil de couverture de test, ex√©cutez simplement¬†:

```sh
graph test -- -c
```

Vous pouvez √©galement ajouter une commande `coverage` personnalis√©e √† votre fichier `package.json`, comme ceci¬†:

```typescript
 "scripts": {
     /.../
     "coverage": "test graph -- -c"
   },
```

Cela ex√©cutera l'outil de couverture et vous devriez voir quelque chose comme ceci dans le terminal¬†:

```sh
$ graph test -c
Sauter l'√©tape de t√©l√©chargement/installation car le binaire existe d√©j√† √† l'adresse suivante : /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compilation...

Ex√©cution en mode rapport de couverture.
 Ô∏è
Lecture des modules de test g√©n√©r√©s... üîéÔ∏è

G√©n√©ration du rapport de couverture üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Dur√©e d'ex√©cution du test dans la sortie du journal

La sortie du journal inclut la dur√©e de l‚Äôex√©cution du test. Voici un exemple¬†:

`[Jeudi 31 mars 2022 13:54:54 +0300] Programme ex√©cut√© en¬†: 42,270 ms.`

## Erreurs de compilation courantes

> Critique¬†: impossible de cr√©er WasmInstance √† partir d'un module valide avec un contexte¬†: importation inconnue¬†: wasi_snapshot_preview1::fd_write n'a pas √©t√© d√©fini

Cela signifie que vous avez utilis√© `console.log` dans votre code, ce qui n'est pas pris en charge par AssemblyScript. Veuillez envisager d'utiliser l'[API Logging](/developing/assemblyscript-api/#logging-api)

> ERREUR TS2554¬†: attendu¬†? arguments, mais j'ai eu ?.
> 
> renvoyer le nouveau ethereum.Block (defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt) ;
> 
> dans ~lib/matchstick-as/assembly/defaults.ts(18,12)
> 
> ERROR TS2554: Expected ? arguments, but got ?.
> 
> renvoyer un nouveau ethereum.Transaction (defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt) ;
> 
> dans ~lib/matchstick-as/assembly/defaults.ts(24,12)

L'inad√©quation des arguments est caus√©e par une inad√©quation entre `graph-ts` et `matchstick-as`. La meilleure fa√ßon de r√©soudre des probl√®mes comme celui-ci est de tout mettre √† jour vers la derni√®re version publi√©e.

## R√©action

Si vous avez des questions, des commentaires, des demandes de fonctionnalit√©s ou si vous souhaitez simplement nous contacter, le meilleur endroit serait The Graph Discord o√π nous avons une cha√Æne d√©di√©e √† Matchstick, appel√©e üî•| tests unitaires.
