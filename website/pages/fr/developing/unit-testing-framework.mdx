---
title: Cadre pour les tests unitaires
---

Matchstick est un cadre de test unitaire, dÃ©veloppÃ© par [LimeChain](https://limechain.tech/), qui permet aux dÃ©veloppeurs de subgraphs de tester leur logique de cartographie dans un environnement de type bac Ã  sable et de dÃ©ployer leurs subgraphs en toute confiance !

## DÃ©marrage

### Installer les dÃ©pendances

Pour utiliser les mÃ©thodes d'assistance aux tests et exÃ©cuter les tests, vous devrez installer les dÃ©pendances suivantesÂ :

```sh
yarn add --dev matchstick-as
```

â— `graph-node` dÃ©pend de PostgreSQL, donc si vous ne l'avez pas dÃ©jÃ , vous devrez l'installer. Nous vous conseillons vivement d'utiliser les commandes ci-dessous, car l'ajouter d'une autre maniÃ¨re peut provoquer des erreurs inattendues !

#### Le MacOS

Commande d'installation Postgres :

```sh
prÃ©parer l'installation de postgresql
```

CrÃ©ez un lien symbolique vers la derniÃ¨re libpq.5.lib _Vous devrez peut-Ãªtre d'abord crÃ©er ce rÃ©pertoire_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Commande d'installation de Postgres (dÃ©pend de votre distribution) :

```sh
sudo apt installer postgresql
```

### WSL (SystÃ¨me Windows pour Linux)

Vous pouvez utiliser Matchstick sur WSL en utilisant Ã  la fois l'approche Docker et l'approche binaire. Comme WSL peut Ãªtre un peu dÃ©licat, voici quelques conseils au cas oÃ¹ vous rencontreriez des problÃ¨mes tels que

```
static BYTES = Symbol("Bytes") SyntaxError: Jeton inattendu =
```

ou bien

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 lancerÂ ;
```

Veuillez vous assurer que vous utilisez une version plus rÃ©cente de Node.js graph-cli qui ne prend plus en charge la **v10.19.0**, et qu'il s'agit toujours de la version par dÃ©faut pour le nouvel Ubuntu. images sur WSL. Par exemple, il est confirmÃ© que Matchstick fonctionne sur WSL avec **v18.1.0**, vous pouvez y accÃ©der soit via **nvm** ou si vous mettez Ã  jour votre Node.js global. N'oubliez pas de supprimer `node_modules` et d'exÃ©cuter Ã  nouveau `npm install` aprÃ¨s avoir mis Ã  jour votre nodejsÂ ! Ensuite, assurez-vous que **libpq** est installÃ©, vous pouvez le faire en exÃ©cutant

```
sudo apt-get install libpq-dev
```

Et en conclussion, n'utilisez pas `graph test` (qui utilise votre installation globale de graph-cli et pour une raison quelconque, cela semble Ãªtre cassÃ© sur WSL actuellement), utilisez plutÃ´t `yarn test` ou `npm run test` (cela utilisera l'instance locale de graph-cli au niveau du projet, qui fonctionne Ã  merveille). Pour cela, vous devez bien sÃ»r avoir un script `"test"` dans votre fichier `package.json` qui peut Ãªtre quelque chose d'aussi simple que

```json
{
   "name": "subgraph de dÃ©monstration",
   "version": "0.1.0",
   "scripts": {
     "test": "test graphique",
     ...
   },
   "dÃ©pendances": {
     "@graphprotocol/graph-cli": "^0.30.0",
     "@graphprotocol/graph-ts": "^0.27.0",
     "matchstick-as": "^0.5.0"
   }
}
```

### Usage

Pour utiliser **Matchstick** dans votre projet de subgraph, il suffit d'ouvrir un terminal, de naviguer vers le dossier racine de votre projet et d'exÃ©cuter simplement `graph test [options] <datasource>` - il tÃ©lÃ©charge le dernier binaire **Matchstick** et exÃ©cute le test spÃ©cifiÃ© ou tous les tests dans un dossier de test (ou tous les tests existants si aucun datasource flag n'est spÃ©cifiÃ©).

### CLI options

Cette opÃ©ration permet d'exÃ©cuter tous les tests contenus dans le dossier test :

```sh
graph test
```

Ceci lancera un test nommÃ© gravity.test.ts et/ou tous les tests Ã  l'intÃ©rieur d'un dossier nommÃ© gravity :

```sh
gravity graph test
```

Ce fichier de test sera le seul Ã  Ãªtre exÃ©cutÃ© :

```sh
chemin de test graph/vers/fichier.test.ts
```

**Les OptionsÂ :**

```sh
-c, --coverage ExÃ©cuter les tests en mode couverture
-d, --docker ExÃ©cutez les tests dans un conteneur Docker (RemarqueÂ : veuillez exÃ©cuter Ã  partir du dossier racine du subgraph)
-f, --force BinaryÂ : tÃ©lÃ©charge Ã  nouveau le binaire. DockerÂ : tÃ©lÃ©charge Ã  nouveau le fichier Docker et reconstruit l'image Docker.
-h, --help Afficher les informations d'utilisation
-l, --logs Enregistre dans la console des informations sur le systÃ¨me d'exploitation, le modÃ¨le de processeur et l'URL de tÃ©lÃ©chargement (Ã  des fins de dÃ©bogage)
-r, --recompile Force les tests Ã  Ãªtre recompilÃ©s
-v, --version <tag> Choisissez la version du binaire Rust que vous souhaitez tÃ©lÃ©charger/utiliser
```

### Docker

Ã€ partir de `graph-cli 0.25.2`, la commande `graph test` prend en charge l'exÃ©cution de `matchstick` dans un conteneur Docker avec le `-d</0. > drapeau. L'implÃ©mentation de Docker utilise <a href="https://docs.docker.com/storage/bind-mounts/">bind mount</a> afin de ne pas avoir Ã  reconstruire l'image Docker Ã  chaque fois que la commande <code>graph test -d` est exÃ©cutÃ©e. Vous pouvez Ã©galement suivre les instructions du rÃ©fÃ©rentiel [matchstick](https://github.com/LimeChain/matchstick#docker-) pour exÃ©cuter Docker manuellement.

â— En cas d'exÃ©cution prÃ©alable de `graph test`, vous risquez de rencontrer l'erreur suivante lors de la construction de docker :

```sh
  erreur de l'expÃ©diteur : failed to xattr node_modules/binary-install-raw/bin/binary-<platform> : permission denied
```

Dans ce cas, il faut crÃ©er un `.dockerignore` dans le dossier racine et ajoutez `node_modules/binary-install-raw/bin`

### La Configuration

Matchstick peut Ãªtre configurÃ© pour utiliser des tests personnalisÃ©s, des bibliothÃ¨ques et un chemin de manifeste via le fichier de configuration `matchstick.yaml`Â :

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Subgraph dÃ©monstration

Vous pouvez tester et jouer avec les exemples de ce guide en clonant le repo [Demo Subgraph](https://github.com/LimeChain/demo-subgraph)

### Tutoriels vidÃ©os

Vous pouvez Ã©galement consulter la sÃ©rie de vidÃ©os sur [Â«Â comment utiliser Matchstick pour Ã©crire des tests unitaires pour vos subgraphs Â»](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Structure des essais (>=0.5.0)

_**IMPORTANT : Requiert matchstick-as >=0.5.0**_

### dÃ©crivez()

`dÃ©crivez(name: String , () => {})` - DÃ©finit un groupe de test.

**_Notez :_**

- _Les descriptions ne sont pas indispensable. Vous pouvez toujours utiliser test() Ã  l'ancienne, en dehors des blocs describe()_

L'exemple:

```typescript
importer { describe, test } du "matchstick-as/assembly/index"
import { handleNewGravatar } du "../../src/gravity"

dÃ©crire ("handleNewGravatar()", () => {
  test("Devrait crÃ©er une nouvelle entitÃ© Gravatar", () => {
    ...
  })
})
```

Exemple de `dÃ©crire ()` imbriquÃ© :

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### tester ()

`test(name: String, () =>, Should_fail: bool)` - DÃ©finit un scÃ©nario de test. Vous pouvez utiliser test() Ã  lâ€™intÃ©rieur des blocs dÃ©crire() ou indÃ©pendamment.

L'exemple:

```typescript
importez { describe, test } from "matchstick-as/assembly/index"
importez { handleNewGravatar } from "../../src/gravity"

dÃ©crivez ("handleNewGravatar()", () => {
  testez ("Devrait crÃ©er une nouvelle entitÃ©", () => {
    ...
  })
})
```

ou bien

```typescript
test("handleNewGravatar() doit crÃ©er une nouvelle entitÃ©", () => {
  ...
})


```

---

### avantTout()

ExÃ©cute un bloc de code aprÃ¨s tous les tests du fichier. Si `afterAll` est dÃ©clarÃ© Ã  l'intÃ©rieur d'un bloc `describe`, il est exÃ©cutÃ© Ã  la fin de ce bloc `describe`.

Les Exemples:

Le code contenu dans `beforeAll` sera exÃ©cutÃ© une fois avant les tests _all_ du fichier.

```typescript
import { describe, test, beforeAll } du "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } du "../../src/gravity"
import { Gravatar } du "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
  ...
})

describe("Lorsque l'entitÃ© n'existe pas", () => {
  test("il devrait crÃ©er un nouveau Gravatar avec l'id 0x1", () => {
    ...
  })
})

describe("Lorsque l'entitÃ© existe dÃ©jÃ ", () => {
  test("il devrait mettre Ã  jour le Gravatar avec l'id 0x0", () => {
    ...
  })
})
```

Le code contenu dans `beforeAll` sera exÃ©cutÃ© une fois avant tous les tests du premier bloc de description

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "Premier Gravatar"
    gravatar.save()
    ...
  })

  test("met Ã  jour le Gravatar avec l'identifiant 0x0", () => {
    ...
  })

  test("crÃ©e un nouveau Gravatar avec l'identifiant 0x1", () => ; {
    ...
  })
})
```

---

### afterAll()

Lance un bloc de code aprÃ¨s tous les tests du fichier. Si `afterAll` est dÃ©clarÃ© Ã  l'intÃ©rieur d'un bloc `describe`, il s'exÃ©cute Ã  la fin de ce bloc `describe`.

L'exemple:

Le code situÃ© dans `afterAll` sera exÃ©cutÃ© une fois aprÃ¨s _all_ tests dans le fichier.

```typescript
importer { describe, test, afterAll } depuis "matchstick-as/assembly/index"
importer { handleUpdatedGravatar, handleNewGravatar } depuis "../../src/gravity"
importer { store } depuis "@graphprotocol/graph-ts"

aprÃ¨sTout(() => {
   store.remove("Gravatar", "0x0")
   ...
})

dÃ©crire("handleNewGravatar, () => {
   test("crÃ©e un Gravatar avec l'identifiant 0x0", () => {
    ...
  })
})

dÃ©crire("handleUpdatedGravatar", () => {
   test("met Ã  jour Gravatar avec l'identifiant 0x0", () => {
    ...
  }     ...
   })
})
```

Le code Ã  l'intÃ©rieur de `afterAll` s'exÃ©cute une fois aprÃ¨s tous les tests du premier bloc de description

```typescript
importez { describe, test, afterAll, clearStore } du "matchstick-as/assembly/index"
importez { handleUpdatedGravatar, handleNewGravatar } du "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Lance un bloc de code avant chaque test. Si `beforeEach` est dÃ©clarÃ© Ã  l'intÃ©rieur d'un bloc `describe`, il s'exÃ©cute avant chaque test de ce bloc `describe`.

Exemples : Le code contenu dans `beforeEach` s'exÃ©cute avant chaque test.

```typescript
importez { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

ExÃ©cutez un bloc de code avant chaque test. Si `beforeEach` est dÃ©clarÃ© Ã  l'intÃ©rieur d'un bloc describe, il s'exÃ©cute avant chaque test de ce bloc describe

```typescript
importez { describe, test, beforeEach } from 'matchstick-as/assembly/index'
importez { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code qui devrait mettre Ã  jour le nom d'affichage Ã  1 Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code qui devrait changer le imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Lance un bloc de code aprÃ¨s chaque test. Si `afterEach` est dÃ©clarÃ© Ã  l'intÃ©rieur d'un bloc de `description`, il s'exÃ©cute aprÃ¨s chaque test de ce bloc de `description`.

Les Exemples:

Code inside `afterEach` will execute after every test.

```typescript
importez { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code qui devrait mettre Ã  jour le nom d'affichage Ã  1 Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code qui devrait changer le imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Le code contenu dans `afterEach` exÃ©cutera aprÃ¨s chaque test dans cette description

```typescript
importez { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
importez { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code qui devrait mettre Ã  jour le nom d'affichage Ã  1 Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code qui devrait changer le imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Asserts

```typescript
fieldEquals (entityTypeÂ : chaÃ®ne, identifiantÂ : chaÃ®ne, fieldNameÂ : chaÃ®ne, ExpectValÂ : chaÃ®ne)

est Ã©gal (attenduÂ : ethereum.Value, rÃ©elÂ : ethereum.Value)

notInStore (entityTypeÂ : chaÃ®ne, identifiantÂ : chaÃ®ne)

adresseEquals (adresse1Â : adresse, adresse2Â : adresse)

bytesEquals (octets1Â : octets, octets2Â : octets)

i32Equals(numÃ©ro1Â : i32, numÃ©ro2Â : i32)

bigIntEquals (bigInt1 : BigInt, bigInt2 : BigInt)

booleanEquals(bool1Â : boolÃ©en, bool2Â : boolÃ©en)

stringEquals(string1 : chaÃ®ne, string2 : chaÃ®ne)

arrayEquals (tableau1Â :Â tableau<ethereum.Value>, tableau2Â : tableau<ethereum.Value>)

tupleEquals (tuple1Â : ethereum.Tuple, tuple2Â : ethereum.Tuple)

assertTrue(valeurÂ : boolÃ©enne)

assertNull<T>(valeurÂ :Â T)

assertNotNull<T>(valeurÂ :Â T)

EntityCount (EntityTypeÂ : chaÃ®ne, ExpectedCountÂ : i32)
```

## Ã‰crivez un test unitaire

Voyons Ã  quoi ressemblerait un test unitaire simple en utilisant les exemples Gravatar dans le [subgraph de dÃ©monstration](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

En supposant que nous disposions de la fonction de traitement suivante (ainsi que de deux fonctions d'aide pour nous faciliter la vie) :

```typescript
fonction d'exportation handleNewGravatar (Ã©vÃ©nementÂ : NewGravatar)Â : void {
   laissez gravatar = new Gravatar(event.params.id.toHex())
   gravatar.owner = event.params.owner
   gravatar.displayName = event.params.displayName
   gravatar.imageUrl = event.params.imageUrl
   gravatar.save()
}

fonction d'exportation handleNewGravatars(events: NewGravatar[]): void {
   events.forEach((event) => {
     handleNewGravatar (Ã©vÃ©nement)
   })
}

fonction d'exportation createNewGravatarEvent(
   identifiantÂ : i32,
   OwnerAddressÂ :Â chaÃ®ne,
   displayNameÂ : chaÃ®ne,
   imageUrlÂ : chaÃ®ne,
): NouveauGravatar {
   laissez mockEvent = newMockEvent()
   laissez newGravatarEvent = new NewGravatar(
     mockEvent.adresse,
     mockEvent.logIndex,
     mockEvent.transactionLogIndex,
     mockEvent.logType,
     mockEvent.block,
     mockEvent.transaction,
     mockEvent.paramÃ¨tres,
   )
   newGravatarEvent.parameters = nouveau tableau()
   laissez idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
   laissez adresseParam = new ethereum.EventParam (
     'adresse du propriÃ©taire',
     ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
   )
   laissez displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
   laissez imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

   newGravatarEvent.parameters.push(idParam)
   newGravatarEvent.parameters.push(addressParam)
   newGravatarEvent.parameters.push(displayNameParam)
   newGravatarEvent.parameters.push(imageUrlParam)

   retourner newGravatarEvent
}
```

Nous devons tout d'abord crÃ©er un fichier de test dans notre projet. Voici un exemple de ce Ã  quoi cela pourrait ressembler :

```typescript
importer { clearStore, test, assert } depuis 'matchstick-as/assembly/index'
importer { Gravatar } depuis '../../generated/schema'
importer { NewGravatar } depuis '../../generated/Gravity/Gravity'
importer { createNewGravatarEvent, handleNewGravatars } depuis '../mappings/gravity'

test('Peut appeler des mappages avec des Ã©vÃ©nements personnalisÃ©s', () => {
   // CrÃ©ez une entitÃ© de test et enregistrez-la dans le magasin comme Ã©tat initial (facultatif)
   laissez gravatar = new Gravatar('gravatarId0')
   gravatar.save()

   // CrÃ©er des Ã©vÃ©nements fictifs
   laissez newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
   laissez anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

   // Appelez les fonctions de mappage en passant les Ã©vÃ©nements que nous venons de crÃ©er
   handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

   // Affirmer l'Ã©tat du magasin
   assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
   assert.fieldEquals('Gravatar', '12345', 'propriÃ©taire', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
   assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

   // Vider le magasin afin de dÃ©marrer le prochain test sur une table rase
   clearStore()
})

test('Test suivant', () => {
   //...
})
```

Cela fait beaucoup Ã  dÃ©cortiquer ! Tout d'abord, une chose importante Ã  noter est que nous importons des choses de `matchstick-as`, notre bibliothÃ¨que d'aide AssemblyScript (distribuÃ©e en tant que module npm). Vous pouvez trouver le dÃ©pÃ´t [ici](https://github.com/LimeChain/matchstick-as). `matchstick-as` nous fournit des mÃ©thodes de test utiles et dÃ©finit Ã©galement la fonction `test()` que nous utiliserons pour construire nos blocs de test. Le reste est assez simple - voici ce qui se passe :

- Mettons en place notre Ã©tat initial et ajoutons une entitÃ© Gravatar personnalisÃ©e ;
- DÃ©finissons deux objets Ã©vÃ©nement `NewGravatar` avec leurs donnÃ©es, en utilisant la fonction `createNewGravatarEvent()` ;
- Appelons des mÃ©thodes de gestion pour ces Ã©vÃ©nements - `handleNewGravatars()` et nous passons la liste de nos Ã©vÃ©nements personnalisÃ©s ;
- Affirmons l'Ã©tat du magasin. Comment cela fonctionne-t-il ? - Nous passons une combinaison unique de type d'entitÃ© et d'identifiant. Ensuite, nous vÃ©rifions un champ spÃ©cifique de cette entitÃ© et affirmons qu'il a la valeur que nous attendons. Nous faisons cela Ã  la fois pour l'entitÃ© Gravatar initiale que nous avons ajoutÃ©e au magasin, ainsi que pour les deux entitÃ©s Gravatar qui sont ajoutÃ©es lorsque la fonction de gestion est appelÃ©e ;
- Et enfin, Nettoyons le magasin Ã  l'aide de `clearStore()` afin que notre prochain test puisse commencer avec un objet magasin frais et vide. Nous pouvons dÃ©finir autant de blocs de test que nous le souhaitons.

Et voilÃ , nous avons formulÃ© notre premier test ! ğŸ‘

Now in order to run our tests you simply need to run the following in your subgraph root folder:

`gravity graph test`

Et si tout se passe bien, vous devriez Ãªtre accueilli par ce qui suitÂ :

![Matchstick saying â€œAll tests passed!â€](/img/matchstick-tests-passed.png)

## ScÃ©narios de tests actuels

### L'Hydratation du magasin avec un certain Ã©tat

Les utilisateurs peuvent hydrater le magasin avec un ensemble connu d'entitÃ©s. Voici un exemple pour initialiser la boutique avec une entitÃ© GravatarÂ :

```typescript
laissez gravatar = new Gravatar('entryId')
gravatar.save()
```

### Appel d'une fonction de cartographie avec un Ã©vÃ©nement

Un utilisateur peut crÃ©er un Ã©vÃ©nement personnalisÃ© et le transmettre Ã  une fonction de cartographie liÃ©e au magasinÂ :

```typescript
importez { store } du 'matchstick-as/assembly/store'
importez { NewGravatar } du '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Appel de tous les mappages avec des projecteurs d'Ã©vÃ©nements

Les utilisateurs peuvent appeler les mappages avec des dispositifs de test.

```typescript
importez { NewGravatar } from '../../generated/Gravity/Gravity'
importez { store } from 'matchstick-as/assembly/store'
importez { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
fonction d'exportation handleNewGravatars(events: NewGravatar[]): void {
     events.forEach(event => {
         handleNewGravatar(Ã©vÃ©nement);
     });
}
```

### Appels de contrat moqueurs

Les utilisateurs peuvent simuler des appels de contratÂ :

```typescript
importez { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
importez { Gravity } from '../../generated/Gravity/Gravity'
importez { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Comme dÃ©montrÃ©, afin de se moquer d'un appel de contrat et d'obtenir une valeur de retour, l'utilisateur doit fournir une adresse de contrat, un nom de fonction, une signature de fonction, un tableau d'arguments et bien sÃ»r â€“ la valeur de retour.

Utilisateurs peuvent Ã©galement simuler des annulations de fonctions :

```typescript
laissez contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
   .withArgs([ethereum.Value.fromAddress(contractAddress)])
   .reverts()
```

### Se moquer des fichiers IPFS (Ã  partir de Matchstick 0.4.1)

Les utilisateurs peuvent simuler les fichiers IPFS en utilisant la fonction `mockIpfsFile(hash, filePath)`. La fonction accepte deux arguments, le premier est le hachage/chemin du fichier IPFS et le second est le chemin d'accÃ¨s Ã  un fichier local.

NOTEZ : Lorsque vous testez `ipfs.map/ipfs.mapJSON`, la fonction de rappel doit Ãªtre exportÃ©e du fichier de test afin que matchstck puisse la dÃ©tecter, comme la fonction `processGravatar()` dans l'exemple de test ci-dessous :

Fichier `.test.ts`Â :

```typescript
importer { assert, test, mockIpfsFile } depuis 'matchstick-as/assembly/index'
importer { ipfs } depuis '@graphprotocol/graph-ts'
importer { gravatarFromIpfs } depuis './utils'

// Exportation du callback ipfs.map() pour que matchtck le dÃ©tecte.
exporter { processGravatar } depuis './utils'

test('ipfs.cat', () => {
   mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

   assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

   gravatarFromIpfs()

   assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
   assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

   clearStore()
})

test('ipfs.map', () => {
   mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

   assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

   ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

   assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
   assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
   assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
   assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

Fichier `utils.ts`Â :

```typescript
importer {Adresse, Ethereum, JSONValue, Valeur, ipfs, json, Octets} depuis "@graphprotocol/graph-ts"
importer { Gravatar } depuis "../../generated/schema"

...

// rappel ipfs.map
fonction d'exportation processGravatar (valeurÂ : JSONValue, userDataÂ : valeur)Â : void {
   // Consultez la documentation de JSONValue pour plus de dÃ©tails sur la faÃ§on de traiter les donnÃ©es.
   // avec valeurs JSON
   laissez obj = valeur.toObject()
   laissez id = obj.get('id')

   si (!id) {
    return
  }
   }

   // Des entitÃ©s de rappel peuvent Ã©galement Ãªtre crÃ©Ã©es
   laissez gravatar = new Gravatar(id.toString())
   gravatar.displayName = userData.toString() + id.toString()
   gravatar.save()
}

// fonction qui appelle ipfs.cat
fonction d'exportation gravatarFromIpfs()Â : void {
   laissez rawData = ipfs.cat("ipfsCatfileHash")

   si (!rawData) {
    return
  }

   laissez jsonData = json.fromBytes (rawData as Bytes).toObject()

   laissez id = jsonData.get('id')
   laissez url = jsonData.get("imageUrl")

   si (!id || !url) {
    return
  }

   laissez gravatar = new Gravatar(id.toString())
   gravatar.imageUrl = url.toString()
   gravatar.save()
}
```

### Affirmation de l'Ã©tat du magasin

Les utilisateurs sont en mesure d'affirmer l'Ã©tat final (ou intermÃ©diaire) du magasin via des entitÃ©s d'affirmation. Pour ce faire, l'utilisateur doit fournir un type d'entitÃ©, l'ID spÃ©cifique d'une entitÃ©, le nom d'un champ sur cette entitÃ© et la valeur attendue du champ. Voici un exemple rapide:

```typescript
importez { assert } du 'matchstick-as/assembly/index'
importez { Gravatar } du '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

L'exÃ©cution de la fonction assert.fieldEquals() vÃ©rifiera l'Ã©galitÃ© du champ donnÃ© par rapport Ã  la valeur attendue indiquÃ©e. Le test Ã©chouera et un message d'erreur sera gÃ©nÃ©rÃ© si les valeurs sont **NON** Ã©gales. Sinon, le test rÃ©ussira.

### Interagir avec les mÃ©tadonnÃ©es d'Ã©vÃ©nement

Les utilisateurs peuvent utiliser les mÃ©tadonnÃ©es de transaction par dÃ©faut, qui peuvent Ãªtre renvoyÃ©es comme un ethereum. Event en utilisant la fonction `newMockEvent()`. L'exemple suivant montre comment vous pouvez lire/Ã©crire dans ces champs sur l'objet Event :

```typescript
// Lisez
let logType = newGravatarEvent.logType

// Ã‰crivez
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Affirmation de l'Ã©galitÃ© des variables

```typescript
assert.equals(ethereum.Value.fromString("bonjour"); ethereum.Value.fromString("bonjour"));
```

### Affirmez qu'une entitÃ© **n'existe pas** dans le magasin

Les utilisateurs peuvent affirmer qu'une entitÃ© n'existe pas dans le magasin. La fonction prend un type d'entitÃ© et un identifiant. Si l'entitÃ© se trouve effectivement dans le magasin, le test Ã©chouera avec un message d'erreur pertinent. Voici un exemple rapide de la faÃ§on d'utiliser cette fonctionnalitÃ©Â :

```typescript
assert.notInStore('Gravatar', '23')
```

### Impression de l'ensemble du magasin (Ã  des fins de dÃ©bogage)

Vous pouvez imprimer l'intÃ©gralitÃ© du magasin sur la console Ã  l'aide de cette fonction d'assistance:

```typescript
importez { logStore } du 'matchstick-as/assembly/store'

logStore()
```

### Ã‰chec prÃ©vu

Les utilisateurs peuvent s'attendre Ã  des Ã©checs de test, en utilisant l'indicateur ShouldFail sur les fonctions test()Â :

```typescript
test(
   'Devrait gÃ©nÃ©rer une erreur',
   () => {
     lancer une nouvelle erreur()
   },
   vrai,
)
```

Si le test est marquÃ© avec ShouldFail = true mais n'Ã©choue PAS, cela apparaÃ®tra comme une erreur dans les journaux et le bloc de test Ã©chouera. De plus, s'il est marquÃ© avec ShouldFail = false (l'Ã©tat par dÃ©faut), l'exÃ©cuteur de test plantera.

### Journal

Avoir des journaux personnalisÃ©s dans les tests unitaires Ã©quivaut exactement Ã  la journalisation des mappages. La diffÃ©rence est que l'objet journal doit Ãªtre importÃ© depuis matchstick-as plutÃ´t que graph-ts. Voici un exemple simple avec tous les types de journaux non critiquesÂ :

```typescript
importez { test } from "matchstick-as/assembly/index";
importez { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Les utilisateurs peuvent Ã©galement simuler une panne critique, comme ceciÂ :

```typescript
test('Tout faire exploser', () => {
   log.critical('Boom!')
})
```

La journalisation des erreurs critiques arrÃªtera lâ€™exÃ©cution des tests et fera tout exploser. AprÃ¨s tout, nous voulons nous assurer que votre code ne contient pas de journaux critiques lors du dÃ©ploiement, et vous devriez le remarquer immÃ©diatement si cela devait se produire.

### Tests dÃ©rivÃ©s

Le test des champs dÃ©rivÃ©s est une fonctionnalitÃ© qui (comme le montre l'exemple ci-dessous) permet Ã  l'utilisateur de dÃ©finir un champ dans une certaine entitÃ© et de mettre Ã  jour automatiquement une autre entitÃ© si elle dÃ©rive l'un de ses champs de la premiÃ¨re entitÃ©. La chose importante Ã  noter est que la premiÃ¨re entitÃ© doit Ãªtre rechargÃ©e car la mise Ã  jour automatique se produit dans le magasin Rust dont le code AS est indÃ©pendant.

```typescript
test('Exemple de test de champs dÃ©rivÃ©s', () => {
   laissez mainAccount = new GraphAccount('12')
   mainAccount.save()
   laissez exploitÃ©Account = new GraphAccount ('1')
   OperatorAccount.operators = ['12']
   exploitÃ©Account.save()
   laissez nst = nouveau NameSignalTransaction('1234')
   nst.signer = '12'
   nst.save()

   assert.assertNull(mainAccount.get('nameSignalTransactions'))
   assert.assertNull(mainAccount.get('operatorOf'))

   mainAccount = GraphAccount.load('12')Â !

   assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
   assert.stringEquals('1', mainAccount.operatorOf[0])
})
```

### Tester les sources de donnÃ©es dynamiques

Le test des sources de donnÃ©es dynamiques peut Ãªtre effectuÃ© en simulant la valeur de retour des fonctions `context()`, `address()` et `network()` du Espace de noms dataSource. Ces fonctions renvoient actuellement les Ã©lÃ©ments suivantsÂ : `context()` - renvoie une entitÃ© vide (DataSourceContext), `address()` - renvoie `0x000000000000000000000000000000000000000000`, ` network()` - renvoie `mainnet`. Les fonctions `create(...)` et `createWithContext(...)` sont simulÃ©es pour ne rien faire, elles n'ont donc pas du tout besoin d'Ãªtre appelÃ©es dans les tests. Les modifications des valeurs de retour peuvent Ãªtre effectuÃ©es via les fonctions de l'espace de noms `dataSourceMock` dans `matchstick-as` (version 0.3.0+).

Example below:

First we have the following event handler (which has been intentionally repurposed to showcase datasource mocking):

```typescript
fonction d'exportation handleApproveTokenDestinations (Ã©vÃ©nementÂ : ApproveTokenDestinations)Â : void {
   laissez tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())Â !
   if (dataSource.network() == 'rinkeby') {
     tokenLockWallet.tokenDestinationsApproved = true
   }
   laissez contexte = dataSource.context()
   if (context.get('contextVal')!.toI32() > 0) {
     tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
   }
   tokenLockWallet.save()
}
```

Et puis nous avons le test utilisant l'une des mÃ©thodes de l'espace de noms dataSourceMock pour dÃ©finir une nouvelle valeur de retour pour toutes les fonctions dataSourceÂ :

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Notez que dataSourceMock.resetValues() est appelÃ© Ã  la fin. C'est parce que les valeurs sont mÃ©morisÃ©es lorsqu'elles sont modifiÃ©es et doivent Ãªtre rÃ©initialisÃ©es si vous voulez revenir aux valeurs par dÃ©faut.

## Couverture de test

Using **Matchstick**, subgraph developers are able to run a script that will calculate the test coverage of the written unit tests.

L'outil de couverture de test prend les binaires de test `wasm` compilÃ©s et les convertit en fichiers `wat`, qui peuvent ensuite Ãªtre facilement inspectÃ©s pour voir si les gestionnaires dÃ©finis dans `subgraph .yaml` ont Ã©tÃ© appelÃ©s. Ã‰tant donnÃ© que la couverture du code (et les tests dans leur ensemble) en sont Ã  leurs tout premiers stades dans AssemblyScript et WebAssembly, **Matchstick** ne peut pas vÃ©rifier la couverture des branches. Au lieu de cela, nous nous appuyons sur l'affirmation selon laquelle si un gestionnaire donnÃ© a Ã©tÃ© appelÃ©, l'Ã©vÃ©nement/la fonction correspondant a Ã©tÃ© correctement simulÃ©.

### Conditions prÃ©alables

Pour exÃ©cuter la fonctionnalitÃ© de couverture de test fournie dans **Matchstick**, vous devez prÃ©parer quelques Ã©lÃ©ments au prÃ©alableÂ :

#### Exportez vos gestionnaires

Pour que **Matchstick** vÃ©rifie quels gestionnaires sont exÃ©cutÃ©s, ces gestionnaires doivent Ãªtre exportÃ©s Ã  partir du **fichier de test**. Ainsi, par exemple, dans notre exemple, dans notre fichier gravitation.test.ts, nous avons le gestionnaire suivant en cours d'importationÂ :

```typescript
importez { handleNewGravatar } from '../../src/gravity'
```

Pour que cette fonction soit visible (pour qu'elle soit incluse dans le fichier `wat` **par son nom**), nous devons Ã©galement l'exporter, comme ceciÂ :

```typescript
exportez { handleNewGravatar }
```

### Usage

Une fois tout configurÃ©, pour exÃ©cuter l'outil de couverture de test, exÃ©cutez simplementÂ :

```sh
graph test -- -c
```

Vous pouvez Ã©galement ajouter une commande `coverage` personnalisÃ©e Ã  votre fichier `package.json`, comme ceciÂ :

```typescript
 "scripts": {
     /.../
     "coverage": "test graph -- -c"
   },
```

Cela exÃ©cutera l'outil de couverture et vous devriez voir quelque chose comme ceci dans le terminalÂ :

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 ï¸
Reading generated test modules... ğŸ”ï¸

Generating coverage report ğŸ“

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### DurÃ©e d'exÃ©cution du test dans la sortie du journal

La sortie du journal inclut la durÃ©e de lâ€™exÃ©cution du test. Voici un exempleÂ :

`[Jeudi 31 mars 2022 13:54:54 +0300] Programme exÃ©cutÃ© enÂ : 42,270 ms.`

## Common compiler errors

> CritiqueÂ : impossible de crÃ©er WasmInstance Ã  partir d'un module valide avec un contexteÂ : importation inconnueÂ : wasi_snapshot_preview1::fd_write n'a pas Ã©tÃ© dÃ©fini

Cela signifie que vous avez utilisÃ© `console.log` dans votre code, ce qui n'est pas pris en charge par AssemblyScript. Veuillez envisager d'utiliser l'[API Logging](/developing/assemblyscript-api/#logging-api)

> ERREUR TS2554Â : attenduÂ ? arguments, mais j'ai eu ?.
> 
> renvoyer le nouveau ethereum.Block (defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt) ;
> 
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
> 
> ERROR TS2554: Expected ? arguments, but got ?.
> 
> renvoyer un nouveau ethereum.Transaction (defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt) ;
> 
> dans ~lib/matchstick-as/assembly/defaults.ts(24,12)

L'inadÃ©quation des arguments est causÃ©e par une inadÃ©quation entre `graph-ts` et `matchstick-as`. La meilleure faÃ§on de rÃ©soudre des problÃ¨mes comme celui-ci est de tout mettre Ã  jour vers la derniÃ¨re version publiÃ©e.

## Feedback

Si vous avez des questions, des commentaires, des demandes de fonctionnalitÃ©s ou si vous souhaitez simplement nous contacter, le meilleur endroit serait The Graph Discord oÃ¹ nous avons une chaÃ®ne dÃ©diÃ©e Ã  Matchstick, appelÃ©e ğŸ”¥| tests unitaires.
