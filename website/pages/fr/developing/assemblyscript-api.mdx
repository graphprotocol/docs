---
title: API AssemblyScript
---

> Remarque : si vous avez créé un subgraph avant la version `graph-cli`/`graph-ts` `0.22.0`, vous utilisez une ancienne version de AssemblyScript, nous vous recommandons de consulter le [`Guide de migration`](/release-notes/assemblyscript-migration-guide)

Cette page documente les API intégrées qui peuvent être utilisées lors de l'écriture de mappages de subgraphs. Deux types d'API sont disponibles prêtes à l'emploi :

- la [bibliothèque Graph TypeScript](https://github.com/graphprotocol/graph-ts) (`graph-ts`) et
- code généré à partir des fichiers de subgraphs par `graph codegen`.

Il est également possible d'ajouter d'autres bibliothèques comme dépendances, à condition qu'elles soient compatibles avec[AssemblyScript](https://github.com/AssemblyScript/assemblyscript). Puisqu'il s'agit de la langue dans laquelle les mappages sont écrits, le [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki).

## Installation

Subgraphs créés avec [`graph init`](/developing/creating-a-subgraph)viennent avec des dépendances préconfigurées. Pour installer ces dépendances, il suffit d'exécuter l'une des commandes suivantes :

```sh
yarn install # Yarn
npm install  # NPM
```

Si le subgraph a été créé à partir de rien, l'une des deux commandes suivantes installera la bibliothèque TypeScript de The Graph en tant que dépendance :

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## Référence API

La bibliothèque `@graphprotocol/graph-ts` fournit les API suivantes :

- Une `ethereum` API pour travailler avec les contrats intelligents Ethereum, les événements, les blocs, les transactions et les valeurs Ethereum.
- A `store` API to load and save entities from and to the Graph Node store.
- Une API `log` pour consigner les messages dans la sortie du nœud de Graph et dans le Graph Explorer.
- Une API `ipfs` pour charger des fichiers depuis IPFS.
- Une API `json` pour analyser les données JSON.
- Une API `crypto` pour utiliser des fonctions cryptographiques.
- Primitives de bas niveau pour traduire entre différents systèmes de types tels que Ethereum, JSON, GraphQL et AssemblyScript.

### Versions

Le `apiVersion` dans le manifeste du subgraph spécifie la version de l'API de mappage qui est exécutée par Graph Node pour un subgraph donné.

| Version | Notes de version                                                                                                                                                                                                                                                               |
|:-------:| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|  0.0.7  | Ajout des classes `TransactionReceipt` et `Log` aux types Ethereum.<br />Ajout du champ `receipt` à l'objet Ethereum Event                                                                                                                                               |
|  0.0.6  | Ajout du champ `nonce` à l'objet Ethereum Transaction<br />Ajout de `baseFeePerGas` à l'objet Ethereum Block                                                                                                                                                             |
|  0.0.5  | AssemblyScript mis à niveau vers la version 0.19.10 (cela inclut les modifications importantes, veuillez consulter le [`Guide de migration`](/release-notes/assemblyscript-migration-guide))<br />`ethereum.transaction.gasUsed` renommé `ethereum.transaction.gasLimit` |
|  0.0.4  | Ajout du champ `functionSignature` à l'objet Ethereum SmartContractCall                                                                                                                                                                                                        |
|  0.0.3  | Ajout du champ `from` à l'objet Ethereum Call<br />`etherem.call.address` renommé `ethereum.call.to`                                                                                                                                                                     |
|  0.0.2  | Added `input` field to the Ethereum Transaction object                                                                                                                                                                                                                         |

### Types intégrés

La documentation sur les types de base intégrés dans AssemblyScript se trouve dans le [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types).

Les types supplémentaires suivants sont fournis par `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` représente un tableau de `u8`.

_Construction_

- `fromI32(x: i32): ByteArray` - Décompose `x` en octets.
- `fromHexString(hex: string): ByteArray` - La longueur d'entrée doit être paire. Le préfixe `0x` est facultatif.

_Type conversions_

- ` tohexstring (): String ` - Convertit en une chaîne hexagonale préfixée avec ` 0x `.
- `toString(): string` - Interprète les octets comme une chaîne UTF-8.
- `toBase58(): string` - Encode les octets dans une chaîne base58.
- `toU32() : u32` - Interprète les octets comme un `u32` little-endian. Se jette en cas de débordement.
- `toI32() : i32` - Interprète le tableau d'octets comme un petit-endien `i32`. Se jette en cas de débordement.

_Operators_

- `equals(y: ByteArray): bool` – peut être écrit sous la forme `x == y`.
- `concat(other: ByteArray) : ByteArray` - renvoie un nouveau `ByteArray` composé de `this` directement suivi de `other`
- `concatI32(other: i32) : ByteArray` - renvoie un nouveau `ByteArray` composé de `this` directement suivi de la représentation en octets de `other`

#### BigDecimal

```typescript
importer { BigDecimal } depuis '@graphprotocol/graph-ts'
```

`BigDecimal` est utilisé pour représenter des décimales de précision arbitraire.

> Remarque : [En interne](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal` est stocké au [format à virgule flottante IEEE-754 decimal128](https://en.wikipedia.org/wiki/Decimal128_floating-point_format), qui prend en charge 34 chiffres décimaux de mantisse. Cela rend `BigDecimal` [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) or equivalent.

_Construction_

- `constructor(bigInt: BigInt)` – crée un `BigDecimal` à partir d'un `BigInt`.
- `static fromString(s: string): BigDecimal` – analyse à partir d'une chaîne décimale.

_Type conversions_

- `toString() : string` – imprime sous forme d'une chaîne décimale.

_Math_

- `plus(y: BigDecimal) : BigDecimal` – peut être écrit sous la forme `x + y`.
- `minus(y: BigDecimal): BigDecimal` – peut s'écrire comme `x - y`.
- `times(y: BigDecimal): BigDecimal` – peut s'écrire comme `x * y`.
- `div(y: BigDecimal): BigDecimal` – peut s'écrire comme `x / y`.
- `equals(y: BigDecimal): bool` – peut s'écrire comme `x == y`.
- `notEqual(y: BigDecimal): bool` – peut s'écrire comme `x != y`.
- `lt(y: BigDecimal): bool` – peut s'écrire comme `x < y`.
- `le(y: BigDecimal): bool` – peut s'écrire comme `x <= y`.
- `gt(y: BigDecimal): bool` – peut s'écrire comme `x > y`.
- `ge(y: BigDecimal): bool` – peut s'écrire comme `x >= y`.
- `neg(): BigDecimal` - peut s'écrire comme `-x`.

#### BigInt

```typescript
importer { BigInt } depuis '@graphprotocol/graph-ts'
```

`BigInt` est utilisé pour représenter de grands entiers. Cela inclut les valeurs Ethereum de type `uint32` à `uint256` et `int64` à `int256`. Tout ce qui se trouve en dessous de `uint32`, tel que `int32`, `uint24` ou `int8` est représenté par `i32` .

La classe `BigInt` possède l'API suivante :

_Construction_

- `BigInt.fromI32(x: i32) : BigInt` – crée un `BigInt` à partir d'un `i32`.
- `BigInt.fromString(s: string) : BigInt` – Analyse un `BigInt` à partir d'une chaîne.
- `BigInt.fromUnsignedBytes(x: Bytes) : BigInt` – Interprète `bytes` comme un entier petit-boutiste non signé. Si votre entrée est big-endian, appelez d'abord `.reverse()`.
- `BigInt.fromSignedBytes(x: Bytes) : BigInt` – Interprète `bytes` comme un petit-boutiste entier signé. Si votre entrée est big-endian, appelez d'abord `.reverse()`.

  _Type conversions_

- `x.toHex(): string` – transforme `BigInt` en une chaîne de caractères hexadécimaux.
- `x.toString(): string` – transforme `BigInt` en une chaîne de nombres décimaux.
- `x.toI32() : i32` – renvoie le `BigInt` sous la forme d'un `i32` ; échoue si la valeur ne rentre pas dans `i32`. C'est une bonne idée de vérifier d'abord `x.isI32()`.
- `x.toBigDecimal() : BigDecimal` - se convertit en décimal sans partie fractionnaire.

_Math_

- `x.plus(y: BigInt): BigInt` – can be written as `x + y`.
- `x.minus(y: BigInt): BigInt` – peut s'écrire comme `x - y`.
- `x.times(y: BigInt): BigInt` – peut s'écrire comme `x * y`.
- `x.div(y: BigInt): BigInt` – peut s'écrire comme `x / y`.
- `x.mod(y: BigInt): BigInt` – peut s'écrire comme `x % y`.
- `x.equals(y: BigInt): bool` – peut s'écrire comme `x == y`.
- `x.notEqual(y: BigInt): bool` – peut s'écrire comme `x != y`.
- `x.lt(y: BigInt): bool` – peut s'écrire comme `x < y`.
- `x.le(y: BigInt): bool` – peut s'écrire comme `x <= y`.
- `x.gt(y: BigInt): bool` – peut s'écrire comme `x > y`.
- `x.ge(y: BigInt): bool` – peut s'écrire comme `x >= y`.
- `x.neg(): BigInt` – peut s'écrire comme `-x`.
- `x.divDecimal(y: BigDecimal) : BigDecimal` – divise par une décimale, donnant un résultat décimal.
- `x.isZero(): bool` – Commodité pour vérifier si le nombre est zéro.
- `x.isI32(): bool` – Vérifiez si le numéro rentre dans un `i32`.
- `x.abs(): BigInt` – Valeur absolue.
- `x.pow(exp: u8): BigInt` – Exponentiation.
- `bitOr(x: BigInt, y: BigInt): BigInt` – peut s'écrire comme `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – peut s'écrire comme `x & y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – peut s'écrire comme `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – peut s'écrire comme `x >> y`.

#### TypedMap

```typescript
import { TypedMap } du '@graphprotocol/graph-ts'
```

`TypedMap` peut être utilisé pour stocker des paires clé-valeur. Voir [cet exemple](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

La classe `TypedMap` possède l'API suivante :

- `new TypedMap<K, V>()` – crée une carte vide avec des clés de type `K` et des valeurs de type `V`
- `map.set(key: K, value: V): void` – définit la valeur de `key` sur `value`
- `map.getEntry(clé : K) : TypedMapEntry<K, V> | null` – renvoie la paire clé-valeur pour une `clé` ou `null` si la `clé` n'existe pas dans la carte
- `map.get(clé : K) : V | null` – renvoie la valeur d'une `key` ou `null` si la `key` n'existe pas dans la carte
- `map.isSet(key: K): bool` – renvoie `true` si la `key` existe dans la carte et `false` si ça ne fait pas

#### Octets

```typescript
importez { Bytes } du '@graphprotocol/graph-ts'
```

`Bytes` est utilisé pour représenter des tableaux d'octets de longueur arbitraire. Cela inclut les valeurs Ethereum de type `bytes`, `bytes32`, etc.

La classe `Bytes` étend [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) d'AssemblyScript et cela prend en charge toutes les fonctionnalités `Uint8Array`, ainsi que les nouvelles méthodes suivantes :

_Construction_

- `fromHexString(hex: string) : Bytes` - Convertit la chaîne `hex` qui doit être composée d'un nombre pair de chiffres hexadécimaux en un `ByteArray`. La chaîne `hex` peut éventuellement commencer par `0x`
- `fromI32(i: i32) : Bytes` - Convertit `i` en un tableau d'octets

_Type conversions_

- `b.toHex()` – renvoie une chaîne hexadécimale représentant les octets du tableau
- `b.toString()` – convertit les octets du tableau en une chaîne de caractères Unicode
- `b.toBase58()` – transforme une valeur Ethereum Bytes en codage base58 (utilisé pour les hachages IPFS)

_Operators_

- `b.concat(other: Bytes) : Bytes` - - renvoie de nouveaux `Bytes` composés de `this` directement suivi de `other`
- `b.concatI32(other: i32) : ByteArray` - renvoie de nouveaux `Octets` composés de `this` suivi directement de la représentation en octets de `other`

#### Addresse

```typescript
import { Address } du '@graphprotocol/graph-ts'
```

`Address` étend `Bytes` pour représenter les valeurs Ethereum `address`.

Il ajoute la méthode suivante en plus de l'API `Bytes` :

- `Address.fromString(s: string) : Adresse` – crée une `Adresse` à partir d'une chaîne hexadécimale
- `Address.fromBytes(b: Bytes) : Adresse` – créez une `Adresse` à partir de `b` qui doit faire exactement 20 octets de long. Passer une valeur avec moins ou plus d'octets entraînera une erreur

### Store API

```typescript
importer { store } depuis '@graphprotocol/graph-ts'
```

L'API `store` permet de charger, enregistrer et supprimer des entités depuis et vers le magasin Graph Node.

Les entités écrites dans le magasin mappent un à un les types `@entity` définis dans le schéma GraphQL du subgraph. Pour faciliter le travail avec ces entités, la commande `graph codegen` fournie par la [Graph CLI](https://github.com/graphprotocol/graph-cli) génère une entité les classes, qui sont des sous-classes du type intégré `Entity`, avec des getters et setters de propriétés pour les champs du schéma ainsi que des méthodes pour charger et enregistrer ces entités.

#### Création d'entités

Ce qui suit est un modèle courant pour créer des entités à partir d’événements Ethereum.

```typescript
// Importer la classe d'événement Transfer générée à partir de l'ABI ERC20
import { Transférer en tant que TransferEvent } depuis '../generated/ERC20/ERC20'

// Importer le type d'entité Transfer généré à partir du schéma GraphQL
importer {Transférer} depuis '../generated/schema'

// Gestionnaire d'événements de transfert
fonction d'exportation handleTransfer (événement : TransferEvent) : void {
   // Créez une entité de transfert, en utilisant le hachage de transaction comme ID d'entité
   laissez id = event.transaction.hash
   let transfer = nouveau transfert (id)

   // Définir les propriétés de l'entité, en utilisant les paramètres de l'événement
   transfert.from = event.params.from
   transfert.to = event.params.to
   transfert.montant = event.params.montant

   // Enregistre l'entité dans le magasin
   transfert.save()
```

Lorsqu'un événement `Transfer` est rencontré lors du traitement de la chaîne, il est transmis au gestionnaire d'événements `handleTransfer` en utilisant le type `Transfer` généré (alias `TransferEvent` ici pour éviter un conflit de nom avec le type d'entité). Ce type permet d'accéder à des données telles que la transaction parent de l'événement et ses paramètres.

Chaque entité doit avoir un identifiant unique pour éviter les collisions avec d'autres entités. Il est assez courant que les paramètres d'événement incluent un identifiant unique pouvant être utilisé. Remarque : L'utilisation du hachage de transaction comme ID suppose qu'aucun autre événement dans la même transaction ne crée d'entités avec ce hachage comme ID.

#### Chargement d'entités depuis le magasin

Si une entité existe déjà, elle peut être chargée depuis le magasin avec les éléments suivants :

```typescript
let id = event.transaction.hash // ou quelle que soit la manière dont l'ID est construit
laisser transférer = Transfer.load (id)
si (transfert == null) {
   transfert = nouveau transfert (id)
}

// Utiliser l'entité Transfer comme avant
```

Comme l'entité n'existe peut-être pas encore dans le magasin, la méthode `load` renvoie une valeur de type `Transfer | nul`. Il peut donc être nécessaire de vérifier la casse `null` avant d'utiliser la valeur.

> **Remarque :** Le chargement des entités n'est nécessaire que si les modifications appartiennent au mappage dépendant des données précédentes d'une entité. Consultez la section suivante pour connaître les deux manières de mettre à jour les entités existantes.

#### Recherche d'entités créées dans un bloc

Depuis `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 et `@graphprotocol/graph-cli` v0.49.0, le La méthode `loadInBlock` est disponible sur tous les types d'entités.

L'API du magasin facilite la récupération des entités créées ou mises à jour dans le bloc actuel. Une situation typique est qu'un gestionnaire crée une transaction à partir d'un événement en chaîne et qu'un gestionnaire ultérieur souhaite accéder à cette transaction si elle existe. Dans le cas où la transaction n'existe pas, le ubgraph devra se rendre dans la base de données juste pour découvrir que l'entité n'existe pas ; si l'auteur du subgraph sait déjà que l'entité doit avoir été créée dans le même bloc, l'utilisation de loadInBlock évite cet aller-retour dans la base de données. Pour certains subgraphs, ces recherches manquées peuvent contribuer de manière significative au temps d'indexation.

```typescript
let id = event.transaction.hash // ou quelle que soit la manière dont l'ID est construit
laisser transférer = Transfer.loadInBlock (id)
si (transfert == null) {
   transfert = nouveau transfert (id)
}

// Utiliser l'entité Transfer comme avant
```

> Remarque : Si aucune entité n'est créée dans le bloc donné, `loadInBlock` renverra `null` même s'il existe une entité avec l'ID donné dans le magasin.

#### Recherche d'entités dérivées

Depuis `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 et `@graphprotocol/graph-cli` v0.51.0, le La méthode `loadRelated` est disponible.

Cela permet de charger des champs d'entités dérivés à partir d'un gestionnaire d'événements. Par exemple, étant donné le schéma suivant :

```graphql
tapez Jeton @entité {
   je l'ai fait!
   titulaire : Titulaire !
   couleur: Ficelle
}

tapez Titulaire @entity {
   je l'ai fait!
   jetons : [Jeton !] ! @derivedFrom(champ : "titulaire")
}
```

Le code suivant chargera l'entité `Token` dont l'entité `Holder` est dérivée :

```typescript
laissez titulaire = Holder.load('test-id')
// Charge les entités Token associées à un détenteur donné
laissez les jetons = titulaire.tokens.load()
```

#### Mise à jour des entités existantes

Il existe deux manières de mettre à jour une entité existante :

1. Chargez l'entité avec par ex. `Transfer.load(id)`, définissez les propriétés de l'entité, puis `.save()` dans le magasin.
2. Créez simplement l'entité avec par ex. `new Transfer(id)`, définissez les propriétés de l'entité, puis `.save()` dans le magasin. Si l'entité existe déjà, les modifications y sont fusionnées.

La modification des propriétés est simple dans la plupart des cas, grâce aux paramètres de propriétés générés :

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

It is also possible to unset properties with one of the following two instructions:

```typescript
transfer.from.unset()
transfer.from = null
```

Cela ne fonctionne qu'avec les propriétés facultatives, c'est-à-dire les propriétés déclarées sans `!` dans GraphQL. Deux exemples seraient `owner : Bytes` ou `amount : BigInt`.

La mise à jour des propriétés du tableau est un peu plus complexe, car l'obtention d'un tableau à partir d'une entité crée une copie de ce tableau. Cela signifie que les propriétés du tableau doivent être définies à nouveau explicitement après avoir modifié le tableau. Ce qui suit suppose que `entity` a un champ `numbers : [BigInt!]!`.

```typescript
// Cela ne fonctionnera pas
entité.numéros.push(BigInt.fromI32(1))
entité.save()

// Cela fonctionnera
laissez les nombres = entité.numéros
nombres.push(BigInt.fromI32(1))
entité.numéros = nombres
entité.save()
```

#### Supprimer des entités du magasin

Il n'existe actuellement aucun moyen de supprimer une entité via les types générés. Au lieu de cela, la suppression d'une entité nécessite de transmettre le nom du type d'entité et l'ID de l'entité à `store.remove` :

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

L'API Ethereum donne accès aux contrats intelligents, aux variables d'état public, aux fonctions de contrat, aux événements, aux transactions, aux blocs et aux données d'encodage/décodage Ethereum.

#### Prise en charge des types Ethereum

Comme pour les entités, `graph codegen` génère des classes pour tous les contrats intelligents et événements utilisés dans un subgraph. Pour cela, les ABI du contrat doivent faire partie de la source de données dans le manifeste du subgraph. Généralement, les fichiers ABI sont stockés dans un dossier `abis/`.

Avec les classes générées, les conversions entre les types Ethereum et les [types intégrés](#built-in-types) ont lieu en arrière-plan afin que les auteurs de subgraphs n'aient pas à s'en soucier.

The following example illustrates this. Given a subgraph schema like

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

et une signature d'événement `Transfer(address,address,uint256)` sur Ethereum, les valeurs `from`, `to` et `amount` de type `address`, `address` et `uint256` sont convertis en `Address` et `BigInt`, permettant à transmettre aux propriétés `Bytes!` et `BigInt!` de l'entité `Transfer` :

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### Événements et données de bloc/transaction

Les événements Ethereum transmis aux gestionnaires d'événements, tels que l'événement `Transfer` dans les exemples précédents, donnent non seulement accès aux paramètres de l'événement, mais également à leur transaction parent et au bloc dont ils font partie. Les données suivantes peuvent être obtenues à partir des instances `event` (ces classes font partie du module `ethereum` dans `graph-ts`) :

```typescript
événement de classe {
   adresse adresse
   logIndex : BigInt
   transactionLogIndex : BigInt
   logType : chaîne | nul
   bloquer : bloquer
   transaction : transaction
   paramètres : Array<EventParam>
   reçu : TransactionReceipt | nul
}

bloc de classe {
   hachage : octets
   parentHash : octets
   onclesHash : octets
   auteur : Adresse
   stateRoot : octets
   transactionsRoot : octets
   reçusRoot : octets
   numéro : BigInt
   gazUtilisé : BigInt
   limite de gaz : BigInt
   horodatage : BigInt
   difficulté : BigInt
   difficulté totale : BigInt
   taille : BigInt | nul
   baseFeePerGas : BigInt | nul
}

classe Transaction {
   hachage : octets
   indice : BigInt
   de l'adresse
   à : Adresse | nul
   valeur : BigInt
   limite de gaz : BigInt
   prix du gaz : BigInt
   entrée : octets
   occasionnel : BigInt
}

classe TransactionReceipt {
   transactionHash : octets
   Indice de transaction : BigInt
   blockHash : octets
   numéro de bloc : BigInt
   CumulGasUsed : BigInt
   gazUtilisé : BigInt
   contractAddress : Adresse
   journaux : Array<Log>
   statut : BigInt
   racine : octets
   logsBloom : octets
}

Journal de classe {
   adresse adresse
   sujets : Tableau<Octets>
   données : octets
   blockHash : octets
   blockNumber : octets
   transactionHash : octets
   Indice de transaction : BigInt
   logIndex : BigInt
   transactionLogIndex : BigInt
   type de journal : chaîne
   supprimé : booléen | nul
}
```

#### Accès à l'état du contrat intelligent

Le code généré par `graph codegen` comprend également des classes pour les contrats intelligents utilisés dans le subgraph. Ceux-ci peuvent être utilisés pour accéder aux variables d'état publiques et appeler les fonctions du contrat au niveau du bloc actuel.

Un modèle courant consiste à accéder au contrat dont provient un événement. Ceci est réalisé avec le code suivant :

```typescript
// Importer la classe de contrat générée et la classe d'événement de transfert générée
importer {{ ERC20Contract, Transfer as TransferEvent } depuis '../generated/ERC20Contract/ERC20Contract'
// Importer la classe d'entité générée
importer { Transfer } depuis '../generated/schema'

fonction d'exportation handleTransfer (événement : TransferEvent) {
   // Lier le contrat à l'adresse qui a émis l'événement
   laissez contrat = ERC20Contract.bind (event.address)

   // Accédez aux variables d'état et aux fonctions en les appelant
   laissez erc20Symbol = contract.symbol()
}
```

`Transfer` est ici alias `TransferEvent` pour éviter un conflit de nom avec le type d'entité

Tant que le `ERC20Contract` sur Ethereum a une fonction publique en lecture seule appelée `symbol`, il peut être appelé avec `.symbol()`. Pour les variables d'état public, une méthode portant le même nom est créée automatiquement.

Tout autre contrat faisant partie du subgraph peut être importé à partir du code généré et peut être lié à une adresse valide.

#### Gestion des appels retournés

Si les méthodes en lecture seule de votre contrat peuvent revenir, vous devez alors gérer cela en appelant la méthode de contrat générée préfixée par `try_`. Par exemple, le contrat Gravity expose la méthode `gravatarToOwner`. Ce code serait capable de gérer un retour dans cette méthode :

```typescript
laissez gravité = Gravity.bind (event.address)
laissez callResult = gravitation.try_gravatarToOwner (gravatar)
if (callResult.reverted) {
   log.info('getGravatar annulé', [])
} autre {
   laisser le propriétaire = callResult.value
}
```

Notez qu'un nœud Graph connecté à un client Geth ou Infura peut ne pas détecter tous les retours, si vous comptez sur cela, nous vous recommandons d'utiliser un nœud Graph connecté à un client Parity.

#### Encodage/décodage ABI

Les données peuvent être codées et décodées selon le format de codage ABI d'Ethereum à l'aide des fonctions `encode` et `decode` du module `ethereum`.

```typescript
importer { Address, BigInt, ethereum } depuis '@graphprotocol/graph-ts'

laissez tupleArray : Array<ethereum.Value> = [
   ethereum.Value.fromAddress(Address.fromString('0x000000000000000000000000000000000000000420')),
   ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray comme ethereum.Tuple

laissez encoded = ethereum.encode(ethereum.Value.fromTuple(tuple)) !

let decoded = ethereum.decode('(adresse,uint256)', encodé)
```

Pour plus d'informations:

- [ABI Spec](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Encodage/décodage [Bibliothèque Rust/CLI](https://github.com/rust-ethereum/ethabi)
- Plus [complex exemple](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Logging API

```typescript
importer { log } du '@graphprotocol/graph-ts'
```

L'API `log` permet aux subgraphs d'enregistrer des informations dans la sortie standard de Graph Node ainsi que dans Graph Explorer. Les messages peuvent être enregistrés en utilisant différents niveaux de journalisation. Une syntaxe de chaîne de format de base est fournie pour composer les messages de journal à partir d'un argument.

L'API `log` comprend les fonctions suivantes :

- `log.debug(fmt: string, args: Array<string>): void` - logs a debug message.
- `log.info(fmt: string, args: Array<string>): void` - enregistre un message d'information.
- `log.warning(fmt: string, args: Array<string>): void` - enregistre un avertissement.
- `log.error(fmt: string, args: Array<string>): void` - enregistre un message d'erreur.
- `log.critical(fmt: string, args: Array<string>): void` – enregistre un message critique _et_ termine le subgraph.

L'API `log` prend une chaîne de format et un tableau de valeurs de chaîne. Il remplace ensuite les espaces réservés par les valeurs de chaîne du tableau. Le premier espace réservé `{}` est remplacé par la première valeur du tableau, le deuxième espace réservé `{}` est remplacé par la deuxième valeur et ainsi de suite.

```typescript
log.info('Message à afficher : {}, {}, {}', [value.toString(), anotherValue.toString(), 'déjà une chaîne'])
```

#### Enregistrer une ou plusieurs valeurs

##### Enregistrer une seule valeur

Dans l'exemple ci-dessous, la valeur de chaîne "A" est passée dans un tableau pour devenir`['A']` avant d'être journalisée :

```typescript
laissez maValeur = 'A'

fonction d'exportation handleSomeEvent (événement : SomeEvent) : void {
   // Affiche : "Ma valeur est : A"
   log.info('Ma valeur est : {}', [myValue])
```

##### Journalisation d'une seule entrée à partir d'un tableau existant

Dans l'exemple ci-dessous, seule la première valeur du tableau d'arguments est journalisée, bien que le tableau contienne trois valeurs.

```typescript
laissez monTableau = ['A', 'B', 'C']

fonction d'exportation handleSomeEvent (événement : SomeEvent) : void {
   // Affiche : "Ma valeur est : A" (Même si trois valeurs sont passées à `log.info`)
   log.info('Ma valeur est : {}', myArray)
}
```

#### Journalisation de plusieurs entrées d'un tableau existant

Chaque entrée du tableau arguments nécessite son propre espace réservé `{}` dans la chaîne du message du journal. L'exemple ci-dessous contient trois espaces réservés `{}` dans le message du journal. Pour cette raison, les trois valeurs de `myArray` sont enregistrées.

```typescript
laissez monTableau = ['A', 'B', 'C']

fonction d'exportation handleSomeEvent (événement : SomeEvent) : void {
   // Affiche : "Ma première valeur est : A, la deuxième valeur est : B, la troisième valeur est : C"
   log.info('Ma première valeur est : {}, la deuxième valeur est : {}, la troisième valeur est : {}', myArray)
}
```

##### Enregistrer une entrée spécifique à partir d'un tableau existant

Pour afficher une valeur spécifique dans le tableau, la valeur indexée doit être fournie.

```typescript
fonction d'exportation handleSomeEvent (événement : SomeEvent) : void {
   // Affiche : "Ma troisième valeur est C"
   log.info('Ma troisième valeur est : {}', [myArray[2]])
}
```

##### Journalisation des informations sur les événements

L'exemple ci-dessous enregistre le numéro de bloc, le hachage de bloc et le hachage de transaction d'un événement :

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
importer { ipfs } du '@graphprotocol/graph-ts'
```

Les contrats intelligents ancrent parfois les fichiers IPFS sur la chaîne. Cela permet aux mappages d'obtenir les hachages IPFS du contrat et de lire les fichiers correspondants depuis IPFS. Les données du fichier seront renvoyées sous forme de `Octets`, ce qui nécessite généralement un traitement ultérieur, par ex. avec l'API `json` documentée plus loin sur cette page.

Étant donné un hachage ou un chemin IPFS, la lecture d'un fichier depuis IPFS se fait comme suit :

```typescript
// Place cela dans un gestionnaire d'événements dans le mappage
laissez hachage = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
laissez data = ipfs.cat (hachage)

// Chemins comme `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// qui incluent des fichiers dans des répertoires sont également pris en charge
laissez chemin = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
laissez data = ipfs.cat (chemin)
```

**Remarque :** `ipfs.cat` n'est pas déterministe pour le moment. Si le fichier ne peut pas être récupéré sur le réseau IPFS avant l'expiration du délai de requête, il renverra `null`. Pour cette raison, il vaut toujours la peine de vérifier le résultat pour `null`.

Il est également possible de traiter des fichiers plus volumineux en streaming avec `ipfs.map`. La fonction attend le hachage ou le chemin d'un fichier IPFS, le nom d'un rappel et des indicateurs pour modifier son comportement :

```typescript
importer { JSONValue, Value } depuis '@graphprotocol/graph-ts'

fonction d'exportation processItem (valeur : JSONValue, userData : valeur) : void {
   // Voir la documentation JSONValue pour plus de détails sur la gestion
   // avec des valeurs JSON
   laissez obj = valeur.toObject()
   laissez id = obj.get('id')
   laissez titre = obj.get('titre')

   si (!id || !titre) {
       {
    return
  }

   // Les rappels peuvent également créer des entités
   laissez newItem = nouvel élément (id)
   newItem.title = titre.toString()
   newitem.parent = userData.toString() // Définit le parent sur "parentId"
   newitem.save()
}

// Place cela dans un gestionnaire d'événements dans le mappage
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Vous pouvez également utiliser `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

Le seul indicateur actuellement pris en charge est `json`, qui doit être transmis à `ipfs.map`. Avec le flag `json`, le fichier IPFS doit être constitué d'une série de valeurs JSON, une valeur par ligne. L'appel à `ipfs.map` lira chaque ligne du fichier, le désérialisera en `JSONValue` et appellera le rappel pour chacune d'elles. Le rappel peut ensuite utiliser des opérations d'entité pour stocker les données de `JSONValue`. Les modifications d'entité sont stockées uniquement lorsque le gestionnaire qui a appelé `ipfs.map` se termine avec succès ; en attendant, ils sont conservés en mémoire, et la taille du fichier que `ipfs.map` peut traiter est donc limitée.

En cas de succès, `ipfs.map` renvoie `void`. Si une invocation du rappel provoque une erreur, le gestionnaire qui a invoqué `ipfs.map` est abandonné et le subgraph est marqué comme ayant échoué.

### Crypto API

```typescript
importer { crypto } du '@graphprotocol/graph-ts'
```

L'API `crypto` met à disposition des fonctions cryptographiques pour une utilisation dans les mappages. Pour l'instant, il n'y en a qu'un :

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

Les données JSON peuvent être analysées à l'aide de l'API `json` :

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array interpreted as a valid UTF-8 sequence
- `json.try_fromBytes(data: Bytes) : Result<JSONValue, boolean>` – version sécurisée de `json.fromBytes`, il renvoie une variante d'erreur si l'analyse échoue
- `json.fromString(data: string): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(data: string) : Result<JSONValue, boolean>` – version sécurisée de `json.fromString`, elle renvoie une variante d'erreur si l'analyse échoue

La classe `JSONValue` fournit un moyen d'extraire des valeurs d'un document JSON arbitraire. Puisque les valeurs JSON peuvent être des booléens, des nombres, des tableaux et plus encore, `JSONValue` est livré avec une propriété `kind` pour vérifier le type d'une valeur :

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

De plus, il existe une méthode pour vérifier si la valeur est `null` :

- `value.isNull(): boolean`

Lorsque le type d'une valeur est certain, elle peut être convertie en un [type intégré](#built-in-types) en utilisant l'une des méthodes suivantes :

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray() : Array<JSONValue>` - (puis convertissez `JSONValue` avec l'une des 5 méthodes ci-dessus)

### Référence des conversions de types

| Source(s)            | Destination          | Conversion function          |
| -------------------- | -------------------- | ---------------------------- |
| Addresse             | Octets               | aucune                       |
| Addresse             | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | aucune                       |
| Octets (signés)      | BigInt               | BigInt.fromSignedBytes(s)    |
| Octets (non signés)  | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Octets               | String (hexadecimal) | s.toHexString() or s.toHex() |
| Octets               | String (unicode)     | s.toString()                 |
| Octets               | String (base58)      | s.toBase58()                 |
| Octets               | i32                  | s.toI32()                    |
| Octets               | u32                  | s.toU32()                    |
| Octets               | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | aucune                       |
| int32                | i32                  | aucune                       |
| int32                | BigInt               | BigInt.fromI32(s)            |
| uint24               | i32                  | aucune                       |
| int64 - int256       | BigInt               | aucune                       |
| uint32 - uint256     | BigInt               | aucune                       |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Addresse             | Address.fromString(s)        |
| Octets               | Addresse             | Address.fromBytes(s)         |
| String               | BigInt               | BigInt.fromString(s)         |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Octets               | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Octets               | ByteArray.fromUTF8(s)        |

### Métadonnées de la source de données

Vous pouvez inspecter l'adresse du contrat, le réseau et le contexte de la source de données qui a appelé le gestionnaire via l'espace de noms `dataSource` :

- `dataSource.address() : Adresse`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entité et DataSourceContext

La classe de base `Entity` et la classe enfant `DataSourceContext` ont des aides pour définir et obtenir dynamiquement les champs :

- `tString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: octets): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): octets`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### DataSourceContext in Manifest

La section `context` dans `dataSources` vous permet de définir des paires clé-valeur accessibles dans vos mappages de subgraphs. Les types disponibles sont `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, < `>Octets`, `Liste` et `BigInt`.

Voici un exemple YAML illustrant l'utilisation de différents types dans la section `context` :

```yaml
dataSources:
  - kind: ethereum/contract
    name: ContractName
    network: mainnet
    context:
      bool_example:
        type: Bool
        data: true
      string_example:
        type: String
        data: 'hello'
      int_example:
        type: Int
        data: 42
      int8_example:
        type: Int8
        data: 127
      big_decimal_example:
        type: BigDecimal
        data: '10.99'
      bytes_example:
        type: Bytes
        data: '0x68656c6c6f'
      list_example:
        type: List
        data:
          - type: Int
            data: 1
          - type: Int
            data: 2
          - type: Int
            data: 3
      big_int_example:
        type: BigInt
        data: '1000000000000000000000000'
```

- `Bool` : Spécifie une valeur booléenne (`true` ou `false`).
- `String` : Spécifie une valeur de chaîne.
- `Int` : Spécifie un entier de 32 bits.
- `Int8` : Spécifie un entier de 8 bits.
- `BigDecimal` : Spécifie un nombre décimal. Doit être cité.
- `BigDecimal`  : spécifie un nombre décimal. Doit être cité.
- `Liste` : Spécifie une liste d'éléments. Chaque élément doit spécifier son type et ses données.
- `BigInt` : Spécifie une grande valeur entière. Doit être cité en raison de sa grande taille.

Ce contexte est ensuite accessible dans vos fichiers de mappage de subgraphs, permettant des subgraphs plus dynamiques et configurables.

### Common AssemblyScript Issues

Il existe certains problèmes [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) qui sont courants lors du développement de subgraphs. Leur difficulté de débogage varie, cependant, en être conscient peut aider. Voici une liste non exhaustive de ces problèmes :

- Les variables de classe `Private` ne sont pas appliquées dans [AssembyScript](https://www.assemblyscript.org/status.html#langage-features). Il n'existe aucun moyen de protéger les variables de classe contre une modification directe à partir de l'objet de classe.
- La portée n'est pas héritée des [fonctions de fermeture](https://www.assemblyscript.org/status.html#on-closures), c'est-à-dire que les variables déclarées en dehors des fonctions de fermeture ne peuvent pas être utilisées. Explication dans les [Points forts des développeurs n° 3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s).
