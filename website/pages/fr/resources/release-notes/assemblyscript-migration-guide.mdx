---
title: Guide de migration de l'AssemblyScript
---

Jusqu'√† pr√©sent, les subgraphs utilisaient l'une des [premi√®res versions d'AssemblyScript](https://github.com/AssemblyScript/assemblyscript/tree/v0.6) (v0.6). Nous avons enfin ajout√© la prise en charge de la [derni√®re version disponible](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10) ! üéâ

Cela permettra aux d√©veloppeurs de subgraph d'utiliser les nouvelles fonctionnalit√©s du langage AS et de la biblioth√®que standard.

Ce guide s'applique √† tous ceux qui utilisent `graph-cli`/`graph-ts` en dessous de la version `0.22.0`. Si vous √™tes d√©j√† √† une version sup√©rieure (ou √©gale) √† celle-ci, vous avez d√©j√† utilis√© la version `0.19.10` d'AssemblyScript üôÇ

> Note : A partir de `0.24.0`, `graph-node` peut supporter les deux versions, en fonction de la `apiVersion` sp√©cifi√©e dans le manifeste du subgraph.

## Fonctionnalit√©s

### Nouvelle fonctionnalit√©

- Les `TypedArray`s peuvent maintenant √™tre construits √† partir des `ArrayBuffer`s en utilisant la [nouvelle m√©thode statique `wrap`](https://www.assemblyscript.org/stdlib/typedarray.html#static-members) ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1))
- Nouvelles fonctions de la biblioth√®que standard : `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare` et `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Ajout de la prise en charge de x instanceof GenericClass ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Ajout de `StaticArray<T>`, une variante de tableau plus efficace ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- Ajout de `Array<T>#flat` ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Impl√©mentation de l'argument `radix` sur `Number#toString` ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- Ajout de la prise en charge des s√©parateurs dans les nombres √† virgule flottante ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7))
- Prise en charge des fonctions de premi√®re classe ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0))
- Ajouter des √©l√©ments int√©gr√©s suivants: `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- Impl√©mentation de `Array/TypedArray/String#at` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- Ajout de la prise en charge des mod√®les de cha√Ænes de caract√®res ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- Ajout de `encodeURI(Component)` et `decodeURI(Component)` ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- Ajout de `toString`, `toDateString` et `toTimeString` √† `Date` ([v0.18.29](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- Ajout de `toUTCString` pour `Date` ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- Ajout du type int√©gr√© `nonnull/NonNullable` ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### Optimizations

- Les fonctions math√©matiques telles que `exp`, `exp2`, `log`, `log2` et `pow` ont √©t√© remplac√©es par des variantes plus rapides ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Optimisation l√©g√®re de `Math.mod` ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- Mise en cache de plus d'acc√®s aux champs dans std Map et Set ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
- Optimisation pour les puissances de deux dans `ipow32/64` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### Autre

- The type of an array literal can now be inferred from its contents ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Updated stdlib to Unicode 13.0.0 ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))

## Comment mettre √† niveau ?

1. Change your mappings `apiVersion` in `subgraph.yaml` to `0.0.6`:

```yaml
...
dataSources:
  ...
    mapping:
      ...
      apiVersion: 0.0.6
      ...
```

2. Update the `graph-cli` you're using to the `latest` version by running:

```bash
# si vous l'avez install√© globalement
npm install --global @graphprotocol/graph-cli@latest

# ou dans votre subgraph si vous l'avez comme d√©pendance de d√©veloppement
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. Do the same for `graph-ts`, but instead of installing globally, save it in your main dependencies:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. Suivez le reste du guide pour corriger les changements de langue.
5. Run `codegen` and `deploy` again.

## Modifications radicales

### Nullability

Sur l'ancienne version d'AssemblyScript, vous pouviez cr√©er du code comme celui-ci¬†:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

Cependant, sur la version la plus r√©cente, comme la valeur est nullable, vous devez v√©rifier, comme ceci¬†:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` n'est plus nul
}
```

Ou forcez-le comme ceci¬†:

```typescript
let maybeValue = load()! // breaks in runtime if value is null

maybeValue.aMethod()
```

Si vous ne savez pas lequel choisir, nous vous recommandons de toujours utiliser la version s√©curis√©e. Si la valeur n'existe pas, vous souhaiterez peut-√™tre simplement effectuer une instruction if pr√©coce avec un retour dans votre gestionnaire de subgraph.

### Ombrage variable

Before you could do [variable shadowing](https://en.wikipedia.org/wiki/Variable_shadowing) and code like this would work:

```typescript
let a = 10
let b = 20
let a = a + b
```

Cependant, cela n'est plus possible et le compilateur renvoie cette erreur¬†:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

Vous devrez renommer vos variables en double si vous conservez une observation de variables.

### Comparaisons nulles

En effectuant la mise √† niveau sur votre subgraph, vous pouvez parfois obtenir des erreurs comme celles-ci¬†:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

To solve you can simply change the `if` statement to something like this:

```typescript
  if (!decimals) {

  // or

  if (decimals === null) {
```

La m√™me chose s'applique si vous faites != au lieu de ==.

### Casting

The common way to do casting before was to just use the `as` keyword, like this:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // equivalent to: <Uint8Array>byteArray
```

Cependant, cela ne fonctionne que dans deux sc√©narios¬†:

- Primitive casting (between types such as `u8`, `i32`, `bool`; eg: `let b: isize = 10; b as usize`);
- Upcasting sur l'h√©ritage de classe (sous-classe ‚Üí superclasse)

Les Exemples:

```typescript
// primitive casting
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
// upcasting on class inheritance
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // same as: bytes as Uint8Array
```

There are two scenarios where you may want to cast, but using `as`/`<T>var` **isn't safe**:

- Downcasting sur l'h√©ritage de classe (superclasse ‚Üí sous-classe)
- Entre deux types qui partagent une superclasse

```typescript
// downcasting on class inheritance
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // breaks in runtime :(
```

```typescript
// between two types that share a superclass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // breaks in runtime :(
```

For those cases, you can use the `changetype<T>` function:

```typescript
// downcasting on class inheritance
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // works :)
```

```typescript
// between two types that share a superclass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // works :)
```

If you just want to remove nullability, you can keep using the `as` operator (or `<T>variable`), but make sure you know that value can't be null, otherwise it will break.

```typescript
// supprimer la possibilit√© de valeur nulle (nullability)
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // suppression s√ªre de null
}

let newBalance = new AccountBalance(balanceId)
```

For the nullability case we recommend taking a look at the [nullability check feature](https://www.assemblyscript.org/basics.html#nullability-checks), it will make your code cleaner üôÇ

Nous avons √©galement ajout√© quelques m√©thodes statiques suppl√©mentaires dans certains types pour faciliter la diffusion, √† savoir¬†:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### V√©rification de nullit√© avec acc√®s √† la propri√©t√©

To use the [nullability check feature](https://www.assemblyscript.org/basics.html#nullability-checks) you can use either `if` statements or the ternary operator (`?` and `:`) like this:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// ou

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

However that only works when you're doing the `if` / ternary on a variable, not on a property access, like this:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // ne compile pas
```

Ce qui g√©n√®re cette erreur¬†:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Pour r√©soudre ce probl√®me, vous pouvez cr√©er une variable pour l'acc√®s √† cette propri√©t√© afin que le compilateur puisse effectuer la v√©rification magique de la nullit√©¬†:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // compile sans probl√®me :)
```

### Surcharge de l'op√©rateur avec acc√®s √† la propri√©t√©

Si vous essayez de additionner (par exemple) un type nullable (√† partir d'un acc√®s √† une propri√©t√©) avec un type non nullable, le compilateur AssemblyScript au lieu de donner une erreur de compilation avertissant que l'une des valeurs est nullable, il compile simplement silencieusement, donnant une chance pour que le code soit interrompu au moment de l'ex√©cution.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // donne une erreur de compilation concernant la nullit√©
let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // ne donne pas d'erreurs de compilation comme il se doit
```

Nous avons ouvert un probl√®me sur le compilateur AssemblyScript pour cela, mais pour l'instant, si vous effectuez ce type d'op√©rations dans vos mappages de subgraph, vous devez les modifier pour effectuer une v√©rification nulle avant.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // maintenant `n` est garanti comme √©tant un BigInt
```

### Initialisation de valeur

Si vous avez un code comme celui-ci¬†:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

Il sera compil√© mais s'arr√™tera au moment de l'ex√©cution, cela se produit parce que la valeur n'a pas √©t√© initialis√©e, alors assurez-vous que votre subgraph a initialis√© ses valeurs, comme ceci¬†:

```typescript
var value = new Type() // initialized
value.x = 10
value.y = 'content'
```

De plus, si vous avez des propri√©t√©s nullables dans une entit√© GraphQL, comme ceci¬†:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

Et vous avez un code similaire √† celui-ci¬†:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

You'll need to make sure to initialize the `total.amount` value, because if you try to access like in the last line for the sum, it will crash. So you either initialize it first:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

Or you can just change your GraphQL schema to not use a nullable type for this property, then we'll initialize it as zero on the `codegen` step üòâ

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
    total = new Total('latest') // initialise d√©j√† les propri√©t√©s non-nullables
}

total.amount = total.amount + BigInt.fromI32(1)
```

### Initialisation de la propri√©t√© de classe

Si vous exportez des classes avec des propri√©t√©s qui sont d'autres classes (d√©clar√©es par vous ou par la biblioth√®que standard), comme ceci¬†:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

The compiler will error because you either need to add an initializer for the properties that are classes, or add the `!` operator:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// ou

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// ou

export class Something {
  value!: Thing
}
```

### Initialisation du tableau

The `Array` class still accepts a number to initialize the length of the list, however you should take care because operations like `.push` will actually increase the size instead of adding to the beginning, for example:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // size 6 :(
```

En fonction des types que vous utilisez, par exemple les types nullables, et de la mani√®re dont vous y acc√©dez, vous pourriez rencontrer une erreur d'ex√©cution comme celle-ci¬†:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

To actually push at the beginning you should either, initialize the `Array` with size zero, like this:

```typescript
let arr = new Array<string>(0) // []

arr.push('something') // ["quelque chose"]
```

Ou vous devriez le muter via index¬†:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'something' // ["quelque chose", "", "", "", ""]
```

### Sch√©ma GraphQL

Il ne s'agit pas d'un changement direct d'AssemblyScript, mais vous devrez peut-√™tre mettre √† jour votre fichier `schema.graphql`.

Vous ne pouvez d√©sormais plus d√©finir de champs dans vos types qui sont des listes non nullables. Si vous avez un sch√©ma comme celui-ci :

```graphql
type Something @entity {
    id: Bytes!
}

type MyEntity @entity {
    id: Bytes!
    invalidField: [Something]! # n'est plus valide
}
```

Vous devrez ajouter un `!` au membre du type List, comme ceci :

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # valide
}
```

This changed because of nullability differences between AssemblyScript versions, and it's related to the `src/generated/schema.ts` file (default path, you might have changed this).

### Autre

- Alignement de `Map#set` et `Set#add` avec la sp√©cification, retournant `this` ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Arrays no longer inherit from ArrayBufferView, but are now distinct ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Classes initialized from object literals can no longer define a constructor ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Le r√©sultat d'une op√©ration binaire `**` est maintenant l'entier de d√©nominateur commun si les deux op√©randes sont des entiers. Auparavant, le r√©sultat √©tait un flottant comme si l'on appelait `Math/f.pow` ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- Contraindre `NaN` √† `false` lors d'une conversion de type vers `bool` ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9))
- When shifting a small integer value of type `i8`/`u8` or `i16`/`u16`, only the 3 respectively 4 least significant bits of the RHS value affect the result, analogous to the result of an `i32.shl` only being affected by the 5 least significant bits of the RHS value. Example: `someI8 << 8` previously produced the value `0`, but now produces `someI8` due to masking the RHS as `8 & 7 = 0` (3 bits) ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0))
- Bug fix of relational string comparisons when sizes differ ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
