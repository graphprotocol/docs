---
title: Deploying a Subgraph to the Hosted Service
---

> Si un réseau n'est pas pris en charge sur le service hébergé, vous pouvez exécuter votre propre [graph-node](https://github.com/graphprotocol/graph-node) pour l'indexer.

Cette page explique comment déployer un subgraph dans le service hébergé. Pour déployer un subgraph, vous devez d'abord installer le [Graph CLI](https://github.com/graphprotocol/graph-cli). Si vous n'avez pas encore créé de subgraph, consultez [créer un subgraph](/developing/creating-a-subgraph).

## Créer un compte de service hébergé

Avant d'utiliser le service hébergé, créez un compte dans notre service hébergé. Vous aurez besoin d'un compte [Github](https://github.com/) pour cela ; si vous n’en avez pas, vous devez d’abord le créer. Ensuite, accédez au [Service hébergé](https://thegraph.com/hosted-service/), cliquez sur _'Inscrivez-vous avec Github'. _ et terminez le flux d'autorisation de Github.

## Stocker le jeton d'accès

Après avoir créé un compte, accédez à votre [tableau de bord](https://thegraph.com/hosted-service/dashboard). Copiez le jeton d'accès affiché sur le tableau de bord et exécutez `graph auth --product hosted-service <ACCESS_TOKEN>`. Le jeton d'accès sera ainsi stocké sur votre ordinateur. Vous ne devez effectuer cette opération qu'une seule fois, ou si vous régénérez le jeton d'accès.

## Créer un subgraph sur le service hébergé

Avant de déployer le subgraph, vous devez le créer dans The Graph Explorer. Accédez au [tableau de bord](https://thegraph.com/hosted-service/dashboard), cliquez sur le bouton _'Ajouter un subgraph'_ et remplissez les informations ci-dessous, le cas échéant :

**Image** - Sélectionnez une image à utiliser comme image de prévisualisation et comme vignette pour le subgraph.

**Nom du sous-graphe** - Avec le nom du compte sous lequel le sous-graphe est créé, ce champ définit également le nom de style `nom du compte/nom du sous-graphe` utilisé pour les déploiements et les points de terminaison GraphQL. _Ce champ ne peut pas être modifié ultérieurement._

**Compte** : le compte sous lequel le subgraph est créé. Il peut s'agir du compte d'un individu ou d'une organisation. _Les subgraphs ne pourront pas être déplacés ultérieurement entre les comptes._

**Sous-titre** : texte qui apparaîtra dans les cartes subgraphs.

**Description** - Description du Subgraph, visible sur la page de détails du subgraph.

**GitHub URL** - Lien vers le dépôt du subgraph sur GitHub.

**Cacher** - Cette option permet de cacher le subgraph dans the Graph Explorer.

Après avoir enregistré le nouveau subgraph, un écran s'affiche avec de l'aide sur la façon d'installer la CLI Graph, de générer l'échafaudage pour un nouveau subgraph et de déployer votre subgraph. Les deux premières étapes ont été couvertes dans la section [Définition d'un subgraph](/developing/defining-a-subgraph).

## Déployer un subgraph sur le service hébergé

Le déploiement de votre subgraph téléchargera les fichiers du subgraph que vous avez construit avec `yarn build` vers IPFS et indiquera à the Graph Explorer de commencer à indexer votre subgraph à l'aide de ces fichiers.

Vous déployez le subgraph en exécutant `yarn deploy`

Après avoir déployé le subgraph, the Graph Explorer affichera l'état de synchronisation de votre subgraph. Selon la quantité de données et le nombre d'événements qui doivent être extraits des blocs historiques, en commençant par le bloc Genesis, la synchronisation peut prendre de quelques minutes à plusieurs heures.

L'état du subgraph passe à `Synced` une fois que le nœud the Graph a extrait toutes les données des blocs historiques. Le nœud de the Graph continuera à inspecter les blocs de votre subgraph au fur et à mesure que ces blocs seront exploités.

## Redéployer un Subgraph

Lorsque vous apportez des modifications à la définition de votre subgraph, par exemple pour corriger un problème dans les mappages d'entités, exécutez à nouveau la commande `yarn deploy` ci-dessus pour déployer la version mise à jour de votre subgraph.

Si votre subgraph précédemment déployé est toujours en statut `Synchronisation`, il sera immédiatement remplacé par la version nouvellement déployée. Si le subgraph précédemment déployé est déjà entièrement synchronisé, Graph Node marquera la nouvelle version déployée comme `Version en attente`, la synchronisera en arrière-plan et ne remplacera la version actuellement déployée par la nouvelle qu'une fois la synchronisation de la nouvelle version terminée. Cela permet de s'assurer que vous disposez d'un subgraph avec lequel travailler pendant la synchronisation de la nouvelle version.

## Déploiement du subgraph sur plusieurs réseaux

Dans certains cas, vous souhaiterez déployer le même subgraph sur plusieurs réseaux sans dupliquer tout son code. Le principal défi qui en découle est que les adresses contractuelles sur ces réseaux sont différentes.

### Utiliser graph-cli

Le `graph build` (depuis `v0.29.0`) et le `graph déployer` (depuis `v0.32.0`) acceptent deux nouvelles options :

```sh
Options:

      ...
      --network <name>          Network configuration to use from the networks config file
      --network-file <path>     Networks config file path (default: "./networks.json")
```

You can use the `--network` option to specify a network configuration from a `json` standard file (defaults to `networks.json`) to easily update your subgraph during development.

**Note:** The `init` command will now auto-generate a `networks.json` based on the provided information. You will then be able to update existing or add additional networks.

If you don't have a `networks.json` file, you'll need to manually create one with the following structure:

```json
{
    "network1": { // the network name
        "dataSource1": { // the dataSource name
            "address": "0xabc...", // the contract address (optional)
            "startBlock": 123456 // the startBlock (optional)
        },
        "dataSource2": {
            "address": "0x123...",
            "startBlock": 123444
        }
    },
    "network2": {
        "dataSource1": {
            "address": "0x987...",
            "startBlock": 123
        },
        "dataSource2": {
            "address": "0xxyz..",
            "startBlock": 456
        }
    },
    ...
}
```

**Note:** You don't have to specify any of the `templates` (if you have any) in the config file, only the `dataSources`. If there are any `templates` declared in the `subgraph.yaml` file, their network will be automatically updated to the one specified with the `--network` option.

Now, let's assume you want to be able to deploy your subgraph to the `mainnet` and `goerli` networks, and this is your `subgraph.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x123...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

This is what your networks config file should look like:

```json
{
  "mainnet": {
    "Gravity": {
      "address": "0x123..."
    }
  },
  "goerli": {
    "Gravity": {
      "address": "0xabc..."
    }
  }
}
```

Now we can run one of the following commands:

```sh
# Using default networks.json file
yarn build --network goerli

# Using custom named file
yarn build --network goerli --network-file path/to/config
```

The `build` command will update your `subgraph.yaml` with the `goerli` configuration and then re-compile the subgraph. Your `subgraph.yaml` file now should look like this:

```yaml
# ...
dataSources :
  - type : ethereum/contrat
    nom : Gravity
    réseau : goerli
    source :
      adresse : '0xabc...'
      abi : Gravité
    mapping :
      kind : ethereum/events
```

Now you are ready to `yarn deploy`.

**Note:** As mentioned earlier, since `graph-cli 0.32.0` you can directly run `yarn deploy` with the `--network` option:

```sh
# Using default networks.json file
yarn deploy --network goerli

# Using custom named file
yarn deploy --network goerli --network-file path/to/config
```

### Using subgraph.yaml template

One solution for older graph-cli versions that allows to parameterize aspects like contract addresses is to generate parts of it using a templating system like [Mustache](https://mustache.github.io/) or [Handlebars](https://handlebarsjs.com/).

To illustrate this approach, let's assume a subgraph should be deployed to mainnet and Goerli using different contract addresses. You could then define two config files providing the addresses for each network:

```json
{
   "network": "réseau principal",
   "adresse": "0x123..."
}
```

and

```json
{
   "réseau": "goerli",
   "adresse": "0xabc..."
}
```

Along with that, you would substitute the network name and addresses in the manifest with variable placeholders `{{network}}` and `{{address}}` and rename the manifest to e.g. `subgraph.template.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/événements
```

In order to generate a manifest to either network, you could add two additional commands to `package.json` along with a dependency on `mustache`:

```json
{
   ...
   "scripts": {
     ...
     "prepare:mainnet": "moustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
     "prepare:goerli": "mustache config/goerli.json subgraph.template.yaml > subgraph.yaml"
   },
   "dépendances dev": {
     ...
     "moustache": "^3.1.0"
   }
}
```

To deploy this subgraph for mainnet or Goerli you would now simply run one of the two following commands:

```sh
# Mainnet:
fil préparer:mainnet && déploiement de fil

# Goerli :
fil préparer:goerli && déploiement de fil
```

A working example of this can be found [here](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759).

**Note:** This approach can also be applied to more complex situations, where it is necessary to substitute more than contract addresses and network names or where generating mappings or ABIs from templates as well.

## Checking subgraph health

If a subgraph syncs successfully, that is a good sign that it will continue to run well forever. However, new triggers on the network might cause your subgraph to hit an untested error condition or it may start to fall behind due to performance issues or issues with the node operators.

Graph Node exposes a graphql endpoint which you can query to check the status of your subgraph. On the Hosted Service, it is available at `https://api.thegraph.com/index-node/graphql`. On a local node, it is available on port `8030/graphql` by default. The full schema for this endpoint can be found [here](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql). Here is an example query that checks the status of the current version of a subgraph:

```graphql
{
   indexingStatusForCurrentVersion(subgraphName : "org/subgraph") {
     synchronisé
     santé
     erreur fatale {
       message
       bloc "{         nombre
         hacher
       }
       gestionnaire
     }
     Chaînes {
       chaîneHeadBlock "{
         nombre
       }
       dernierBloc 
"{
        nombre
       }
     }
   }
}
```

This will give you the `chainHeadBlock` which you can compare with the `latestBlock` on your subgraph to check if it is running behind. `synced` informs if the subgraph has ever caught up to the chain. `health` can currently take the values of `healthy` if no errors occurred, or `failed` if there was an error which halted the progress of the subgraph. In this case, you can check the `fatalError` field for details on this error.

## Hosted service subgraph archive policy

The Hosted Service is a free Graph Node Indexer. Developers can deploy subgraphs indexing a range of networks, which will be indexed, and made available to query via graphQL.

To improve the performance of the service for active subgraphs, the Hosted Service will archive subgraphs that are inactive.

**A subgraph is defined as "inactive" if it was deployed to the Hosted Service more than 45 days ago, and if it has received 0 queries in the last 45 days.**

Les développeurs seront avertis par courriel si l'un de leurs subgraphs a été marqué comme inactif 7 jours avant qu'il ne soit supprimé. S'ils souhaitent "activer" leur subgraph, ils peuvent le faire en effectuant une requête dans le terrain de jeu graphQL du service hébergé de leur subgraph. Les développeurs peuvent toujours redéployer un subgraph archivé s'il est à nouveau nécessaire.

## Subgraph Studio subgraph archive policy

When a new version of a subgraph is deployed, the previous version is archived (deleted from the graph-node DB). This only happens if the previous version is not published to The Graph's decentralized network.

When a subgraph version isn’t queried for over 45 days, that version is archived.

Chaque subgraph concerné par cette politique dispose d'une option de restauration de la version en question.
