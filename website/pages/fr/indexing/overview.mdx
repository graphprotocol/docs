---
title: Vue d’ensemble de l’indexation
---

Les indexeurs sont des opérateurs de nœuds dans The Graph Network qui mettent en jeu des jetons Graph (GRT) afin de fournir des services d'indexation et de traitement de requêtes. Les indexeurs perçoivent des frais de requête et des récompenses d'indexation pour leurs services. Ils perçoivent également des frais de requête qui sont réduits selon une fonction de remise exponentielle.

Le GRT intégré au protocole est soumis à une période de décongélation et peut être réduit si les indexeurs sont malveillants et fournissent des données incorrectes aux applications ou s'ils indexent de manière incorrecte. Les indexeurs gagnent également des récompenses pour la participation déléguée des délégués, afin de contribuer au réseau.

Les indexeurs sélectionnent les subgraphs à indexer en fonction du signal de curation du subgraph, où les curateurs misent du GRT afin d'indiquer quels subgraphs sont de haute qualité et doivent être priorisés. Les consommateurs (par exemple les applications) peuvent également définir les paramètres pour lesquels les indexeurs traitent les requêtes pour leurs subgraphs et définir les préférences pour la tarification des frais de requête.

<Difficulty level="ADVANCED" />

## Questions fréquemment posées

### Quelle est la mise minimale requise pour être indexeur sur le réseau ?

La mise minimale pour un indexeur est actuellement fixée à 100 000 GRT.

### Quelles sont les sources de revenus pour un indexeur ?

**Remboursements des frais de requête** - Paiements pour le traitement des requêtes sur le réseau. Ces paiements sont gérés via des canaux d’état entre un Indexeur et une passerelle. Chaque demande de requête provenant d'une passerelle contient un paiement et la réponse correspondante, une preuve de validité du résultat de la requête.

**Récompenses d'indexation** - Générées via une inflation annuelle de 3 % à l'échelle du protocole, les récompenses d'indexation sont distribuées aux Indexeurs qui indexent les déploiements de subgraph pour le réseau.

### Comment sont distribuées les récompenses d’indexation ?

Les récompenses d'indexation proviennent de l'inflation du protocole fixée à 3 % d'émission annuelle. Elles sont distribuées à travers les subgraphs en fonction de la proportion de tous les signaux de curation sur chacun, puis distribuées proportionnellement aux Indexeurs en fonction de leur participation allouée à ce subgraph. **Une allocation doit être fermée avec une preuve d'indexation (POI) valide, qui répond aux normes définies par la charte d'arbitrage pour être éligible aux récompenses**

De nombreux outils ont été créés par la communauté pour calculer les récompenses ; vous en trouverez une collection organisée dans la [collection Guides communautaires](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). Vous pouvez également trouver une liste à jour des outils dans les canaux #Delegators et #Indexers sur le [serveur Discord](https://discord.gg/graphprotocol). Nous proposons ici un [optimiseur d'allocation recommandé](https://github.com/graphprotocol/allocation-optimizer) intégré à la pile logicielle d'indexation.

### Qu'est-ce qu'une preuve d'indexation (POI) ?

Les POI sont utilisés dans le réseau pour vérifier qu'un indexeur indexe les subgraphs sur lesquels ils ont été alloués. Un POI pour le premier bloc de l'époque actuelle doit être soumis lors de la clôture d'une allocation pour que cette allocation soit éligible aux récompenses d'indexation. Un POI pour un bloc est un résumé de toutes les transactions du magasin d'entités pour un déploiement de subgraph spécifique jusqu'à ce bloc inclus.

### Quand les récompenses d’indexation sont-elles distribuées ?

Les allocations accumulent continuellement des récompenses pendant qu'elles sont actives et allouées dans un délai de 28 époques. Les récompenses sont collectées par les indexeurs et distribuées chaque fois que leurs allocations sont clôturées. Cela se produit soit manuellement, chaque fois que l'indexeur souhaite forcer leur fermeture, soit après 28 époques, un délégant peut fermer l'allocation pour l'indexeur, mais cela n'entraîne aucune récompense. 28 époques est la durée de vie maximale de l'allocation (à l'heure actuelle, une époque dure environ 24 heures).

### Les récompenses d’indexation en attente peuvent-elles être surveillées ?

Le contrat RewardsManager dispose d'une fonction en lecture seule [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316) qui peut être utilisée pour vérifier les récompenses en attente pour une allocation spécifique.

De nombreux tableaux de bord créés par la communauté incluent des valeurs de récompenses en attente et ils peuvent être facilement vérifiés manuellement en suivant ces étapes :

1. Interroger le [subgraph du mainnet] (https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one) pour obtenir les identifiants de toutes les allocations actives :

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Utilisez Etherscan pour appeler la fonction `getRewards()` :

- Naviguer vers l'[interface Etherscan du contrat Rewards](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)

<!---->

- Pour appeler la fonction `getRewards()` :
  - Développez la liste déroulante **9. getRewards**.
  - Saisissez l'**allocationID** dans le champ de saisie.
  - Cliquez sur le bouton **Query**.

### Que sont les litiges et où puis-je les consulter ?

Les requêtes et les allocations de l'indexeur peuvent toutes deux être contestées sur The Graph pendant la période de contestation. Le délai de contestation varie selon le type de litige. Les requêtes/attestations ont une fenêtre de contestation de 7 époques, tandis que les allocations ont 56 époques. Passé ces délais, aucun litige ne peut être ouvert ni contre les attributions ni contre les requêtes. Lorsqu'un litige est ouvert, une caution d'un minimum de 10 000 GRT est exigée par les pêcheurs, qui sera verrouillée jusqu'à ce que le litige soit finalisé et qu'une résolution soit trouvée. Les pêcheurs sont tous les participants au réseau qui ouvrent des différends.

Les litiges ont **trois** issues possibles, tout comme le dépôt des Fishermen.

- Si la contestation est rejetée, le GRT déposé par les Pêcheurs sera brûlé, et l'Indexeur contesté ne sera pas sabré.
- Si le différend est réglé par un match nul, la caution du pêcheur sera restituée et l'indexeur contesté ne sera pas réduit.
- Si la contestation est acceptée, le GRT déposé par les Pêcheurs sera restitué, l'Indexeur contesté sera réduit et les Pêcheurs gagneront 50% du GRT réduit.

Les litiges peuvent être consultés dans l'interface utilisateur sur la page de profil d'un Indexeur sous l'onglet « litiges ».

### Que sont les remises sur les frais de requête et quand sont-elles distribuées ?

Les frais de requêtes sont collectés par la passerelle et distribués aux indexeurs selon une fonction de remboursement exponentielle (voir la proposition GIP [ici](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). La fonction de remboursement exponentiel est proposée comme un moyen de garantir que les Indexeurs obtiennent le meilleur résultat en répondant fidèlement aux requêtes. Elle incite les indexeurs à allouer un montant élevé de staking (qui peut être réduit en cas d'erreur lors du service d'une requête) par rapport au montant des frais de requête qu'ils peuvent percevoir.

Une fois qu'une allocation a été clôturée, les remises peuvent être réclamées par l'indexeur. Lors de la réclamation, les remises sur les frais de requête sont distribuées à l'indexeur et à leurs délégués en fonction de la réduction des frais de requête et de la fonction de remise exponentielle.

### Qu'est-ce que la réduction des frais de requête et la réduction des récompenses d'indexation ?

Les valeurs `queryFeeCut` et `indexingRewardCut` sont des paramètres de délégation que l'Indexeur peut définir avec les cooldownBlocks pour contrôler la distribution des GRT entre l'Indexeur et ses Délégateurs. Voir les dernières étapes de [Staking dans le protocol](/indexing/overview/#stake-in-the-protocol) pour les instructions sur la définition des paramètres de délégation.

- **queryFeeCut** - le pourcentage des remboursements de frais de requête qui sera distribué à l'Indexeur. Si cette valeur est fixée à 95 %, l'Indexeur recevra 95 % des frais de requête perçus lors de la clôture d'une allocation, les 5 % restants revenant aux Délégateurs.

- **indexingRewardCut** - le pourcentage des récompenses d'indexation qui sera distribué à l'Indexeur. Si cette valeur est fixée à 95 %, l'Indexeur recevra 95 % des récompenses d'indexation lorsqu'une allocation sera clôturée et les Délégateurs se partageront les 5 % restants.

### Comment les indexeurs savent-ils quels subgraphs indexer ?

Les indexeurs peuvent se différencier en appliquant des techniques avancées pour prendre des décisions d'indexation de subgraphs, mais pour donner une idée générale, nous discuterons de plusieurs mesures clés utilisées pour évaluer les subgraphs du réseau :

- **Signal de curation** - La proportion du signal de curation du réseau appliquée à un subgraph particulier est un bon indicateur de l'intérêt porté à ce subgraph, en particulier pendant la phase de démarrage, lorsque le volume des requêtes augmente.

- **Frais de requête perçus** - Les données historiques relatives au volume des frais de requête perçus pour un subgraph spécifique constituent un bon indicateur de la demande future.

- **Montant staké** - Le fait de surveiller le comportement d'autres Indexeurs ou d'examiner les proportions du staking total alloué à des subgraph spécifiques peut permettre à un Indexeur de surveiller l'offre de requêtes de subgraph afin d'identifier les subgraphs dans lesquels le réseau se montre confiant ou les subgraphs pour lesquels un besoin d'offre supplémentaire est susceptible de se faire sentir.

- **Subgraph sans récompenses d'indexation** - Certains subgraphs ne génèrent pas de récompenses d'indexation, principalement parce qu'ils utilisent des fonctionnalités non prises en charge comme IPFS ou parce qu'ils interrogent un autre réseau en dehors du réseau mainnet. Vous verrez un message sur un subgraph s'il ne génère pas de récompenses d'indexation.

### Quelle est la configuration matérielle requise ?

- **Petit** - Suffisante pour commencer à indexer plusieurs subgraphs, il faudra probablement l'étendre.
- **Standard** - Configuration par défaut, c'est ce qui est utilisé dans les manifestes de déploiement de l'exemple k8s/terraform.
- **Moyen** - Indexeur de production prenant en charge 100 subgraphs et 200 à 500 requêtes par seconde.
- **Grand** - Prêt à indexer tous les subgraphs actuellement utilisés et à répondre aux demandes du trafic correspondant.

| Installation | Postgres<br />(CPUs) | Postgres<br />(mémoire en Gbs) | Postgres<br />(disque en TB) | VMs<br />(CPUs) | VMs<br />(mémoire en Gbs) |
| ------------ | :------------------: | :----------------------------: | :--------------------------: | :-------------: | :-----------------------: |
| Petit        |           4          |                8               |               1              |        4        |             16            |
| Standard     |           8          |               30               |               1              |        12       |             48            |
| Moyen        |          16          |               64               |               2              |        32       |             64            |
| Large        |          72          |               468              |              3.5             |        48       |                           |

### Quelles sont les précautions de sécurité de base qu’un indexeur doit prendre ?

- **Portefeuille de l'opérateur** - La mise en place d'un portefeuille de l'opérateur est une précaution importante car elle permet à un Indexeur de maintenir une séparation entre les clés qui contrôlent le staking et celles qui contrôlent les opérations quotidiennes. Voir [Staking dans le Protocol](/indexing/overview/#stake-in-the-protocol) pour les instructions.

- **Pare-feu** - Seul le service Indexer doit être exposé publiquement et une attention particulière doit être portée au verrouillage des ports d'administration et de l'accès à la base de données : l'endpoint JSON-RPC de Graph Node (port par défaut : 8030), l'endpoint de l'API de gestion de l'Indexer (port par défaut : 18000), et l'endpoint de la base de données Postgres (port par défaut : 5432) ne doivent pas être exposés.

## Infrastructure

Au centre de l'infrastructure d'un Indexeur se trouve Graph Node qui surveille les réseaux indexés, extrait et charge les données en fonction d'une définition de subgraph et les sert en tant qu'[API GraphQL](/about/#how-the-graph-works). Graph Node doit être connecté à un endpoint exposant les données de chaque réseau indexé, à un nœud IPFS pour l'extraction des données, à une base de données PostgreSQL pour son stockage et aux composants de l'Indexeur qui facilitent ses interactions avec le réseau.

- **Base de données PostgreSQL** - La base de données principale de Graph Node, c'est ici que sont stockées les données des subgraphs. Le service d'indexation et l'agent utilisent également la base de données pour stocker les données du canal d'état, les modèles de coûts, les règles d'indexation et les actions d'allocation.

- **Endpoint des données** - Pour les réseaux compatibles avec l'EVM, Graph Node doit être connecté à un endpoint qui expose une API JSON-RPC compatible avec l'EVM. Il peut s'agir d'un seul client ou d'une configuration plus complexe qui répartit la charge entre plusieurs clients. Il est important de savoir que certains subgraphs nécessitent des capacités client particulières, telles que le mode archive et/ou l'API de traçage de la parité.

- **Nœud IPFS (version inférieure à 5)** - Les métadonnées de déploiement de subgraph sont stockées sur le réseau IPFS. Graph Node accède principalement au nœud IPFS pendant le déploiement du subgraph pour récupérer le manifeste du subgraph et tous les fichiers liés. Les indexeurs du réseau n'ont pas besoin d'héberger leur propre nœud IPFS, un nœud IPFS pour le réseau est hébergé à l'adresse https://ipfs.network.thegraph.com.

- **Service d'indexation** - Gère toutes les communications externes requises avec le réseau. Il partage les modèles de coûts et les états d'indexation, transmet les requêtes des passerelles à un Graph Node et gère les paiements des requêtes via des canaux d'état avec la passerelle.

- **Agent Indexeur** - Facilite les interactions des Indexeurs sur la on-chain, notamment l'enregistrement sur le réseau, la gestion des déploiements de subgraph vers leur(s) Graph Node/s, et la gestion des allocations.

- **Serveur de métriques Prometheus** - Les composants Graph Node et Indexer enregistrent leurs métriques sur le serveur de métriques.

Remarque : Pour prendre en charge la mise à l'échelle agile, il est recommandé de séparer les problèmes de requête et d'indexation entre différents ensembles de nœuds : nœuds de requête et nœuds d'index.

### Aperçu des ports

> **Important** : Attention à ne pas exposer les ports publiquement - les **ports d'administration** doivent être verrouillés. Cela inclut les endpoints JSON-RPC de Graph Node et les endpoints de gestion de l'indexeur détaillés ci-dessous.

#### Nœud de The Graph

| Port | Objectif                                                   | Routes                                         | Argument CLI       | Variable d'environnement |
| ---- | ---------------------------------------------------------- | ---------------------------------------------- | ------------------ | ------------------------ |
| 8000 | Serveur HTTP GraphQL<br />(pour les requêtes de subgraphs) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port       | -                        |
| 8001 | GraphQL WS<br />(pour les abonnements aux subgraphs)       | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port         | -                        |
| 8020 | JSON-RPC<br />(pour gérer les déploiements)                | /                                              | \--admin-port      | -                        |
| 8030 | API de statut d'indexation des subgraphs                   | /graphq                                        | \--index-node-port | -                        |
| 8040 | Métriques Prometheus                                       | /metrics                                       | \--metrics-port    | -                        |

#### Service d'indexation

| Port | Objectif                                                            | Routes                                                      | Argument CLI    | Variable d'environnement |
| ---- | ------------------------------------------------------------------- | ----------------------------------------------------------- | --------------- | ------------------------ |
| 7600 | Serveur HTTP GraphQL<br />(pour les requêtes payantes de subgraphs) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port         | `INDEXER_SERVICE_PORT`   |
| 7300 | Métriques Prometheus                                                | /metrics                                                    | \--metrics-port | -                        |

#### Agent indexeur

| Port | Objectif                     | Routes | Argument du CLI              | Variable d'environment                    |
| ---- | ---------------------------- | ------ | ---------------------------- | ----------------------------------------- |
| 8000 | API de gestion des indexeurs | /      | \--indexer-management-port   | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT`   |

### Configurer l'infrastructure du serveur à l'aide de Terraform sur Google Cloud

> Note : Les indexeurs peuvent alternativement utiliser AWS, Microsoft Azure ou Alibaba.

#### Conditions préalables à l'installation

- Google Cloud SDK
- Outil de ligne de commande kubectl
- Terraform

#### Créer un projet Google Cloud

- Cloner ou naviguer vers le [dépôt de l'Indexeur](https://github.com/graphprotocol/indexer).

- Naviguez jusqu'au répertoire `./terraform`, c'est là que toutes les commandes doivent être exécutées.

```sh
cd terraform
```

- Authentifiez-vous auprès de Google Cloud et créez un nouveau projet.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Utilisez la page de facturation de Google Cloud Console pour activer la facturation du nouveau projet.

- Créez une configuration Google Cloud.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Activez les API Google Cloud requises.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Créez un compte de service.

```sh
svc_name=<NOM_DU_COMPTE_SERVICE>
gcloud iam service-accounts create $svc_name \
  --description="Compte de service pour Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Obtenir l'e-mail du compte de service à partir de la liste
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Activez le peering entre la base de données et le cluster Kubernetes qui sera créé à l'étape suivante.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Créez un fichier de configuration Terraform minimal (mettez à jour si nécessaire).

```sh
indexer=<NOM_DE _L_INDEXEUR>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<mot de passe de la base de données>"
EOF
```

#### Utiliser Terraform pour créer une infrastructure

Avant d'exécuter une commande, lisez [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) et créez un fichier `terraform.tfvars` dans ce répertoire (ou modifiez celui que nous avons créé à l'étape précédente). Pour chaque variable pour laquelle vous souhaitez remplacer la valeur par défaut ou pour laquelle vous devez définir une valeur, saisissez un paramètre dans `terraform.tfvars`.

- Exécutez les commandes suivantes pour créer l'infrastructure.

```sh
# Installer les Plugins Requis
terraform init

# Afficher le plan des ressources à créer
terraform plan

# Créez les ressources (attendez-vous à ce que cela prenne jusqu'à 30 minutes)
terraform apply
```

Téléchargez les informations d’identification du nouveau cluster dans `~/.kube/config` et définissez-le comme contexte par défaut.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Création des composants Kubernetes pour l'indexeur

- Copiez le répertoire `k8s/overlays` dans un nouveau répertoire `$dir` et ajustez l'entrée `bases` dans `$dir/kustomization.yaml` afin qu'elle pointe vers le répertoire `k8s/base`.

- Lisez tous les fichiers de `$dir` et ajustez les valeurs indiquées dans les commentaires.

Déployer toutes les ressources avec `kubectl apply -k $dir`.

### Nœud de The Graph

[Graph Node](https://github.com/graphprotocol/graph-node) est une implémentation Rust open source qui utilise la blockchain Ethereum pour mettre à jour de manière déterministe un store de données qui peut être interrogé via l'endpoint GraphQL. Les développeurs utilisent des subgraphs pour définir leur schéma et un ensemble de mappages pour transformer les données provenant de la blockchain. Graph Node gère la synchronisation de l'ensemble de la chaîne, la surveillance des nouveaux blocs et le service via un endpoint GraphQL.

#### Commencer à partir des sources

#### Conditions préalables à l'installation

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Exigences supplémentaires pour les utilisateurs d'Ubuntu** - Pour faire fonctionner Graph Node sur Ubuntu, quelques paquets supplémentaires peuvent être nécessaires.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Installation

1. Démarrer un serveur de base de données PostgreSQL

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Clonez le repo [Graph Node](https://github.com/graphprotocol/graph-node) et compilez les sources en lançant `cargo build`

3. Maintenant que toutes les dépendances sont configurées, démarrez le Graph Node :

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Démarrer avec Docker

#### Conditions préalables

- **Nœud Ethereum** - Par défaut, l'installation de docker compose utilisera mainnet : [http://host.docker.internal:8545](http://host.docker.internal:8545) pour se connecter au nœud Ethereum sur votre machine hôte. Vous pouvez remplacer ce nom de réseau et cette url en mettant à jour `docker-compose.yaml`.

#### Installation

1. Clonez Graph Node et accédez au répertoire Docker :

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Pour les utilisateurs linux uniquement - Utilisez l'adresse IP de l'hôte au lieu de `host.docker.internal` dans le `docker-compose.yaml ` en utilisant le script inclus :

```sh
./setup.sh
```

3. Démarrez un nœud graph local qui se connectera à votre point de terminaison Ethereum :

```sh
docker-compose up
```

### Composants de l'indexeur

Pour participer avec succès au réseau, il faut une surveillance et une interaction presque constantes. Nous avons donc créé une suite d'applications Typescript pour faciliter la participation au réseau des indexeurs. Il existe trois composants d'indexeur :

- **Agent d'indexation** - L'agent surveille le réseau et l'infrastructure de l'Indexeur et gère les déploiements de subgraphs qui sont indexés et alloués onchain, ainsi que la quantité allouée à chacun d'entre eux.

- **Service d'indexation** - Le seul composant qui doit être exposé à l'extérieur, le service transmet les requêtes de subgraphs à Graph Node, gère les canaux d'état pour les paiements de requêtes, partage les informations importantes de prise de décision avec les clients tels que les passerelles.

- **CLI de l'Indexeur** - L'interface de ligne de commande pour la gestion de l'agent d'Indexeur. Elle permet aux Indexeurs de gérer les modèles de coûts, les allocations manuelles, la file d'attente des actions et les règles d'indexation.

#### Commencer

L'agent d'Indexeur et le service d'Indexeur doivent être situés au même endroit que votre infrastructure Graph Node. Il existe de nombreuses façons de mettre en place des environnements d'exécution virtuels pour vos composants d'Indexeurs ; nous expliquerons ici comment les exécuter sur baremetal en utilisant les packages NPM ou les sources, ou via kubernetes et docker sur Google Cloud Kubernetes Engine. Si ces exemples de configuration ne s'appliquent pas à votre infrastructure, il y aura probablement un guide communautaire à consulter, venez nous dire bonjour sur [Discord](https://discord.gg/graphprotocol) ! N'oubliez pas de [staker sur le protocole](/indexing/overview/#stake-in-the-protocol) avant de démarrer vos composants d'Indexeur !

#### À partir des packages NPM

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### De la source

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Utiliser docker

- Extraire les images du registre

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Ou créez des images localement à partir de la source

```sh
# service d'Indexeur
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# service d'agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Exécutez les composants

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**NOTE** : Après le démarrage des conteneurs, le service d'Indexeurs doit être accessible à l'adresse [http://localhost:7600](http://localhost:7600) et l'agent d'Indexeur doit exposer l'API de gestion de l'Indexeur à l'adresse [http://localhost:18000/](http://localhost:18000/).

#### Utilisation de K8s et Terraform

Voir la section [Configuration de l'infrastructure du serveur à l'aide de Terraform sur Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Usage

> **NOTE** : Toutes les variables de configuration peuvent être appliquées soit en tant que paramètres de la commande au démarrage, soit en utilisant des variables d'environnement du format `COMPONENT_NAME_VARIABLE_NAME` (ex. `INDEXER_AGENT_ETHEREUM`).

#### Indexer agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexer CLI

Le CLI d'Indexeur est un plugin pour [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) accessible via la commande `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Gestion de l'indexeur à l'aide de l'indexeur CLI

L'outil suggéré pour interagir avec l'**API de gestion de l'Indexeur** est la **CLI d'Indexeur**, une extension de **Graph CLI**. L'agent d'Indexeur a besoin de l'apport d'un Indexeur pour interagir de manière autonome avec le réseau au nom de l'Indexeur. Les mécanismes permettant de définir le comportement de l'agent Indexeur sont le mode **gestion de l'allocation** et les **règles d'indexation**. En mode automatique, un Indexeur peut utiliser des **règles d'indexation** pour appliquer sa stratégie spécifique de sélection des subgraphs à indexer et à servir des requêtes. Les règles sont gérées via une API GraphQL servie par l'agent et connue sous le nom d'API de gestion de l'Indexeur. En mode manuel, un Indexeur peut créer des actions d'allocation en utilisant la **file d'attente des actions** et les approuver explicitement avant qu'elles ne soient exécutées. En mode supervision, les **règles d'indexation** sont utilisées pour alimenter la **file d'attente des actions** et nécessitent également une approbation explicite avant d'être exécutées.

#### Usage

La **CLI d'Indexeur** se connecte à l'agent d'Indexeur, généralement par le biais d'une redirection de port, de sorte que le CLI n'a pas besoin d'être exécuté sur le même serveur ou cluster. Pour vous aider à démarrer, et pour vous donner un peu de contexte, nous allons décrire brièvement la CLI.

- `graph indexer connect <url>` - Se connecter à l'API de gestion de l'Indexeur. Généralement, la connexion au serveur est ouverte via une redirection de port, afin que la CLI puisse être facilement utilisée à distance. (Exemple : `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Pour obtenir une ou plusieurs règles d'indexation en utilisant `all` comme `<deployment-id>` pour obtenir toutes les règles, ou `global` pour obtenir les valeurs par défaut globales. Un argument supplémentaire `--merged` peut être utilisé pour spécifier que les règles spécifiques au déploiement sont fusionnées avec la règle globale. C'est ainsi qu'elles sont appliquées dans l'agent d'Indexeur.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Pour définir une ou plusieurs règles d'indexation.

- `graph indexer rules start [options] <deployment-id>` - Commence à indexer un déploiement de subgraphs s'il est disponible et définit sa `decisionBasis` à `always`, de sorte que l'agent d'Indexeur choisira toujours de l'indexer. Si la règle globale est définie sur always, tous les subgraphs disponibles sur le réseau seront indexés.

- `graph indexer rules stop [options] <deployment-id>` - Arrête l'indexation d'un déploiement et met sa `decisionBasis` à never, de sorte qu'il ignorera ce déploiement lorsqu'il décidera des déploiements à indexer.

- `graph indexer rules maybe [options] <deployment-id>` - Définit la `decisionBasis` pour un déploiement à `rules`, afin que l'agent d'Indexeur utilise les règles d'indexation pour décider d'indexer ou non ce déploiement.

- `graph indexer actions get [options] <action-id>` - Récupère une ou plusieurs actions en utilisant `all` ou laisse `action-id` vide pour obtenir toutes les actions. Un argument supplémentaire `--status` peut être utilisé pour afficher toutes les actions d'un certain statut.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Met en file d'attente une action de réallocation

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Met en file d'attente une action de désallocation

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Met en file d'attente une action de désallocation

- `graph indexer actions cancel [<action-id> ...]` - Annule toutes les actions de la file d'attente si id n'est pas spécifié, sinon annule un tableau d'id avec l'espace comme séparateur

- `graph indexer actions approve [<action-id> ...]` - Approuve l'exécution de plusieurs actions

- `graph indexer actions execute approve` - Force le worker à exécuter immédiatement les actions approuvées

Toutes les commandes qui affichent des règles dans la sortie peuvent choisir entre les formats de sortie pris en charge(`table`, `yaml`, et `json`) en utilisant l'argument `-output`.

#### Règles d'indexation

Les règles d'indexation peuvent être appliquées par défaut au niveau global ou pour des déploiements de subgraphs spécifiques en utilisant leurs identifiants. Les champs `deployment` et `decisionBasis` sont obligatoires, tandis que tous les autres champs sont optionnels. Lorsqu'une règle d'indexation a `rules` comme `decisionBasis`, l'agent d'Indexeur compare les valeurs de seuil non nulles de cette règle avec les valeurs extraites du réseau pour le déploiement correspondant. Si le déploiement du subgraph a des valeurs supérieures (ou inférieures) à l'un des seuils, il sera choisi pour l'indexation.

For example, if the global rule has a `minStake` of **5** (GRT), any subgraph deployment which has more than 5 (GRT) of stake allocated to it will be indexed. Threshold rules include `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, and `minAverageQueryFees`.

Modèle de données:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Exemple d'utilisation de la règle d'indexation :

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### CLI de la file des actions

The indexer-cli provides an `actions` module for manually working with the action queue. It uses the **Graphql API** hosted by the indexer management server to interact with the actions queue.

The action execution worker will only grab items from the queue to execute if they have `ActionStatus = approved`. In the recommended path actions are added to the queue with ActionStatus = queued, so they must then be approved in order to be executed onchain. The general flow will look like:

- Action ajoutée à la file d'attente par l'outil d'optimisation tiers ou l'utilisateur indexeur-cli
- Indexer can use the `indexer-cli` to view all queued actions
- Indexer (or other software) can approve or cancel actions in the queue using the `indexer-cli`. The approve and cancel commands take an array of action ids as input.
- The execution worker regularly polls the queue for approved actions. It will grab the `approved` actions from the queue, attempt to execute them, and update the values in the db depending on the status of execution to `success` or `failed`.
- If an action is successful the worker will ensure that there is an indexing rule present that tells the agent how to manage the allocation moving forward, useful when taking manual actions while the agent is in `auto` or `oversight` mode.
- L'indexeur peut surveiller la file d'attente des actions pour consulter un historique de l'exécution des actions et, si nécessaire, réapprouver et mettre à jour les éléments d'action en cas d'échec de leur exécution. La file d'attente des actions fournit un historique de toutes les actions mises en file d'attente et entreprises.

Modèle de données:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Exemple d'utilisation à partir de la source :

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Notez que les types d'actions pris en charge pour la gestion des allocations ont des exigences d'entrée différentes :

- `Allocate` - allocate stake to a specific subgraph deployment

  - paramètres d'action requis :
    - deploymentID
    - amount

- `Unallocate` - close allocation, freeing up the stake to reallocate elsewhere

  - paramètres d'action requis :
    - ID d'allocation
    - deploymentID
  - paramètres d'action facultatifs :
    - poi
    - force (force l'utilisation du POI fourni même s'il ne correspond pas à ce que fournit le nœud graph)

- `Reallocate` - atomically close allocation and open a fresh allocation for the same subgraph deployment

  - paramètres d'action requis :
    - ID d'allocation
    - deploymentID
    - amount
  - paramètres d'action facultatifs :
    - poi
    - force (force l'utilisation du POI fourni même s'il ne correspond pas à ce que fournit le nœud graph)

#### Modèles de coûts

Les modèles de coûts fournissent une tarification dynamique pour les requêtes en fonction des attributs du marché et des requêtes. Le service Indexeur partage un modèle de coût avec les passerelles pour chaque subgraph pour lequel elles ont l'intention de répondre aux requêtes. Les passerelles, à leur tour, utilisent le modèle de coût pour prendre des décisions de sélection des indexeurs par requête et pour négocier le paiement avec les indexeurs choisis.

#### Agora

Le langage Agora fournit un format flexible pour déclarer des modèles de coûts pour les requêtes. Un modèle de prix Agora est une séquence d'instructions qui s'exécutent dans l'ordre pour chaque requête de niveau supérieur dans une requête GraphQL. Pour chaque requête de niveau supérieur, la première instruction qui y correspond détermine le prix de cette requête.

Une instruction est composée d'un prédicat, qui est utilisé pour faire correspondre les requêtes GraphQL, et d'une expression de coût qui, une fois évaluée, génère un coût en GRT décimal. Les valeurs dans la position d'argument nommé d'une requête peuvent être capturées dans le prédicat et utilisées dans l'expression. Des éléments globaux peuvent également être définis et remplacés par des espaces réservés dans une expression.

Exemple de modèle de coût :

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Exemple de calcul des coûts de requête utilisant le modèle ci-dessus :

| Requête                                                                        | Prix    |
| ------------------------------------------------------------------------------ | ------- |
| { pairs(skip: 5000) { id } }                                                   | 0.5 GRT |
| { tokens { symbol } }                                                          | 0.1 GRT |
| { pairs(skip: 5000) { id } tokens { symbol } }                                 | 0.6 GRT |

#### Application du modèle de coût

Les modèles de coûts sont appliqués via la CLI Indexer, qui les transmet à l'API de gestion de l'indexeur de l'agent Indexer pour les stocker dans la base de données. Le service d'indexation les récupérera ensuite et fournira les modèles de coûts aux passerelles chaque fois qu'elles les demanderont.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interagir avec le réseau

### Enjeu dans le protocole

Les premières étapes pour participer au réseau en tant qu'Indexeur sont d'approuver le protocole, de staker des fonds et (facultativement) de configurer une adresse opérateur pour les interactions quotidiennes avec le protocole.

> Note: For the purposes of these instructions Remix will be used for contract interaction, but feel free to use your tool of choice ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), and [MyCrypto](https://www.mycrypto.com/account) are a few other known tools).

Once an Indexer has staked GRT in the protocol, the [Indexer components](/indexing/overview/#indexer-components) can be started up and begin their interactions with the network.

#### Approuver les jetons

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **GraphToken.abi** with the [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. With `GraphToken.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the GraphToken contract address - Paste the GraphToken contract address (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) next to `At Address` and click the `At address` button to apply.

6. Call the `approve(spender, amount)` function to approve the Staking contract. Fill in `spender` with the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) and `amount` with the tokens to stake (in wei).

#### Jetons de mise

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **Staking.abi** with the staking ABI.

3. With `Staking.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the Staking contract address - Paste the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) next to `At Address` and click the `At address` button to apply.

6. Call `stake()` to stake GRT in the protocol.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their indexingRewardCut (parts per million), queryFeeCut (parts per million), and cooldownBlocks (number of blocks). To do so call `setDelegationParameters()`. The following example sets the queryFeeCut to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the indexingRewardCutto distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set `thecooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### Définition des paramètres de délégation

The `setDelegationParameters()` function in the [staking contract](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) is essential for Indexers, allowing them to set parameters that define their interactions with Delegators, influencing their reward sharing and delegation capacity.

### Comment définir les paramètres de délégation

Pour définir les paramètres de délégation à l'aide de l'interface Graph Explorer, suivez ces étapes :

1. Navigate to [Graph Explorer](https://thegraph.com/explorer/).
2. Connectez votre portefeuille. Choisissez multisig (comme Gnosis Safe) puis sélectionnez mainnet. Note : Vous devrez répéter ce processus pour Arbitrum One.
3. Connectez le portefeuille que vous avez en tant que signataire.
4. Accédez à la section "Settings" puis sélectionnez "Delegation Parameters". Ces paramètres doivent être configurés afin d’obtenir un taux effectif dans la fourchette souhaitée. Une fois les valeurs saisies dans les champs prévus, l’interface calcule automatiquement ce taux effectif. Ajustez les valeurs selon vos besoins pour atteindre le pourcentage effectif désiré.
5. Soumettez la transaction au réseau.

> Note : Cette transaction devra être confirmée par les signataires du portefeuille multisig.

### La durée de vie d'une allocation

After being created by an Indexer a healthy allocation goes through two states.

- **Active** - Once an allocation is created onchain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a subgraph deployment, which allows them to claim indexing rewards and serve queries for that subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - An Indexer is free to close an allocation once 1 epoch has passed ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) or their Indexer agent will automatically close the allocation after the **maxAllocationEpochs** (currently 28 days). When an allocation is closed with a valid proof of indexing (POI) their indexing rewards are distributed to the Indexer and its Delegators ([learn more](/indexing/overview/#how-are-indexing-rewards-distributed)).

Indexers are recommended to utilize offchain syncing functionality to sync subgraph deployments to chainhead before creating the allocation onchain. This feature is especially useful for subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
