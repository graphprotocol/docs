---
title: Disparadores de Substreams
---

Los disparadores personalizados te permiten enviar datos directamente a tu archivo de mapeo del subgrafo y a sus entidades (similares a tablas y campos), permitiendo el uso completo de la capa GraphQL. Al importar las definiciones de Protobuf emitidas por tu módulo de Substreams, puedes recibir y procesar estos datos dentro del manejador de tu subgrafo, garantizando una gestión de datos eficiente y optimizada dentro del marco del subgrafo.

> Nota: Si aún no lo has hecho, visita una de las guías prácticas que encontrarás aquí (/substreams/sps/introduction/) para estructurar tu primer proyecto en el Contenedor de Desarrollo.

El siguiente código demuestra cómo definir una función 'handleTransactions' en un controlador de subgraph. Esta función recibe bytes sin procesar de Substreams como parámetro y los decodifica en un objeto 'Transactions'. Para cada transacción, se crea una nueva entidad en el subgrafo.

```tsx
export function handleTransactions(bytes: Uint8Array): void {
  let transactions = assembly.eth.transaction.v1.Transactions.decode(bytes.buffer).transactions // 1.
  if (transactions.length == 0) {
    log.info('No transactions found', [])
    return
  }

  for (let i = 0; i < transactions.length; i++) {
    // 2.
    let transaction = transactions[i]

    let entity = new Transaction(transaction.hash) // 3.
    entity.from = transaction.from
    entity.to = transaction.to
    entity.save()
  }
}
```

Esto es lo que ves en el archivo mappings.ts:

1. Los bytes que contienen los datos de Substreams se decodifican en el objeto 'Transactions' generado, y este objeto se utiliza como cualquier otro objeto de AssemblyScript.
2. Iterando sobre las transacciones
3. Crear una nueva entidad de subgrafo para cada transacción.

To go through a detailed example of a trigger-based subgraph, [click here](/substreams/sps/tutorial/).
