---
title: اسمبلی سکرپٹ مائیگریشن گائیڈ
---

اب تک، سب گراف [اسمبلی اسکرپٹ کے پہلے ورژن](https://github.com/AssemblyScript/assemblyscript/tree/v0.6) (v0.6) میں سے ایک استعمال کر رہے ہیں۔ آخر کار ہم نے [جدید ترین دستیاب](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10) کے لیے تعاون شامل کر دیا ہے! 🎉

وہ سب گراف ڈویلپرز کو اسمبلی لینگوج اور سٹینڈرڈ لائبریری کی نئ خصوصیات استعمال کرنے پر فعال کرے گا.

یہ ہدایت نامہ `graph-cli`/`graph-ts` ورژن `0.22.0` کے نیچے استعمال کرنے والے ہر فرد پر لاگو ہوتا ہے۔ اگر آپ پہلے ہی اس سے زیادہ (یا برابر) ورژن پر ہیں، تو آپ اسمبلی اسکرپٹ کا ورژن `0.19.10` پہلے ہی استعمال کر رہے ہیں 🙂

> نوٹ: `0.24.0` کے مطابق، `graph-node` سب گراف مینی فیسٹ میں متعین `apiVersion` کی بنیاد پر، دونوں ورژنز کو سپورٹ کر سکتا ہے.

## خصوصیات

### نئ خصوصیت

- `TypedArray`s اب `ArrayBuffer`s سے [نیا ` wrap` جامد طریقہ](https://www.assemblyscript.org/stdlib/typedarray.html#static-members کا استعمال کر کے بنایا جا سکتا ہے) ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1))
- لائبریری کے نئے معیاری فنکشنز: `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare` اور `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- GenericClass ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2)) کے x مثال کے لئے تعاون شامل کیا گیا
- شامل کیا گیا `StaticArray<T>`، ایک زیادہ موثر ایرے ویرینٹ ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- شامل کیا گیا `Array<T>#flat` ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- `Number#toString` پر `radix` دلیل کو نافذ کیا گیا ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- فلوٹنگ پوائنٹ لٹریلز ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7)) میں الگ کرنے والوں کے لیے تعاون شامل کیا گیا
- فرسٹ کلاس فنکشنز ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0)) کے لیے شامل کردہ تعاون
- بلٹ انز شامل کریں: `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- `Array/TypedArray/String#at` لاگو کریں ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- تمثیل کے لغوی سٹرنگز کے لیے شامل کیا گیا تعاون ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- `encodeURI(Component)` اور `decodeURI(ج Component)` شامل کریں ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- `toString`، `toDateString` اور `toTimeString` کو `Date` میں شامل کریں ([v0.18.29](https://github.com/ AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- `Date` کے لیے `toUTCSstring` شامل کریں ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- شامل کریں `nonnull/NonNullable` بلٹ ان قسم ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### اصلاح

- `Math` فنکشنز جیسے `exp`، `exp2`، `log`، `log2` اور ` pow` کو تیز تر متغیرات سے بدل دیا گیا ہے ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- `Math.mod` کو تھوڑا سا بہتر بنائیں ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- Std میپ اور سیٹ ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8)) میں مزید فیلڈ رسائی کیش کریں
- `ipow32/64` میں دو کی طاقتوں کو بہتر بنائیں ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### دوسرا

- ایک ایرے کے لغوی کی قسم کا اندازہ اب اس کے مواد سے لگایا جا سکتا ہے ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Stdlib کو یونیکوڈ 13.0.0 میں اپ ڈیٹ کیا گیا ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))

## اپ گریڈ کیسے کریں؟

1. اپنی میپنگز `apiVersion` کو `subgraph.yaml` میں `0.0.6` میں تبدیل کریں:

```yaml
...
dataSources:
  ...
    mapping:
      ...
      apiVersion: 0.0.6
      ...
```

2. `graph-cli` کو اپ ڈیٹ کریں جسے آپ `تازہ ترین` ورژن میں استعمال کر رہے ہیں یہ چلا کر:

```bash
# if you have it globally installed
npm install --global @graphprotocol/graph-cli@latest

# or in your subgraph if you have it as a dev dependency
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. `graph-ts` کے لیۓ بھی ایسا ہی کریں، لیکن عالمی سطح پر انسٹال کرنے کے بجائے، اسے اپنے اہم انحصار میں محفوظ کریں:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. زبان کو توڑنے والی تبدیلیوں کو ٹھیک کرنے کے لیے بقیہ گائیڈ پر عمل کریں.
5. `codegen` اور `deploy` کو دوباری چلائیں.

## بریکنگ تبدیلیاں

### کالعدم ہونا

اسمبلی اسکرپٹ کے پرانے ورژن پر، آپ اس طرح کا کوڈ بنا سکتے ہیں:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

تاہم نئے ورژن پر، کیونکہ ویلیو کالعدم ہے، اس کے لیے آپ کو اس طرح چیک کرنے کی ضرورت ہے:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` is not null anymore
}
```

یا اسے اس طرح فورس کریں:

```typescript
let maybeValue = load()! // breaks in runtime if value is null

maybeValue.aMethod()
```

اگر آپ کو یقین نہیں ہے کہ کون سا انتخاب کرنا ہے، تو ہم ہمیشہ محفوظ ورژن استعمال کرنے کی تجویز کرتے ہیں۔ اگر ویلیو موجود نہیں ہے تو آپ اپنے سب گراف ہینڈلر میں واپسی کے ساتھ صرف ابتدائی اف سٹیٹمینٹ کرنا چاہتے ہیں.

### متغیر شیڈونگ

اس سے پہلے کہ آپ [متغیر شیڈونگ](https://en.wikipedia.org/wiki/Variable_shadowing) کر سکیں اور اس طرح کا کوڈ کام کرے گا:

```typescript
let a = 10
let b = 20
let a = a + b
```

تاہم اب یہ ممکن نہیں ہے، اور کمپائلر یہ غلطی واپس کرتا ہے:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

اگر آپ کے پاس متغیر شیڈونگ ہے تو آپ کو اپنے ڈپلیکیٹ متغیرات کا نام تبدیل کرنے کی ضرورت ہوگی.

### کالعدم موازنہ

اپنے سب گراف پر اپ گریڈ کرنے سے، بعض اوقات آپ کو اس طرح کی غلطیاں مل سکتی ہیں:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

حل کرنے کے لیے آپ صرف `if` اسٹیٹمنٹ کو اس طرح تبدیل کر سکتے ہیں:

```typescript
  if (!decimals) {

  // or

  if (decimals === null) {
```

اگر آپ == کی بجائے != کر رہے ہیں تو بھی یہی لاگو ہوتا ہے.

### کاسٹنگ

اس سے پہلے کاسٹ کرنے کا عام طریقہ صرف `as` کلیدی لفظ استعمال کرنا تھا، اس طرح:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // equivalent to: <Uint8Array>byteArray
```

تاہم یہ صرف دو صورتوں میں کام کرتا ہے:

- قدیم کاسٹنگ (قسم کے درمیان جیسے کہ `u8`, `i32`, `bool`; eg: `let b: isize = 10; b as usize`);
- کلاس وراثت پر اپکاسٹنگ (سپر کلاس → سب کلاس)

مثالیں:

```typescript
// primitive casting
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
// upcasting on class inheritance
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // same as: bytes as Uint8Array
```

دو ایسے حالات ہیں جہاں آپ کاسٹ کرنا چاہیں گے، لیکن `as`/`<T>var` **محفوظ نہیں ہے**:

- طبقاتی وراثت میں کمی ( سب کلاس → سپر کلاس)
- دو قسموں کے درمیان جو ایک سپر کلاس کا اشتراک کرتے ہیں

```typescript
// downcasting on class inheritance
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // breaks in runtime :(
```

```typescript
// between two types that share a superclass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // breaks in runtime :(
```

ان معاملات کے لیے، آپ `changetype<T>` فنکشن استعمال کر سکتے ہیں:

```typescript
// downcasting on class inheritance
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // works :)
```

```typescript
// between two types that share a superclass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // works :)
```

اگر آپ صرف منسوخی کو ہٹانا چاہتے ہیں، تو آپ `as` آپریٹر (یا `<T>variable`) کا استعمال جاری رکھ سکتے ہیں، لیکن یقینی بنائیں کہ آپ جانتے ہیں کہ قدر کالعدم نہیں ہوسکتی دوسری صورت میں یہ ٹوٹ جائے گا.

```typescript
// remove nullability
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // safe remove null
}

let newBalance = new AccountBalance(balanceId)
```

منسوخی کے معاملے کے لیے ہم تجویز کرتے ہیں کہ [منسوخی چیک فیچر](https://www.assemblyscript.org/basics.html#nullability-checks) پر ایک نظر ڈالیں، یہ آپ کے کوڈ کو صاف کر دے گا 🙂

نیز ہم نے کاسٹنگ کو آسان بنانے کے لیے کچھ اقسام میں کچھ مزید جامد طریقے شامل کیے ہیں، وہ یہ ہیں:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### پراپرٹی ایکسیس کے ساتھ منسوخی کی جانچ

[منسوخی چیک فیچر](https://www.assemblyscript.org/basics.html#nullability-checks) استعمال کرنے کے لیے آپ یا تو `if` اسٹیٹمنٹس یا ٹرنری استعمال کرسکتے ہیں۔ آپریٹر (`?` اور `:`) اس طرح:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// or

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

تاہم یہ صرف اس وقت کام کرتا ہے جب آپ متغیر پر `if` / ٹرنری کر رہے ہوں، نہ کہ کسی پراپرٹی تک رسائی پر، اس طرح:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // doesn't compile
```

جو اس غلطی کو ظاہر کرتا ہے:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

اس مسئلے کو حل کرنے کے لیے، آپ اس پراپرٹی تک رسائی کے لیے ایک متغیر بنا سکتے ہیں تاکہ مرتب کرنے والا منسوخی چیک میجک کر سکے:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // compiles just fine :)
```

### پراپرٹی ایکسیس کے ساتھ آپریٹر اوور لوڈنگ

اگر آپ (مثال کے طور پر) ایک غیر منسوخ قسم (پراپرٹی ایکسیس سے) کو ایک غیر کالعدم کے ساتھ جمع کرنے کی کوشش کرتے ہیں، تو اسمبلی اسکرپٹ کمپائلر کمپائل ٹائم ایرر انتباہ دینے کے بجائے کہ ایک قدر کالعدم ہے، یہ صرف خاموشی سے مرتب کرتا ہے، موقع دیتے ہوئے رن ٹائم پر کوڈ کے ٹوٹنے کے لیے.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // give compile time error about nullability

let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // doesn't give compile time errors as it should
```

ہم نے اس کے لیے اسمبلی اسکرپٹ کمپائلر پر ایک ایشو کھولا ہے، لیکن ابھی کے لیے اگر آپ اپنی سب گراف میپنگز میں اس قسم کی کارروائیاں کرتے ہیں، تو آپ کو اس سے پہلے ایک کالعدم چیک کرنے کے لیے انہیں تبدیل کرنا چاہیے.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // now `n` is guaranteed to be a BigInt
```

### ویلیو کی ابتدا

اگر آپ کے پاس اس طرح کا کوڈ ہے:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

یہ کمپائل کرے گا لیکن رن ٹائم پر ٹوٹ جائے گا، ایسا اس لیے ہوتا ہے کیونکہ ویلیو شروع نہیں کی گئی ہے، اس لیے یقینی بنائیں کہ آپ کے سب گراف نے اپنی ویلیوس کی ابتدا کی ہے، اس طرح:

```typescript
var value = new Type() // initialized
value.x = 10
value.y = 'content'
```

نیز اگر آپ کے پاس گراف کیو ایل ہستی میں کالعدم خصوصیات ہیں، اس طرح:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

اور آپ کے پاس اس سے ملتا جلتا کوڈ ہے:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

آپ کو `total.amount` ویلیو کو شروع کرنا یقینی بنانا ہوگا، کیونکہ اگر آپ رقم کے لیے آخری لائن کی طرح رسائی حاصل کرنے کی کوشش کرتے ہیں، تو یہ کریش ہوجائے گا۔ تو آپ یا تو اسے پہلے شروع کریں:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

یا آپ اپنے GraphQL سکیما کو تبدیل کر سکتے ہیں تاکہ اس پراپرٹی کے لیے ایک غیر قابل استعمال قسم کا استعمال نہ کیا جائے، پھر ہم اسے `codegen` ویلیو پر صفر کے طور پر شروع کریں گے 😉

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest') // already initializes non-nullable properties
}

total.amount = total.amount + BigInt.fromI32(1)
```

### کلاس پراپرٹی کی شروعات

اگر آپ ایسی خصوصیات کے ساتھ کسی بھی کلاس کو برآمد کرتے ہیں جو دوسری کلاسیں ہیں (آپ کے ذریعہ یا معیاری لائبریری کے ذریعہ اعلان کردہ) اس طرح:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

کمپائلر میں غلطی ہو جائے گی کیونکہ آپ کو یا تو ان خصوصیات کے لیے ایک ابتدائی شامل کرنے کی ضرورت ہے جو کلاسز ہیں، یا `!` آپریٹر شامل کریں:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// or

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// or

export class Something {
  value!: Thing
}
```

### ایرے شروع کرنا

`Array` کلاس ابھی بھی فہرست کی لمبائی کو شروع کرنے کے لیے ایک نمبر کو قبول کرتی ہے، تاہم آپ کو خیال رکھنا چاہیے کیونکہ `.push` جیسے آپریشن شروع میں شامل کرنے کے بجائے سائز میں اضافہ کریں گے، مثال کے طور پر:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // size 6 :(
```

ان اقسام پر منحصر ہے جو آپ استعمال کر رہے ہیں، مثال کے طور پر کالعدم، اور آپ ان تک کیسے رسائی حاصل کر رہے ہیں، آپ کو رن ٹائم غلطی کا سامنا کرنا پڑ سکتا ہے اس طرح:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

اصل میں شروع میں دھکیلنے کے لیے آپ کو یا تو، `Array` کو سائز صفر کے ساتھ شروع کرنا چاہیے، اس طرح:

```typescript
let arr = new Array<string>(0) // []

arr.push('something') // ["something"]
```

یا آپ کو اسے انڈیکس کے ذریعے تبدیل کرنا چاہئے:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'something' // ["something", "", "", "", ""]
```

### گراف کیو ایل اسکیما

یہ اسمبلی اسکرپٹ میں براہ راست تبدیلی نہیں ہے، لیکن آپ کو اپنی `schema.graphql` فائل کو اپ ڈیٹ کرنا پڑ سکتا ہے.

اب آپ اپنی اقسام میں ان فیلڈز کی وضاحت نہیں کر سکتے جو کہ غیر منسوخ فہرست ہیں۔ اگر آپ کے پاس اس طرح کا سکیما ہے:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something]! # no longer valid
}
```

آپ کو فہرست کی قسم کے میمبر میں ایک `!` شامل کرنا پڑے گا، اس طرح:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # valid
}
```

یہ اسمبلی اسکرپٹ ورژنز کے درمیان منسوخی کے فرق کی وجہ سے تبدیل ہوا، اور اس کا تعلق `src/generated/schema.ts` فائل سے ہے (پہلے سے طے شدہ راستہ، ہو سکتا ہے آپ نے اسے تبدیل کیا ہو).

### دوسرا

- قیاس کے ساتھ منسلک `Map#set` اور `Set#add`، واپس کر رہے ہیں `this` ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- ایریس اب ArrayBufferView سے وراثت میں نہیں ملتی ہیں، لیکن اب الگ ہیں ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- آبجیکٹ لٹریلز سے شروع کی گئی کلاسز اب کنسٹرکٹر کی وضاحت نہیں کر سکتی ہیں ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- ایک `**` بائنری آپریشن کا نتیجہ اب مشترکہ ڈینومینیٹر انٹیجر ہے اگر دونوں آپرینڈ انٹیجرز ہیں۔ اس سے پہلے، نتیجہ ایک فلوٹ تھا جیسے کہ کال کر رہا ہو `Math/f.pow` ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- زبردستی `NaN` کو `false` جب `bool` ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9)) پر کاسٹ کریں
- `i8`/`u8` یا `i16`/`u16` قسم کی چھوٹی انٹیجر ویلیو کو منتقل کرتے وقت، بالترتیب صرف 3 کم از کم 4 RHS ویلیو کے اہم بٹس نتیجہ کو متاثر کرتے ہیں، جو کہ `i32.shl` کے نتیجہ کے مطابق صرف RHS ویلیو کے 5 کم سے کم اہم بٹس سے متاثر ہوتے ہیں۔ مثال: `someI8 << 8` نے پہلے `0` کی ویلیو تیار کی تھی، لیکن اب RHS کو `8 & 7 = 0` (3 بٹس) ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0))
- جب سائز مختلف ہوں تو متعلقہ سٹرنگ کے موازنہ کی بگ فکس ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
