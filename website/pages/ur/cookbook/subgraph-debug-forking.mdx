---
title: فورکس کا استعمال کرتے ہوۓ تیز اور آسان ڈیبگنگ
---

جیسا کہ بہت سے سسٹمز بڑی مقدار میں ڈیٹا پر کارروائی کرتے ہیں، گراف کے انڈیکسرز (گراف نوڈس) کو آپ کے سب گراف کو ٹارگٹ بلاکچین کے ساتھ ہم آہنگ کرنے میں کافی وقت لگ سکتا ہے۔ ڈیبگنگ کے مقصد کے ساتھ فوری تبدیلیوں اور انڈیکسنگ کے لیے درکار طویل انتظار کے اوقات کے درمیان فرق انتہائی غیر نتیجہ خیز ہے اور ہم اس سے بخوبی واقف ہیں۔ یہی وجہ ہے کہ ہم **سب گراف فورکنگ** متعارف کروا رہے ہیں، جسے [LimeChain](https://limechain.tech/) نے تیار کیا ہے، اور اس مضمون میں میں آپ کو دکھاؤں گا کہ کس طرح اس خصوصیت کو سب گراف ڈیبگنگ کو تیز کرنے کے لیے استعمال کیا جا سکتا ہے!

## ٹھیک ہے، یہ ہے کیا؟

**سب گراف فورکنگ ** _دوسرے_ سب گراف اسٹور (عام طور پر ایک دور دراز) سے سستی سے ہستیوں کو بازیافت کرنے کا عمل ہے.

ڈیبگنگ کے تناظر میں، **سب گراف فورکنگ** آپ کو بغیر انتظار کیے بلاک _X_ پر اپنے ناکام سب گراف کو ڈیبگ کرنے کی اجازت دیتا ہے۔ _X_ کو بلاک کرنے کے لیے مطابقت پذیری کے لیے.

## کیا؟! کیسے؟

جب آپ انڈیکسنگ کے لیے ریموٹ گراف نوڈ پر سب گراف کو تعینات کرتے ہیں اور یہ بلاک _X_ پر ناکام ہوجاتا ہے، تو اچھی خبر یہ ہے کہ گراف نوڈ اب بھی اپنے اسٹور کا استعمال کرتے ہوئے GraphQL کیوریز پیش کرے گا، جو _X_ کو بلاک کرنے کے لیے مطابقت پذیر ہے۔ یہ بہت اچھا ہے! اس کا مطلب ہے کہ ہم بلاک _X_ کو انڈیکس کرتے وقت پیدا ہونے والے بگ کو ٹھیک کرنے کے لیے اس "تازہ ترین" اسٹور کا فائدہ اٹھا سکتے ہیں.

مختصر طور پر، ہم ریموٹ گراف نوڈ سے _ناکام سب گراف کو فورک کرنے جا رہے ہیں_ جس کی ضمانت دی گئی ہے کہ سب گراف کو بلاک کرنے کے لیے انڈیکس کیا جائے گا _X_ بلاک _X_ پر ڈی بگ کیے جانے والے مقامی طور پر تعینات سب گراف فراہم کرنے کے لیے انڈیکسنگ کی حالت کا تازہ ترین منظر.

## براۓ مہربانی، مجہے کچھ کوڈ دکھائیں!

سب گراف ڈی بگنگ پر توجہ مرکوز رکھنے کے لیے، آئیے چیزوں کو سادہ رکھیں اور [مثالی- سب گراف](https://github.com/graphprotocol/graph-tooling/tree/main/examples/ethereum-gravatar) کے ساتھ چلائیں۔ ایتھیریم گریویٹی سمارٹ کنٹریکٹ کی انڈیکس کرنا.

یہاں `Gravatar` کی انڈیکسنگ کے لیے بیان کردہ ہینڈلرز ہیں، بغیر کسی بگ کے:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

افوہ، کتنی بدقسمتی کی بات ہے، جب میں اپنے بہترین نظر آنے والے سب گراف کو [ہوسٹڈ سروس](https://thegraph.com/hosted-service/) میں تعینات کرتا ہوں تو یہ _"گراوتار نہیں ملا!"_ خرابی.

درست کرنے کی کوشش کرنے کا معمول کا طریقہ یہ ہے:

1. میپنگ کے ماخذ میں تبدیلی کریں، جس کے بارے میں آپ کو یقین ہے کہ مسئلہ حل ہو جائے گا (جبکہ میں جانتا ہوں کہ ایسا نہیں ہوگا).
2. سب گراف کو [ہوسٹڈ سروس](https://thegraph.com/hosted-service/) (یا کسی اور ریموٹ گراف نوڈ) پر دوبارہ تعینات کریں.
3. اس کے مطابقت پذیر ہونے کا انتظار کریں.
4. اگر یہ دوبارہ ٹوٹ جاتا ہے تو 1 پر واپس جائیں، ورنہ: ہورے!

یہ واقعی ایک عام ڈیبگ کے عمل سے کافی واقف ہے، لیکن ایک قدم ایسا ہے جو اس عمل کو بری طرح سست کر دیتا ہے: _3۔ اس کے مطابقت پذیر ہونے کا انتظار کریں۔_

**سب گراف فورکنگ** کا استعمال کرتے ہوئے ہم بنیادی طور پر اس مرحلے کو ختم کر سکتے ہیں۔ یہاں یہ کیسا لگتا ہے:

0. **_مناسب فورک بیس_** سیٹ کے ساتھ ایک مقامی گراف نوڈ کو اسپن اپ کریں.
1. میپنگ کے ماخذ میں تبدیلی کریں، جس سے آپ کو یقین ہے کہ مسئلہ حل ہو جائے گا.
2. مقامی گراف نوڈ پر تعینات کریں، **_ناکام سب گراف کو روکنا_** اور ** _مسائل والے بلاک سے شروع_**.
3. اگر یہ دوبارہ ٹوٹ جاتا ہے، تو 1 پر واپس جائیں، ورنہ: ہورے!

اب، آپ کے پاس 2 سوالات ہوسکتے ہیں:

1. فورک بیس کیا؟؟؟
2. فورکنگ کون؟!

اور میرا جواب:

1. `fork-base` "بیس" یو آر ایل ہے، اس طرح کہ جب _سب گراف آئی ڈی_ کو نتیجہ خیز URL میں شامل کیا جاتا ہے (`<fork-base>/<subgraph-id>`) سب گراف کے اسٹور کے لیے ایک درست گراف کیو ایل اینڈ پوائنٹ ہے.
2. فورکنگ آسان ہے، پریشان ہونے کی ضرورت نہیں ہے:

```bash
$ graph deploy <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

اس کے علاوہ، سب گراف مینی فیسٹ میں `dataSources.source.startBlock` فیلڈ کو مشکل بلاک کی تعداد پر سیٹ کرنا نہ بھولیں، تاکہ آپ غیر ضروری بلاکس کو انڈیکس کرنا چھوڑ کر فورک کا فائدہ اٹھا سکیں!

تو، یہاں میں کیا کرتا ہوں:

0. میں ایک مقامی گراف نوڈ کو گھماتا ہوں ([یہ کیسے کرنا ہے](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) `fork-base` اختیار کے ساتھ اس پر سیٹ کیا گیا ہے: `https://api.thegraph.com/subgraphs/id/`، چونکہ میں ایک سب گراف کو فورک کروں گا، وہ چھوٹی چھوٹی جسے میں نے تعینات کیا ہے پہلے، [ہوسٹڈ سروس](https://thegraph.com/hosted-service/) سے.

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

1. محتاط معائنے کے بعد میں نے محسوس کیا کہ میرے دو ہینڈلرز میں `Gravatar` کو انڈیکس کرتے وقت استعمال ہونے والی `id` نمائندگیوں میں کوئی مماثلت نہیں ہے۔ جب کہ `handleNewGravatar` اسے ہیکس میں تبدیل کرتا ہے (`()event.params.id.toHex`)، ` handleUpdatedGravatar` int32 استعمال کرتا ہے (`()event.params.id.toI32`) جس کی وجہ سے `handleUpdatedGravatar` "Gravatar نہیں ملا!" سے گھبراتا ہے۔ میں ان دونوں کو `id` کو ہیکس میں تبدیل کرتا ہوں.
2. تبدیلیاں کرنے کے بعد میں اپنے سب گراف کو مقامی گراف نوڈ پر تعینات کرتا ہوں، **_ناکام سب گراف کو فورک کرنا_** اور ترتیب < `subgraph.yaml` میں `6190343` کو `dataSources.source.startBlock`:

```bash
$ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

3. میں مقامی گراف نوڈ کے ذریعہ تیار کردہ لاگز کا معائنہ کرتا ہوں اور ہورے!، ایسا لگتا ہے کہ سب کچھ کام کر رہا ہے.
4. میں اپنے اب بگ فری سب گراف کو ریموٹ گراف نوڈ پر تعینات کرتا ہوں اور اس کے بعد ہمیشہ خوشی سے جیتا ہوں! (کوئی آلو نہیں)
5. ختم شد...
