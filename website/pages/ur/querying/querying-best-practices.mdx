---
title: بہترین طریقوں سے استفسار کرنا
---

گراف بلاکچینز سے ڈیٹا کو استفسار کرنے کا ایک ڈیسینٹرالائزڈ طریقہ فراہم کرتا ہے.

گراف نیٹ ورک کا ڈیٹا گراف کیو ایل API کے ذریعے ظاہر کیا جاتا ہے، جس سے گراف کیو ایل لینگویج کے ساتھ ڈیٹا سے استفسار کرنا آسان ہو جاتا ہے.

یہ صفحہ گراف کیو ایل لینگویج کے ضروری اصولوں اور گراف کیو ایل سوالات کے بہترین طریقوں کے بارے میں آپ کی رہنمائی کرے گا.

---

## ایک گراف کیو ایل API کا استفسار کرنا

### گراف کیو ایل کے استفسار کی اناٹومی

REST API کے برعکس، ایک گراف کیو ایل API ایک اسکیما پر بنایا گیا ہے جو اس بات کی وضاحت کرتا ہے کہ کون سے سوالات کیے جا سکتے ہیں.

مثال کے طور پر، `token` استفسار کا استعمال کرتے ہوئے ٹوکن حاصل کرنے کے لیے ایک سوال اس طرح نظر آئے گا:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

جو درج ذیل قابل پیشن گوئی JSON جواب واپس کرے گا (_جب مناسب `$id` متغیر ویلیو_ کو پاس کریں گے):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

گراف کیو ایل استفسارات گراف کیو ایل لینگویج استعمال کرتے ہیں، جس کی وضاحت [ایک تصریح](https://spec.graphql.org/) پر ہوتی ہے.

مندرجہ بالا `GetToken` استفسار لینگویج کے متعدد حصوں پر مشتمل ہے (نیچے `[...]` پلیس ہولڈرز سے بدل دیا گیا ہے):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

اگرچہ نحوی کرنے اور نہ کرنے کی فہرست طویل ہے، لیکن گراف کیو ایل کے سوالات لکھنے کی بات کرتے وقت ذہن میں رکھنے کے لیے ضروری اصول یہ ہیں:

- ہر ایک `queryName` کو فی آپریشن صرف ایک بار استعمال کیا جانا چاہیے.
- ہر ایک ` field ` کو انتخاب میں صرف ایک بار استعمال کیا جانا چاہیے (ہم `token` کے تحت دو بار `id` سے استفسار نہیں کرسکتے ہیں)
- کچھ ` field ` یا استفسارات (جیسے `tokens`) پیچیدہ قسمیں واپس کرتے ہیں جن کے لیے سب فیلڈ کے انتخاب کی ضرورت ہوتی ہے۔ توقع کے وقت انتخاب فراہم نہ کرنا (یا توقع نہ ہونے پر انتخاب فراہم کرنا - مثال کے طور پر، `id` پر) ایک خرابی پیدا کرے گا۔ فیلڈ کی قسم جاننے کے لیے، براہ کرم [گراف ایکسپلورر](/network/explorer) سے رجوع کریں.
- کسی دلیل کو تفویض کردہ کوئی بھی متغیر اس کی قسم سے مماثل ہونا چاہیے.
- متغیرات کی دی گئی فہرست میں، ان میں سے ہر ایک منفرد ہونا چاہیے.
- تمام متعین متغیرات کو استعمال کیا جانا چاہیے.

مندرجہ بالا قواعد کی پیروی کرنے میں ناکامی گراف API کی غلطی کے ساتھ ختم ہو جائے گی.

کوڈ کی مثالوں کے ساتھ قواعد کی مکمل فہرست کے لیے، براہ کرم ہمارے گراف کیو ایل کی توثیق گائیڈ دیکھیں.

<br />

### گراف کیو ایل API کو ایک سوال بھیجنا

گراف کیو ایل ایک لینگویج اور کنونشنز کا مجموعہ ہے جو HTTP پر نقل و حمل کرتا ہے.

اس کا مطلب ہے کہ آپ معیاری `fetch` (مقامی طور پر یا `@whatwg-node/fetch` یا `isomorphic-fetch` کے ذریعے) کا استعمال کرتے ہوئے گراف کیو ایل API سے استفسار کرسکتے ہیں.

تاہم، جیسا کہ ["ایک درخواست سے استفسار کرنا"](/querying/querying-from-an-application) میں بتایا گیا ہے، ہم آپ کو ہمارا `graph-client` استعمال کرنے کی تجویز کرتے ہیں جو منفرد خصوصیات کی حمایت کرتا ہے جیسے:

- کراس چین سب گراف ہینڈلنگ: ایک سوال میں متعدد سب گرافس سے استفسار کرنا
- [خودکار بلاک ٹریکنگ](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [خودکار صفحہ بندی](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- مکمل طور پر ٹائپ شدہ نتیجہ

<br />

`graph-client` کے ساتھ گراف سے استفسار کرنے کا طریقہ یہاں ہے:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

مزید گراف کیو ایل کلائنٹ متبادلات کا احاطہ ["ایک درخواست سے استفسار کرنا"](/querying/querying-from-an-application) میں کیا گیا ہے.

<br />

اب جب کہ ہم نے گراف کیو ایل استفسارات کی ترکیب کے بنیادی اصولوں کا احاطہ کیا ہے، آئیے اب گراف کیو ایل استفسار تحریر کے بہترین طریقوں کو دیکھتے ہیں.

---

## گراف کیو ایل کے سوالات لکھنا

### ہمیشہ جامد سوالات لکھیں

ایک عام (خراب) پریکٹس مندرجہ ذیل طور پر استفسار کے سٹرنگس کو متحرک طور پر بنانا ہے:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

جبکہ مذکورہ بالا ٹکڑا ایک درست گراف کیو ایل استفسار پیدا کرتا ہے، **اس میں بہت سی خرابیاں ہیں**:

- یہ مجموعی طور پر سوال کو **سمجھنا مشکل** بناتا ہے
- ڈویلپرز **سٹرنگ انٹرپولیشن کو محفوظ طریقے سے صاف کرنے کے ذمہ دار ہیں**
- متغیر کی ویلیوس کو درخواست کے پیرامیٹرز کے حصے کے طور پر نہ بھیجنا **سرور سائیڈ پر ممکنہ کیشنگ کو روکتا ہے**
- یہ **ٹولز کو استفسار کا مستحکم تجزیہ کرنے سے روکتا ہے** (مثال کے طور پر: Linter، یا جنریشنز ٹولز ٹائپ کریں)

اس وجہ سے، استفسارات کو ہمیشہ جامد سٹرنگس کے طور پر لکھنے کی سفارش کی جاتی ہے:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

ایسا کرنے سے **بہت سے فائدے** ہوتے ہیں:

- سوالات کو **پڑھنے اور برقرار رکھنے میں آسانی**
- گراف کیو ایل **سرور متغیرات کو صاف کرتا ہے**
- سرور کی سطح پر **متغیرات کو کیش کیا جا سکتا ہے**
- **سوالات کا مستحکم طور پر ٹولز کے ذریعے تجزیہ کیا جا سکتا ہے** (مندرجہ ذیل حصوں میں اس پر مزید)

**نوٹ: جامد سوالات میں فیلڈز کو مشروط طور پر کیسے شامل کیا جائے**

ہم صرف ایک خاص شرط پر ` owner ` فیلڈ کو شامل کرنا چاہتے ہیں.

اس کے لیے، ہم ذیل میں `@include(if:...)` ہدایت کا فائدہ اٹھا سکتے ہیں:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

نوٹ: مخالف ہدایت `@skip(if: ...)` ہے.

<br />

### کارکردگی کی تجاویز

**"جو چاہو مانگو"**

گراف کیو ایل اپنی "جو چاہو مانگو" ٹیگ لائن کے لیے مشہور ہوا.

اس وجہ سے، گراف کیو ایل میں، تمام دستیاب فیلڈز کو انفرادی طور پر فہرست بنائے بغیر حاصل کرنے کا کوئی طریقہ نہیں ہے.

گراف کیو ایل APIs سے استفسار کرتے وقت، ہمیشہ صرف ان فیلڈز سے استفسار کرنے کے بارے میں سوچیں جو حقیقت میں استعمال ہوں گے.

اوور فیچنگ کی ایک عام وجہ اداروں کا مجموعہ ہے۔ پہلے سے طے شدہ طور پر، سوالات ایک مجموعہ میں 100 ہستیوں کو حاصل کریں گے، جو عام طور پر اس سے کہیں زیادہ ہوتا ہے جو اصل میں استعمال کیا جائے گا، مثلاً، صارف کو دکھانے کے لیے۔ اس لیے سوالات کو تقریباً ہمیشہ پہلے واضح طور پر سیٹ کرنا چاہیے، اور اس بات کو یقینی بنانا چاہیے کہ وہ صرف اتنی ہی ہستیوں کو حاصل کریں جتنی انھیں درحقیقت ضرورت ہے۔ اس کا اطلاق نہ صرف استفسار میں اعلیٰ سطحی مجموعوں پر ہوتا ہے، بلکہ اس سے بھی زیادہ اداروں کے گھریلو مجموعوں پر ہوتا ہے.

مثال کے طور پر، درج ذیل استفسار میں:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

جواب میں 100 ٹوکنز میں سے ہر ایک کے لیے 100 ٹرانزیکشن ہو سکتے ہیں.

اگر ایپلیکیشن کو صرف 10 ٹرانزیکشنز کی ضرورت ہے، سوال کو واضح طور پر ٹرانزیکشنز فیلڈ پر `first: 10` سیٹ کرنا چاہیے.

**متعدد سوالات کو یکجا کرنا**

آپ کی درخواست کو درج ذیل کے طور پر متعدد قسم کے ڈیٹا سے استفسار کرنے کی ضرورت ہو سکتی ہے:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

جب کہ یہ نفاذ مکمل طور پر درست ہے، اس کے لیے گراف کیو ایل API کے ساتھ دو چکر لگانے کی ضرورت ہوگی.

خوش قسمتی سے، درج ذیل کے طور پر ایک ہی گراف کیو ایل درخواست میں متعدد سوالات بھیجنا بھی درست ہے:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

یہ نقطہ نظر نیٹ ورک پر گزارے جانے والے وقت کو کم کرکے (آپ کو API کا ایک راؤنڈ ٹرپ بچاتا ہے) **مجموعی کارکردگی کو بہتر بنائے گا** اور ایک **مزید جامع نفاذ** فراہم کرے گا.

<br />

### لیوریج گراف کیو ایل فریگمنٹس

گراف کیو ایل سوالات لکھنے کے لیے ایک مددگار خصوصیت گراف کیو ایل فریگمنٹ ہے.

درج ذیل استفسار کو دیکھتے ہوئے، آپ دیکھیں گے کہ کچھ فیلڈز کو متعدد سلیکشن سیٹس (`{ ... }`) میں دہرایا جاتا ہے:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

اس طرح کے دہرائے جانے والے فیلڈز (`id`, `active`, `status`) بہت سے مسائل لاتے ہیں:

- مزید وسیع سوالات کے لیے پڑھنا مشکل ہے
- ایسے ٹولز کا استعمال کرتے وقت جو سوالات کی بنیاد پر ٹائپ اسکرپٹ کی قسمیں تیار کرتے ہیں (_آخری حصے میں اس پر مزید_)، `newDelegate` اور `oldDelegate` کے نتیجے میں دو الگ الگ ان لائن انٹرفیس ہوں گے.

استفسار کا ایک ریفیکٹر ورژن درج ذیل ہوگا:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

گراف کیو ایل `fragment` کا استعمال پڑھنے کی اہلیت کو بہتر بنائے گا (خاص طور پر پیمانے پر) لیکن اس کے نتیجے میں ٹائپ اسکپٹ ٹائپس جینریشن بہتر ہوں گی.

ٹائپ جنریشن ٹول کا استعمال کرتے وقت، مندرجہ بالا استفسار ایک مناسب `DelegateItemFragment` قسم پیدا کرے گا (_آخری "ٹولز" سیکشن دیکھیں_).

<br />

### گراف کیو ایل فریگمنٹ کیا کریں اور نہ کریں

**فریگمنٹ بیس ایک ٹائپ کا ہونا چاہیے**

ایک فریگمینٹ غیر قابل اطلاق ٹائپ پر مبنی نہیں ہو سکتا، مختصراً، **اس ٹائپ پر جس میں فیلڈز نہیں ہیں**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` ایک **اسکالر** (مقامی "سادہ" ٹائپ) ہے جسے فریگمینٹس کی بنیاد کے طور پر استعمال نہیں کیا جاسکتا.

**فریگمینٹ پھیلانے کا طریقہ**

فریگمینٹس کی وضاحت مخصوص ٹائپس پر کی جاتی ہے اور اس کے مطابق استفسارات میں استعمال کیا جانا چاہیے.

مثال:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` اور `oldDelegate` ٹائپ `Transcoder` ہیں.

یہاں `Vote` ٹائپ کے ٹکڑے کو پھیلانا ممکن نہیں ہے.

**فریگمنٹ کو ڈیٹا کی ایٹم بزنس یونٹ کے طور پر بیان کریں**

گراف کیو ایل فریگمنٹ کو ان کے استعمال کی بنیاد پر بیان کیا جانا چاہیے.

زیادہ تر استعمال کے کیس کے لیے، فی ٹائپ کے ایک فریگمینٹ کی وضاحت کرنا (بار بار فیلڈز کے استعمال یا ٹائپ جنریشن کی صورت میں) کافی ہے.

فریگمینٹ استعمال کرنے کے لیے یہاں انگوٹھے کا اصول ہے:

- جب ایک ہی قسم کے فیلڈز کو ایک کیوری میں دہرایا جاتا ہے، تو انہیں ایک فریگمینٹ میں گروپ کریں
- جب ایک جیسے لیکن ایک جیسے فیلڈز کو دہرایا نہیں جاتا ہے، تو متعدد فریگمینٹس بنائیں، مثال کے طور پر:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## ضروری اوزار

### گراف کیو ایل ویب پر مبنی ایکسپلوررز

سوالات کو اپنی درخواست میں چلا کر ان پر تکرار کرنا بوجھل ہو سکتا ہے۔ اس وجہ سے، اپنی درخواست میں شامل کرنے سے پہلے اپنے سوالات کو جانچنے کے لیے [گراف ایکسپلورر](https://thegraph.com/explorer) کا استعمال کرنے میں ہچکچاہٹ محسوس نہ کریں۔ گراف ایکسپلورر آپ کے سوالات کو جانچنے کے لیے آپ کو پہلے سے ترتیب شدہ گراف کیو ایل پلے گراؤنڈ فراہم کرے گا.

اگر آپ اپنے سوالات کو ڈیبگ/ٹیسٹ کرنے کے لیے مزید لچکدار طریقہ تلاش کر رہے ہیں، تو اسی طرح کے دیگر ویب پر مبنی ٹولز دستیاب ہیں جیسے کہ [Altair](https://altair.sirmuel.design/) اور [GraphiQL](https://graphiql-online.com/graphiql).

<br />

### گراف کیو ایل لنٹنگ

مذکورہ بالا بہترین طریقوں اور نحوی اصولوں کو برقرار رکھنے کے لیے، درج ذیل ورک فلو اور IDE ٹولز کو استعمال کرنے کی انتہائی سفارش کی جاتی ہے.

**GraphQL ESLint**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) صفر کی کوشش کے ساتھ گراف کیو ایل کے بہترین طریقوں میں سرفہرست رہنے میں آپ کی مدد کرے گا.

["operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) کو ترتیب دینا ضروری اصولوں کو نافذ کرے گا جیسے:

- `@graphql-eslint/fields-on-correct-type`: کیا فیلڈ ایک مناسب ٹائپ پر استعمال ہوتی ہے؟
- `@graphql-eslint/no-unused variables`: کیا دیئے گئے متغیر کو غیر استعمال شدہ رہنا چاہئے؟
- اور مزید!

یہ آپ کو پلے گراؤنڈ میں یا انہیں پروڈکشن میں چلانے کے **سوالات کی جانچ کیے بغیر بھی غلطیوں کو پکڑنے** کی اجازت دے گا!

<br />

### IDE plugins

**VSCode اور GraphQL**

[GraphQL VSCode ایکسٹینشن](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) حاصل کرنے کے لیے آپ کے ترقیاتی ورک فلو میں ایک بہترین اضافہ ہے:

- نحو کو نمایاں کرنا
- خودکار تکمیل کی تجاویز
- اسکیما کے خلاف توثیق
- ٹکڑے
- ٹکڑوں اور ان پٹ کی اقسام کے لیے تعریف پر جائیں

اگر آپ `graphql-eslint` استعمال کر رہے ہیں، تو [ESLint VSCode ایکسٹینشن](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) ہے آپ کے کوڈ میں موجود غلطیوں اور انتباہات کو درست طریقے سے دیکھنا ضروری ہے.

**WebStorm/Intellij اور GraphQL**

[JS گراف کیو ایل پلگ ان](https://plugins.jetbrains.com/plugin/8097-graphql/) فراہم کر کے گراف کیو ایل کے ساتھ کام کرتے ہوئے آپ کے تجربے کو نمایاں طور پر بہتر بنائے گا:

- نحو کو نمایاں کرنا
- خودکار تکمیل کی تجاویز
- اسکیما کے خلاف توثیق
- ٹکڑے

اس [WebStorm مضمون](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) پر مزید معلومات جو پلگ ان کی تمام اہم خصوصیات کو ظاہر کرتا ہے.
