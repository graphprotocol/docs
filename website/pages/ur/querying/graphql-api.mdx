---
title: GraphQL API
---

یہ گائیڈ GraphQL کیوری API کی وضاحت کرتا ہے جو گراف پروٹوکول کے لیے استعمال ہوتا ہے.

## کیوریز

اپنے سب گراف اسکیما میں آپ `Entities` نامی اقسام کی وضاحت کرتے ہیں۔ ہر ایک `Entity` قسم کے لیے، ایک `entity` اور `entities` فیلڈ کو اعلی درجے کی `Query` قسم پر تیار کیا جائے گا۔ نوٹ کریں کہ گراف استعمال کرتے وقت `Query` کو `graphql` کیوری کے اوپر شامل کرنے کی ضرورت نہیں ہے.

### مثالیں

آپ کے اسکیما میں بیان کردہ واحد `Token` ہستی کے لیے کیوری:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> **نوٹ:** کسی ایک ہستی کے لیے کیوری کرتے وقت، `id` فیلڈ درکار ہے, اور یہ ایک سٹرنگ ہونا چاہیے.

تمام `Token` اداروں سے کیوری کریں:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### سورٹنگ

کسی مجموعہ سے کیوری کرتے وقت، `orderBy` پیرامیٹر کو کسی خاص وصف کے مطابق ترتیب دینے کے لیے استعمال کیا جا سکتا ہے۔ اضافی طور پر، ترتیب کی سمت بتانے کے لیے `orderDirection` استعمال کیا جا سکتا ہے، `asc` چڑھنے کے لیے یا `desc` اترنے کے لیے.

#### مثال

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### نیسٹڈ ہستی کی چھانٹی کی مثال

گراف نوڈ کے مطابق [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) ہستیوں کو ترتیب دیا جا سکتا ہے نیسٹڈ اداروں کی بنیاد پر.

درج ذیل مثال میں، ہم ٹوکنز کو ان کے مالک کے نام سے ترتیب دیتے ہیں:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> فی الحال, آپ `@entity` اور `@derivedFrom` فیلڈز پر ایک سطح کی گہری `String` یا `ID` اقسام کے مطابق ترتیب دے سکتے ہیں۔ بدقسمتی سے، [ایک سطح کی گہری ہستیوں پر انٹرفیس کے لحاظ سے چھانٹنا](https://github.com/graphprotocol/graph-node/pull/4058)، ان فیلڈز کے لحاظ سے چھانٹنا جو اری اور نیسٹڈ ہستی ہیں ابھی تک حمایت نہیں کی.

### صفحہ بندی

کسی مجموعہ سے کیوری کرتے وقت، `first` پیرامیٹر کو مجموعہ کے آغاز سے صفحہ بندی کرنے کے لیے استعمال کیا جا سکتا ہے۔ یہ بات قابل غور ہے کہ ڈیفالٹ ترتیب ترتیب صعودی حرفی ترتیب میں ID کے لحاظ سے ہے ، تخلیق کے وقت سے نہیں.

مزید، `skip` پیرامیٹر کو ہستیوں کو چھوڑنے اور صفحہ بندی کرنے کے لیے استعمال کیا جا سکتا ہے۔ جیسے `first:100` پہلی 100 ہستیوں کو دکھاتا ہے اور `first:100, skip:100` اگلی 100 ہستیوں کو دکھاتا ہے.

کیوریز کو بہت بڑی `skip` اقدار کے استعمال سے گریز کرنا چاہیے کیونکہ وہ عام طور پر خراب کارکردگی کا مظاہرہ کرتے ہیں۔ بڑی تعداد میں آئٹمز کو بازیافت کرنے کے لیے، کسی خاصیت کی بنیاد پر ہستیوں کے ذریعے صفحہ بنانا بہت بہتر ہے جیسا کہ آخری مثال میں دکھایا گیا ہے.

#### `first` استعمال کرنے کی مثال

پہلے 10 ٹوکنز سے کیوری کریں:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

مجموعے کے بیچ میں اداروں کے گروپس کے لیے کیوری کرنے کے لیے، `skip` پیرامیٹر کو `first` پیرامیٹر کے ساتھ استعمال کیا جا سکتا ہے تاکہ مجموعہ کے آغاز سے شروع ہونے والی ایک مخصوص تعداد کو چھوڑ دیا جا سکے.

#### `first` اور `skip` استعمال کرنے کی مثال

کیوری 10 `Token` ہستیوں کو، مجموعہ کے آغاز سے 10 مقامات سے آف سیٹ:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### `first` اور `id_ge` استعمال کرنے کی مثال

اگر کسی کلائنٹ کو بڑی تعداد میں ہستیوں کو بازیافت کرنے کی ضرورت ہے، کسی وصف پر کیوری کی بنیاد رکھنا اور اس وصف سے فلٹر کرنا زیادہ پرفارمنس ہے۔ مثال کے طور پر، ایک کلائنٹ اس کیوری کا استعمال کرتے ہوئے بڑی تعداد میں ٹوکنز بازیافت کرے گا:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

پہلی بار، یہ `lastID = ""` کے ساتھ کیوری بھیجے گا، اور اس کے بعد کی درخواستوں کے لیے `lastID` کو آخری کی `id` پچھلی درخواست میں آخری ہستی کے وصف پر سیٹ کرے گا۔ یہ نقطہ نظر `skip` اقدار کو بڑھانے کے مقابلے میں نمایاں طور پر بہتر کارکردگی کا مظاہرہ کرے گا.

### فلٹرنگ

آپ مختلف خصوصیات کو فلٹر کرنے کے لیے اپنے کیوریز میں `where` پیرامیٹر استعمال کر سکتے ہیں۔ آپ `where` پیرامیٹر کے اندر متعدد اقدار پر فلٹر کرسکتے ہیں.

#### `where` استعمال کرنے کی مثال

`failed` نتیجہ کے ساتھ کیوری کے چیلنجز:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

آپ قدر کے موازنہ کے لیے `_gt`، `_lte` جیسے لاحقے استعمال کرسکتے ہیں:

#### رینج فلٹرنگ کی مثال

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### بلاک فلٹرنگ کی مثال

آپ `_change_block(number_gte: Int)` کے ذریعے بھی ہستیوں کو فلٹر کر سکتے ہیں - یہ ان ہستیوں کو فلٹر کرتا ہے جو مخصوص بلاک میں یا اس کے بعد اپ ڈیٹ ہوئے تھے.

یہ کارآمد ہو سکتا ہے اگر آپ صرف ان ہستیوں کو لانے کے خواہاں ہیں جو تبدیل ہو چکی ہیں، مثال کے طور پر آخری بار جب آپ نے پول کیا تھا۔ یا متبادل طور پر یہ تحقیق کرنا یا ڈیبگ کرنا مفید ہو سکتا ہے کہ آپ کے سب گراف میں ہستی کیسے تبدیل ہو رہی ہیں (اگر بلاک فلٹر کے ساتھ ملایا جائے تو، آپ صرف ان ہستیوں کو الگ تھلگ کر سکتے ہیں جو ایک مخصوص بلاک میں تبدیل ہوئی ہیں).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### نیسٹڈ ہستی فلٹرنگ کی مثال

`_` لاحقہ والے فیلڈز میں نیسٹڈ ہستیوں کی بنیاد پر فلٹرنگ ممکن ہے.

یہ مفید ہو سکتا ہے اگر آپ صرف ان ہستیوں کو لانے کے خواہاں ہیں جن کی چائلڈ لیول کے ہستی فراہم کردہ شرائط کو پورا کرتے ہیں.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### منطقی آپریٹرز

گراف نوڈ کے مطابق [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) آپ متعدد گروپ بنا سکتے ہیں۔ ایک سے زیادہ معیارات کی بنیاد پر نتائج کو فلٹر کرنے کے لیے `and` یا `or` آپریٹرز کا استعمال کرتے ہوئے اسی `where` دلیل میں پیرامیٹرز.

##### `AND` آپریٹر

مندرجہ ذیل مثال میں، ہم `outcome` `succeeded` اور `number` کے ساتھ چیلنجوں کے لیے فلٹر کر رہے ہیں جو `100` سے زیادہ یا اس کے برابر ہیں.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Syntactic شوگر:** آپ `and` آپریٹر کو ہٹا کر کوما سے الگ کردہ سب اظہار کو پاس کر کے مذکورہ کیوری کو آسان بنا سکتے ہیں.
>
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### `OR` آپریٹر

مندرجہ ذیل مثال میں، ہم `outcome` `succeeded` اور `number` کے ساتھ چیلنجوں کے لیے فلٹر کر رہے ہیں جو `100` سے زیادہ یا اس کے برابر ہیں.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **نوٹ**: کیوریز تیار کرتے وقت، `or` آپریٹر کے استعمال کے کارکردگی کے اثرات پر غور کرنا ضروری ہے۔ جب کہ `or` تلاش کے نتائج کو وسیع کرنے کے لیے ایک کارآمد ٹول ہو سکتا ہے، لیکن اس کے اہم اخراجات بھی ہو سکتے ہیں۔ `or` کے ساتھ اہم مسائل میں سے ایک یہ ہے کہ یہ کیوریز کو سست کرنے کا سبب بن سکتا ہے۔ اس کی وجہ یہ ہے کہ `or` کو متعدد اشاریہ جات کے ذریعے اسکین کرنے کے لیے ڈیٹا بیس کی ضرورت ہوتی ہے، جو کہ ایک وقت طلب عمل ہوسکتا ہے۔ ان مسائل سے بچنے کے لیے، یہ تجویز کیا جاتا ہے کہ ڈویلپرز استعمال کریں اور آپریٹرز کے بجائے یا جب بھی ممکن ہو۔ یہ زیادہ درست فلٹرنگ کی اجازت دیتا ہے اور تیز تر، زیادہ درست کیوریز کا باعث بن سکتا ہے.

#### تمام فلٹرز

پیرامیٹر لاحقوں کی مکمل فہرست:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> براہ کرم نوٹ کریں کہ کچھ لاحقے صرف مخصوص اقسام کے لیے معاون ہیں۔ مثل کے طور پر، `Boolean` صرف `_not`، `_in`، اور `_not_in` کو سپورٹ کرتا ہے، لیکن `_` دستیاب ہے صرف آبجیکٹ اور انٹرفیس کی اقسام کے لیے.

اس کے علاوہ، مندرجہ ذیل عالمی فلٹرز `where` دلیل کے حصے کے طور پر دستیاب ہیں:

```gr
_change_block(number_gte: Int)
```

### ٹائم ٹریول کے کیوریز

آپ اپنے ہستیوں کی حالت کے بارے میں نہ صرف تازہ ترین بلاک کے لیے کیوری کر سکتے ہیں، جو پہلے سے طے شدہ ہے، بلکہ ماضی میں کسی آربٹریری بلاک کے لیے بھی۔ جس بلاک پر کیوری ہونا چاہیے اس کی وضاحت یا تو اس کے بلاک نمبر یا اس کے بلاک ہیش سے کیوریز کے ٹاپ لیول فیلڈز میں `block` دلیل شامل کر کے کی جا سکتی ہے.

اس طرح کے کیوری کا نتیجہ وقت کے ساتھ نہیں بدلے گا، یعنی ماضی کے کسی مخصوص بلاک پر کیوریز کرنے سے وہی نتیجہ آئے گا چاہے اس پر عمل کیا جائے، اس استثنا کے ساتھ کہ اگر آپ چین کے سر کے بالکل قریب بلاک پر کیوری کرتے ہیں۔, نتیجہ تبدیل ہو سکتا ہے اگر وہ بلاک مین چین پر نہ ہو اور چین دوبارہ منظم ہو جائے۔ ایک بار جب کسی بلاک کو حتمی سمجھا جائے تو کیوری کا نتیجہ تبدیل نہیں ہوگا.

نوٹ کریں کہ موجودہ نفاذ اب بھی کچھ حدود کے تابع ہے جو ان ضمانتوں کی خلاف ورزی کر سکتی ہے. نفاذ ہمیشہ یہ نہیں بتا سکتا کہ دیا گیا بلاک ہیش بالکل بھی مین چین پر نہیں ہے، یا یہ کہ کسی بلاک کے لیے بلاک ہیش کے ذریعے کی گئی کیوری کا نتیجہ جسے ابھی تک حتمی نہیں سمجھا جا سکتا ہے، کیوری کے ساتھ ساتھ چلنے والی بلاک کی تنظیم نو سے متاثر ہو سکتا ہے۔ وہ بلاک ہیش کے ذریعے سوالات کے نتائج کو متاثر نہیں کرتے جب بلاک حتمی ہو اور مین چین پر جانا جاتا ہو۔ [یہ مسئلہ](https://github.com/graphprotocol/graph-node/issues/1405) وضاحت کرتا ہے کہ یہ حدود کیا ہیں.

#### مثال

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

یہ کیوری `Challenge` ہستیوں کو لوٹائے گا، اور ان سے وابستہ `Application` ہستیوں، جیسا کہ وہ بلاک نمبر 8,000,000 پروسیسنگ کے بعد براہ راست موجود تھے.

#### مثال

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

یہ کیوری `Challenge` ہستیوں ور ان سے وابستہ `Application` ہستیوں کو لوٹائے گا، جیسا کہ وہ دی گئی ہیش کے ساتھ بلاک پر کارروائی کرنے کے بعد براہ راست موجود تھے.

### فل ٹیکسٹ تلاش کے کیوریز

فل ٹیکسٹ تلاش کے کیوری والے فیلڈز ایک تاثراتی ٹیکسٹ سرچ API فراہم کرتے ہیں جسے سب گراف اسکیما میں شامل کیا جا سکتا ہے اور اپنی مرضی کے مطابق بنایا جا سکتا ہے۔ اپنے سب گراف میں مکمل متن کی تلاش کو شامل کرنے کے لیے [فل ٹیکسٹ سرچ فیلڈز کی وضاحت](/developing/creating-a-subgraph#defining-fulltext-search-fields) سے رجوع کریں.

فل ٹیکسٹ کی تلاش کے کیوریز میں ایک مطلوبہ فیلڈ ہے، `text`, تلاش کی اصطلاحات کی فراہمی کے لیے. اس `text` تلاش کے فیلڈ میں استعمال کرنے کے لیے کئی خصوصی فل ٹیکسٹ آپریٹرز دستیاب ہیں.

فل ٹیکسٹ سرچ آپریٹرز:

| علامت | آپریٹر | تفصیل |
| --- | --- | --- |
| `&` | `And` | ایک سے زیادہ تلاش کی اصطلاحات کو ایک فلٹر میں یکجا کرنے کے لیے ان ہستیوں کے لیے جس میں فراہم کردہ تمام اصطلاحات شامل ہوں |
| &#x7c; | `Or` | Or آپریٹر کے ذریعہ الگ کردہ متعدد تلاش کی اصطلاحات کے ساتھ کیوریز فراہم کردہ شرائط میں سے کسی سے بھی مماثلت کے ساتھ تمام ہستیوں کو واپس کریں گے |
| `<>` | `Follow by` | دو الفاظ کے درمیان فاصلہ بتائیں. |
| `:*` | `Prefix` | ایسے الفاظ تلاش کرنے کے لیے پریفکس ​​تلاش کی اصطلاح استعمال کریں جن کا سابقہ ​​مماثل ہو (۲ حروف درکار ہیں.) |

#### مثالیں

`or` آپریٹر استعمال کرتے ہوۓ​، یہ کیوری بلاگ ہستیوں کو فلٹر کرے گا جس میں ان کے فل ٹیکسٹ فیلڈز میں "انارکزم" یا "کرمپیٹ" کی مختلف حالتیں ہوں گی.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

`follow by` آپریٹر فل ٹیکسٹ دستاویزات میں ایک مخصوص فاصلے کے علاوہ الفاظ کی وضاحت کرتا ہے۔ مندرجہ ذیل کیوری تمام بلاگز کو "ڈیسینٹرلائز" کے بعد "فلسفہ" کے تغیرات کے ساتھ واپس کرے گا

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

مزید پیچیدہ فلٹرز بنانے کے لیے فل ٹیکسٹ آپریٹرز کو یکجا کریں۔ ایک بہانہ سرچ آپریٹر کے ساتھ اس مثال کے کیوری کی پیروی کے ساتھ مل کر بلاگ کے تمام ہستیوں کو ایسے الفاظ سے مماثل کرے گا جو "lou" کے بعد "موسیقی" سے شروع ہوتے ہیں.

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### توثیق

گراف نوڈ [تخصص پر مبنی](https://spec.graphql.org/October2021/#sec-Validation) توثیق کو لاگو کرتا ہے جو اسے [graphql-tools-rs](https:// کا استعمال کرتے ہوئے موصول ہوتا ہے۔ github.com/dotansimha/graphql-tools-rs#validation-rules)، جو [graphql-js حوالہ کا نفاذ](https://github.com/graphql/graphql-js پر مبنی ہے /tree/main/src/validation)۔ وہ کیوریز جو توثیق کے اصول میں ناکام ہو جاتے ہیں ایک معیاری خرابی کے ساتھ ایسا کرتے ہیں - مزید جاننے کے لیے [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) ملاحظہ کریں.

## سکیما

آپ کے ڈیٹا کے ماخذ کا اسکیما -- یعنی، ہستی کی اقسام، اقدار اور رشتے جو کیوری کے لیے دستیاب ہیں -- کی وضاحت [GraphQL انٹرفیس ڈیفینیشن لینگویج (IDL)](https://facebook.github.io/graphql/draft/# کے ذریعے کی گئی ہے۔ sec-Type-System).

GraphQL اسکیمے عام طور پر `queries`، `subscriptions` اور `mutations` کے لیے جڑ کی اقسام کی وضاحت کرتے ہیں۔ گراف صرف `queries` کو سپورٹ کرتا ہے۔ آپ کے سب گراف کے لیے روٹ `Query` قسم خود بخود GraphQL اسکیما سے تیار ہوتی ہے جو آپ کے سب گراف مینی فیسٹ میں شامل ہے.

> **Note:** ہمارا API تغیرات کو ظاہر نہیں کرتا ہے کیونکہ ڈویلپرز سے توقع کی جاتی ہے کہ وہ اپنی ایپلیکیشنز سے بنیادی بلاکچین کے خلاف براہ راست ٹرانزیکشن جاری کریں.

### ہستیوں

آپ کے اسکیما میں `@entity` ہدایات کے ساتھ تمام GraphQL اقسام کو ہستیوں کے طور پر سمجھا جائے گا اور ان کا ایک `ID` فیلڈ ہونا ضروری ہے.

> **نوٹ:** فی الحال، آپ کے اسکیما میں تمام اقسام میں ایک `@entity` ہدایت ہونی چاہیے۔ مستقبل میں، ہم بغیر کسی `@entity` کی قسموں کو ویلیو آبجیکٹ کے طور پر دیکھیں گے، لیکن یہ ابھی تک تعاون یافتہ نہیں ہے.

### سب گراف میٹا ڈیٹا

تمام سب گراف میں ایک خودکار طور پر تیار کردہ `_Meta_` آبجیکٹ ہے، جو سب گراف میٹا ڈیٹا تک رسائی فراہم کرتا ہے۔ اس سے اس طرح کیوری کیا جا سکتا ہے:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

اگر کوئی بلاک فراہم کیا جاتا ہے تو، میٹا ڈیٹا اس بلاک کا ہوتا ہے، اگر تازہ ترین انڈیکسڈ بلاک استعمال نہیں کیا جاتا ہے۔ اگر فراہم کیا گیا ہو، تو بلاک سب گراف کے اسٹارٹ بلاک کے بعد ہونا چاہیے، اور حال ہی میں انڈیکس کیے گئے بلاک سے کم یا اس کے برابر ہونا چاہیے.

`deployment` ایک منفرد ID ہے، جو `subgraph.yaml` فائل کے IPFS CID سے مطابقت رکھتی ہے.

`block` تازہ ترین بلاک کے بارے میں معلومات فراہم کرتا ہے (`_meta` کو بھیجی گئی کسی بھی بلاک کی رکاوٹوں کو مدنظر رکھتے ہوئے):

- ہیش: بلاک کی ہیش
- نمبر: بلاک نمبر
- ٹائم اسٹیمپ: بلاک کا ٹائم اسٹیمپ، اگر دستیاب ہو (یہ فی الحال صرف ای وی ایم نیٹ ورکس کو انڈیکس کرنے والے سب گرافس کے لیے دستیاب ہے)

`hasIndexingErrors` ایک بولین ہے جو اس بات کی نشاندہی کرتا ہے کہ آیا سب گراف کو کچھ ماضی کے بلاک پر انڈیکسنگ کی غلطیوں کا سامنا کرنا پڑا
