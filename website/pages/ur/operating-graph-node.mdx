---
title: گراف نوڈ کو آپریٹ کرنا
---

گراف نوڈ وہ جزو ہے جو سب گراف کو انڈیکس کرتا ہے، اور نتیجے میں ڈیٹا کو GraphQL API کے ذریعے کیوری کے لیے دستیاب کرتا ہے. اس طرح یہ انڈیکسر اسٹیک میں مرکزی حیثیت رکھتا ہے، اور ایک کامیاب انڈیکسر چلانے کے لیے گراف نوڈ کا درست آپریشن بہت ضروری ہے.

یہ گراف نوڈ کا سیاق و سباق کا جائزہ فراہم کرتا ہے، اور انڈیکسرز کے لیے دستیاب کچھ زیادہ جدید اختیارات فراہم کرتا ہے. تفصیلی دستاویزات اور ہدایات [گراف نوڈ ریپوزٹری](https://github.com/graphprotocol/graph-node) میں مل سکتی ہیں.

## گراف نوڈ

[گراف نوڈ](https://github.com/graphprotocol/graph-node) گراف نیٹ ورک پر سب گرافس کو انڈیکس کرنے، بلاکچین کلائنٹس سے منسلک کرنے، سب گرافس کو انڈیکس کرنے اور انڈیکس شدہ ڈیٹا کو دستیاب کرنے کے لیے حوالہ عمل ہے.

گراف نوڈ (اور پورا انڈیکسر اسٹیک) ننگی بیئر میٹل پر، یا کلاؤڈ ماحول میں چلایا جا سکتا ہے. مرکزی انڈیکسنگ کے جزو کی یہ لچک گراف پروٹوکول کی مضبوطی کے لیے اہم ہے. اسی طرح، گراف نوڈ کو [سورس کے ذریعہ سے بنایا جا سکتا ہے](https://github.com/graphprotocol/graph-node)، یا انڈیکسرز [فراہم کردہ ڈوکر کی تصاویر](https://hub.docker.com/r/graphprotocol/graph-node) میں سے کسی ایک کو استعمال کر سکتے ہیں.

### PostgreSQL ڈیٹا بیس

گراف نوڈ کا مرکزی اسٹور، یہ وہ جگہ ہے جہاں سب گراف کا ڈیٹا ذخیرہ کیا جاتا ہے، ساتھ ہی سب گراف کے بارے میں میٹا ڈیٹا، اور سب گراف-اگنوسٹک نیٹ ورک ڈیٹا جیسے کہ بلاک کیشے، اور ایتھ_کال کیشے.

### نیٹ ورک کلائنٹس

کسی نیٹ ورک کو انڈیکس کرنے کے لیے، گراف نوڈ کو EVM سے مطابقت رکھنے والے JSON-RPC API کے ذریعے نیٹ ورک کلائنٹ تک رسائی کی ضرورت ہے۔ یہ RPC کسی ایک کلائنٹ سے منسلک ہو سکتا ہے یا یہ زیادہ پیچیدہ سیٹ اپ ہو سکتا ہے جو متعدد پر بیلنس لوڈ کرتا ہے.

اگرچہ کچھ سب گراف کو صرف ایک مکمل نوڈ کی ضرورت ہو سکتی ہے، کچھ میں انڈیکسنگ کی خصوصیات ہوسکتی ہیں جن کے لیے اضافی RPC فعالیت کی ضرورت ہوتی ہے۔ خاص طور پر سب گراف جو `eth_calls` کو انڈیکسنگ کے حصے کے طور پر بناتے ہیں ان کے لیے آرکائیو نوڈ کی ضرورت ہوگی جو [EIP-1898](https://eips.ethereum.org/EIPS/eip-1898) کو سپورٹ کرتا ہو، اور `callHandlers`، یا `blockHandlers` کے ساتھ `call` فلٹر کے ساتھ سب گراف، `trace_filter` سپورٹ کی ضرورت ہے ([ٹریس ماڈیول کی دستاویزات یہاں دیکھیں](https://openethereum.github.io/JSONRPC-trace-module)).

**نیٹ ورک فائر ہوزز** - ایک فائر ہوز ایک gRPC سروس ہے جو ایک ترتیب شدہ، ابھی تک فورک-آگاہ، بلاکس کا سلسلہ فراہم کرتی ہے، جس کو گراف کے کور ڈویلپرز نے پیمانے پر پرفارمنس انڈیکسنگ کو بہتر طریقے سے سپورٹ کرنے کے لیے تیار کیا ہے۔ یہ فی الحال انڈیکسر کی ضرورت نہیں ہے، لیکن انڈیکسرز کو مکمل نیٹ ورک سپورٹ سے پہلے ٹیکنالوجی سے آشنا ہونے کی ترغیب دی جاتی ہے۔ فائر ہوز کے بارے میں مزید جانیں [یہاں](https://firehose.streamingfast.io/).

### IPFS نوڈس

سب گراف تعیناتی کا میٹا ڈیٹا IPFS نیٹ ورک پر محفوظ کیا جاتا ہے. گراف نوڈ بنیادی طور پر سب گراف کی تعیناتی کے دوران IPFS نوڈ تک رسائی حاصل کرتا ہے تاکہ سب گراف مینی فیسٹ اور تمام منسلک فائلوں کو حاصل کیا جا سکے. نیٹ ورک انڈیکسرز کو اپنے IPFص نوڈ کو ہوسٹ کرنے کی ضرورت نہیں ہے. نیٹ ورک کے لیے ایک IPFS نوڈ https://ipfs.network.thegraph.com پر ہوسٹ کیا گیا ہے.

### Prometheus میٹرکس سرور

نگرانی اور رپورٹنگ کو فعال کرنے کے لیے، گراف نوڈ اختیاری طور پر میٹرکس کو prometheus میٹرکس سرور پر لاگ کر سکتا ہے.

### سورس سے شروع کرنا

#### اولین ضروریات کو انسٹال کریں

- **Rust**

- **Rust**

- **IPFS**

- **اوبنٹو کے صارفین کے لیے اضافی تقاضے** - اوبنٹو پر گراف نوڈ چلانے کے لیے چند اضافی پیکجوں کی ضرورت ہو سکتی ہے.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### سیٹ اپ

1. PostgreSQL ڈیٹا بیس سرور چالو کریں

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. [گراف نوڈ](https://github.com/graphprotocol/graph-node) ریپو کلون کریں اور `cargo build` چلا کر سورس کو بلڈ کریں

3. اب جب کہ تمام انحصار سیٹ اپ ہو چکے ہیں، گراف نوڈ شروع کریں:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

### Kubernetes کے ساتھ شروع کریں

ایک مکمل Kubernetes مثال کی کنفگریشن [انڈیکسر ریپوزٹری](https://github.com/graphprotocol/indexer/tree/main/k8s) میں مل سکتی ہے.

### پورٹس

جب یہ چل رہا ہوتا ہے گراف نوڈ مندرجہ ذیل پورٹس کو بے نقاب کرتا ہے:

| Port | Purpose | Routes | CLI Argument | Environment Variable |
| --- | --- | --- | --- | --- |
| 8000 | GraphQL HTTP server<br />(سب گراف کی کیوریز کے لیے) | /subgraphs/id/...<br />/subgraphs/name/.../... | --http-port | - |
| 8001 | GraphQL WS<br />(سب گراف سبسکرپشنز کے لیے) | /subgraphs/id/...<br />/subgraphs/name/.../... | --ws-port | - |
| 8020 | JSON-RPC<br />(تعیناتیوں کے انتظام کے لیے) | / | --admin-port | - |
| 8030 | سب گراف انڈیکسنگ اسٹیٹس API | /graphql | --index-node-port | - |
| 8040 | Prometheus میٹرکس | /metrics | --metrics-port | - |

> **اہم**: پورٹس کو عوامی طور پر ظاہر کرنے میں محتاط رہیں - **انتظامی پورٹس** کو بند رکھا جانا چاہیے. اس میں گراف نوڈ کا JSON-RPC اینڈ پوائنٹ شامل ہے.

## اعلی درجے کی گراف نوڈ کنفیگریشن

اس کے آسان ترین طور پر، گراف نوڈ کو گراف نوڈ کے ایک انسٹینس, واحد PostgreSQL ڈیٹا بیس، ایک IPFS نوڈ، اور نیٹ ورک کلائنٹس کے ساتھ آپریٹ کیا جا سکتا ہے جیسا کہ سب گراف کو انڈیکس کرنے کے لیے ضرورت ہوتی ہے.

ان گراف نوڈس کو سپورٹ کرنے کے لیے ایک سے زیادہ گراف نوڈس، اور ایک سے زیادہ ڈیٹا بیس کو شامل کرکے اس سیٹ اپ کو افقی طور پر طور پر بڑھایا کیا جا سکتا ہے. اعلی درجے کے صارفین گراف نوڈ کی کچھ افقی اسکیلنگ صلاحیتوں کے ساتھ ساتھ `config.toml` فائل اور گراف نوڈ کے ماحولیاتی تغیرات کے ذریعے ترتیب دینے کے کچھ جدید اختیارات سے فائدہ اٹھا سکتے ہیں.

### `config.toml`

[TOML](https://toml.io/en/) کنفیگریشن فائل کو CLI میں بے نقاب ہونے والی کنفیگریشن سے زیادہ پیچیدہ کنفیگریشن سیٹ کرنے کے لیے استعمال کیا جا سکتا ہے. فائل کا مقام --config command line switch کے ساتھ پاس کیا جاتا ہے.

> کنفیگریشن فائل استعمال کرتے وقت، --postgres-url، --postgres-secondary-hosts اور --postgres-host-weights کے آپشنز استعمال کرنا ممکن نہیں ہے.

ایک کم سے کم `config.toml` فائل فراہم کی جا سکتی ہے. درج ذیل فائل --postgres-url کمانڈ لائن آپشن کو استعمال کرنے کے مترادف ہے:

```toml
[store]
[store.primary]
connection="<.. postgres-url argument ..>"
[deployment]
[[deployment.rule]]
indexers = [ "<.. list of all indexing nodes ..>" ]
```

`config.toml` کی مکمل دستاویزات [گراف نوڈ دستاویزات ](https://github.com/graphprotocol/graph-node/blob/master/docs/config.md)میں مل سکتی ہیں.

#### متعدد گراف نوڈس

گراف نوڈ انڈیکسنگ افقی طور پر اسکیل کر سکتی ہے، مختلف نوڈس میں انڈیکسنگ اور کیوریز کو تقسیم کرنے کے لیے گراف نوڈ کی متعدد انسٹینسز کو چلا کر. یہ آسانی سے شروع ہونے پر مختلف `node_id` کے ساتھ ترتیب شدہ گراف نوڈس کو چلا کر کیا جا سکتا ہے (مثال کے طور پر Docker کمپوز فائل میں)، جسے پھر `config.toml` فائل میں استعمال کیا جا سکتا ہے, [وقف شدہ کیوری نوڈس](#dedicated-query-nodes)، [بلاک انجسٹرز](#dedicated-block-ingestor) کی وضاحت کرنے کے لیے، اور نوڈس میں سب گراف کو [تعیناتی قواعد](#deployment-rules) کے ساتھ تقسیم کرنا.

> نوٹ کریں کہ ایک سے زیادہ گراف نوڈس کو ایک ہی ڈیٹا بیس کو استعمال کرنے کے لیے کنفیگر کیا جا سکتا ہے، جسے خود کو شارڈنگ کے ذریعے افقی طور پر سکیل کیا جا سکتا ہے.

#### تعیناتی کے قواعد

ایک سے زیادہ گراف نوڈس کے پیش نظر، نئے سب گرافس کی تعیناتی کا انتظام کرنا ضروری ہے تاکہ ایک ہی سب گراف کو دو مختلف نوڈس کے ذریعہ انڈیکس نہ کیا جائے، جو تصادم کا باعث بنے. یہ تعیناتی کے قواعد کا استعمال کرتے ہوئے کیا جا سکتا ہے، جو یہ بھی بتا سکتا ہے کہ اگر ڈیٹا بیس کی شارڈنگ کا استعمال کیا جا رہا ہو تو سب گراف کا ڈیٹا کس `shard` میں محفوظ کیا جانا چاہیے. تعیناتی کے قواعد سب گراف کے نام اور اس نیٹ ورک پر مماثل ہو سکتے ہیں جس کو تعیناتی فیصلہ کرنے کے لیے انڈیکس کر رہی ہے.

مثال کی تعیناتی کے اصول کی کنفگریشن:

```toml
[deployment]
[[deployment.rule]]
match = { name = "(vip|important)/.*" }
shard = "vip"
indexers = [ "index_node_vip_0", "index_node_vip_1" ]
[[deployment.rule]]
match = { network = "kovan" }
# No shard, so we use the default shard called 'primary'
indexers = [ "index_node_kovan_0" ]
[[deployment.rule]]
match = { network = [ "xdai", "poa-core" ] }
indexers = [ "index_node_other_0" ]
[[deployment.rule]]
# There's no 'match', so any subgraph matches
shards = [ "sharda", "shardb" ]
indexers = [
    "index_node_community_0",
    "index_node_community_1",
    "index_node_community_2",
    "index_node_community_3",
    "index_node_community_4",
    "index_node_community_5"
  ]
```

تعیناتی کے قواعد کے بارے میں مزید [یہاں](https://github.com/graphprotocol/graph-node/blob/master/docs/config.md#controlling-deployment) پڑھیں.

#### وقف شدہ کیوری نوڈس

نوڈس کو کنفیگریشن فائل میں درج ذیل کو شامل کرکے واضح طور پر کیوری نوڈس کے لیے کنفیگر کیا جاسکتا ہے:

```toml
[general]
query = "<regular expression>"
```

کوئی بھی نوڈ جس کا node-id-- ریگولر ایکسپریشن سے میل کھاتا ہے صرف کیوریز کا جواب دینے کے لیے ترتیب دیا جائے گا.

#### شارڈنگ کے ذریعے ڈیٹا بیس کو بڑھانا

زیادہ تر استعمال کے معاملات میں، ایک واحد Postgres ڈیٹا بیس گراف نوڈ کی انسٹینس کو سپورٹ کرنے کے لیے کافی ہے. جب ایک گراف نوڈ کی انسٹینس ایک واحد postgres ڈیٹا بیس سے بڑھ جاتی ہے، تو یہ ممکن ہے کہ گراف نوڈ کے ڈیٹا کے ذخیرہ کو متعدد پوسٹگریس ڈیٹا بیس میں تقسیم کیا جا سکے. تمام ڈیٹا بیس مل کر گراف نوڈ انسٹینس کا اسٹور بناتے ہیں. ہر انفرادی ڈیٹا بیس کو شارڈ کہا جاتا ہے.

شارڈز کو ایک سے زیادہ ڈیٹا بیسز میں سب گراف کی تعیناتیوں کو تقسیم کرنے کے لیے استعمال کیا جا سکتا ہے، اور ڈیٹا بیس میں کیوریز کے بوجھ کو پھیلانے کے لیے نقلیں استعمال کرنے کے لیے بھی استعمال کیا جا سکتا ہے. اس میں دستیاب ڈیٹا بیس کنکشنز کی تعداد کو ترتیب دینا شامل ہے جو ہر ایک `graph-node` کو ہر ڈیٹا بیس کے لیے اپنے کنکشن پول میں رکھنا چاہیے، جو کہ تیزی سے اہم ہو جاتا ہے کیونکہ مزید سب گرافس کو انڈیکس کیا جا رہا ہے.

شارڈنگ مفید ہو جاتا ہے جب آپ کا موجودہ ڈیٹا بیس اس بوجھ کو برقرار نہیں رکھ سکتا جو گراف نوڈ اس پر ڈالتا ہے، اور جب ڈیٹا بیس کے سائز کو مزید بڑھانا ممکن نہ ہو.

> عام طور پر یہ بہتر ہے کہ شارڈز کے ساتھ شروع کرنے سے پہلے، ایک ہی ڈیٹا بیس کو جتنا ہو سکے بڑا بنائیں. ایک استثناء وہ ہے جہاں کیوری ٹریفک کو سب گرافس کے درمیان بہت غیر مساوی طور پر تقسیم کیا جاتا ہے; ان حالات میں یہ بھاری طور پر مدد کر سکتا ہے اگر اعلی حجم کے سب گراف کو ایک شارڈ میں اور باقی سب کچھ دوسرے میں رکھا جائے کیونکہ اس سیٹ اپ سے یہ زیادہ امکان ہوتا ہے کہ زیادہ حجم والے سب گرافس کا ڈیٹا db-internal کیشے میں رہتا ہے اور ایسا نہیں ہوتا ہے کہ وہ کم حجم والے سب گرافس سے ڈیٹا کی جگہ لے لیں جس کی ضرورت نہیں ہے.

کنکشن کنفیگر کرنے کے معاملے میں، postgresql.conf میں max_connections کے ساتھ شروع کریں 400 سیٹ کریں(یا شاید 200 بھی) اور store_connection_wait_time_ms اور store_connection_checkout_count Prometheus میٹرکس دیکھیں. قابل توجہ انتظار کے اوقات (5ms سے اوپر کی کوئی بھی چیز) اس بات کا اشارہ ہے کہ بہت کم کنکشن دستیاب ہیں; زیادہ انتظار کا وقت بھی ڈیٹا بیس کے بہت مصروف ہونے کی وجہ سے ہوگا (جیسے زیادہ CPU لوڈ). تاہم اگر ڈیٹا بیس بصورت دیگر مستحکم معلوم ہوتا ہے تو، زیادہ انتظار کے اوقات کنکشن کی تعداد بڑھانے کی ضرورت کی نشاندہی کرتے ہیں. کنفیگریشن میں، ہر گراف نوڈ انسٹینس کتنے کنکشن استعمال کر سکتا ہے ایک بالائی حد ہے، اور اگر گراف نوڈ کو ان کی ضرورت نہ ہو تو کنکشن کو کھلا نہیں رکھے گا.

اسٹور کنفیگریشن کے بارے میں مزید [یہاں](https://github.com/graphprotocol/graph-node/blob/master/docs/config.md#configuring-multiple-databases) پڑھیں.

#### وقف شدہ بلاک انجیش

اگر ایک سے زیادہ نوڈس کنفیگر کیے گئے ہیں، تو ایک نوڈ کو مختص کرنا ضروری ہو گا جو نئے بلاکس کے ادخال کے لیے ذمہ دار ہے، تاکہ تمام کنفیگر کیے گئے انڈیکس نوڈس چین ہیڈ کو پولنگ نہیں کر رہے ہوں. یہ `chains` namespace کے حصے کے طور پر کیا جاتا ہے، جس میں `node_id` کو بلاک ادخال کے لیے استعمال کیا جائے گا:

```toml
[chains]
ingestor = "block_ingestor_node"
```

#### متعدد نیٹ ورکس کو سپورٹ کرنا

گراف پروٹوکول انعامات کی انڈیکسنگ کے لیے تعاون یافتہ نیٹ ورکس کی تعداد میں اضافہ کر رہا ہے، اور ایسے بہت سے سب گراف موجود ہیں جو غیر تعاون یافتہ نیٹ ورکس کو ترتیب دیتے ہیں جن کو ایک انڈیکسر عمل میں لانا چاہے گا. `config.toml` فائل اس کی تاثراتی اور لچکدار کنفیگریشن کی اجازت دیتی ہے:

- متعدد نیٹ ورکس
- ایک سے زیادہ فراہم کنندگان فی نیٹ ورک (یہ فراہم کنندگان میں بوجھ کو تقسیم کرنے کی اجازت دے سکتا ہے، اور مکمل نوڈس کے ساتھ ساتھ آرکائیو نوڈس کی ترتیب کی بھی اجازت دے سکتا ہے، گراف نوڈ سستے فراہم کنندگان کو ترجیح دیتا ہے اگر کام کا بوجھ اجازت دیتا ہے).
- فراہم کنندہ کی اضافی تفصیلات، جیسے خصوصیات، تصدیق اور فراہم کنندہ کی قسم (تجرباتی firehose سپورٹ کے لیے)

`[chains]` سیکشن ایتھیریم فراہم کنندگان کو کنٹرول کرتا ہے جن سے گراف نوڈ جڑتا ہے، اور جہاں ہر چین کے لیے بلاکس اور دیگر میٹا ڈیٹا کو محفوظ کیا جاتا ہے. مندرجہ ذیل مثال دو چینز کو ترتیب دیتی ہے، مین نیٹ اور کووان، جہاں مین نیٹ کے لیے بلاکس کو vip شارڈ میں اور کووان کے لیے بلاکس کو پرائمری شارڈ میں محفوظ کیا جاتا ہے. مین نیٹ چین دو مختلف فراہم کنندگان کا استعمال کر سکتا ہے، جبکہ کووان کے پاس صرف ایک فراہم کنندہ ہے.

```toml
[chains]
ingestor = "block_ingestor_node"
[chains.mainnet]
shard = "vip"
provider = [
  { label = "mainnet1", url = "http://..", features = [], headers = { Authorization = "Bearer foo" } },
  { label = "mainnet2", url = "http://..", features = [ "archive", "traces" ] }
]
[chains.kovan]
shard = "primary"
provider = [ { label = "kovan", url = "http://..", features = [] } ]
```

فراہم کنندہ کنفیگریشن کے بارے میں مزید پڑھیں [یہاں](https://github.com/graphprotocol/graph-node/blob/master/docs/config.md#configuring-ethereum-providers).

### ماحولیاتی تغیرات

گراف نوڈ ماحولیاتی تغیرات کی ایک حد کو سپورٹ کرتا ہے جو خصوصیات کو فعال کر سکتا ہے، یا گراف نوڈ کے رویہ کو تبدیل کر سکتا ہے. یہ [یہاں](https://github.com/graphprotocol/graph-node/blob/master/docs/environment-variables.md) درج ہیں.

### مسلسل تعیناتی

وہ صارفین جو اعلی درجے کی ترتیب کے ساتھ سکیلڈ انڈیکسنگ سیٹ اپ چلا رہے ہیں وہ اپنے گراف نوڈس کو Kubernetes کے ساتھ منظم کرنے سے فائدہ اٹھا سکتے ہیں.

- انڈیکسر ریپوزٹری میں ایک [مثال Kubernetes حوالہ](https://github.com/graphprotocol/indexer/tree/main/k8s) ہے
- [Launchpad](https://docs.graphops.xyz/launchpad/intro), GraphOps کے زیر انتظام Kubernetes پر گراف پروٹوکول انڈیکسر چلانے کے لیے ایک toolkit ہے. یہ گراف نوڈ کی تعیناتی کو منظم کرنے کے لیے Helm charts اور ایک CLI فراہم کرتا ہے.

### گراف نوڈ کا انتظام

چلتے ہوئے گراف نوڈ (یا گراف نوڈس!) کو دیکھتے ہوئے، پھر چیلنج یہ ہے کہ ان نوڈس میں تعینات سب گراف کا انتظام کرنا. گراف نوڈ سب گرافس کو منظم کرنے میں مدد کے لیے ٹولز کی ایک رینج پیش کرتا ہے.

#### لاگنگ

گراف نوڈ کے لاگز گراف نوڈ اور مخصوص سب گراف کی ڈیبگنگ اور اصلاح کے لیے مفید معلومات فراہم کر سکتے ہیں. گراف نوڈ `GRAPH_LOG` ماحولیاتی تغیرات کے ذریعے درج ذیل سطحوں کے ساتھ مختلف لاگ سطح کو سپورٹ کرتا ہے: error، warn، info، debug یا trace.

اس کے علاوہ `GRAPH_LOG_QUERY_TIMING` کو `gql` پر سیٹ کرنا اس بارے میں مزید تفصیلات فراہم کرتا ہے کہ GraphQL کی کیوریز کیسے چل رہی ہیں (حالانکہ یہ logs کی ایک بڑی مقدار پیدا کرے گا).

#### نگرانی اور انتباہ

گراف نوڈ بطور ڈیفالٹ 8040 port پر prometheus endpoint کے ذریعے میٹرکس فراہم کرتا ہے. Grafana کو پھر ان metrics کو دیکھنے کے لیے استعمال کیا جا سکتا ہے.

انڈیکسر ریپوزٹری ایک [مثال Grafana کنفگریشن](https://github.com/graphprotocol/indexer/blob/main/k8s/base/grafana.yaml) فراہم کرتی ہے.

#### Graphman

` graphman` گراف نوڈ کے لیے ایک مینٹیننس ٹول ہے، جو روزانہ مختلف اور غیر معمولی کاموں کی تشخیص اور حل میں مدد کرتا ہے.

گراف مین کمانڈ آفیشل کنٹینرز میں شامل ہے، اور آپ اسے چلانے کے لیے اپنے گراف نوڈ کنٹینر میں docker exec کر سکتے ہیں. اس کے لیے ایک `config.toml` فائل درکار ہے.

`graphman` کمانڈز کی مکمل دستاویزات گراف نوڈ ریپوزٹری میں دستیاب ہیں. گراف نوڈ `/docs` \[/docs/graphman.md\] (https://github.com/graphprotocol/graph-node/blob/master/docs/graphman.md) میں دیکھیں

### سب گرافس کے ساتھ کام کرنا

#### انڈیکسنگ اسٹیٹس API

پورٹ 8030/graphql پر بطور ڈیفالٹ دستیاب ہے، انڈیکسنگ اسٹیٹس API مختلف سب گرافس کے لیے انڈیکسنگ کی حیثیت کو جانچنے، انڈیکسنگ کے ثبوتوں کی جانچ، سب گراف کی خصوصیات کا معائنہ کرنے اور مزید بہت سے طریقوں کو ظاہر کرتا ہے.

مکمل اسکیما [یہاں](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql) دستیاب ہے.

#### انڈیکسنگ کی کارکردگی

انڈیکسنگ کے عمل کے تین الگ الگ حصے ہیں:

- فراہم کنندہ سے دلچسپی کے ایوینٹس لانا
- مناسب ہینڈلرز کے ساتھ ایوینٹس پر کارروائی کرنا (اس میں سٹیٹ کے لیے چین کو کال کرنا، اور اسٹور سے ڈیٹا حاصل کرنا شامل ہو سکتا ہے)
- نتیجے کے ڈیٹا کو اسٹور پر لکھنا

یہ مراحل پائپ لائنڈ ہیں (یعنی انہیں متوازی طور پر انجام دیا جا سکتا ہے)، لیکن وہ ایک دوسرے پر منحصر ہیں. جہاں سب گراف انڈیکس میں سست ہیں، بنیادی وجہ مخصوص سب گراف پر منحصر ہوگی.

انڈیکسنگ میں سستی کی عام وجوہات:

- چین سے متعلقہ واقعات کو تلاش کرنے میں لگنے والا وقت (خاص طور پر کال ہینڈلرز سست ہوسکتے ہیں، `trace_filter` پر انحصار کے پیش نظر)
- ہینڈلرز کے حصے کے طور پر بڑی تعداد میں `eth_calls` بنانا
- عمل درآمد کے دوران سٹور کے تعامل کی ایک بڑی مقدار
- اسٹور میں محفوظ کرنے کے لیے ڈیٹا کی ایک بڑی مقدار
- کارروائی کرنے کے لیے ایوینٹس کی ایک بڑی تعداد
- ہجوم نوڈس کے لیے سست ڈیٹا بیس کنکشن کا وقت
- فراہم کنندہ خود چین ہیڈ کے پیچھے پڑا ہے
- فراہم کنندہ سے چین ہیڈ پر نئی رسیدیں لانے میں سست روی

سب گراف انڈیکسنگ میٹرکس انڈیکسنگ کی سستی کی بنیادی وجہ کی تشخیص میں مدد کر سکتی ہے. کچھ معاملات میں، مسئلہ خود سب گراف کے ساتھ ہوتا ہے، لیکن دوسروں میں، بہتر نیٹ ورک فراہم کرنے والے، ڈیٹا بیس کے تنازعہ میں کمی اور دیگر ترتیب میں بہتری انڈیکسنگ کی کارکردگی کو نمایاں طور پر بہتر بنا سکتی ہے.

#### ناکام سب گراف

انڈیکسنگ کے دوران سب گرافس ناکام ہو سکتے ہیں، اگر وہ غیر متوقع ڈیٹا کا سامنا کرتے ہیں، کچھ جزو توقع کے مطابق کام نہیں کر رہا ہے، یا اگر ایونٹ ہینڈلرز یا کنفیگریشن میں کچھ بگ ہے۔ ناکامی کی دو عمومی قسمیں ہیں:

- تعییناتی ناکامیاں: یہ وہ ناکامیاں ہیں جو دوبارہ کوششوں سے حل نہیں ہوں گی
- غیر مقررہ ناکامیاں: یہ فراہم کنندہ کے ساتھ مسائل، یا کچھ غیر متوقع گراف نوڈ کی خرابی کی وجہ سے ہوسکتی ہیں. جب ایک غیر مقررہ ناکامی واقع ہوتی ہے تو، گراف نوڈ ناکام ہونے والے ہینڈلرز کو دوبارہ کوشش کرے گا، وقت کے ساتھ پیچھے ہٹتا ہے.

بعض صورتوں میں ایک ناکامی کو انڈیکسر کے ذریعے حل کیا جا سکتا ہے (مثال کے طور پر اگر غلطی صحیح قسم کا فراہم کنندہ نہ ہونے کا نتیجہ ہے، مطلوبہ فراہم کنندہ کو شامل کرنے سے انڈیکسنگ جاری رہے گی). تاہم دوسری صورتوں میں، سب گراف کوڈ میں تبدیلی کی ضرورت ہے.

> ڈیٹرمنسٹک ناکامیوں کو "حتمی" سمجھا جاتا ہے، جس میں فیلنگ بلاک کے لیے انڈیکسنگ کا ثبوت تیار کیا جاتا ہے، جب کہ نان ڈیٹرمنسٹک ناکامیاں نہیں ہوتی ہیں، کیونکہ سب گراف "نا ناکام" ہونے کا انتظام کر سکتا ہے اور انڈیکسنگ جاری رکھ سکتا ہے. بعض صورتوں میں، غیر متعین لیبل غلط ہے، اور سب گراف کبھی بھی غلطی پر قابو نہیں پائے گا. اس طرح کی ناکامیوں کو گراف نوڈ ریپوزٹری پر مسائل کے طور پر رپورٹ کیا جانا چاہئے.

#### کیشے

فراہم کنندہ سے ری فیچنگ کو بچانے کے لیے گراف نوڈ اسٹور میں مخصوص ڈیٹا کیشے کر لیتا ہے. بلاکس کیش کیے جاتے ہیں، جیسا کہ `eth_calls` کے نتائج ہیں (مؤخر الذکر کو مخصوص بلاک کے طور پر کیش کیا جاتا ہے). یہ کیشنگ قدرے تبدیل شدہ سب گراف کی "دوبارہ مطابقت پذیری" کے دوران انڈیکسنگ کی رفتار کو شدید طور پر بڑھا سکتی ہے.

تاہم، بعض صورتوں میں، اگر ایتھیریم نوڈ نے کچھ مدت کے لیے غلط ڈیٹا فراہم کیا ہے، تو یہ کیش میں اپنا راستہ بنا سکتا ہے، جس کے نتیجے میں غلط ڈیٹا یا ناکام سب گرافس ہوتے ہیں۔ اس معاملے میں انڈیکسرز زہریلے کیشے کو صاف کرنے کے لیے `graphman` کا استعمال کر سکتے ہیں، اور پھر متاثرہ سب گراف کو ریوائنڈ کر سکتے ہیں، جو پھر (امید ہے) صحت مند فراہم کنندہ سے تازہ ڈیٹا حاصل کرے گا.

اگر کسی بلاک کیشے کی عدم مطابقت کا شبہ ہے، جیسے کہ tx رسید غائب ہونے کا ایوینٹ:

1. چین کا نام تلاش کرنے کے لیے `graphman chain list`.
2. `graphman chain check-blocks <CHAIN> by-number <NUMBER>` چیک کرے گا کہ آیا کیش شدہ بلاک فراہم کنندہ سے مماثل ہے، اور اگر ایسا نہیں ہوتا ہے تو بلاک کو کیشے سے حذف کر دیتا ہے.
   1. اگر کوئی فرق ہے تو، `graphman chain truncate <CHAIN>` کے ساتھ پورے کیش کو تراشنا زیادہ محفوظ ہوسکتا ہے.
   2. اگر بلاک فراہم کنندہ سے میل کھاتا ہے، تو مسئلہ کو براہ راست فراہم کنندہ کے خلاف ڈیبگ کیا جا سکتا ہے.

#### مسائل اور غلطیوں کو کیوری کرنا

ایک بار ایک سب گراف کو انڈیکس کرنے کے بعد، انڈیکسرز سب گراف کے وقف کردہ کیوری کے اختتامی نقطہ کے ذریعے کیوریز پیش کرنے کی توقع کر سکتے ہیں. اگر انڈیکسر کافی تعداد میں کیوریز کے حجم کو پیش کرنے کی امید کر رہا ہے تو، ایک وقف شدہ کیوری نوڈ کی تجویز کی جاتی ہے، اور بہت زیادہ کیوریز کی تعداد کی صورت میں، انڈیکسر نقل شارڈز کو ترتیب دینا چاہیں گے تاکہ کیوریز انڈیکسنگ کے عمل کو متاثر نہ کریں.

تاہم، ایک وقف شدہ کیوری نوڈ اور نقل کے ساتھ بھی، بعض کیوریز کو عمل میں لانے میں کافی وقت لگ سکتا ہے، اور بعض صورتوں میں میموری کے استعمال میں اضافہ ہوتا ہے اور دوسرے صارفین کے لیے کیوری کے وقت پر منفی اثر پڑتا ہے.

یہاں ایک "سلور بلیٹ" نہیں ہے، لیکن آہستہ چلنے والی کیوریز کو روکنے، تشخیص کرنے اور ان سے نمٹنے کے لیے ٹولز کی ایک رینج ہے.

##### کیوری کی کیشنگ

گراف نوڈ پہلے سے طے شدہ طور پر GraphQL کی کیوریز کو محفوظ کرتا ہے، جو ڈیٹا بیس کے بوجھ کو نمایاں طور پر کم کر سکتا ہے. اسے `GRAPH_QUERY_CACHE_BLOCKS` اور `GRAPH_QUERY_CACHE_MAX_MEM` ترتیبات کے ساتھ مزید ترتیب دیا جا سکتا ہے. مزید [یہاں](https://github.com/graphprotocol/graph-node/blob/master/docs/environment-variables.md#graphql-caching) پڑھیں.

##### کیوریز کا تجزیہ کرنا

مشکل کیوریز اکثر دو طریقوں میں سے ایک میں سامنے آتی ہیں. کچھ معاملات میں، صارفین خود رپورٹ کرتے ہیں کہ دی گئی کیوری آہستہ ہے. اس صورت میں چیلنج آہستگی کی وجہ کی تشخیص کرنا ہے ء چاہے یہ عام مسئلہ ہو، یا اس سب گراف یا کیوری کے لیے مخصوص ہو. اور پھر اگر ممکن ہو تو یقیناً اسے حل کرنا.

دوسری صورتوں میں، مسئلہ ایک کیوری نوڈ پر زیادہ میموری کا استعمال ہو سکتا ہے، ایسی صورت میں چیلنج سب سے پہلے اس کیوری کی نشاندہی کرنا ہے جس کی وجہ سے مسئلہ ہے.

انڈیکسرز گراف نوڈ کے کیوری کے کیوری لاگز پر کارروائی اور خلاصہ کرنے کے لیے [qlog](https://github.com/graphprotocol/qlog/) کا استعمال کر سکتے ہیں. `GRAPH_LOG_QUERY_TIMING` کو بھی سست کیوریز کی شناخت اور ڈیبگ کرنے میں مدد کے لیے فعال کیا جا سکتا ہے.

سست کیوریز کو دیکھتے ہوئے، انڈیکسرز کے پاس کچھ آپشنز ہوتے ہیں. بلاشبہ وہ اپنے لاگت ماڈل کو تبدیل کر سکتے ہیں، تاکہ مسئلہ کرنے والی کیوری کو بھیجنے کی لاگت میں نمایاں اضافہ ہو سکے. اس کے نتیجے میں اس کیوری کی تعدد میں کمی واقع ہوسکتی ہے. تاہم یہ اکثر مسئلے کی بنیادی وجہ کو حل نہیں کرتا ہے.

##### Account-like optimisation

ڈیٹا بیس ٹیبلز جو اینٹیٹیز کو ذخیرہ کرتے ہیں عام طور پر دو قسموں میں آتے ہیں: 'transaction-like'، جہاں اینٹیٹیز کو، ایک بار بنائے جانے کے بعد، کبھی اپ ڈیٹ نہیں کیا جاتا، یعنی، وہ مالیاتی ٹرانزیکشن کی فہرست کے مشابہ کچھ ذخیرہ کرتے ہیں، اور 'account-like' جہاں اینٹیٹیز کو اکثر اپ ڈیٹ کیا جاتا ہے، یعنی، وہ مالیاتی اکاؤنٹس کی طرح کچھ ذخیرہ کرتے ہیں جو ہر بار جب کوئی ٹرانزیکشن ریکارڈ ہوتا ہے تو ان میں ترمیم کی جاتی ہے. اکاؤنٹ جیسی ٹیبلز اس حقیقت کی خصوصیت رکھتی ہیں کہ ان میں بڑی تعداد میں اینٹیٹی کے ورژنز ہوتے ہیں، لیکن نسبتاً کم الگ الگ اینٹیٹیز ہیں. اکثر، ایسے ٹیبلز میں الگ الگ اینٹیٹیز کی تعداد قطاروں کی کل تعداد کا 1% ہوتی ہے (اینٹیٹی کے ورژنز)

اکاؤنٹ جیسا کے ٹیبلز کے لیے، `graph-node` ایسی کیوریز پیدا کر سکتا ہے جو اس تفصیلات سے فائدہ اٹھاتے ہیں کہ Postgres اتنی زیادہ شرح کے ساتھ ڈیٹا کو کیسے ذخیرہ کرتا ہے، یعنی کہ حالیہ بلاکس کے تمام ورژنز اس طرح کے ٹیبل کے لئے مجموعی اسٹوریج کا ایک چھوٹا ذیلی حصہ.

کمانڈ `graphman stats show <sgdNNNN`> ظاہر کرتا ہے، ایک تعیناتی میں ہر ہستی کی قسم/ٹیبل کے لیے، کتنی الگ الگ ہستیوں، اور ہر ٹیبل میں ہستی کے کتنے ورژنز ہیں. یہ ڈیٹا Postgres کے اندرونی اندازوں پر مبنی ہے، اور اس لیے ضروری طور پر غلطی کا امکان ہے، اور شدت کے توازن سے پھر سکتا ہے. `entities` کالم میں ایک `-1` کا مطلب ہے کہ Postgres کا خیال ہے کہ تمام قطاریں ایک الگ ہستی پر مشتمل ہیں.

عام طور پر، وہ ٹیبلز جہاں الگ الگ ہستیوں کی تعداد قطاریں/ہستی ورژنز کی کل تعداد کے 1% سے کم ہوتی ہے account-like کی آپٹیمائزیشن کے لیے اچھے امیدوار ہوتے ہیں. جب `graphman stats` کا آؤٹ پٹ اشارہ کرتا ہے کہ ایک ٹیبل اس اصلاح سے فائدہ اٹھا سکتا ہے، تو `graphman stats show <sgdNNN> <table>` کو چلانے سے ٹیبل کی مکمل گنتی ہوگی. جو سست ہو سکتا ہے، لیکن اینٹیٹی کے مجموعی ورژنز کے لیے الگ الگ اینٹیٹیز کے تناسب کا ایک درست پیمانہ فراہم کرتا ہے.

ایک بار جب ایک ٹیبل اکاؤنٹ جیسا ہونے کا تعین کر لیا جاتا ہے، تو `graphman stats account-like <sgdNNN>.<table>` چلانے سے اس ٹیبل کے خلاف کیوریز کے لیے اکاؤنٹ کی طرح کی آپٹیمائزیشن آن ہو جائے گی. آپٹیمائزیشن کو دوبارہ `graphman stats account-like --clear <sgdNNN>.<table>` کے ساتھ دوبارہ بند کیا جا سکتا ہے یہ معلوم کرنے میں کیوری نوڈس کو 5 منٹ تک کا وقت لگتا ہے کہ آپٹمائزیشن آن کر دی گئی ہے یا بند. آپٹیمائزیشن کو آن کرنے کے بعد، اس بات کی تصدیق کرنا ضروری ہے کہ تبدیلی درحقیقت اس ٹیبل کے لیے کیوریز کو آہستہ نہیں کرتی ہے. اگر آپ نے Postgres کی نگرانی کے لیے گرافانا کو کنفیگر کیا ہے، تو سست کیوریز `pg_stat_activity` میں بڑی تعداد میں ظاہر ہوں گے، جس میں کئی سیکنڈ لگیں گے. اس صورت میں، آپٹیمائزیشن کو دوبارہ بند کرنے کی ضرورت ہے.

یونی سویپ جیسے سب گرافس کے لیے، `pair` اور `token` ٹیبلز اس آپٹیمائزیشن کے لیے اہم امیدوار ہیں، اور ڈیٹا بیس کے بوجھ پر کافی اثر ڈال سکتے ہیں.

#### سب گراف کو ختم کرنا

> یہ نئی فعالیت ہے، جو گراف نوڈ 0.29.x میں دستیاب ہوگی

کسی موقع پر ایک انڈیکسر شاید دیئے گئے سب گراف کو ختم کرنا چاہے گا. یہ آسانی سے `graphman drop` کے ذریعے کیا جا سکتا ہے، جو ایک تعیناتی اور اس کے تمام انڈیکس شدہ ڈیٹا کو ختم کر دیتا ہے. تعیناتی کو یا تو سب گراف کے نام، IPFS ہیش `Qm..`، یا ڈیٹا بیس namespace کی جگہ `sgdNNN` کے طور پر بیان کیا جا سکتا ہے. مزید دستاویزات [یہاں](https://github.com/graphprotocol/graph-node/blob/master/docs/graphman.md#-drop) دستیاب ہیں.
