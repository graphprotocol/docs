---
title: انڈیکسنگ
---

Indexers are node operators in The Graph Network that stake Graph Tokens (GRT) in order to provide indexing and query processing services. Indexers earn query fees and indexing rewards for their services. They also earn query fees that are rebated according to an exponential rebate function.

پروٹوکول میں داؤ پر لگائی گئی GRT پگھلنے کی مدت سے مشروط ہے اور اگر انڈیکسرز بدنیتی پر مبنی ہوں اور ایپلیکیشنز کو غلط ڈیٹا پیش کرتے ہیں یا اگر وہ غلط طریقے سے انڈیکس کرتے ہیں تو اسے کم کیا جا سکتا ہے. انڈیکسرز نیٹ ورک میں حصہ ڈالنے کے لیے ڈیلیگیٹرز کی جانب سے دیے گئے سٹیک کے لیے بھی انعامات حاصل کرتے ہیں.

انڈیکسرز سب گراف کے کیوریشن سگنل کی بنیاد پر انڈیکس کرنے کے لیے سب گرافس کا انتخاب کرتے ہیں, جہاں کیوریٹرز GRT کو سٹیک کرتے ہیں تاکہ یہ ظاہر کیا جا سکے کہ کون سے سب گرافس اعلیٰ معیار کے ہیں اور انہیں ترجیح دی جانی چاہیے. صارفین (مثلاً ایپلی کیشنز) ایسے عوامل کا تعین کر سکتے ہیں جن کے لیے انڈیکسرز اپنے سب گرافس کے لیے کیوریز پر کارروائی کرتے ہیں اور کیوری کی فیس کی قیمتوں کے لیے ترجیحات طے کرتے ہیں.

<Difficulty level="ADVANCED" />

## عمومی سوالات

### نیٹ ورک پر انڈیکسر بننے کے لیے کم از کم کتنا سٹیک درکار ہے?

انڈیکسر کے لیے کم از کم سٹیک فی الحال 100 ہزار GRT پر سیٹ ہے.

### انڈیکسر کے لیے آمدنی کے سلسلے کیا ہیں؟

**کیوری کی فیس ری بیٹ** - نیٹ ورک پر کیوریز پیش کرنے کے لیے ادائیگیاں. یہ ادائیگیاں ریاستی چینلز کے ذریعے انڈیکسر اور گیٹ وے کے درمیان ثالثی کی جاتی ہیں. گیٹ وے سے ہر کیوری کی درخواست میں ایک ادائیگی اور متعلقہ جواب کیوری کے نتیجہ کی درستگی کا ثبوت ہے.

**انڈیکسنگ کے انعامات** - سالانہ %3 پروٹوکول کے وسیع افراط زر کے ذریعے تیار کیا گیا, انڈیکسنگ کے انعامات ان انڈیکسرز میں تقسیم کیے جاتے ہیں جو نیٹ ورک کے لیے سب گراف کی تعیناتیوں کو ترتیب دے رہے ہیں.

### انڈیکسنگ کے انعامات کیسے تقسیم کیے جاتے ہیں?

انڈیکسنگ کے انعامات پروٹوکول کے افراط زر سے آتے ہیں جو کہ %3 سالانہ جاری کرنے پر مقر ر ہے. وہ ہر ایک پر تمام کیوریشن سگنل کے تناسب کی بنیاد پر سب گرافس میں تقسیم کیے جاتے ہیں, پھر اس سب گراف پر ان کے مختص سٹیک کی بنیاد پر انڈیکسرز کو متناسب طور پر تقسیم کیے جاتے ہیں. **ایک مختص کرنے کو انڈیکسنگ کے درست ثبوت (POI) کے ساتھ مختص کرنا ضروری ہے جو ثالثی چارٹر کے ذریعہ مقرر کردہ معیارات پر پورا اترتا ہے تاکہ انعامات کا اہل ہو.**

انعامات کا حساب لگانے کے لیے کمیونٹی کی طرف سے متعدد ٹولز بنائے گئے ہیں; آپ کو ان کا ایک مجموعہ [کمیونٹی گائیڈز کا مجموعہ](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c) میں مل جائے گا. آپ [ڈسکورڈ سرور](https://discord.gg/vtvv7FP) پر Delegators# اور Indexers# چینلز میں ٹولز کی تازہ ترین فہرست بھی تلاش کر سکتے ہیں. یہاں ہم ایک [تجویز کردہ ایلوکیشن آپٹیمائزر](https://github.com/graphprotocol/AllocationOpt.jl) کو مربوط کرتے ہیں جو کہ انڈیکسر سافٹ ویئر اسٹیک کے ساتھ مرکوب ہے.

### انڈئکسنگ کا ثبوت (POI) کیا ہے؟

POIs کو نیٹ ورک میں اس بات کی تصدیق کرنے کے لیے استعمال کیا جاتا ہے کہ ایک انڈیکسر ان سب گرافس کو انڈیکس کر رہا ہے جو انہوں نے مختص کیے ہیں. موجودہ ایپوک کے پہلے بلاک کے لیے ایک POI جمع کرانا ضروری ہے جب اس ایلوکیشن کے لیے ایلوکیشن کو بند کرتے ہوئے تاکہ انڈیکسنگ کے انعامات کے لیے اہل ہو سکے. ایک بلاک کے لیے POI تمام ہستیاں سٹور کی ٹرانزیکشنز کے لیے ایک ڈائجسٹ ہوتا ہے جس میں اس بلاک تک اور اس سمیت کسی مخصوص سب گراف کی تعیناتی ہوتی ہے.

### انڈیکسنگ کے انعامات کب تقسیم کیے جاتے ہیں؟

ایلوکیشنز مسلسل انعامات حاصل کر رہی ہوتی ہیں جب کہ وہ فعال ہیں اور 28 ایپوکس میں مختص کر دی جاتی ہیں. انعامات اینڈیکسرز کے ذریعے جمع کیے جاتے ہیں، اور ایلوکیشن کے بند ہوتے ہی تقسیم کر دیے جاتے ہیں. یہ یا تو دستی طور پر ہوتا ہے، جب بھی انڈیکسر انہیں زبردستی بند کرنا چاہتا ہے، یا 28 ایپوکس کے بعد ایک ڈیلیگیٹر انڈیکسر کے لیے ایلوکیشن کو بند کر سکتا ہے، لیکن اس کے نتیجے میں کوئی انعام نہیں ہوتا. 28 ایپوکس زیادہ سے زیادہ ایلوکیشن کا دورانیہ ہے (ابھی، ایک ایپوک تقریبا ~ 24 گھنٹے تک رہتا ہے).

### کیا زیر غور انڈیکسنگ کے انعامات کی نگرانی کی جا سکتی ہے؟

RewardsManager کنٹریکٹ میں صرف پڑھنے کے لیے [getRewards](https://github.com/graphprotocol/contracts/blob/master/contracts/rewards/RewardsManager.sol#L317) فنکشن ہوتا ہے جسے مخصوص مختص کے لیے زیر التواء انعامات کو چیک کرنے کے لیے استعمال کیا جا سکتا ہے.

کمیونٹی کے بنائے ہوئے بہت سے ڈیش بورڈز میں زیر التواء انعامات کی قدریں شامل ہیں اور ان اقدامات پر عمل کر کے انہیں آسانی سے دستی طور پر چیک کیا جا سکتا ہے:

1. تمام فعال ایلوکیشنز کی IDs حاصل کرنے کے لیے [mainnet سب گراف](https://thegraph.com/hosted-service/subgraph/graphprotocol/graph-network-mainnet) کو کیوری کریں:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

`getRewards()` کو کال کرنے کے لیے ایتھر سکین استعمال کریں:

- [انعامات کے کنٹریکٹ پر ایتھرسکین انٹرفیس](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract) پر جائیں

* `getRewards()` کو کال کرنے کے لیے:
  - **10. getRewards** ڈراپ ڈاؤن کو پھیلائیں.
  - ان پٹ میں **AllocationID** درج کریں.
  - **کیوری** بٹن پر کلک کریں.

### تنازعات کیا ہیں اور میں انہیں کہاں دیکھ سکتا ہوں?

انڈیکسر کی کیوریز اور ایکوکیشنز دونوں تنازعات کی مدت کے دوران گراف پر متنازعہ ہوسکتے ہیں. تنازعہ کی نوعیت کے لحاظ سے تنازعہ کی مدت مختلف ہوتی ہے. کیوریز/attestations میں تنازعات کے 7 epochs ہوتے ہیں، جبکہ ایلوکیشنز میں 56 epochs ہوتے ہیں. یہ مدت گزر جانے کے بعد، ایلوکیشنز یا کیوریز میں سے کسی کے خلاف تنازعات نہیں کھولے جا سکتے. جب کوئی تنازعہ کھولا جاتا ہے تو، Fishermen کو کم از کم 10,000 GRT جمع کرنا ضروری ہے، جو تنازعہ کے حتمی ہونے اور حل ہونے تک locked رہیں گے. Fishermen کسی بھی نیٹ ورک کے شرکاء ہیں جو تنازعات کو کھولتے ہیں.

تنازعات کے **تین** ممکنہ نتائج ہوتے ہیں, اسی طرح Fishermen کی جمع کردہ میں.

- اگر تنازعہ مسترد کر دیا جاتا ہے, تو Fishermen کی طرف سے جمع کردہ GRT کو جلا دیا جائے گا، اور متنازعہ انڈیکسر کی کٹوتی نہیں کی جائے گی.
- اگر تنازعہ قرعہ اندازی کے طور پر طے پا جاتا ہے، تو Fishermen کی جمع رقم واپس کر دی جائے گی، اور متنازعہ انڈیکسر کی کٹوتی نہیں کی جائے گی.
- اگر تنازعہ قبول کر لیا جاتا ہے، تو Fishermen کی طرف سے جمع کرائی گئی GRT واپس کر دی جائے گی، متنازعہ انڈیکسر کی کٹوتی کر لی جائے گی اور Fishermen کٹوتی کے GRT کا 50% کمائیں گے.

تنازعات کو `Disputes` ٹیب کے نیچے انڈیکسر کے پروفائل پیج کی UI میں دیکھا جا سکتا ہے.

### کیوری فیس ری بیٹس کیا ہیں اور وہ کب تقسیم کی جاتی ہیں?

Query fees are collected by the gateway and distributed to indexers according to the exponential rebate function (see GIP [here](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)).

Once an allocation has been closed the rebates are available to be claimed by the Indexer. Upon claiming, the query fee rebates are distributed to the Indexer and their Delegators based on the query fee cut and the exponential rebate function.

### کیوری فی کٹ اور انڈیکسنگ ریوارڈ کٹ کیا ہے؟

`queryFeeCut` اور `indexingRewardCut` قدریں ڈیلی گیشن پیرامیٹر ہیں جنہیں انڈیکسر, انڈیکسر اور ان کے ڈیلیگیٹرز کے درمیان GRT کی تقسیم کو کنٹرول کرنے کے لیے cooldownBlocks کے ساتھ سیٹ کر سکتا ہے. ڈیلیگیشن کے پیرامیٹرز کو ترتیب دینے کے لیے ہدایات کے لیے [پروٹوکول میں حصہ لینا](/network/indexing#stake-in-the-protocol) میں آخری مراحل دیکھیں.

- **queryFeeCut** - the % of query fee rebates that will be distributed to the Indexer. If this is set to 95%, the Indexer will receive 95% of the query fees earned when an allocation is closed with the other 5% going to the Delegators.

- **indexingRewardCut** - the % of indexing rewards that will be distributed to the Indexer. If this is set to 95%, the Indexer will receive 95% of the indexing rewards when an allocation is closed and the Delegators will split the other 5%.

### انڈیکسر کیسے جانتے ہیں کہ کون سے سب گرافس کو انڈیکس کرنا ہے؟

انڈیکسرز سب گراف انڈیکسنگ کے فیصلے کرنے کے لیے جدید تکنیکوں کو استعمال کر کے خود کو نمایاں کر سکتے ہیں لیکن ایک عمومی خیال دینے کے لیے ہم نیٹ ورک میں سب گراف کی جانچ کے لیے استعمال ہونے والی کئی کلیدی میٹرکس پر بات کریں گے:

- **کیوریشن سگنل** - کسی خاص سب گراف پر لاگو نیٹ ورک کیوریشن سگنل کا تناسب اس سب گراف میں دلچسپی کا ایک اچھا اشارہ ہے, خاص طور پر بوٹسٹریپ مرحلے کے دوران جب کیوری کا حجم بڑھ رہا ہوتا ہے.

- **جمع کی گئی کیوری فیس** - ایک مخصوص سب گراف کے لیے جمع کردہ کیوری فیس کی مقدار کا تاریخی ڈیٹا مستقبل کی طلب کا ایک اچھا اشارہ ہے.

- **سٹیک پر لگی رقم** - دوسرے انڈیکسرز کے رویے کی نگرانی کرنا یا مخصوص سب گراف کے لیے مختص کل حصص کے تناسب کو دیکھنا انڈیکسر کو سب گراف کی کیوریز کے لیے سپلائی سائیڈ کی نگرانی کرنے کی اجازت دے سکتا ہے تاکہ ان سب گرافوں کی شناخت کی جا سکے جن پر نیٹ ورک اعتماد ظاہر کر رہا ہے یا ان سب گرافس جو مزید سپلائی کی ضرورت کو ظاہر کر سکتے ہیں.

- **انڈیکسنگ انعامات کے بغیر سب گراف** - کچھ سب گراف بنیادی طور پر اس وجہ سے انڈیکسنگ کے انعامات نہیں بناتے کہ وہ IPFS جیسی غیر تعاون یافتہ خصوصیات استعمال کر رہے ہیں یا اس وجہ سے کہ وہ مین نیٹ سے باہر کسی دوسرے نیٹ ورک کو کیوری کر رہے ہیں. آپ کو سب گراف پر ایک پیغام نظر آئے گا اگر یہ انڈیکسنگ کے انعامات نہیں بنا رہا ہے.

### ہارڈ ویئر کی ضروریات کیا ہیں؟

- **چھوٹا** - کئی سب گرافس کی انڈیکسنگ شروع کرنے کے لیے کافی ہے، ممکنہ طور پر توسیع کی ضرورت ہوگی.
- **معیاری** - پہلے سے طے شدہ سیٹ اپ، یہ وہی ہے جو مثال کے k8s/terraform کے تعیناتی مینی فیسٹس میں استعمال ہوتا ہے.
- **درمیانہ** - پروڈکشن انڈیکسر 100 سب گراف اور 200-500 درخواستیں فی سیکنڈ کو اٹھا سکتا ہے.
- **بڑا** - تمام فی الحال زیر استعمال سب گرافس کو انڈیکس کرنے اور متعلقہ ٹریفک کے لیے درخواستیں پیش کرنے کے لیے تیار ہے.

| سیٹ اپ  | Postgres<br />(CPUs) | Postgres<br />(GBs میں memory) | Postgres<br />(TBs میں disk) | VMs<br />(CPUs) | VMs<br />(GBs میں میموری) |
| ------- |:--------------------------:|:------------------------------------:|:----------------------------------:|:---------------------:|:-------------------------------:|
| چھوٹا   |             4              |                  8                   |                 1                  |           4           |               16                |
| معیاری  |             8              |                  30                  |                 1                  |          12           |               48                |
| درمیانہ |             16             |                  64                  |                 2                  |          32           |               64                |
| بڑا     |             72             |                 468                  |                3.5                 |          48           |               184               |

### وہ کون سی چند بنیادی حفاظتی تدابیر ہیں جو ایک انڈیکسر کو اختیار کرنی چاہیے؟

- **آپریٹر والیٹ** - آپریٹر والیٹ کا سیٹ اپ کرنا ایک اہم احتیاط ہے کیونکہ یہ ایک انڈیکسر کو اپنی کلیدوں کے درمیان علیحدگی برقرار رکھنے کی اجازت دیتا ہے جو سٹیک کو کنٹرول کرتی ہیں اور جو روزمرہ کے کاموں کے کنٹرول میں ہیں. ہدایات کے لیے [پروٹوکول میں حصہ ڈالنا](/network/indexing#stake-in-the-protocol) دیکھیں.

- **فائر وال** - صرف انڈیکسر سروس کو عوامی طور پر ظاہر کی ضرورت ہے اور ایڈمن پورٹس اور ڈیٹا بیس تک رسائی کو لاک ڈاؤن کرنے پر خاص توجہ دی جانی چاہیے: گراف نوڈ JSON-RPC اینڈ پوائنٹ (ڈیفالٹ پورٹ: 8030)، انڈیکسر مینجمنٹ API endpoint (ڈیفالٹ پورٹ: 18000)، اور Postgres ڈیٹا بیس اینڈ پوائنٹ (ڈیفالٹ پورٹ: 5432) کو ظاہر نہیں کرنا چاہیے.

## انفراسٹرکچر

انڈیکسر کے بنیادی ڈھانچے کے مرکز میں گراف نوڈ ہوتا ہے جو انڈیکسڈ نیٹ ورکس کی نگرانی کرتا ہے، سب گراف کی تعریف کے مطابق ڈیٹا کو نکالتا اور لوڈ کرتا ہے اور اسے [GraphQL API](/about/#how-the-graph-works) کے طور پر کام کرتا ہے۔ گراف نوڈ کو ہر انڈیکسڈ نیٹ ورک سے ڈیٹا کو ظاہر کرنے والے اینڈ پوائنٹ سے منسلک ہونے کی ضرورت ہے۔ ڈیٹا سورسنگ کے لیے ایک IPFS نوڈ؛ اس کے اسٹور کے لیے ایک PostgreSQL ڈیٹا بیس؛ اور انڈیکسر اجزاء جو نیٹ ورک کے ساتھ اس کے تعامل کو آسان بناتے ہیں.

- **PostgreSQL ڈیٹا بیس** - گراف نوڈ کا مرکزی اسٹور، یہ وہ جگہ ہے جہاں سب گراف ڈیٹا محفوظ کیا جاتا ہے. انڈیکسر سروس اور ایجنٹ سٹیٹ چینل کے ڈیٹا، لاگت کے ماڈل، انڈیکسنگ کے قواعد، اور ایلوکیشن کارروائیوں کو ذخیرہ کرنے کے لیے بھی ڈیٹا بیس کا استعمال کرتے ہیں.

- **ڈیٹا اینڈ پوائنٹ** - EVM-مطابقت پذیر نیٹ ورکس کے لیے، گراف نوڈ کو ایک ایسے اینڈ پوائنٹ سے منسلک کرنے کی ضرورت ہے جو EVM کے موافق JSON-RPC API کو ظاہر کرے۔ یہ ایک کلائنٹ کی شکل اختیار کر سکتا ہے یا یہ زیادہ پیچیدہ سیٹ اپ ہو سکتا ہے جو متعدد پر بیلنس کو لوڈ کرتا ہے۔ یہ جاننا ضروری ہے کہ کچھ سب گراف کے لیے مخصوص کلائنٹ کی صلاحیتوں کی ضرورت ہوگی جیسے کہ آرکائیو موڈ اور/یا پیریٹی ٹریسنگ API.

- **IPFS نوڈ (ورزن 5 سے کم)** - سب گراف تعیناتی میٹا ڈیٹا IPFS نیٹ ورک پر محفوظ کیا جاتا ہے. گراف نوڈ بنیادی طور پر سب گراف کی تعیناتی کے دوران IPFS نوڈ تک رسائی حاصل کرتا ہے تاکہ سب گراف مینی فیسٹ اور تمام منسلک فائلوں کو حاصل کیا جا سکے. نیٹ ورک انڈیکسرز کو اپنے IPFS نوڈ کی میزبانی کرنے کی ضرورت نہیں ہے، نیٹ ورک کے لیے ایک IPFS نوڈ https://ipfs.network.thegraph.com پر ہوسٹ کیا گیا ہے.

- **انڈیکسر سروس** - نیٹ ورک کے ساتھ تمام مطلوبہ بیرونی مواصلات کو ہینڈل کرتا ہے۔ لاگت کے ماڈلز اور انڈیکسنگ کے حالات کا اشتراک کرتا ہے، گیٹ ویز سے کیوری کی درخواستوں کو گراف نوڈ پر منتقل کرتا ہے، اور گیٹ وے کے ساتھ سٹیٹ چینلز کے ذریعے کیوری کی ادائیگیوں کا انتظام کرتا ہے.

- **انڈیکسر ایجنٹ** - نیٹ ورک پر رجسٹریشن، اس کے گراف نوڈ/س میں سب گراف کی تعیناتیوں کا انتظام، اور ایلوکیشنز کا نظم کرنے سمیت چین پر انڈیکسرز کے تعاملات کی سہولت فراہم کرتا ہے.

- **Prometheus میٹرکس سرور** - گراف نوڈ اور انڈیکسر کمپونینٹس اپنے میٹرکس کو میٹرکس سرور پر لاگ کرتے ہیں.

نوٹ: فرتیلی پیمائی کو سپورٹ کرنے کے لیے، یہ تجویز کیا جاتا ہے کہ کیوری اور انڈیکسنگ کے معاملات کو نوڈس کے مختلف سیٹس کے درمیان الگ کیا جائے: کیوری نوڈس اور انڈیکس نوڈس.

### پورٹس کا جائزہ

> **اہم بات**: پورٹس کو عوامی طور پر ظاہر کرنے کے بارے میں محتاط رہیں - **انتظامی پورٹس** کو لاک ڈاؤن رکھا جانا چاہیے. اس میں گراف نوڈ JSON-RPC اور نیچے دیے گئے انڈیکسر مینجمنٹ اینڈ پوائنٹس شامل ہیں.

#### گراف نوڈ

| Port | Purpose                                                   | Routes                                               | CLI Argument      | Environment Variable |
| ---- | --------------------------------------------------------- | ---------------------------------------------------- | ----------------- | -------------------- |
| 8000 | GraphQL HTTP server<br />(سب گراف کی کیوریز کے لیے) | /subgraphs/id/...<br />/subgraphs/name/.../... | --http-port       | -                    |
| 8001 | GraphQL WS<br />(سب گراف subscriptions کے لیے)      | /subgraphs/id/...<br />/subgraphs/name/.../... | --ws-port         | -                    |
| 8020 | JSON-RPC<br />(تعیناتیوں کے انتظام کے لیے)          | /                                                    | --admin-port      | -                    |
| 8030 | سب گراف انڈیکسنگ اسٹیٹس API                               | /graphql                                             | --index-node-port | -                    |
| 8040 | Prometheus میٹرکس                                         | /metrics                                             | --metrics-port    | -                    |

#### انڈیکسر سروس

| Port | Purpose                                                           | Routes                                                                  | CLI Argument   | Environment Variable   |
| ---- | ----------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------- | ---------------------- |
| 7600 | GraphQL HTTP server<br />(ادا شدہ سب گراف کی کیوریز کے لیے) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | --port         | `INDEXER_SERVICE_PORT` |
| 7300 | Prometheus میٹرکس                                                 | /metrics                                                                | --metrics-port | -                      |

#### انڈیکسر ایجنٹ

| Port | Purpose             | Routes | CLI Argument              | Environment Variable                    |
| ---- | ------------------- | ------ | ------------------------- | --------------------------------------- |
| 8000 | انڈیکسر مینجمنٹ API | /      | --indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### گوگل کلاؤڈ پر ٹیرا فورم کا استعمال کرتے ہوئے سرور کا بنیادی ڈھانچہ ترتیب دیں

> نوٹ: انڈیکسرز متبادل طور پر AWS، Microsoft Azure، یا Alibaba استعمال کر سکتے ہیں.

#### اولین ضروریات کو انسٹال کریں

- Google Cloud SDK
- Kubectl command line tool
- Terraform

#### گوگل کلاؤڈ پروجیکٹ بنائیں

- انڈیکسر ریپوزٹری کی نقل کریں یا اس پر تشریف لے جائیں.

- ./terraform ڈائریکٹری پر جائیں, یہ وہ جگہ ہے جہاں تمام کمانڈز چلائی جانی چاہئے.

```sh
cd terraform
```

- گوگل کلاؤڈ کے ساتھ تصدیق کریں اور ایک نیا پروجیکٹ بنائیں.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- نئے پروجیکٹ کے لیے بلنگ کو فعال کرنے کے لیے گوگل کلاؤڈ کنسول کا بلنگ والا صفحہ استعمال کریں.

- گوگل کلاؤڈ کنفگریشن بنائیں.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- مطلوبہ گوگل کلاؤڈ APIs کو فعال کریں.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- ایک سروس اکاؤنٹ بنائیں.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- ڈیٹا بیس اور Kubernetes کلسٹر کے درمیان پیئرنگ کو فعال کریں جو اگلے مرحلے میں بنائے جائیں گے.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- کم سے کم terraform کنفیگریشن فائل بنائیں (ضرورت کے مطابق اپ ڈیٹ کریں).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database passowrd>"
EOF
```

#### انفراسٹرکچر بنانے کے لیے Terraform کا استعمال کریں

کوئی بھی کمانڈ چلانے سے پہلے، [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) کو پڑھیں اور اس ڈائرکٹری میں ایک فائل `terraform.tfvars` بنائیں (یا اس میں ترمیم کریں جسے ہم نے آخری مرحلے میں بنایا تھا). ہر variable کے لیے جہاں آپ ڈیفالٹ کو اوور رائڈ کرنا چاہتے ہیں، یا جہاں آپ کو کوئی ویلیو سیٹ کرنا ہے، `terraform.tfvars` میں ایک سیٹنگ درج کریں.

- انفراسٹرکچر بنانے کے لیے درج ذیل کمانڈز چلائیں.

```sh
# Install required plugins
terraform init

# View plan for resources to be created
terraform plan

# Create the resources (expect it to take up to 30 minutes)
terraform apply
```

نئے کلسٹر کے لیے اسناد کو `~/.kube/config` میں ڈاؤن لوڈ کریں اور اسے اپنے ڈیفالٹ سیاق و سباق کے طور پر سیٹ کریں.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### انڈیکسر کے لیے Kubernetes اجزاء کی تخلیق

- ڈائریکٹری `k8s/overlays` کو ایک نئی ڈائریکٹری `$dir,` میں کاپی کریں اور `bases` اندراج کو `$dir/kustomization.yaml` میں ایڈجسٹ کریں تاکہ یہ ڈائریکٹری `k8s/base` کی طرف اشارہ کرے.

- `$dir` میں تمام فائلوں کو پڑھیں اور تبصروں میں بتائی گئی کسی بھی قدر کو ایڈجسٹ کریں.

`kubectl apply -k $dir` کے ساتھ تمام وسائل تعینات کریں.

### گراف نوڈ

[گراف نوڈ](https://github.com/graphprotocol/graph-node) ایک اوپن سورس Rust کا نفاذ ہے جو Ethereum بلاکچین کو ڈیٹا سٹور کو متعین طور پر اپ ڈیٹ کرنے کے لیے فراہم کرتا ہے جس سے GraphQL اینڈ پوائنٹ کے ذریعے کیوری کیا جا سکتا ہے. ڈویلپرز اپنے اسکیما کی وضاحت کرنے کے لیے سب گراف کا استعمال کرتے ہیں، اور بلاک چین سے حاصل کردہ ڈیٹا کو تبدیل کرنے کے لیے میپنگ کا ایک سیٹ اور گراف نوڈ پوری چین کو ہم آہنگ کرنے، نئے بلاکس کی مانیٹرنگ، اور GraphQL اینڈ پوائنٹ کے ذریعے اسے پیش کرنے کے لیے استعمال کرتے ہیں.

#### سورس سے شروع کرنا

#### اولین ضروریات کو انسٹال کریں

- **Rust**

- **Rust**

- **IPFS**

- **اوبنٹو کے صارفین کے لیے اضافی تقاضے** - اوبنٹو پر گراف نوڈ چلانے کے لیے چند اضافی پیکجوں کی ضرورت ہو سکتی ہے.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### سیٹ اپ

1. PostgreSQL ڈیٹا بیس سرور چالو کریں

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. [گراف نوڈ](https://github.com/graphprotocol/graph-node) ریپو کلون کریں اور `cargo build` چلا کر سورس کو بلڈ کریں

3. اب جب کہ تمام انحصار سیٹ اپ ہو چکے ہیں، گراف نوڈ شروع کریں:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Docker کے ساتھ استعمال شروع کرنا

#### اولین ضروریات

- **ایتھیریم نوڈ** - پہلے سے طے شدہ طور پر، ڈوکر کمپوز سیٹ اپ مین نیٹ کا استعمال کرے گا: [http://host.docker.internal:8545](http://host.docker.internal:8545) آپ کی ہوسٹ مشین پر ایتھیریم نوڈ سے رابطہ قائم کرنے کے لیے. آپ `docker-compose.yaml` کو اپ ڈیٹ کرکے اس نیٹ ورک کا نام اور url تبدیل سکتے ہیں.

#### سیٹ اپ

1. گراف نوڈ کو کلون کریں اور Docker ڈائرکٹری پر جائیں:

```sh
git clone http://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. صرف linux صارفین کے لیے - شامل اسکرپٹ کا استعمال کرتے ہوئے `docker-compose.yaml` میں `host.docker.internal` کے بجائے host IP کا ایڈریس استعمال کریں:

```sh
./setup.sh
```

3. ایک مقامی گراف نوڈ شروع کریں جو آپ کے ایتھریم اینڈ پوائنٹ سے جڑے گا:

```sh
docker-compose up
```

### انڈیکسر کے اجزاء

نیٹ ورک میں کامیابی کے ساتھ حصہ لینے کے لیے تقریباً مسلسل نگرانی اور تعامل کی ضرورت ہوتی ہے، اس لیے ہم نے انڈیکسرز نیٹ ورک کی شرکت کی سہولت کے لیے Typescript ایپلی کیشنز کا ایک مجموعہ بنایا ہے. انڈیکسر کے تین کمپونینٹس ہیں:

- **انڈیکسر ایجنٹ** - ایجنٹ نیٹ ورک اور انڈیکسر کے اپنے بنیادی انفراسٹرکچر کی نگرانی کرتا ہے اور اس کا انتظام کرتا ہے کہ کون سے سب گراف کی تعیناتیوں کو انڈیکس کیا جا رہا ہے اور چین کی طرف مختص کیا جاتا ہے اور ہر ایک کے لیے کتنی رقم مختص کی جاتی ہے.

- **انڈیکسر سروس** - واحد کمپونینٹ جسے بیرونی طور پر سامنے لانے کی ضرورت ہے، سروس سب گراف کیوریز کو گراف نوڈ تک پہنچاتی ہے، کیوری کی ادائیگی کے لیے سٹیٹ چینلز کا انتظام کرتی ہے، کلائنٹس کو فیصلہ سازی کی اہم معلومات شیئر کرتی ہے جیسا کہ گیٹ ویز.

- **انڈیکسر CLI** - انڈیکسر ایجنٹ کے انتظام کے لیے کمانڈ لائن انٹرفیس. یہ انڈیکسرز کو لاگت کے ماڈل، دستی ایلوکیشنز، اعمال کی قطار، اور انڈیکسنگ کے قواعد کا نظم کرنے کے قابل بناتا ہے.

#### شروع کرتے ہوئے

انڈیکسر ایجنٹ اور انڈیکسر سروس آپ کے گراف نوڈ انفراسٹرکچر کے ساتھ مل کر واقع ہونی چاہیے۔ آپ کے انڈیکسر کمپونینٹس کے لیے ورچوئل ایگزیکیوشن ماحول قائم کرنے کے بہت سے طریقے ہیں۔ یہاں ہم وضاحت کریں گے کہ انہیں NPM پیکجز یا سورس کا استعمال کرتے ہوئے، یا گوگل کلاؤڈ kubernetes انجن پر kubernetes اور docker کے ذریعے بیئر میٹل پر کیسے چلایا جائے۔ اگر سیٹ اپ کی یہ مثالیں آپ کے بنیادی ڈھانچے میں اچھی طرح سے شامل نہیں ہوتی ہیں تو ممکنہ طور پر حوالہ دینے کے لیے کمیونٹی گائیڈ ہو گا، آئیں [ڈسکورڈ](https://thegraph.com/discord) پر ہیلو کہیں! اپنے انڈیکسر اجزاء کو شروع کرنے سے پہلے [پروٹوکول میں سٹیک کرناا](/network/indexing#stake-in-the-protocol) یاد رکھیں!

#### NPM پیکیجیز سے

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### سورس سے

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### docker استعمال کرتے ہوئے

- ریجیسٹری سے تصاویر کو پل کریں

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

یا سورس سے مقامی طور پر تصاویر کو بلڈ کریں

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- اجزاء کو چلائیں

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**نوٹ**: کنٹینرز چالو کرنے کے بعد، انڈیکسر سروس کو [http://localhost:7600](http://localhost:7600) پر قابل رسائی ہونا چاہیے اور انڈیکسر ایجنٹ کو Indexer management API کو [http://localhost:18000/](http://localhost:18000/) پر ظاہر کرنا چاہیے.

#### K8s اور Terraform کو استعمال کرتے ہوئے

[Google Cloud پر Terraform کا استعمال کرتے ہوئے سرور انفراسٹرکچر سیٹ اپ کریں](/network/indexing#setup-server-infrastructure-using-terraform-on-google-cloud) سیکشن دیکھیں

#### استعمال

> **نوٹ**: تمام runtime کنفیگریشن variables یا تو startup پر کمانڈ پر پیرامیٹرز کے طور پر لاگو کیے جا سکتے ہیں یا `COMPONENT_NAME_VARIABLE_NAME` format کے environment variables کا استعمال کرتے ہوئے (مثال کے طور پر `INDEXER_AGENT_ETHEREUM`).

#### انڈیکسر ایجنٹ

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### انڈیکسر سروس

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  | pino-pretty
```

#### انڈیکسر CLI

Indexer CLI [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) کے لیے ایک plugin ہے جس کو `گراف انڈیکسر` پر terminal میں قابل رسائی حاصل ہے.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### انڈیکسر CLI کا استعمال کرتے ہوئے انڈیکسر کا انتظام

**انڈیکسر مینجمنٹ API** کے ساتھ تعامل کے لیے تجویز کردہ ٹول **انڈیکسر CLI** ہے، جو کہ **گراف CLI** کی توسیع ہے. انڈیکسر ایجنٹ کو انڈیکسر سے ان پٹ کی ضرورت ہوتی ہے تاکہ انڈیکسر کی جانب سے نیٹ ورک کے ساتھ خود مختاری سے تعامل کیا جا سکے. انڈیکسر ایجنٹ کے رویے کی وضاحت کرنے کا طریقہ کار **مختص کا انتظام** موڈ اور **انڈیکسنگ کے قواعد** ہیں. آٹو موڈ میں، ایک انڈیکسر **انڈیکسنگ کے قواعد** کا استعمال کر سکتا ہے تاکہ انڈیکس اور کیوری پیش کرنے میں سب گرافوں کو چننے کے لیے اپنی مخصوص حکمت عملی کو لاگو کیا جا سکے. اصولوں کا نظم ایک GraphQL API کے ذریعے کیا جاتا ہے جو ایجنٹ کے ذریعہ پیش کیا جاتا ہے اور اسے انڈیکسر مینیجمینٹ API کے نام سے جانا جاتا ہے. دستی موڈ میں، ایک انڈیکسر **اعمال کی قطار** کا استعمال کرتے ہوئے مختص کی کارروائیاںمختص کی کارروائیاں بنا سکتا ہے اور ان کے چلنے سے پہلے انہیں واضح طور پر منظور کر سکتا ہے۔ نگرانی کے موڈ میں، **انڈیکسنگ کے قواعد** کا استعمال **اعمال کی قطار** کو آباد کرنے کے لیے کیا جاتا ہے اور اس کو چلانے کے لیے واضح منظوری بھی درکار ہوتی ہے.

#### استعمال

**انڈیکسر CLI** انڈیکسر ایجنٹ سے جڑتی ہے، عام طور پر پورٹ فارورڈنگ کے ذریعے، لہذا CLI کو ایک ہی سرور یا کلسٹر پر چلانے کی ضرورت نہیں ہے. شروع کرنے میں آپ کی مدد کرنے کے لیے، اور کچھ سیاق و سباق فراہم کرنے کے لیے، CLI کو یہاں مختصراً بیان کیا جائے گا.

- `graph indexer connect <url>` - انڈیکسر مینیجمینٹ API سے جڑیں. عام طور پر سرور سے کنکشن, پورٹ فارورڈنگ کے ذریعے کھولا جاتا ہے، لہذا CLI آسانی سے دور سے چلایا جا سکتا ہے. (مثال: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - تمام قواعد حاصل کرنے کے لیے `all` کو بطور `<deployment-id>` استعمال کرتے ہوئے ایک یا زیادہ انڈیکسر کے قواعد حاصل کریں، یا عالمی ڈیفالٹس حاصل کرنے کے لیے `global` کو استعمال کریں. ایک اضافی دلیل `--merged` کو یہ بتانے کے لیے استعمال کیا جا سکتا ہے کہ تعیناتی کے مخصوص اصول عالمی اصول کے ساتھ ضم ہو گئے ہیں. انڈیکسر ایجنٹ میں ان کا اطلاق اس طرح ہوتا ہے.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - ایک یا اس سے زیادہ انڈیکسنگ کے اصول مرتب کریں.

- `graph indexer rules start [options] <deployment-id>` - اگر دستیاب ہو تو سب گراف کی تعیناتی کو انڈیکس کرنا شروع کریں اور اس کا `decisionBasis` کو `Always` پر سیٹ کریں، اس لیے انڈیکسر ایجنٹ ہمیشہ اسے انڈیکس کرنے کا انتخاب کرے گا. اگر عالمی اصول کو ہمیشہ پر سیٹ کیا جاتا ہے تو نیٹ ورک پر دستیاب تمام سب گرافس کو انڈیکس کیا جائے گا.

- `graph indexer rules stop [options] <deployment-id>` - کسی تعیناتی کو انڈیکس کرنا بند کریں اور اس کا `decisionBasis` never پر سیٹ کریں، لہذا یہ انڈیکس میں تعیناتیوں کا فیصلہ کرتے وقت اس تعیناتی کو چھوڑ دے گا.

- `graph indexer rules maybe [options] <deployment-id>` — تعیناتی کے لیے `decisionBasis` کو `rules` پر سیٹ کریں، تاکہ انڈیکسر ایجنٹ یہ فیصلہ کرنے کے لیے انڈیکسنگ کے اصول استعمال کرے کہ آیا اس تعیناتی کو انڈیکس کرنا ہے.

- `graph indexer actions get [options] <action-id>` - `all` کا استعمال کرتے ہوئے ایک یا زیادہ کارروائیاں حاصل کریں یا تمام کارروائیاں حاصل کرنے کے لیے `action-id` کو خالی چھوڑ دیں. ایک اضافی argument `--status` کو کسی خاص status کی تمام کارروائیاں کو پرنٹ کرنے کے لیے استعمال کیا جا سکتا ہے.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - قطار(Queue) مختص کرنے کی کارروائی

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Queue reallocate action

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Queue unallocate action

- `graph indexer actions cancel [<action-id> ...]` - اگر id غیر متعین ہے تو queue میں موجود تمام کارروائیوں کو منسوخ کریں، بصورت دیگر seperator کے طور پر space کے ساتھ id کی array کو منسوخ کریں

- `graph indexer actions approve [<action-id> ...]` - عملدرآمد کے لیے متعدد کارروائیوں کو منظور کریں

- `graph indexer actions execute approve` - کارکن کو فوری طور پر منظور شدہ کارروائیوں کو انجام دینے پر مجبور کریں

تمام کمانڈز جو output میں قواعد کو ظاہر کرتی ہیں وہ `-output` دلیل(argument) کا استعمال کرتے ہوئے معاون output فارمیٹس (`table`، `yaml`، اور `json`) کے درمیان انتخاب کرسکتے ہیں.

#### انڈیکسنگ کے قواعد

انڈیکسنگ کے قوانین یا تو عالمی ڈیفالٹس کے طور پر لاگو کیے جا سکتے ہیں یا ان کی IDs کا استعمال کرتے ہوئے مخصوص سب گراف کی تعیناتیوں کے لیے۔ `deployment` اور `decisionBasis` فیلڈز لازمی ہیں، جبکہ دیگر تمام فیلڈز اختیاری ہیں. جب انڈیکسنگ کے اصول میں `rules` بطور `decisionBasis` ہوتا ہے، تو انڈیکسر ایجنٹ اس اصول پر non-null حد کی قدروں کا موازنہ متعلقہ تعیناتی کے لیے نیٹ ورک سے حاصل کردہ اقدار سے کرے گا. اگر سب گراف کی تعیناتی میں کسی بھی حد سے اوپر (یا نیچے) قدریں ہیں تو اسے انڈیکسنگ کے لیے منتخب کیا جائے گا.

مثال کے طور پر، اگر عالمی اصول میں `minStake` **5** (GRT) ہے، تو کسی بھی سب گراف کی تعیناتی جس میں 5 (GRT) سے زیادہ سٹیک مختص کیا گیا ہے، انڈیکس کیا جائے گا. حد کے اصولوں میں شامل ہیں `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, اور `minAverageQueryFees`.

ڈیٹا ماڈل:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

انڈیکسنگ کے اصول کے استعمال کی مثال:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Actions queue CLI

Indexer-cli کارروائی کی قطار کے ساتھ دستی طور پر کام کرنے کے لیے ایک `actions` ماڈیول فراہم کرتا ہے. یہ کارروائی کی قطارe کے ساتھ تعامل کرنے کے لیے انڈیکسر مینیجمینٹ سرور کے زیر اہتمام **Graphql API** کا استعمال کرتا ہے.

عمل پر عملدرآمد کرنے والا کارکن صرف اس صورت میں قطار سے آئٹمز کو پکڑے گا جب ان کے پاس `ActionStatus = approved` ہو. تجویز کردہ راستے میں کارروائیوں کو ActionStatus = queued کے ساتھ قطار میں شامل کیا جاتا ہے، لہذا ان کو آن چین پر عمل درآمد کرنے کے لیے منظور ہونا ضروری ہے۔ عام بہاؤ اس طرح نظر آئے گا:

- فریق ثالث کا اصلاح کنندہ ٹول یا indexer-cli صارف کے ذریعے قطار میں ایکشن شامل کیا گیا
- انڈیکسر تمام queued کارروائیوں کو دیکھنے کے لیے `indexer-cli` استعمال کر سکتا ہے
- Indexer (یا دیگر software) `indexer-cli` کا استعمال کرتے ہوئے queue میں کارروائیوں کو منظور یا منسوخ کر سکتا ہے۔ approve اور cancel کی کمانڈز کے بطور ان پٹ action ids کی ایک array لیتی ہیں.
- Execution worker باقاعدگی سے منظور شدہ کارروائیوں کے لیے قطار میں polling کرتا ہے۔ یہ قطار سے `approved` کارروائیوں کو پکڑے گا، ان کو execute کرنے کی کوشش کرے گا، اور db میں اقدار کو `success` یا `failed` پر عمل درآمد کی حیثیت کے لحاظ سے اپ ڈیٹ کرے گا.
- اگر کوئی کارروائی کامیاب ہوتی ہے تو کارکن اس بات کو یقینی بنائے گا کہ ایک انڈیکسنگ کا اصول موجود ہے جو ایجنٹ کو بتاتا ہے کہ ایلوکیشن کو آگے بڑھنے کا طریقہ کس طرح منظم کرنا ہے، جب ایجنٹ `auto` یا `oversight` موڈ میں ہوتا ہے تو دستی کارروائی کرتے وقت مفید ہوتا ہے.
- انڈیکسر ایکشن کے عمل کی تاریخ دیکھنے کے لیے action queue کی نگرانی کر سکتا ہے اور اگر ضرورت ہو تو ایکشن کے اجزاء کو دوبارہ منظور اور اپ ڈیٹ کر سکتا ہے اگر وہ عمل درآمد میں ناکام رہے. action queue تمام queued اور taken اعمال کی تاریخ فراہم کرتی ہے.

ڈیٹا ماڈل:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

سورس سے استعمال کی مثال:

```bash
indexer indexer actions get all

indexer indexer actions get --status queued

indexer indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

indexer indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

indexer indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

indexer indexer actions cancel

indexer indexer actions approve 1 3 5

indexer indexer actions execute approve
```

نوٹ کریں کہ ایلوکیشن کے انتظام کے لیے معاون کارروائی کی اقسام میں مختلف ان پٹ تقاضے ہوتے ہیں:

- `Allocate` - ایک مخصوص سب گراف کی تعیناتی میں سٹیک مختص کریں

  - مطلوبہ ایکشن params:
    - deploymentID
    - amount

- `Unallocate` - ایلوکیشن بند کریں، دوسری جگہوں پر دوبارہ مختص کرنے کے لیے سٹیک کو آزاد کریں

  - مطلوبہ ایکشن params:
    - allocationID
    - deploymentID
  - اختیاری ایکشن params:
    - poi
    - فورس (فراہم کردہ POI استعمال کرنے والی فورس یہاں تک کہ اگر یہ گراف نوڈ کے فراہم کردہ سے مماثل نہیں ہے)

- `Reallocate` - جوہری طور پر ایلوکیشن کو بند کریں اور اسی سب گراف کی تعیناتی کے لیے ایک تازہ ایلوکیشن کھولیں

  - مطلوبہ ایکشن params:
    - allocationID
    - deploymentID
    - amount
  - اختیاری ایکشن params:
    - poi
    - فورس (فراہم کردہ POI استعمال کرنے والی فورس یہاں تک کہ اگر یہ گراف نوڈ کے فراہم کردہ سے مماثل نہیں ہے)

#### لاگت کے ماڈل

لاگت کے ماڈل مارکیٹ اور کیوری کی خصوصیات پر مبنی کیوریز کے لیے متحرک قیمت فراہم کرتے ہیں. انڈیکسر سروس ہر سب گراف کے گیٹ ویز کے ساتھ لاگت ماڈل شیئر کرتی ہے جس کے لیے وہ کیوریز کا جواب دینا چاہتے ہیں. گیٹ وے، بدلے میں، فی کیوری انڈیکسر کے انتخاب کے فیصلے کرنے اور منتخب کردہ انڈیکسرز کے ساتھ ادائیگی پر بات چیت کرنے کے لیے لاگت ماڈلز کا استعمال کرتے ہیں.

#### Agora

Agora زبان کیوریز کے لیے لاگت ماڈل بنانے کے لیے ایک لچکدار فارمیٹ فراہم کرتی ہے. Agora لاگت کے ماڈل سٹیٹمنٹس کا ایک سلسلہ ہے جو GraphQL کیوری میں ہر اعلیٰ درجے کی کیوری کے لیے ترتیب دیتا ہے. ہر top-level کیوری کے لیے، پہلا بیان جو اس سے ملتا ہے اس کیوری کی قیمت کا تعین کرتا ہے.

ایک بیان ایک پیشن گوئی پر مشتمل ہوتی ہے، جو GraphQL کی کیوریز کے ملاپ کے لیے استعمال ہوتی ہے، اور ایک cost expression جس کا جب اندازہ کیا جاتا ہے تو اعشاریہ GRT میں لاگت نکلتی ہے. کیوری کی نامزد argument پوزیشن میں اقدار کو پیش گوئی میں پکڑا جاسکتا ہے اور expression میں استعمال کیا جاسکتا ہے. Globals کو ایک expression میں placeholders کے لیے بھی سیٹ اور متبادل کیا جا سکتا ہے.

مثال کا cost model:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

مندرجہ بالا ماڈل کا استعمال کرتے ہوئے کیوری کی قیمت کی مثال:

| کیوری                                                                        | قیمت    |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#123; tokens &#125; symbol &#125; &#125; | 0.6 GRT |

#### Cost ماڈل لاگو کرنا

لاگت کے ماڈلز کا اطلاق انڈیکسر CLI کے ذریعے کیا جاتا ہے، جو ڈیٹا بیس میں ذخیرہ کرنے کے لیے انڈیکسر ایجنٹ کے انڈیکسر مینجمنٹ API کو بھیجتا ہے. اس کے بعد انڈیکسر سروس انہیں اٹھائے گی اور لاگت کے ماڈلز کو گیٹ ویز پر پیش کرے گی جب بھی وہ ان سے پوچھیں گے.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## نیٹ ورک کے ساتھ تعامل

### پروٹوکول میں حصہ ڈالنا

انڈیکسر کے طور پر نیٹ ورک میں حصہ لینے کے پہلے اقدامات پروٹوکول، سٹیک فنڈز کو منظور کرنا، اور (اختیاری طور پر) روزانہ پروٹوکول تعاملات کے لیے آپریٹر ایڈریس ترتیب دینا ہیں. _**نوٹ**: ان ہدایات کے مقاصد کے لیے Remix کو معاہدہ کے تعامل کے لیے استعمال کیا جائے گا، لیکن بلا جھجھک اپنی پسند کا ٹول استعمال کریں ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), اور [MyCrypto](https://www.mycrypto.com/account) چند دوسرے معروف ٹولز ہیں)._

ایک بار جب ایک انڈیکسر نے پروٹوکول میں GRT کو سٹیک کر دیا ہے، تو [انڈیکسر اجزاء](/network/indexing#indexer-components) کو شروع کیا جا سکتا ہے اور نیٹ ورک کے ساتھ اپنے تعاملات شروع کر سکتے ہیں.

#### ٹوکنز منظور کریں

1. [Remix ایپ ](https://remix.ethereum.org/) کو ایک براؤزر میں کھولیں

2. `File Explorer` میں [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json) کے ساتھ **GraphToken.abi** کے نام سے ایک فائل بنائیں.

3. `GraphToken.abi` کو منتخب کرنے اور ایڈیٹر میں کھولنے کے ساتھ، Remix انٹرفیس میں Deploy اور `Run Transactions` سیکشن پر جائیں.

4. ماحول کے نیچے `Injected Web3` کو منتخب کریں اور `Account` کے نیچے اپنا انڈیکسر ایڈریس منتخب کریں.

5. گراف ٹوکن کے کنٹریکٹ ایڈریس کو سیٹ کریں - گراف ٹوکن کنٹریکٹ ایڈریس (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) کو `At Address` کے آگے چسپاں کریں اور لاگو کرنے کے لیے `At address` بٹن پر کلک کریں.

6. اسٹیکنگ کنٹریکٹ کو منظور کرنے کے لیے `approve(spender, amount)` فنکشن کو کال کریں. `spender` کو اسٹیکنگ کنٹریکٹ ایڈریس (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) اور `amount` کو داؤ پر لگانے والے ٹوکنز کے ساتھ (wei میں) بھریں.

#### سٹیک ٹوکنز

1. [Remix ایپ ](https://remix.ethereum.org/) کو ایک براؤزر میں کھولیں

2. `File Explorer` میں اسٹیکنگ ABI کے ساتھ **Staking.abi** کے نام سے ایک فائل بنائیں.

3. `Staking.abi` کو منتخب کرنے اور ایڈیٹر میں کھولنے کے ساتھ، Remix انٹرفیس میں `Deploy` اور `Run Transactions` سیکشن پر جائیں.

4. ماحول کے نیچے `Injected Web3` کو منتخب کریں اور `Account` کے نیچے اپنا انڈیکسر کے ایڈریس کو منتخب کریں.

5. اسٹیکنگ کنٹریکٹ ایڈریس سیٹ کریں - اسٹیکنگ کنٹریکٹ ایڈریس (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) کو `At Address` کے آگے چسپاں کریں اور لاگو کرنے کے لیے `At address` بٹن پر کلک کریں.

6. پروٹوکول میں GRT کو داؤ پر لگانے کے لیے `stake()` کو کال کریں.

7. (اختیاری) انڈیکسرز اپنے انڈیکسر انفراسٹرکچر کے لیے آپریٹر بننے کے لیے ایک اور ایڈریس کی منظوری دے سکتے ہیں تاکہ فنڈز کو کنٹرول کرنے والی کلیدوں کو ان سے الگ کر سکیں جو روزمرہ کے کاموں کو انجام دے رہے ہیں جیسے سب گراف کو مختص کرنا اور (ادائیگی) کیوریز پیش کرنا. آپریٹر کو سیٹ کرنے کے لیے آپریٹر ایڈریس کے ساتھ `setOperator()` کال کریں.

8. (اختیاری) انعامات کی تقسیم کو کنٹرول کرنے اور اسٹریٹجک طور پر ڈیلیگیٹرز کو راغب کرنے کے لیے انڈیکسرز اپنے indexingRewardCut (پارٹس فی ملین)، queryFeeCut (پارٹس فی ملین) اور cooldownBlocks (بلاکس کی تعداد) کو اپ ڈیٹ کرکے اپنے ڈیلیگیشن پیرامیٹرز کو اپ ڈیٹ کرسکتے ہیں. ایسا کرنے کے لیے `setDelegationParameters()` کو کال کریں۔ درج ذیل مثال queryFeeCut کو سیٹ کرتی ہے کہ کیوری کی چھوٹ کا 95% انڈیکسر کو اور 5% ڈیلیگیٹرز کو تقسیم کرے، IndexingRewardCut کو سیٹ کریں کہ 60% انڈیکسنگ ریوارڈز انڈیکسر کو اور 40% ڈیلیگیٹرز کو تقسیم کریں، اور `thecooldownBlocks` کا دورانیہ 500 بلاکس سیٹ کریں.

```
setDelegationParameters(950000, 600000, 500)
```

### ایک ایلوکیشن کا دورانیہ

ایک انڈیکسر کے ذریعہ بنائے جانے کے بعد ایک صحت مند ایلوکیشن چار مرحلوں سے گزرتا ہے.

- **Active** - ایک بار جب ایک ایلوکیشن on-chain بن جاتی ہے ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) تو اسے **active** سمجھا جاتا ہے. انڈیکسر کے اپنے اور​/یا ڈیلیگیٹ سٹیک کا ایک حصہ سب گراف کی تعیناتی کے لیے مختص کیا جاتا ہے، جو انہیں انڈیکسنگ انعامات کا دعوی کرنے اور اس سب گراف کی تعیناتی کے لیے کیوریز پیش کرنے کی اجازت دیتا ہے. انڈیکسر ایجنٹ انڈیکسر کے اصولوں کی بنیاد پر ایلوکیشن کا انتظام کرتا ہے.

- **Closed** - ایک انڈیکسر 1 ایپوک گزر جانے کے بعد ایلوکیشن کو بند کرنے کے لیے آزاد ہوتا ہے ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) یا ان کا انڈیکسر ایجنٹ **maxAllocationEpochs** (فی الحال 28 دن) کے بعد مختص کو خود بخود بند کر دے گا. جب کوئی ایلوکیشن انڈیکسنگ کے درست ثبوت (POI) کے ساتھ بند کر دیا جاتا ہے تو ان کے انڈیکسنگ کے انعامات انڈیکسر اور اس کے ڈیلیگیٹرز میں تقسیم کیے جاتے ہیں (مزید جاننے کے لیے نیچے "انعامات کیسے تقسیم کیے جاتے ہیں؟" دیکھیں).

انڈیکسرز کو تجویز کی جاتی ہے کہ وہ offchain مطابقت پذیری کی فعالیت کو استعمال کریں تاکہ on-chain ایلوکیشن سے پہلے سب گراف کی تعیناتیوں کو chainhead سے ہم آہنگ کیا جا سکے. یہ خصوصیت خاص طور پر ان سب گرافوں کے لیے مفید ہے جن کی مطابقت پذیری میں 28 ایپوک سے زیادہ وقت لگ سکتا ہے یا غیر یقینی طور پر ناکام ہونے کے کچھ امکانات ہوتے ہیں.
