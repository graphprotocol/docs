---
title: सर्वोत्तम पद्धतींची चौकशी करणे
---

आलेख ब्लॉकचेन वरून डेटा क्वेरी करण्यासाठी विकेंद्रित मार्ग प्रदान करतो.

ग्राफ नेटवर्कचा डेटा GraphQL API द्वारे उघड केला जातो, ज्यामुळे GraphQL भाषेसह डेटाची क्वेरी करणे सोपे होते.

हे पृष्‍ठ तुम्हाला GraphQL भाषेचे अत्यावश्यक नियम आणि GraphQL क्वेरी सर्वोत्तम पद्धतींबद्दल मार्गदर्शन करेल.

---

## GraphQL API क्वेरी करत आहे

### ग्राफक्यूएल क्वेरीचे शरीरशास्त्र

REST API च्या विपरीत, GraphQL API एका स्कीमावर तयार केले जाते जे कोणत्या क्वेरी पूर्ण केल्या जाऊ शकतात हे परिभाषित करते.

उदाहरणार्थ, `टोकन` क्वेरी वापरून टोकन मिळवण्यासाठीची क्वेरी खालीलप्रमाणे दिसेल:

```graphql
qक्वेरी GetToken($id: ID!) {
   टोकन (id: $id) {
     आयडी
     मालक
   }
} uery GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

जे खालील अंदाजे JSON प्रतिसाद देईल (_योग्य `$id` व्हेरिएबल व्हॅल्यू_ पास करताना):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQL क्वेरी GraphQL भाषा वापरतात, जी [विशिष्टता](https://spec.graphql.org/) वर परिभाषित केली जाते.

वरील `GetToken` क्वेरी अनेक भाषा भागांनी बनलेली आहे (खाली `[...]` प्लेसहोल्डरने बदलली आहे):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

सिंटॅक्टिक करा आणि करू नका याची यादी लांब असताना, ग्राफक्यूएल क्वेरी लिहिताना लक्षात ठेवण्याचे आवश्यक नियम येथे आहेत:

- प्रत्येक `queryName` प्रत्येक ऑपरेशनसाठी फक्त एकदाच वापरले जाणे आवश्यक आहे.
- प्रत्येक `फील्ड` निवडीमध्ये फक्त एकदाच वापरला जाणे आवश्यक आहे (आम्ही `टोकन` अंतर्गत दोनदा `आयडी` क्वेरी करू शकत नाही)
- काही `फील्ड` किंवा क्वेरी (जसे की `टोकन्स`) जटिल प्रकार देतात ज्यांना उप-फील्डची निवड आवश्यक असते. अपेक्षित असताना निवड प्रदान न केल्याने (किंवा अपेक्षित नसताना एक प्रदान करणे - उदाहरणार्थ, `id` वर) त्रुटी वाढवेल. फील्ड प्रकार जाणून घेण्यासाठी, कृपया [द ग्राफ एक्सप्लोरर](/network/explorer) पहा.
- आर्ग्युमेंटला नियुक्त केलेले कोणतेही व्हेरिएबल त्याच्या प्रकाराशी जुळले पाहिजे.
- व्हेरिएबल्सच्या दिलेल्या सूचीमध्ये, त्यापैकी प्रत्येक अद्वितीय असणे आवश्यक आहे.
- सर्व परिभाषित व्हेरिएबल्स वापरणे आवश्यक आहे.

वरील नियमांचे पालन करण्यात अयशस्वी झाल्यास ग्राफ API मधील त्रुटीसह समाप्त होईल.

कोड उदाहरणांसह नियमांच्या संपूर्ण सूचीसाठी, कृपया आमचे GraphQL प्रमाणीकरण मार्गदर्शक पहा.

<br />

### GraphQL API वर क्वेरी पाठवत आहे

GraphQL ही एक भाषा आणि परंपरांचा संच आहे जी HTTP वर वाहतूक करते.

याचा अर्थ असा की तुम्ही मानक `fetch` (मूळ किंवा `@whatwg-node/fetch` किंवा `isomorphic-fetch` द्वारे) वापरून GraphQL API साठी क्वेरी करू शकता.

तथापि, ["अ‍ॅप्लिकेशनमधून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये सांगितल्याप्रमाणे, आम्ही तुम्हाला आमचे `ग्राफ-क्लायंट` वापरण्याची शिफारस करतो जे अद्वितीय वैशिष्ट्यांना समर्थन देते जसे की:

- क्रॉस-चेक्रॉस-चेन सबग्राफ हँडलिंग: एकाच क्वेरीमध्ये एकाधिक सबग्राफमधून क्वेरी करणेन
- [स्वयंचलित ब्लॉक ट्रॅकिंग](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [स्वयंचलित पृष्ठांकन](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- पूर्ण टाईप केलेला निकाल

<br />

`ग्राफ-क्लायंट` सह आलेखाची क्वेरी कशी करायची ते येथे आहे:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

अधिक GraphQL क्लायंट पर्याय ["अ‍ॅप्लिकेशनमधून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये समाविष्ट आहेत.

<br />

आता आम्ही GraphQL क्वेरी सिंटॅक्सचे मूलभूत नियम समाविष्ट केले आहेत, आता GraphQL क्वेरी लेखनाच्या सर्वोत्तम पद्धती पाहू.

---

## ग्राफक्यूएल क्वेरी लिहित आहे

### नेहमी स्थिर प्रश्न लिहा

खालीलप्रमाणे क्वेरी स्ट्रिंग्स डायनॅमिकपणे तयार करणे ही एक सामान्य (वाईट) सराव आहे:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

वरील स्निपेट एक वैध GraphQL क्वेरी तयार करत असताना, **त्यात अनेक कमतरता आहेत**:

- त्यामुळे संपूर्ण क्वेरी **समजणे कठीण** होते
- विकसक **स्ट्रिंग इंटरपोलेशन सुरक्षितपणे निर्जंतुक करण्यासाठी जबाबदार आहेत**
- विनंती पॅरामीटर्सचा भाग म्हणून व्हेरिएबल्सची मूल्ये पाठवत नाही **सर्व्हर-साइडवर संभाव्य कॅशिंग प्रतिबंधित करा**
- ते **साधनांना क्वेरीचे स्थिर विश्लेषण करण्यापासून प्रतिबंधित करते** (उदा: लिंटर, किंवा जनरेशन टूल्स टाइप करा)

या कारणास्तव, नेहमी स्थिर स्ट्रिंग म्हणून क्वेरी लिहिण्याची शिफारस केली जाते:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

असे केल्याने **अनेक फायदे** मिळतात:

- **वाचणे आणि देखरेख करणे सोपे** क्वेरी
- GraphQL **सर्व्हर व्हेरिएबल्स सॅनिटायझेशन हाताळतो**
- <strong x-iसर्व्हर-स्तरावर **व्हेरिएबल्स कॅशे केले जाऊ शकतात**d="1">
- **प्रश्नांचे साधनांद्वारे स्थिर विश्लेषण केले जाऊ शकते** (याबद्दल पुढील विभागांमध्ये अधिक)

**टीप: स्थिर क्वेरीमध्ये फील्ड सशर्त कसे समाविष्ट करावे**

आम्ही केवळ एका विशिष्ट स्थितीवर `मालक` फील्ड समाविष्ट करू इच्छितो.

यासाठी, आम्ही खालीलप्रमाणे `@include(if:...)` निर्देशाचा फायदा घेऊ शकतो:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

टीप: उलट निर्देश `@skip(if: ...)` आहे.

<br />

### कामगिरी टिपा

**"तुला काय हवे ते मागा"**

GraphQL त्याच्या "तुम्हाला काय हवे आहे" या टॅगलाइनसाठी प्रसिद्ध झाले.

या कारणास्तव, ग्राफक्यूएलमध्ये, सर्व उपलब्ध फील्ड वैयक्तिकरित्या सूचीबद्ध केल्याशिवाय मिळवण्याचा कोणताही मार्ग नाही.

GraphQL API ची क्वेरी करताना, नेहमी फक्त प्रत्यक्षात वापरल्या जाणार्‍या फील्डची क्वेरी करण्याचा विचार करा.

ओव्हर-फेचिंगचे एक सामान्य कारण म्हणजे घटकांचे संकलन. डीफॉल्टनुसार, क्वेरी संग्रहामध्ये 100 संस्था आणतील, जे सहसा वापरकर्त्याला दाखवण्यासाठी वापरल्या जाणार्‍या प्रत्यक्षात वापरल्या जाणार्‍या पेक्षा जास्त असते. त्यामुळे क्वेरी जवळजवळ नेहमीच प्रथम स्पष्टपणे सेट केल्या पाहिजेत आणि ते फक्त त्यांना आवश्यक तेवढ्याच संस्था आणतात याची खात्री करा. हे केवळ एका क्वेरीमधील उच्च-स्तरीय संग्रहांना लागू होत नाही, तर त्याहूनही अधिक घटकांच्या नेस्टेड संग्रहांना लागू होते.

उदाहरणार्थ, खालील क्वेरीमध्ये:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

प्रतिसादामध्ये प्रत्येक 100 टोकनसाठी 100 व्यवहार असू शकतात.

ऍप्लिकेशनला फक्त 10 व्यवहारांची आवश्यकता असल्यास, क्वेरीने व्यवहार फील्डवर स्पष्टपणे `first: 10` सेट केले पाहिजे.

**एकाधिक क्वेरी एकत्र करणे**

तुमच्या ॲप्लिकेशनला खालीलप्रमाणे अनेक प्रकारच्या डेटाची चौकशी करण्याची आवश्यकता असू शकते:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

ही अंमलबजावणी पूर्णपणे वैध असली तरी, त्यासाठी GraphQL API सह दोन फेऱ्यांची आवश्यकता असेल.

सुदैवाने, खालीलप्रमाणे एकाच GraphQL विनंतीमध्ये एकाधिक क्वेरी पाठवणे देखील वैध आहे:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

हा दृष्टिकोन नेटवर्कवर घालवलेला वेळ कमी करून **एकूण कार्यप्रदर्शन सुधारेल** आणि एक **अधिक संक्षिप्त अंमलबजावणी**.

<br />

### GraphQL फ्रॅगमेंट्सचा फायदा घ्या

GraphQL क्वेरी लिहिण्यासाठी उपयुक्त वैशिष्ट्य म्हणजे GraphQL फ्रॅगमेंट.

खालील क्वेरी पाहिल्यावर, तुमच्या लक्षात येईल की काही फील्ड एकाधिक निवड-संचांमध्ये पुनरावृत्ती होत आहेत (`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

अशी पुनरावृत्ती फील्ड (`id`, `active`, `status`) अनेक समस्या आणतात:

- अधिक विस्तृत प्रश्नांसाठी वाचणे कठीण
- प्रश्नांवर आधारित TypeScript प्रकार व्युत्पन्न करणारी साधने वापरताना (_त्यावर शेवटच्या विभागात अधिक_), `newDelegate` आणि `oldDelegate` या दोन वेगळ्या इनलाइनचा परिणाम होईल इंटरफेस.

क्वेरीची रिफॅक्टर केलेली आवृत्ती खालीलप्रमाणे असेल:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

GraphQL `fragment` वापरल्याने वाचनीयता (विशेषत: स्केलवर) सुधारेल परंतु TypeScript प्रकारांची निर्मिती देखील चांगली होईल.

प्रकार जनरेशन टूल वापरताना, वरील क्वेरी योग्य `DelegateItemFragment` प्रकार व्युत्पन्न करेल (_शेवटचा "साधने" विभाग पहा_).

<br />

### GraphQL फ्रॅगमेंट काय करावे आणि करू नये

**फ्रॅगमेंट बेस एक प्रकार असणे आवश्यक आहे**

एक तुकडा गैर-लागू प्रकारावर आधारित असू शकत नाही, थोडक्यात, **फील्ड नसलेल्या प्रकारावर**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` हा एक **स्केलर** (नेटिव्ह "प्लेन" प्रकार) आहे जो तुकड्यांचा आधार म्हणून वापरला जाऊ शकत नाही.

**तुकडा कसा पसरवायचा**

तुकड्या विशिष्ट प्रकारांवर परिभाषित केल्या आहेत आणि त्यानुसार क्वेरींमध्ये वापरल्या पाहिजेत.

उदाहरण:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` आणि `oldDelegate` हे `Transcoder` प्रकारचे आहेत.

येथे `Vote` प्रकाराचा तुकडा पसरवणे शक्य नाही.

**डेटाचे अणु व्यवसाय एकक म्हणून फ्रॅगमेंट परिभाषित करा**

GraphQL फ्रॅगमेंट त्यांच्या वापराच्या आधारावर परिभाषित करणे आवश्यक आहे.

बर्‍याच वापर-केससाठी, प्रति प्रकार एक तुकडा परिभाषित करणे (पुन्हा फील्ड वापरण्याच्या किंवा प्रकार निर्मितीच्या बाबतीत) पुरेसे आहे.

फ्रॅगमेंट वापरण्यासाठी येथे एक नियम आहे:

- जेव्हा एकाच प्रकारची फील्ड क्वेरीमध्ये पुनरावृत्ती होते, तेव्हा त्यांना एका तुकड्यात गटबद्ध करा
- जेव्हा समान परंतु समान फील्डची पुनरावृत्ती होत नाही, तेव्हा अनेक तुकडे तयार करा, उदा:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## आवश्यक साधने

### ग्राफक्यूएल वेब-आधारित एक्सप्लोरर

तुमच्या ऍप्लिकेशनमध्ये क्वेरी चालवून त्यावर पुनरावृत्ती करणे त्रासदायक असू शकते. या कारणास्तव, तुमच्‍या अॅप्लिकेशनमध्‍ये जोडण्‍यापूर्वी तुमच्‍या क्‍वेरींची चाचणी करण्‍यासाठी [The Graph Explorer](https://thegraph.com/explorer) वापरण्‍यास अजिबात संकोच करू नका. तुमच्या प्रश्नांची चाचणी घेण्यासाठी ग्राफ एक्सप्लोरर तुम्हाला पूर्व-कॉन्फिगर केलेले GraphQL खेळाचे मैदान देईल.

तुम्‍ही तुमच्‍या क्‍वेरी डीबग/चाचणी करण्‍याचा अधिक लवचिक मार्ग शोधत असल्‍यास, इतर समान वेब-आधारित साधने उपलब्‍ध आहेत जसे की [Altair](https://altair.sirmuel.design/) आणि [GrafiQL](https://graphiql-online.com/graphiql).

<br />

### ग्राफक्यूएल लिंटिंग

वर नमूद केलेल्या सर्वोत्तम पद्धती आणि वाक्यरचना नियमांचे पालन करण्यासाठी, खालील वर्कफ्लो आणि IDE टूल्स वापरण्याची अत्यंत शिफारस केली जाते.

**ग्राफक्यूएल ईएसलिंट**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) तुम्हाला GraphQL सर्वोत्कृष्ट पद्धतींमध्ये शून्य प्रयत्नात राहण्यास मदत करेल.

["operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) कॉन्फिगरेशन सेटअप हे आवश्यक नियम लागू करेल जसे की:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: दिलेले व्हेरिएबल वापरलेले नसावे का?
- आणि अधिक!

हे तुम्हाला खेळाच्या मैदानावर किंवा उत्पादनात चालवताना **तपासणी क्वेरीशिवाय त्रुटी पकडण्याची** अनुमती देईल!

<br />

### IDE प्लगइन

**VSCode आणि GraphQL**

[GraphQL VSCode विस्तार](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) हे मिळवण्यासाठी तुमच्या विकास कार्यप्रवाहात एक उत्कृष्ट जोड आहे:

- वाक्यरचना हायलाइटिंग
- स्वयंपूर्ण सूचना
- स्कीमा विरुद्ध प्रमाणीकरण
- स्निपेट्स
- तुकड्या आणि इनपुट प्रकारांसाठी परिभाषा वर जा

जर तुम्ही `graphql-eslint` वापरत असाल, तर तुमच्या कोडमध्ये इनलाइन केलेल्या त्रुटी आणि चेतावणी योग्यरित्या व्हिज्युअलायझ करण्यासाठी [ESLint VSCode विस्तार](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) असणे आवश्यक आहे.

**वेबस्टॉर्म/इंटेलिज आणि ग्राफक्यूएल**

[JS GraphQL प्लगइन](https://plugins.jetbrains.com/plugin/8097-graphql/) प्रदान करून GraphQL सोबत काम करताना तुमच्या अनुभवामध्ये लक्षणीय सुधारणा करेल:

- वाक्यरचना हायलाइटिंग
- स्वयंपूर्ण सूचना
- स्कीमा विरुद्ध प्रमाणीकरण
- स्निपेट्स

या [वेबस्टॉर्म लेख](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) वर अधिक माहिती जी प्लगइनची सर्व मुख्य वैशिष्ट्ये दर्शवते.
