---
title: GraphQL API
---

हे मार्गदर्शक GraphQL क्वेरी API चे स्पष्टीकरण देते जे आलेख प्रोटोकॉलसाठी वापरले जाते.

## प्रश्न

तुमच्या सबग्राफ स्कीमामध्ये तुम्ही `एंटिटीज` नावाचे प्रकार परिभाषित करता. प्रत्येक `संस्था` प्रकारासाठी, उच्च-स्तरीय `क्वेरी` प्रकारावर एक `संस्था` आणि `संस्था` फील्ड व्युत्पन्न केले जाईल. लक्षात ठेवा की ग्राफ वापरताना `क्वेरी` `graphql` क्वेरीच्या शीर्षस्थानी समाविष्ट करणे आवश्यक नाही.

### उदाहरणे

तुमच्या स्कीमामध्ये परिभाषित केलेल्या एका `टोकन` घटकासाठी क्वेरी:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> **टीप:** एका घटकासाठी क्वेरी करताना, `id` फील्ड आवश्यक आहे आणि ती एक स्ट्रिंग असणे आवश्यक आहे.

सर्व `टोकन` घटकांची चौकशी करा:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### वर्गीकरण

संग्रहाची क्वेरी करताना, विशिष्ट गुणधर्मानुसार क्रमवारी लावण्यासाठी `orderBy` पॅरामीटर वापरला जाऊ शकतो. याव्यतिरिक्त, `ऑर्डर डायरेक्शन` चा वापर क्रमवारीची दिशा, चढत्यासाठी `asc` किंवा उतरत्यासाठी `desc` निर्दिष्ट करण्यासाठी केला जाऊ शकतो.

#### उदाहरण

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### नेस्टेड एंटिटी सॉर्टिंगचे उदाहरण

ग्राफ नोड [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) नुसार नेस्टेड घटकांच्या आधारावर घटकांची क्रमवारी लावली जाऊ शकते.

खालील उदाहरणामध्ये, आम्ही टोकन त्यांच्या मालकाच्या नावानुसार क्रमवारी लावतो:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> सध्या, तुम्ही `@entity` आणि `@derivedFrom` फील्डवर एक-स्तरीय खोल `स्ट्रिंग` किंवा `आयडी` प्रकारांनुसार क्रमवारी लावू शकता. दुर्दैवाने, [एका स्तर-खोल घटकांवरील इंटरफेसनुसार क्रमवारी लावणे](https://github.com/graphprotocol/graph-node/pull/4058), अॅरे आणि नेस्टेड घटक असलेल्या फील्डनुसार क्रमवारी लावणे अद्याप समर्थित नाही.

### पृष्ठांकन

संग्रहाची क्वेरी करताना, संग्रहाच्या सुरुवातीपासून पृष्ठांकन करण्यासाठी `प्रथम` पॅरामीटर वापरला जाऊ शकतो. हे लक्षात घेण्यासारखे आहे की डीफॉल्ट क्रमवारी आयडी नुसार चढत्या अल्फान्यूमेरिक क्रमाने आहे, निर्मिती वेळेनुसार नाही.

पुढे, `वगळा` पॅरामीटर घटक वगळण्यासाठी आणि पृष्ठांकन करण्यासाठी वापरले जाऊ शकते. उदा. `first:100` पहिल्या 100 संस्था दाखवते आणि `first:100, skip:100` पुढील 100 संस्था दाखवते.

क्वेरींनी खूप मोठी `वगळा` मूल्ये वापरणे टाळले पाहिजे कारण ते सामान्यतः खराब कार्य करतात. मोठ्या संख्येने आयटम पुनर्प्राप्त करण्यासाठी, शेवटच्या उदाहरणात दर्शविल्याप्रमाणे एखाद्या विशेषतावर आधारित घटकांद्वारे पृष्ठ करणे अधिक चांगले आहे.

#### `प्रथम` वापरून उदाहरण

पहिल्या 10 टोकनसाठी क्वेरी करा:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

संकलनाच्या मध्यभागी असलेल्या घटकांच्या गटांसाठी क्वेरी करण्यासाठी, सुरुवातीपासून सुरू होणारी विशिष्ट संख्या वगळण्यासाठी `वगळा` पॅरामीटरचा वापर `प्रथम` पॅरामीटरसह केला जाऊ शकतो. संग्रहाचे.

#### `प्रथम` आणि `वगळा` वापरण्याचे उदाहरण

क्वेरी 10 `टोकन` संस्था, संकलनाच्या सुरुवातीपासून 10 ठिकाणांद्वारे ऑफसेट:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### `first` आणि `id_ge` वापरण्याचे उदाहरण

जर एखाद्या क्लायंटला मोठ्या संख्येने संस्था पुनर्प्राप्त करण्याची आवश्यकता असेल, तर विशेषतावर आधारित क्वेरी करणे आणि त्या गुणधर्माद्वारे फिल्टर करणे अधिक कार्यक्षम आहे. उदाहरणार्थ, क्लायंट ही क्वेरी वापरून मोठ्या संख्येने टोकन पुनर्प्राप्त करेल:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

प्रथमच, ते `lastID = ""` सह क्वेरी पाठवेल आणि त्यानंतरच्या विनंत्यांसाठी शेवटच्या `id` विशेषतावर `lastID` सेट करेल मागील विनंतीमध्ये अस्तित्व. वाढत्या `वगळा` मूल्यांचा वापर करण्यापेक्षा हा दृष्टीकोन लक्षणीयरीत्या चांगली कामगिरी करेल.

### फिल्टरिंग

वेगवेगळ्या गुणधर्मांसाठी फिल्टर करण्यासाठी तुम्ही तुमच्या क्वेरींमध्ये `where` पॅरामीटर वापरू शकता. तुम्ही `कुठे` पॅरामीटरमध्ये बहुविध मूल्यांवर फिल्टर करू शकता.

#### `कुठे` वापरण्याचे उदाहरण

`अयशस्वी` परिणामासह क्वेरी आव्हाने:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

मूल्याच्या तुलनेसाठी तुम्ही `_gt`, `_lte` सारखे प्रत्यय वापरू शकता:

#### श्रेणी फिल्टरिंगचे उदाहरण

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### ब्लॉक फिल्टरिंगचे उदाहरण

तुम्ही `_change_block(number_gte: Int)` द्वारे देखील घटक फिल्टर करू शकता - हे निर्दिष्ट ब्लॉकमध्ये किंवा नंतर अपडेट केलेल्या घटकांना फिल्टर करते.

तुम्ही फक्त बदललेल्या घटकांना आणण्याचा विचार करत असाल तर हे उपयुक्त ठरू शकते, उदाहरणार्थ तुम्ही शेवटच्या वेळी मतदान केले तेव्हापासून. किंवा वैकल्पिकरित्या तुमच्या सबग्राफमध्ये संस्था कशा बदलत आहेत याची तपासणी करणे किंवा डीबग करणे उपयुक्त ठरू शकते (ब्लॉक फिल्टरसह एकत्रित केल्यास, तुम्ही विशिष्ट ब्लॉकमध्ये बदललेल्या घटकांना वेगळे करू शकता).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### नेस्टेड एंटिटी फिल्टरिंगचे उदाहरण

नेस्टेड घटकांच्या आधारे फिल्टरिंग `_` प्रत्यय असलेल्या फील्डमध्ये शक्य आहे.

तुम्ही फक्त अशाच संस्था आणण्याचा विचार करत असाल ज्यांच्या बाल-स्तरीय संस्था प्रदान केलेल्या अटी पूर्ण करतात.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### तार्किक ऑपरेटर

ग्राफ नोड नुसार [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) तुम्ही एकाधिक गटबद्ध करू शकता एकापेक्षा जास्त निकषांवर आधारित परिणाम फिल्टर करण्यासाठी `आणि` किंवा `किंवा` ऑपरेटर वापरून समान `जिथे` युक्तिवादात पॅरामीटर्स.

##### `आणि` ऑपरेटर

खालील उदाहरणामध्ये, आम्ही `परिणाम` `यशस्वी` आणि `संख्या` `100` पेक्षा जास्त किंवा त्यापेक्षा जास्त असलेल्या आव्हानांसाठी फिल्टर करत आहोत.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **सिंटॅक्टिक शुगर:** तुम्ही स्वल्पविरामाने विभक्त केलेला उप-अभिव्यक्ती पास करून `आणि` ऑपरेटर काढून वरील क्वेरी सोपी करू शकता.
>
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### `OR` Operator

खालील उदाहरणामध्ये, आम्ही `परिणाम` `यशस्वी` किंवा `संख्या` `100` पेक्षा जास्त किंवा त्यापेक्षा जास्त असलेल्या आव्हानांसाठी फिल्टर करत आहोत.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **टीप**: क्वेरी तयार करताना, `किंवा` ऑपरेटर वापरण्याच्या कार्यप्रदर्शन प्रभावाचा विचार करणे महत्त्वाचे आहे. शोध परिणामांचा विस्तार करण्यासाठी `किंवा` हे एक उपयुक्त साधन असू शकते, परंतु त्याची महत्त्वपूर्ण किंमत देखील असू शकते. `किंवा` सह मुख्य समस्यांपैकी एक ही आहे की यामुळे क्वेरी मंद होऊ शकतात. याचे कारण असे की `किंवा` ला एकाधिक अनुक्रमणिकांद्वारे डेटाबेस स्कॅन करणे आवश्यक आहे, ही एक वेळ घेणारी प्रक्रिया असू शकते. या समस्या टाळण्यासाठी, विकासक वापरण्याची शिफारस केली जाते आणि त्याऐवजी किंवा जेव्हा शक्य असेल तेव्हा ऑपरेटर वापरतात. हे अधिक अचूक फिल्टरिंगसाठी अनुमती देते आणि जलद, अधिक अचूक क्वेरीस नेऊ शकते.

#### सर्व फिल्टर

पॅरामीटर प्रत्ययांची संपूर्ण यादी:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> कृपया लक्षात घ्या की काही प्रत्यय केवळ विशिष्ट प्रकारांसाठी समर्थित आहेत. उदाहरणार्थ, `बूलियन` फक्त `_not`, `_in` आणि `_not_in` चे समर्थन करते, परंतु `_` केवळ ऑब्जेक्ट आणि इंटरफेस प्रकारांसाठी उपलब्ध आहे.

याव्यतिरिक्त, खालील जागतिक फिल्टर `कुठे` युक्तिवादाचा भाग म्हणून उपलब्ध आहेत:

```gr
_change_block(number_gte: Int)
```

### वेळ-प्रवास प्रश्न

तुम्‍ही तुमच्‍या एंटिटीच्‍या स्‍थितीबद्दल क्‍वेरी करू शकता, जे डीफॉल्‍ट असलेल्‍या नवीनतम ब्लॉकसाठीच नाही, तर भूतकाळातील एका अनियंत्रित ब्लॉकसाठी देखील आहे. क्वेरी ज्या ब्लॉकवर व्हायला हवी तो ब्लॉक नंबर किंवा त्याच्या ब्लॉक हॅशद्वारे क्वेरीच्या टॉप लेव्हल फील्डमध्ये `ब्लॉक` युक्तिवाद समाविष्ट करून निर्दिष्ट केला जाऊ शकतो.

अशा क्वेरीचा परिणाम कालांतराने बदलणार नाही, म्हणजे, एखाद्या विशिष्ट भूतकाळातील ब्लॉकवर क्वेरी केल्याने तोच परिणाम मिळेल, जेव्हा तो कार्यान्वित केला जातो तेव्हा अपवाद वगळता, जर तुम्ही साखळीच्या अगदी जवळ असलेल्या ब्लॉकवर क्वेरी केली तर, जर तो ब्लॉक मुख्य साखळीवर नसला आणि साखळीची पुनर्रचना झाली तर परिणाम बदलू शकतो. एकदा ब्लॉकला अंतिम मानले जाऊ शकते, क्वेरीचा निकाल बदलणार नाही.

लक्षात ठेवा की सध्याची अंमलबजावणी अजूनही काही मर्यादांच्या अधीन आहे ज्यामुळे या हमींचे उल्लंघन होऊ शकते. अंमलबजावणी नेहमी सांगू शकत नाही की दिलेला ब्लॉक हॅश मुख्य शृंखलावर अजिबात नाही, किंवा ब्लॉकसाठी ब्लॉक हॅशद्वारे केलेल्या क्वेरीचा परिणाम ज्याला अंतिम मानले जाऊ शकत नाही अशा ब्लॉकच्या पुनर्रचनावर परिणाम होऊ शकतो. प्रश्न जेव्हा ब्लॉक अंतिम असतो आणि मुख्य शृंखलावर असल्याचे ओळखले जाते तेव्हा ते ब्लॉक हॅशद्वारे क्वेरीच्या परिणामांवर परिणाम करत नाहीत. [हा मुद्दा](https://github.com/graphprotocol/graph-node/issues/1405) या मर्यादा काय आहेत हे तपशीलवार स्पष्ट करते.

#### उदाहरण

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

ही क्वेरी `चॅलेंज` संस्था आणि त्यांच्याशी संबंधित `अॅप्लिकेशन` संस्था परत करेल, कारण ते ब्लॉक क्रमांक 8,000,000 वर प्रक्रिया केल्यानंतर थेट अस्तित्वात होते.

#### उदाहरण

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

ही क्वेरी `चॅलेंज` संस्था आणि त्यांच्याशी संबंधित `Application` घटक परत करेल, कारण ते दिलेल्या हॅशसह ब्लॉकवर प्रक्रिया केल्यानंतर थेट अस्तित्वात होते.

### पूर्ण मजकूर शोध क्वेरी

फुलटेक्स्ट शोध क्वेरी फील्ड एक अभिव्यक्त मजकूर शोध API प्रदान करतात जे सबग्राफ स्कीमामध्ये जोडले जाऊ शकतात आणि सानुकूलित केले जाऊ शकतात. तुमच्या सबग्राफमध्ये पूर्ण मजकूर शोध जोडण्यासाठी [पूर्ण मजकूर शोध फील्ड परिभाषित करणे](/developing/creating-a-subgraph#defining-fulltext-search-fields) पहा.

पूर्ण मजकूर शोध क्वेरींमध्ये शोध संज्ञा पुरवण्यासाठी एक आवश्यक फील्ड आहे, `text`. या `text` शोध क्षेत्रात वापरण्यासाठी अनेक विशेष फुलटेक्स्ट ऑपरेटर उपलब्ध आहेत.

पूर्ण मजकूर शोध ऑपरेटर:

| चिन्ह | ऑपरेटर्स | वर्णन |
| --- | --- | --- |
| `&` | `आणि` | प्रदान केलेल्या सर्व संज्ञांचा समावेश असलेल्या घटकांसाठी फिल्टरमध्ये एकाधिक शोध संज्ञा एकत्र करण्यासाठी |
| &#x7c; | `किंवा` | किंवा ऑपरेटरने विभक्त केलेल्या एकाधिक शोध संज्ञांसह क्वेरी प्रदान केलेल्या कोणत्याही अटींशी जुळणारे सर्व घटक परत करतील |
| `<->` | `द्वारे अनुसरण करा` | दोन शब्दांमधील अंतर निर्दिष्ट करा. |
| `:*` | `Prefix` | उपसर्ग जुळणारे शब्द शोधण्यासाठी उपसर्ग शोध संज्ञा वापरा (2 वर्ण आवश्यक.) |

#### उदाहरणे

`किंवा` ऑपरेटर वापरून, ही क्वेरी त्यांच्या फुलटेक्स्ट फील्डमध्ये "अराजकता" किंवा "क्रम्पेट" च्या भिन्नतेसह ब्लॉग घटकांना फिल्टर करेल.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

`फॉलो बाय` ऑपरेटर पूर्ण मजकूर दस्तऐवजांमध्ये विशिष्ट अंतराशिवाय शब्द निर्दिष्ट करतो. खालील क्वेरी "विकेंद्रित" आणि त्यानंतर "तत्वज्ञान" च्या भिन्नतेसह सर्व ब्लॉग परत करेल

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

अधिक जटिल फिल्टर बनवण्यासाठी फुलटेक्स्ट ऑपरेटर एकत्र करा. सबब शोध ऑपरेटरसह, या उदाहरण क्वेरीच्या फॉलोसह एकत्रितपणे "lou" आणि त्यानंतर "music" ने सुरू होणार्‍या शब्दांसह सर्व ब्लॉग घटकांशी जुळेल.

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### प्रमाणीकरण

ग्राफ नोड [स्पेसिफिकेशन-आधारित](https://spec.graphql.org/October2021/#sec-Validation) [graphql-tools-rs](https:// वापरून प्राप्त केलेल्या GraphQL क्वेरीचे प्रमाणीकरण लागू करते github.com/dotansimha/graphql-tools-rs#validation-rules), जे [graphql-js संदर्भ अंमलबजावणी](https://github.com/graphql/graphql-js वर आधारित आहे /tree/main/src/validation). प्रमाणीकरण नियमात अयशस्वी होणाऱ्या क्वेरी प्रमाणित त्रुटीसह करतात - अधिक जाणून घेण्यासाठी [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) ला भेट द्या.

## स्कीमा

तुमच्या डेटा स्रोताचा स्कीमा--म्हणजेच, क्वेरीसाठी उपलब्ध असलेले अस्तित्व प्रकार, मूल्ये आणि संबंध--[GraphQL इंटरफेस व्याख्या भाषा (IDL)](https://facebook.github.io/graphql/draft/# द्वारे परिभाषित केले जातात. sec-Type-System).

GraphQL स्कीमा सामान्यतः `क्वेरी`, `सदस्यता` आणि `उत्परिवर्तन` साठी रूट प्रकार परिभाषित करतात. आलेख फक्त `क्वेरी` ला सपोर्ट करतो. तुमच्या सबग्राफसाठी मूळ `क्वेरी` प्रकार तुमच्या सबग्राफ मॅनिफेस्टमध्ये समाविष्ट असलेल्या GraphQL स्कीमामधून आपोआप व्युत्पन्न केला जातो.

> **टीप:** आमचे API उत्परिवर्तन उघड करत नाही कारण विकासकांनी त्यांच्या अनुप्रयोगांमधून अंतर्निहित ब्लॉकचेनवर थेट व्यवहार करणे अपेक्षित आहे.

### संस्था

तुमच्या स्कीमामधील `@entity` निर्देशांसह सर्व GraphQL प्रकारांना संस्था म्हणून मानले जाईल आणि त्यांच्याकडे `ID` फील्ड असणे आवश्यक आहे.

> **टीप:** सध्या, तुमच्या स्कीमामधील सर्व प्रकारांमध्ये `@entity` निर्देश असणे आवश्यक आहे. भविष्यात, आम्ही `@entity` निर्देशांशिवाय प्रकारांना व्हॅल्यू ऑब्जेक्ट्स म्हणून हाताळू, परंतु हे अद्याप समर्थित नाही.

### सबग्राफ मेटाडेटा

सर्व सबग्राफमध्ये स्वयं-व्युत्पन्न `_Meta__` ऑब्जेक्ट असतो, जो सबग्राफ मेटाडेटामध्ये प्रवेश प्रदान करतो. हे खालीलप्रमाणे विचारले जाऊ शकते:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

जर ब्लॉक प्रदान केला असेल तर, मेटाडेटा त्या ब्लॉकचा असेल, जर नवीनतम अनुक्रमित ब्लॉक वापरला नसेल. प्रदान केल्यास, ब्लॉक सबग्राफच्या स्टार्ट ब्लॉक नंतर असणे आवश्यक आहे आणि सर्वात अलीकडील अनुक्रमित ब्लॉकपेक्षा कमी किंवा समान असणे आवश्यक आहे.

`डिप्लॉयमेंट` हा एक अद्वितीय आयडी आहे, जो `subgraph.yaml` फाइलच्या IPFS CID शी संबंधित आहे.

`block` नवीनतम ब्लॉकबद्दल माहिती प्रदान करते (`_meta` ला पास केलेल्या कोणत्याही ब्लॉक मर्यादा लक्षात घेऊन):

- हॅश: ब्लॉकचा हॅश
- क्रमांक: ब्लॉक क्रमांक
- टाइमस्टॅम्प: ब्लॉकचा टाइमस्टॅम्प, उपलब्ध असल्यास (हे सध्या फक्त ईव्हीएम नेटवर्क्सच्या अनुक्रमणिकेच्या सबग्राफसाठी उपलब्ध आहे)

`hasIndexingErrors` हे बुलियन आहे जे काही मागील ब्लॉकमध्ये सबग्राफमध्ये अनुक्रमणिक त्रुटी आढळल्या आहेत की नाही हे ओळखण्यासाठी
