---
title: सबग्राफ तयार करणे
---

सबग्राफ ब्लॉकचेनमधून डेटा काढतो, त्यावर प्रक्रिया करतो आणि तो संग्रहित करतो जेणेकरून GraphQL द्वारे सहजपणे क्वेरी करता येईल.

![सबग्राफ परिभाषित करणे](/img/defining-a-subgraph.png)

सबग्राफ व्याख्येमध्ये काही फाइल्स असतात:

- `subgraph.yaml`: सबग्राफ मॅनिफेस्ट असलेली YAML फाइल

- `schema.graphql`: एक GraphQL स्कीमा जो तुमच्या सबग्राफसाठी कोणता डेटा संग्रहित केला जातो आणि GraphQL द्वारे त्याची क्वेरी कशी करावी हे परिभाषित करते

- `AssemblyScript मॅपिंग`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) कोड जो इव्हेंट डेटामधून तुमच्या स्कीमामध्ये परिभाषित केलेल्या घटकांमध्ये अनुवादित करतो (उदा. `mapping.ts` या ट्युटोरियलमध्ये)

> ग्राफच्या विकेंद्रीकृत नेटवर्कवर तुमचा सबग्राफ वापरण्यासाठी, तुम्हाला [एपीआय की तयार करणे](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key) आवश्यक असेल. तुम्ही तुमच्या सबग्राफमध्ये किमान [10,000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network) सह [सिग्नल जोडावे](/network/curating/#how-to-signal) अशी शिफारस केली जाते.

तुम्ही मॅनिफेस्ट फाइलच्या सामग्रीबद्दल तपशीलात जाण्यापूर्वी, तुम्हाला [ग्राफ CLI](https://github.com/graphprotocol/graph-cli) स्थापित करणे आवश्यक आहे जे तुम्हाला तयार करण्यासाठी आवश्यक असेल. आणि सबग्राफ तैनात करा.

## ग्राफ CLI स्थापित करा

आलेख CLI JavaScript मध्ये लिहिलेले आहे, आणि ते वापरण्यासाठी तुम्हाला `यार्न` किंवा `npm` स्थापित करावे लागेल; असे गृहीत धरले जाते की तुमच्याकडे पुढील गोष्टींमध्ये सूत आहे.

तुमच्याकडे `यार्न` आल्यावर, चालवून आलेख CLI स्थापित करा

**यार्नसह स्थापित करा:**

```bash
yarn global add @graphprotocol/graph-cli
```

**सह स्थापित करा npm:**

```bash
npm install -g @graphprotocol/graph-cli
```

एकदा स्थापित केल्यानंतर, `graph init` कमांडचा वापर नवीन सबग्राफ प्रोजेक्ट सेट करण्यासाठी केला जाऊ शकतो, एकतर विद्यमान करारातून किंवा उदाहरण सबग्राफमधून. ही कमांड `graph init --product subgraph-studio` मध्ये पास करून सबग्राफ स्टुडिओवर सबग्राफ तयार करण्यासाठी वापरली जाऊ शकते. जर तुमच्याकडे आधीपासून तुमच्या पसंतीच्या नेटवर्कवर स्मार्ट कॉन्ट्रॅक्ट तैनात केले असेल, तर त्या कॉन्ट्रॅक्टमधून नवीन सबग्राफ बूटस्ट्रॅप करणे हा सुरू करण्याचा एक चांगला मार्ग असू शकतो.

## विद्यमान करारातून

खालील कमांड एक सबग्राफ तयार करते जे विद्यमान कराराच्या सर्व घटनांना अनुक्रमित करते. ते इथरस्कॅन वरून ABI करार मिळवण्याचा प्रयत्न करते आणि स्थानिक फाइल मार्गाची विनंती करण्यासाठी परत येते. पर्यायी युक्तिवादांपैकी कोणतेही गहाळ असल्यास, ते तुम्हाला परस्परसंवादी फॉर्ममधून घेऊन जाते.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

सबग्राफ स्टुडिओमध्ये `<SUBGRAPH_SLUG>` हा तुमच्या सबग्राफचा आयडी आहे, तो तुमच्या सबग्राफ तपशील पेजवर आढळू शकतो.

## उदाहरणाच्या सबग्राफमधून

दुसरा मोड `graph init` सपोर्ट करतो तो उदाहरण सबग्राफमधून नवीन प्रोजेक्ट तयार करतो. खालील कमांड हे करते:

```sh
आलेख init --studio <SUBGRAPH_SLUG>
```

उदाहरण सबग्राफ हे Dani Grant च्या ग्रॅव्हिटी कॉन्ट्रॅक्टवर आधारित आहे जे वापरकर्ता अवतार व्यवस्थापित करते आणि `NewGravatar` किंवा `UpdateGravatar` इव्हेंट जेव्हाही अवतार तयार किंवा अपडेट केले जातात. सबग्राफ ग्राफ नोड स्टोअरमध्ये `Gravatar` संस्था लिहून आणि हे इव्हेंटनुसार अपडेट केले जातील याची खात्री करून हे इव्हेंट हाताळते. या उदाहरणासाठी सबग्राफ मॅनिफेस्ट बनवणार्‍या फाइल्सवर पुढील विभाग जातील.

## विद्यमान सबग्राफमध्ये नवीन डेटास्रोत जोडा

`v0.31.0` पासून `graph-cli` `graph add` आदेशाद्वारे विद्यमान सबग्राफमध्ये नवीन डेटास्रोत जोडण्यास समर्थन देते.

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Options:

      --abi <path>              Path to the contract ABI (default: download from Etherscan)
      --contract-name           Name of the contract (default: Contract)
      --merge-entities          Whether to merge entities with the same name (default: false)
      --network-file <path>     Networks config file path (default: "./networks.json")
```

`add` कमांड इथरस्कॅनमधून ABI आणेल (जोपर्यंत ABI पथ `--abi` पर्यायाने निर्दिष्ट केला जात नाही), आणि नवीन `डेटास्रोत` तयार करेल. > त्याच प्रकारे `graph init` कमांड `डेटास्रोत` `---करारातून` तयार करते, त्यानुसार स्कीमा आणि मॅपिंग अद्यतनित करते.

`--merge-entities` पर्याय विकसकाला `संस्था` आणि `इव्हेंट` नावातील विरोधाभास कसे हाताळायचे आहेत हे ओळखतो:

- `सत्य` असल्यास: नवीन `डेटास्रोत` ने विद्यमान `इव्हेंटहँडलर्स` वापरावे & `संस्था`.
- जर `असत्य`: एक नवीन अस्तित्व & इव्हेंट हँडलर `${dataSourceName}{EventName}` सह तयार केला पाहिजे.

कराराचा `पत्ता` संबंधित नेटवर्कसाठी `networks.json` वर लिहिला जाईल.

> **टीप:** परस्परसंवादी क्ली वापरताना, यशस्वीरित्या `ग्राफ इनिट` चालवल्यानंतर, तुम्हाला एक नवीन `डेटास्रोत` जोडण्यासाठी सूचित केले जाईल.

## सबग्राफ मॅनिफेस्ट

सबग्राफ मॅनिफेस्ट `subgraph.yaml` स्मार्ट कॉन्ट्रॅक्ट्स तुमच्या सबग्राफ इंडेक्सेस परिभाषित करतो, या कॉन्ट्रॅक्टमधील कोणत्या इव्हेंट्सकडे लक्ष द्यायचे आणि ग्राफ नोड स्टोअर करत असलेल्या आणि क्वेरी करण्याची परवानगी देणार्‍या घटकांसाठी इव्हेंट डेटा कसा मॅप करायचा. सबग्राफ मॅनिफेस्टसाठी संपूर्ण तपशील [येथे](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md) आढळू शकतात.

सबग्राफच्या उदाहरणासाठी, `subgraph.yaml` आहे:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

मॅनिफेस्टसाठी अद्यतनित करण्याच्या महत्त्वाच्या नोंदी आहेत:

- `वर्णन`: सबग्राफ काय आहे याचे मानवी वाचनीय वर्णन. जेव्हा सबग्राफ होस्ट केलेल्या सेवेवर तैनात केला जातो तेव्हा हे वर्णन ग्राफ एक्सप्लोररद्वारे प्रदर्शित केले जाते.

- `रेपॉजिटरी`: रिपॉझिटरीची URL जिथे सबग्राफ मॅनिफेस्ट आढळू शकते. हे ग्राफ एक्सप्लोररद्वारे देखील प्रदर्शित केले जाते.

- `वैशिष्ट्ये`: सर्व वापरलेल्या [वैशिष्ट्य](#experimental-features) नावांची सूची.

- `dataSources.source`: स्मार्ट कॉन्ट्रॅक्टचा पत्ता सबग्राफ स्त्रोत आणि वापरण्यासाठी स्मार्ट कॉन्ट्रॅक्टचा ABI. पत्ता ऐच्छिक आहे; ते वगळणे सर्व करारांमधून जुळणारे इव्हेंट अनुक्रमित करण्यास अनुमती देते.

- `dataSources.source.startBlock`: ब्लॉकची पर्यायी संख्या ज्यावरून डेटा स्रोत अनुक्रमणिका सुरू करतो. बहुतेक प्रकरणांमध्ये, आम्ही ज्या ब्लॉकमध्ये करार तयार केला होता तो वापरण्याचा सल्ला देतो.

- `dataSources.mapping.entities`: डेटा स्रोत स्टोअरमध्ये लिहित असलेल्या संस्था. प्रत्येक घटकासाठी स्कीमा schema.graphql फाइलमध्ये परिभाषित केले आहे.

- `dataSources.mapping.abis`: स्त्रोत करारासाठी एक किंवा अधिक नावाच्या ABI फाइल्स तसेच तुम्ही मॅपिंगमधून परस्परसंवाद करता अशा इतर स्मार्ट करारांसाठी.

- `dataSources.mapping.eventHandlers`: या सबग्राफवर प्रतिक्रिया देणारे स्मार्ट कॉन्ट्रॅक्ट इव्हेंट आणि मॅपिंगमधील हँडलर्सची यादी करते—./src/mapping.ts उदाहरणामध्ये—जे या इव्हेंटचे स्टोअरमधील घटकांमध्ये रूपांतर करतात.

- `dataSources.mapping.callHandlers`: या सबग्राफवर प्रतिक्रिया देणारे स्मार्ट कॉन्ट्रॅक्ट फंक्शन्स सूचीबद्ध करते आणि मॅपिंगमधील हँडलर्स जे इनपुट आणि आउटपुटला स्टोअरमधील संस्थांमध्ये फंक्शन कॉलमध्ये रूपांतरित करतात.

- `dataSources.mapping.blockHandlers`: हा सबग्राफ ज्या ब्लॉक्सवर प्रतिक्रिया देतो आणि मॅपिंगमधील हँडलर चेनमध्ये ब्लॉक जोडला जातो तेव्हा रन करण्यासाठी सूचीबद्ध करतो. फिल्टरशिवाय, ब्लॉक हँडलर प्रत्येक ब्लॉकला चालवला जाईल. हँडलरला `kind: call` सह `filter` फील्ड जोडून पर्यायी कॉल-फिल्टर प्रदान केले जाऊ शकते. ब्लॉकमध्ये डेटा स्रोत करारासाठी किमान एक कॉल असेल तरच हे हँडलर चालवेल.

एकच सबग्राफ एकाधिक स्मार्ट कॉन्ट्रॅक्ट्समधील डेटा अनुक्रमित करू शकतो. प्रत्येक करारासाठी एक एंट्री जोडा ज्यामधून डेटा `डेटास्रोत` अॅरेमध्ये अनुक्रमित करणे आवश्यक आहे.

ब्लॉकमधील डेटा स्रोतासाठी ट्रिगर खालील प्रक्रिया वापरून क्रमबद्ध केले जातात:

1. इव्हेंट आणि कॉल ट्रिगर प्रथम ब्लॉकमधील व्यवहार निर्देशांकानुसार ऑर्डर केले जातात.
2. समान व्यवहारामधील इव्हेंट आणि कॉल ट्रिगर्स एक नियम वापरून ऑर्डर केले जातात: प्रथम इव्हेंट ट्रिगर नंतर कॉल ट्रिगर, प्रत्येक प्रकार मॅनिफेस्टमध्ये परिभाषित केलेल्या क्रमाचा आदर करतो.
3. ब्लॉक ट्रिगर इव्हेंट आणि कॉल ट्रिगर्सनंतर चालवले जातात, ते मॅनिफेस्टमध्ये परिभाषित केलेल्या क्रमाने.

हे ऑर्डरिंग नियम बदलू शकतात.

### ABIs मिळवणे

ABI फाइल(ल्या) तुमच्या कराराशी जुळल्या पाहिजेत. ABI फाइल्स मिळविण्याचे काही मार्ग आहेत:

- तुम्ही तुमचा स्वतःचा प्रकल्प तयार करत असल्यास, तुम्हाला तुमच्या सर्वात वर्तमान ABI मध्ये प्रवेश मिळण्याची शक्यता आहे.
- तुम्ही सार्वजनिक प्रकल्पासाठी सबग्राफ तयार करत असल्यास, तुम्ही तो प्रकल्प तुमच्या संगणकावर डाउनलोड करू शकता आणि [`ट्रफल कंपाइल`](https://truffleframework.com/docs/truffle/overview) वापरून किंवा कंपाइल करण्यासाठी सोल्क वापरून ABI मिळवू शकता.
- तुम्ही [Etherscan](https://etherscan.io/) वर ABI देखील शोधू शकता, परंतु हे नेहमीच विश्वसनीय नसते, कारण तेथे अपलोड केलेला ABI कालबाह्य असू शकतो. तुमच्याकडे योग्य ABI असल्याची खात्री करा, अन्यथा तुमचा सबग्राफ चालवणे अयशस्वी होईल.

## ग्राफक्यूएल स्कीमा

तुमच्या सबग्राफसाठी स्कीमा `schema.graphql` फाइलमध्ये आहे. GraphQL स्कीमा GraphQL इंटरफेस व्याख्या भाषा वापरून परिभाषित केले आहेत. तुम्ही कधीही GraphQL स्कीमा लिहिला नसल्यास, GraphQL प्रकार प्रणालीवर हा प्राइमर तपासण्याची शिफारस केली जाते. GraphQL स्कीमासाठी संदर्भ दस्तऐवजीकरण [GraphQL API](/querying/graphql-api) विभागात आढळू शकते.

## संस्था परिभाषित करणे

संस्था परिभाषित करण्यापूर्वी, एक पाऊल मागे घेणे आणि तुमचा डेटा कसा संरचित आणि लिंक केलेला आहे याचा विचार करणे महत्त्वाचे आहे. सबग्राफ स्कीमामध्ये परिभाषित केलेल्या डेटा मॉडेल आणि सबग्राफद्वारे अनुक्रमित घटकांविरुद्ध सर्व क्वेरी केल्या जातील. यामुळे, सबग्राफ स्कीमा तुमच्या dapp च्या गरजांशी जुळेल अशा प्रकारे परिभाषित करणे चांगले आहे. इव्हेंट किंवा फंक्शन्स ऐवजी "डेटा असलेले ऑब्जेक्ट्स" म्हणून घटकांची कल्पना करणे उपयुक्त ठरू शकते.

The Graph सह, तुम्ही फक्त `schema.graphql` मध्ये अस्तित्व प्रकार परिभाषित करता, आणि ग्राफ नोड एकल उदाहरणे आणि त्या घटक प्रकाराच्या संग्रहासाठी क्वेरी करण्यासाठी उच्च स्तरीय फील्ड तयार करेल. प्रत्येक प्रकार जो अस्तित्व असावा त्याला `@entity` निर्देशासह भाष्य करणे आवश्यक आहे. डीफॉल्टनुसार, घटक बदलण्यायोग्य असतात, याचा अर्थ मॅपिंग विद्यमान घटक लोड करू शकतात, त्यामध्ये सुधारणा करू शकतात आणि त्या घटकाची नवीन आवृत्ती संग्रहित करू शकतात. परिवर्तनशीलता किंमतीवर येते आणि ज्या घटकांसाठी हे ज्ञात आहे की ते कधीही सुधारित केले जाणार नाहीत, उदाहरणार्थ, त्यांच्यामध्ये केवळ साखळीतून शब्दशः काढलेला डेटा असतो, त्यांना `@entity सह अपरिवर्तनीय म्हणून चिन्हांकित करण्याची शिफारस केली जाते. (अपरिवर्तनीय: खरे)`. मॅपिंग अपरिवर्तनीय घटकांमध्ये बदल करू शकतात जोपर्यंत ते बदल त्याच ब्लॉकमध्ये होतात ज्यामध्ये अस्तित्व तयार केले गेले होते. अपरिवर्तनीय संस्था लिहिण्यासाठी आणि क्वेरी करण्यासाठी खूप वेगवान असतात आणि म्हणून जेव्हा शक्य असेल तेव्हा वापरल्या पाहिजेत.

### उत्तम उदाहरण

खाली दिलेला `Gravatar` घटक एका Gravatar ऑब्जेक्टभोवती संरचित आहे आणि एखाद्या घटकाची व्याख्या कशी करता येईल याचे उत्तम उदाहरण आहे.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### वाईट उदाहरण

खालील उदाहरण `GravatarAccepted` आणि `GravatarDeclined` घटक इव्हेंटवर आधारित आहेत. 1:1 घटकांना इव्हेंट किंवा फंक्शन कॉल मॅप करण्याची शिफारस केलेली नाही.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### पर्यायी आणि आवश्यक फील्ड

घटक फील्ड आवश्यक किंवा पर्यायी म्हणून परिभाषित केले जाऊ शकतात. आवश्यक फील्ड स्कीमामधील `!` द्वारे सूचित केले जातात. मॅपिंगमध्ये आवश्यक फील्ड सेट केले नसल्यास, फील्डची चौकशी करताना तुम्हाला ही त्रुटी प्राप्त होईल:

```
नॉन-नल फील्ड 'नावासाठी शून्य मूल्य सोडवले
```

प्रत्येक घटकामध्ये एक `id` फील्ड असणे आवश्यक आहे, जे `Bytes!` किंवा `String!` प्रकारचे असणे आवश्यक आहे. सामान्यतः `बाइट्स!` वापरण्याची शिफारस केली जाते, जोपर्यंत `id` मध्ये मानवी वाचता येण्याजोगा मजकूर नसतो, कारण `Bytes!` आयडी असलेल्या संस्था लिहिण्यास जलद असतील. आणि `स्ट्रिंग!` `id` सह क्वेरी करा. `id` फील्ड प्राथमिक की म्हणून काम करते आणि समान प्रकारच्या सर्व घटकांमध्ये अद्वितीय असणे आवश्यक आहे. ऐतिहासिक कारणांसाठी, `ID!` हा प्रकार देखील स्वीकारला जातो आणि `String!` साठी समानार्थी शब्द आहे.

काही घटक प्रकारांसाठी `id` हे इतर दोन घटकांच्या आयडीवरून तयार केले जाते; ते `concat` वापरून शक्य आहे, उदा., `left` च्या id वरून id तयार करण्यासाठी `let id = left.id.concat(right.id)` > आणि `उजवीकडे`. त्याचप्रमाणे, विद्यमान घटकाच्या आयडी आणि काउंटर `count` वरून आयडी तयार करण्यासाठी, `let id = left.id.concatI32(count)` वापरता येईल. अशा सर्व घटकांसाठी `left` ची लांबी समान असेल तोपर्यंत युनिक आयडी तयार करण्याची हमी दिली जाते, उदाहरणार्थ, `left.id` हा `पत्ता आहे `.

### अंगभूत स्केलर प्रकार

#### ग्राफक्यूएल समर्थित स्केलर

आम्ही आमच्या GraphQL API मध्ये खालील स्केलरला समर्थन देतो:

| प्रकार       | वर्णन                                                                                                                                                                                                   |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `बाइट्स`     | बाइट अॅरे, हेक्साडेसिमल स्ट्रिंग म्हणून प्रस्तुत केले जाते. सामान्यतः इथरियम हॅश आणि पत्त्यांसाठी वापरले जाते.                                                                                          |
| `स्ट्रिंग`   | `स्ट्रिंग` मूल्यांसाठी स्केलर. शून्य वर्ण समर्थित नाहीत आणि आपोआप काढले जातात.                                                                                                                          |
| `बुलियन`     | `बूलियन` मूल्यांसाठी स्केलर.                                                                                                                                                                            |
| `इंट`        | GraphQL spec `Int` ला ३२ बाइट्सचा आकार ठरवतो.                                                                                                                                                           |
| `BigInt`     | मोठे पूर्णांक. इथरियमच्या `uint32`, `int64`, `uint64`, ..., `uint256` प्रकारांसाठी वापरले जाते. टीप: `uint32` खाली सर्व काही, जसे की `int32`, `uint24` किंवा `int8` `i32` म्हणून प्रस्तुत केले जाते 0>. |
| `बिग डेसिमल` | `BigDecimal` उच्च सुस्पष्टता दशांश एक महत्त्वपूर्ण आणि घातांक म्हणून प्रस्तुत केले जाते. घातांक श्रेणी −6143 ते +6144 पर्यंत आहे. 34 लक्षणीय अंकांपर्यंत पूर्णांक.                                      |

#### एनम्स

तुम्ही स्कीमामध्ये enums देखील तयार करू शकता. Enums मध्ये खालील वाक्यरचना आहे:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

एकदा enum स्कीमामध्ये परिभाषित केल्यावर, तुम्ही enum मूल्याचे स्ट्रिंग प्रतिनिधित्व एखाद्या घटकावर enum फील्ड सेट करण्यासाठी वापरू शकता. उदाहरणार्थ, तुम्ही प्रथम तुमची संस्था परिभाषित करून आणि नंतर `entity.tokenStatus = "SecondOwner"` सह फील्ड सेट करून `tokenStatus` ला `SecondOwner` वर सेट करू शकता. इनम फील्डसह टोकन अस्तित्व कसे दिसेल हे खालील उदाहरण दाखवते:

एनम्स लिहिण्याबद्दल अधिक तपशील [GraphQL दस्तऐवजीकरण](https://graphql.org/learn/schema/) मध्ये आढळू शकतात.

#### अस्तित्व संबंध

एखाद्या घटकाचा तुमच्या स्कीमामधील एक किंवा अधिक इतर घटकांशी संबंध असू शकतो. हे नातेसंबंध तुमच्या प्रश्नांमध्ये असू शकतात. आलेखामधील संबंध दिशाहीन आहेत. नात्याच्या "शेवट" वर एकदिशात्मक संबंध परिभाषित करून द्विदिशात्मक संबंधांचे अनुकरण करणे शक्य आहे.

नातेसंबंध हे इतर कोणत्याही क्षेत्राप्रमाणेच घटकांवर परिभाषित केले जातात शिवाय निर्दिष्ट केलेला प्रकार दुसर्‍या घटकाचा आहे.

#### वन-टू-वन संबंध

`TransactionReceipt` घटक प्रकारासह पर्यायी वन-टू-वन संबंधांसह `व्यवहार` अस्तित्व प्रकार परिभाषित करा:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### एक-ते-अनेक संबंध

टोकन अस्तित्व प्रकारासह आवश्यक एक-ते-अनेक संबंधांसह `टोकन बॅलन्स` अस्तित्व प्रकार परिभाषित करा:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### उलटे लुकअप

`@derivedFrom` फील्डद्वारे एखाद्या घटकावर उलट लुकअप परिभाषित केले जाऊ शकतात. हे घटकावर एक आभासी फील्ड तयार करते ज्याची चौकशी केली जाऊ शकते परंतु मॅपिंग API द्वारे व्यक्तिचलितपणे सेट केली जाऊ शकत नाही. उलट, ते इतर घटकावर परिभाषित केलेल्या नातेसंबंधातून प्राप्त झाले आहे. अशा संबंधांसाठी, नातेसंबंधाच्या दोन्ही बाजू संचयित करणे क्वचितच अर्थपूर्ण आहे आणि अनुक्रमणिका आणि क्वेरी कार्यप्रदर्शन दोन्ही चांगले होईल जेव्हा फक्त एक बाजू संग्रहित केली जाते आणि दुसरी साधित केली जाते.

एक-ते-अनेक संबंधांसाठी, संबंध नेहमी 'एका' बाजूला साठवले पाहिजेत आणि 'अनेक' बाजू नेहमी काढल्या पाहिजेत. 'अनेक' बाजूंवर संस्थांचा अ‍ॅरे संचयित करण्याऐवजी अशा प्रकारे नातेसंबंध संचयित केल्याने, अनुक्रमणिका आणि सबग्राफ क्वेरी या दोन्हीसाठी नाटकीयरित्या चांगले कार्यप्रदर्शन होईल. सर्वसाधारणपणे, घटकांचे अ‍ॅरे संग्रहित करणे जितके व्यावहारिक आहे तितके टाळले पाहिजे.

#### उदाहरण

आम्ही `tokenBalances` फील्ड मिळवून टोकनमधून टोकनसाठी शिल्लक उपलब्ध करू शकतो:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### अनेक-ते-अनेक संबंध

अनेक-ते-अनेक नातेसंबंधांसाठी, जसे की वापरकर्ते जे कोणत्याही संस्थेशी संबंधित असू शकतात, सर्वात सरळ, परंतु सामान्यतः सर्वात कार्यक्षम नसतात, संबंध मॉडेल करण्याचा मार्ग समाविष्ट असलेल्या दोन घटकांपैकी प्रत्येकामध्ये एक अॅरे आहे. नातेसंबंध सममितीय असल्यास, नातेसंबंधाची फक्त एक बाजू संग्रहित करणे आवश्यक आहे आणि दुसरी बाजू मिळवता येते.

#### उदाहरण

`वापरकर्ता` घटक प्रकारापासून `संस्थे` घटक प्रकारापर्यंत रिव्हर्स लुकअप परिभाषित करा. खालील उदाहरणामध्ये, हे `संस्था` घटकामधील `सदस्य` विशेषता शोधून साध्य केले जाते. क्वेरींमध्ये, `वापरकर्ता` वरील `संस्था` फील्ड वापरकर्त्याचा आयडी समाविष्ट असलेल्या सर्व `संस्था` घटक शोधून सोडवले जाईल.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

हे नातेसंबंध संचयित करण्याचा अधिक कार्यक्षम मार्ग म्हणजे मॅपिंग टेबलद्वारे ज्यामध्ये प्रत्येक `वापरकर्ता` / `संस्था` जोडीसाठी एक एंट्री आहे जसे की स्कीमा

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

या दृष्टिकोनासाठी क्वेरी पुनर्प्राप्त करण्यासाठी एका अतिरिक्त स्तरावर उतरणे आवश्यक आहे, उदाहरणार्थ, वापरकर्त्यांसाठी संस्था:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

अनेक-ते-अनेक संबंध संचयित करण्याच्या या अधिक विस्तृत मार्गामुळे सबग्राफसाठी कमी डेटा संग्रहित केला जाईल आणि म्हणूनच अनुक्रमणिका आणि क्वेरीसाठी नाटकीयरित्या वेगवान असलेल्या सबग्राफमध्ये.

#### स्कीमामध्ये टिप्पण्या जोडत आहे

GraphQL स्पेसनुसार, दुहेरी कोटेशन `""` वापरून स्कीमा एंटिटी विशेषतांवर टिप्पण्या जोडल्या जाऊ शकतात. हे खालील उदाहरणात स्पष्ट केले आहे:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## पूर्ण मजकूर शोध फील्ड परिभाषित करणे

मजकूर शोध इनपुटवर आधारित फुलटेक्स्ट शोध क्वेरी फिल्टर आणि रँक घटक. फुलटेक्स्ट क्वेरी अनुक्रमित मजकूर डेटाशी तुलना करण्यापूर्वी स्टेममध्ये क्वेरी मजकूर इनपुटवर प्रक्रिया करून समान शब्दांसाठी जुळणी परत करण्यास सक्षम आहेत.

पूर्ण मजकूर क्वेरी व्याख्येमध्ये क्वेरीचे नाव, मजकूर फील्डवर प्रक्रिया करण्यासाठी वापरला जाणारा भाषा शब्दकोष, परिणाम ऑर्डर करण्यासाठी वापरले जाणारे रँकिंग अल्गोरिदम आणि शोधामध्ये समाविष्ट फील्ड समाविष्ट असतात. प्रत्येक फुलटेक्स्ट क्वेरी एकाधिक फील्डमध्ये असू शकते, परंतु सर्व समाविष्ट फील्ड एकाच घटक प्रकारातील असणे आवश्यक आहे.

पूर्ण मजकूर क्वेरी जोडण्यासाठी, GraphQL स्कीमामध्ये फुलटेक्स्ट निर्देशासह `_Schema__` प्रकार समाविष्ट करा.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

उदाहरण `bandSearch` फील्ड `नाव`, `वर्णन</0 मधील मजकूर दस्तऐवजांवर आधारित <code>बँड` घटक फिल्टर करण्यासाठी क्वेरींमध्ये वापरले जाऊ शकते >, आणि `जैव` फील्ड. पूर्ण मजकूर शोध API आणि अधिक उदाहरण वापराच्या वर्णनासाठी [GraphQL API - क्वेरी](/querying/graphql-api#queries) वर जा.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[वैशिष्ट्य व्यवस्थापन](#experimental-features):** `specVersion` `0.0.4</code वरून > आणि पुढे, सबग्राफ मॅनिफेस्टमधील <code>वैशिष्ट्ये` विभागांतर्गत `fullTextSearch` घोषित करणे आवश्यक आहे.

### भाषा समर्थित

भिन्न भाषा निवडल्याने पूर्ण मजकूर शोध API वर निश्चित, काहीवेळा सूक्ष्म असले तरी परिणाम होईल. फुलटेक्स्ट क्वेरी फील्डद्वारे कव्हर केलेले फील्ड निवडलेल्या भाषेच्या संदर्भात तपासले जातात, म्हणून विश्लेषण आणि शोध क्वेरीद्वारे तयार केलेले लेक्सेम भाषेनुसार भिन्न असतात. उदाहरणार्थ: समर्थित तुर्की शब्दकोश वापरताना "टोकन" हे "टोक" वर स्टेम केले जाते, तर अर्थातच, इंग्रजी शब्दकोश "टोकन" वर स्टेम करेल.

समर्थित भाषा शब्दकोश:

| कोड  | शब्दकोश    |
| ---- | ---------- |
| सोपे | सामान्य    |
| da   | डॅनिश      |
| nl   | डच         |
| en   | इंग्रजी    |
| fi   | फिनिश      |
| fr   | फ्रेंच     |
| de   | जर्मन      |
| hu   | हंगेरियन   |
| ते   | इटालियन    |
| नाही | नॉर्वेजियन |
| pt   | पोर्तुगीज  |
| ro   | रोमानियन   |
| ru   | रशियन      |
| es   | स्पॅनिश    |
| sv   | स्वीडिश    |
| tr   | तुर्की     |

### रँकिंग अल्गोरिदम

परिणाम ऑर्डर करण्यासाठी समर्थित अल्गोरिदम:

| अल्गोरिदम     | वर्णन                                                                  |
| ------------- | ---------------------------------------------------------------------- |
| रँक           | निकाल ऑर्डर करण्यासाठी फुलटेक्स्ट क्वेरीची जुळणी गुणवत्ता (0-1) वापरा. |
| proximityRank | रँक प्रमाणेच पण सामन्यांच्या समीपतेचाही समावेश आहे.                    |

## मॅपिंग लेखन

मॅपिंग्स एका विशिष्ट स्त्रोताकडून डेटा घेतात आणि आपल्या स्कीमामध्ये परिभाषित केलेल्या घटकांमध्ये त्याचे रूपांतर करतात. मॅपिंग्स [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) नावाच्या [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki) नावाच्या उपसंचात लिहिल्या जातात जे WASM ([WebAssembly](https://webassembly.org/)) मध्ये संकलित केले जाऊ शकतात. असेंबलीस्क्रिप्ट सामान्य TypeScript पेक्षा कठोर आहे, तरीही एक परिचित वाक्यरचना प्रदान करते.

`mapping.eventHandlers` अंतर्गत `subgraph.yaml` मध्ये परिभाषित केलेल्या प्रत्येक इव्हेंट हँडलरसाठी, त्याच नावाचे निर्यात केलेले कार्य तयार करा. प्रत्येक हँडलरने हाताळल्या जात असलेल्या इव्हेंटच्या नावाशी संबंधित प्रकारासह `इव्हेंट` नावाचा एकच पॅरामीटर स्वीकारला पाहिजे.

उदाहरणाच्या सबग्राफमध्ये, `src/mapping.ts` मध्ये `NewGravatar` आणि `UpdatedGravatar` इव्हेंटसाठी हँडलर आहेत:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

पहिला हँडलर `NewGravatar` इव्हेंट घेतो आणि `नवीन Gravatar(event.params.id.toHex())` सह एक नवीन `Gravatar` अस्तित्व तयार करतो, पॉप्युलेट करतो संबंधित इव्हेंट पॅरामीटर्स वापरून संस्था फील्ड. हे घटक उदाहरण `event.params.id.toHex()` च्या id मूल्यासह, व्हेरिएबल `gravatar` द्वारे प्रस्तुत केले जाते.

दुसरा हँडलर ग्राफ नोड स्टोअरमधून विद्यमान `Gravatar` लोड करण्याचा प्रयत्न करतो. ते अद्याप अस्तित्वात नसल्यास, ते मागणीनुसार तयार केले जाते. नंतर `gravatar.save()` वापरून स्टोअरमध्ये परत सेव्ह करण्यापूर्वी नवीन इव्हेंट पॅरामीटर्सशी जुळण्यासाठी घटक अपडेट केला जातो.

### नवीन संस्था तयार करण्यासाठी शिफारस केलेले आयडी

प्रत्येक घटकाकडे एक `id` असणे आवश्यक आहे जे समान प्रकारच्या सर्व घटकांमध्ये अद्वितीय आहे. जेव्हा अस्तित्व तयार केले जाते तेव्हा घटकाचे `id` मूल्य सेट केले जाते. नवीन घटक तयार करताना विचारात घेण्यासाठी खाली काही शिफारस केलेली `id` मूल्ये आहेत. टीप: `id` चे मूल्य `स्ट्रिंग` असणे आवश्यक आहे.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

आम्ही [ग्राफ टाइपस्क्रिप्ट लायब्ररी](https://github.com/graphprotocol/graph-ts) प्रदान करतो ज्यामध्ये ग्राफ नोड स्टोअरशी संवाद साधण्यासाठी उपयुक्तता आणि स्मार्ट कॉन्ट्रॅक्ट डेटा आणि संस्था हाताळण्यासाठी सोयी असतात. तुम्ही `mapping.ts` मध्ये `@graphprotocol/graph-ts` आयात करून ही लायब्ररी तुमच्या मॅपिंगमध्ये वापरू शकता.

## कोड जनरेशन

स्मार्ट कॉन्ट्रॅक्ट्स, इव्हेंट्स आणि संस्थांसोबत काम करणे सोपे आणि टाइप-सुरक्षित करण्यासाठी, ग्राफ CLI सबग्राफच्या GraphQL स्कीमा आणि डेटा स्रोतांमध्ये समाविष्ट केलेल्या कॉन्ट्रॅक्ट ABIs मधून असेंबलीस्क्रिप्ट प्रकार व्युत्पन्न करू शकतो.

यासह केले जाते

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

परंतु बर्‍याच प्रकरणांमध्ये, सबग्राफ आधीपासूनच `package.json` द्वारे कॉन्फिगर केलेले असतात जे तुम्हाला ते साध्य करण्यासाठी खालीलपैकी एक चालवण्याची परवानगी देतात:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

हे `subgraph.yaml` मध्ये नमूद केलेल्या ABI फाइल्समधील प्रत्येक स्मार्ट करारासाठी असेंब्लीस्क्रिप्ट क्लास तयार करेल, ज्यामुळे तुम्हाला हे करार मॅपिंगमधील विशिष्ट पत्त्यांवर बंधनकारक करता येतील आणि ब्लॉकच्या विरूद्ध केवळ-वाचनीय करार पद्धती कॉल करता येतील. प्रक्रिया केली. हे प्रत्येक कॉन्ट्रॅक्ट इव्हेंटसाठी इव्हेंट पॅरामीटर्स तसेच ब्लॉक आणि इव्हेंटमधून उद्भवलेल्या व्यवहारासाठी सुलभ प्रवेश प्रदान करण्यासाठी एक वर्ग देखील तयार करेल. हे सर्व प्रकार `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts` वर लिहिलेले आहेत. उदाहरणाच्या सबग्राफमध्ये, हे `generated/Gravity/Gravity.ts` असेल, मॅपिंगना हे प्रकार आयात करण्यास अनुमती देतात.

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

या व्यतिरिक्त, सबग्राफच्या GraphQL स्कीमामध्ये प्रत्येक घटक प्रकारासाठी एक वर्ग तयार केला जातो. हे वर्ग टाइप-सेफ एंटिटी लोडिंग, एंटिटी फील्डमध्ये वाचन आणि लिहिण्याचा अॅक्सेस प्रदान करतात तसेच स्टोअर करण्यासाठी संस्था लिहिण्यासाठी `सेव्ह()` पद्धत प्रदान करतात. सर्व घटक वर्ग `<OUTPUT_DIR>/schema.ts` वर लिहिलेले आहेत, मॅपिंगना ते यासह आयात करण्यास अनुमती देतात

```javascript
import { Gravatar } from '../generated/schema'
```

> **टीप:** मॅनिफेस्टमध्ये समाविष्ट केलेल्या GraphQL स्कीमा किंवा ABI मध्ये प्रत्येक बदलानंतर कोड जनरेशन पुन्हा केले जाणे आवश्यक आहे. सबग्राफ तयार करण्यापूर्वी किंवा उपयोजित करण्यापूर्वी ते किमान एकदा केले जाणे आवश्यक आहे.

कोड जनरेशन तुमचा मॅपिंग कोड `src/mapping.ts` मध्ये तपासत नाही. ग्राफ एक्सप्लोररमध्ये तुमचा सबग्राफ उपयोजित करण्याचा प्रयत्न करण्यापूर्वी तुम्हाला ते तपासायचे असल्यास, तुम्ही `यार्न बिल्ड` चालवू शकता आणि टाइपस्क्रिप्ट कंपायलरला सापडलेल्या कोणत्याही वाक्यरचना त्रुटींचे निराकरण करू शकता.

## डेटा स्रोत टेम्पलेट्स

EVM-सुसंगत स्मार्ट कॉन्ट्रॅक्ट्समधील एक सामान्य नमुना म्हणजे नोंदणी किंवा फॅक्टरी कॉन्ट्रॅक्टचा वापर, जिथे एक करार तयार करतो, व्यवस्थापित करतो किंवा इतर करारांची अनियंत्रित संख्या संदर्भित करतो ज्या प्रत्येकाची स्वतःची स्थिती आणि घटना असतात.

या उप-करारांचे पत्ते कदाचित माहीत नसतील किंवा नसतील आणि यापैकी बरेच करार तयार केले जाऊ शकतात आणि/किंवा कालांतराने जोडले जाऊ शकतात. म्हणूनच, अशा प्रकरणांमध्ये, एकल डेटा स्रोत किंवा डेटा स्त्रोतांची निश्चित संख्या परिभाषित करणे अशक्य आहे आणि अधिक गतिशील दृष्टीकोन आवश्यक आहे: _डेटा स्रोत टेम्पलेट्स_.

### मुख्य करारासाठी डेटा स्रोत

प्रथम, तुम्ही मुख्य करारासाठी नियमित डेटा स्रोत परिभाषित करता. खाली दिलेला स्निपेट [Uniswap](https://uniswap.org) एक्सचेंज फॅक्टरी करारासाठी एक सरलीकृत उदाहरण डेटा स्रोत दर्शवितो. `NewExchange(address,address)` इव्हेंट हँडलर लक्षात ठेवा. जेव्हा कारखाना कराराद्वारे नवीन एक्सचेंज कॉन्ट्रॅक्ट ऑन-चेन तयार केला जातो तेव्हा हे उत्सर्जित होते.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### डायनॅमिकली तयार केलेल्या करारांसाठी डेटा स्रोत टेम्पलेट्स

त्यानंतर, तुम्ही मॅनिफेस्टमध्ये _डेटा स्रोत टेम्पलेट्स_ जोडता. हे नियमित डेटा स्रोतांसारखेच आहेत, त्याशिवाय त्यांना `स्रोत` अंतर्गत पूर्व-परिभाषित करार पत्ता नाही. सामान्यत:, तुम्ही पालक कराराद्वारे व्यवस्थापित किंवा संदर्भित केलेल्या प्रत्येक प्रकारच्या उप-करारासाठी एक टेम्पलेट परिभाषित कराल.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### डेटा स्रोत टेम्पलेट इन्स्टंट करणे

अंतिम चरणात, तुम्ही टेम्पलेटपैकी एकावरून डायनॅमिक डेटा स्रोत उदाहरण तयार करण्यासाठी तुमचे मुख्य कॉन्ट्रॅक्ट मॅपिंग अपडेट करता. या उदाहरणात, तुम्ही `Exchange` टेम्प्लेट इंपोर्ट करण्यासाठी मुख्य कॉन्ट्रॅक्ट मॅपिंग बदलू शकता आणि नवीन एक्सचेंज कॉन्ट्रॅक्ट इंडेक्सिंग सुरू करण्यासाठी त्यावर `Exchange.create(address)` पद्धत कॉल कराल.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **टीप:** नवीन डेटा स्रोत केवळ तो ज्या ब्लॉकमध्ये तयार केला गेला होता आणि पुढील सर्व ब्लॉकसाठी कॉल्स आणि इव्हेंटवर प्रक्रिया करेल, परंतु ऐतिहासिक डेटावर प्रक्रिया करणार नाही, म्हणजे, डेटावर प्रक्रिया करणार नाही. जे आधीच्या ब्लॉक्समध्ये समाविष्ट आहे.
> 
> पूर्वीच्या ब्लॉक्समध्ये नवीन डेटा स्रोताशी संबंधित डेटा असल्यास, कराराची वर्तमान स्थिती वाचून आणि नवीन डेटा स्रोत तयार करताना त्या स्थितीचे प्रतिनिधित्व करणारी संस्था तयार करून तो डेटा अनुक्रमित करणे सर्वोत्तम आहे.

### डेटा स्रोत संदर्भ

डेटा स्रोत संदर्भ टेम्प्लेट इन्स्टंट करताना अतिरिक्त कॉन्फिगरेशन पास करण्याची परवानगी देतात. आमच्या उदाहरणात, समजा एक्सचेंजेस एका विशिष्ट ट्रेडिंग जोडीशी संबंधित आहेत, जे `NewExchange` इव्हेंटमध्ये समाविष्ट आहे. ती माहिती तात्काळ डेटा स्त्रोतामध्ये पास केली जाऊ शकते, जसे की:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

`एक्सचेंज` टेम्प्लेटच्या मॅपिंगमध्ये, संदर्भ नंतर प्रवेश केला जाऊ शकतो:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

सर्व मूल्य प्रकारांसाठी `setString` आणि `getString` सारखे सेटर आणि गेटर्स आहेत.

## ब्लॉक सुरू करा

`startBlock` ही एक पर्यायी सेटिंग आहे जी तुम्हाला साखळीतील कोणत्या ब्लॉकमधून डेटा स्रोत अनुक्रमणिका सुरू करेल हे परिभाषित करू देते. स्टार्ट ब्लॉक सेट केल्याने डेटा स्त्रोताला अप्रासंगिक असलेले लाखो ब्लॉक्स वगळण्याची परवानगी मिळते. सामान्यतः, सबग्राफ डेव्हलपर `startBlock` सेट करेल ज्या ब्लॉकमध्ये डेटा स्रोताचा स्मार्ट करार तयार केला गेला होता.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **टीप:** इथरस्कॅनवर कॉन्ट्रॅक्ट क्रिएशन ब्लॉक त्वरीत शोधला जाऊ शकतो:
> 
> 1. शोध बारमध्ये त्याचा पत्ता प्रविष्ट करून करार शोधा.
> 2. `Contract Creator` विभागातील निर्मिती व्यवहार हॅशवर क्लिक करा.
> 3. व्यवहार तपशील पृष्ठ लोड करा जिथे तुम्हाला त्या करारासाठी प्रारंभ ब्लॉक मिळेल.

## हँडलर्सना कॉल करा

इव्हेंट्स कराराच्या स्थितीत संबंधित बदल एकत्रित करण्याचा एक प्रभावी मार्ग प्रदान करतात, तर अनेक करार गॅसच्या किमती ऑप्टिमाइझ करण्यासाठी लॉग तयार करणे टाळतात. या प्रकरणांमध्ये, सबग्राफ डेटा स्त्रोत करारावर केलेल्या कॉलची सदस्यता घेऊ शकतो. फंक्शन सिग्नेचर आणि मॅपिंग हँडलरचा संदर्भ देणारे कॉल हँडलर परिभाषित करून हे साध्य केले जाते जे या फंक्शनवर कॉलवर प्रक्रिया करेल. या कॉल्सवर प्रक्रिया करण्यासाठी, मॅपिंग हँडलरला कॉलमधील टाइप केलेल्या इनपुट आणि आउटपुटसह युक्तिवाद म्हणून `ethereum.Call` प्राप्त होईल. व्यवहाराच्या कॉल साखळीतील कोणत्याही खोलीत केलेले कॉल मॅपिंगला ट्रिगर करतील, प्रॉक्सी कॉन्ट्रॅक्टद्वारे डेटा स्त्रोत करारासह क्रियाकलाप कॅप्चर करण्यास अनुमती देईल.

कॉल हँडलर्स फक्त दोनपैकी एका प्रकरणात ट्रिगर होतील: जेव्हा निर्दिष्ट केलेल्या फंक्शनला कॉन्ट्रॅक्ट व्यतिरिक्त इतर खात्याद्वारे कॉल केले जाते किंवा जेव्हा ते सॉलिडिटीमध्ये बाह्य म्हणून चिन्हांकित केले जाते आणि त्याच कॉन्ट्रॅक्टमधील दुसर्‍या फंक्शनचा भाग म्हणून कॉल केले जाते.

> **टीप:** कॉल हँडलर सध्या पॅरिटी ट्रेसिंग API वर अवलंबून आहेत. काही नेटवर्क, जसे की BNB चेन आणि आर्बिट्रम, या API चे समर्थन करत नाहीत. जर या नेटवर्कपैकी एका सबग्राफ इंडेक्सिंगमध्ये एक किंवा अधिक कॉल हँडलर असतील, तर ते समक्रमण सुरू होणार नाही. सबग्राफ विकसकांनी त्याऐवजी इव्हेंट हँडलर वापरावे. हे कॉल हँडलर्सपेक्षा कितीतरी अधिक कार्यक्षम आहेत, आणि प्रत्येक evm नेटवर्कवर समर्थित आहेत.

### कॉल हँडलरची व्याख्या

तुमच्‍या मॅनिफेस्‍टमध्‍ये कॉल हँडलर परिभाषित करण्‍यासाठी, तुम्ही ज्या डेटा स्रोताची सदस्यता घेऊ इच्छिता त्याखाली फक्त `कॉल हँडलर` अॅरे जोडा.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`फंक्शन` हे कॉल फिल्टर करण्यासाठी सामान्यीकृत फंक्शन स्वाक्षरी आहे. `हँडलर` गुणधर्म हे तुमच्या मॅपिंगमधील फंक्शनचे नाव आहे जे तुम्ही डेटा सोर्स कॉन्ट्रॅक्टमध्ये टार्गेट फंक्शन कॉल केल्यावर कार्यान्वित करू इच्छिता.

### मॅपिंग कार्य

प्रत्येक कॉल हँडलर एकच पॅरामीटर घेतो ज्याचा प्रकार कॉल फंक्शनच्या नावाशी संबंधित असतो. वरील उदाहरणातील सबग्राफमध्ये, मॅपिंगमध्ये `createGravatar` फंक्शन कॉल केल्यावर आणि वितर्क म्हणून `CreateGravatarCall` पॅरामीटर प्राप्त करण्यासाठी हँडलर असतो:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

`handleCreateGravatar` फंक्शन एक नवीन `CreateGravatarCall` घेते जो `@graphprotocol/graph-ts</ द्वारे प्रदान केलेला <code>ethereum.Call` चा उपवर्ग आहे. code>, ज्यामध्ये कॉलचे टाइप केलेले इनपुट आणि आउटपुट समाविष्ट आहेत. तुम्ही `graph codegen` चालवता तेव्हा तुमच्यासाठी `CreateGravatarCall` प्रकार जनरेट केला जातो.

## ब्लॉक हँडलर

कॉन्ट्रॅक्ट इव्हेंट्स किंवा फंक्शन कॉल्सची सदस्यता घेण्याव्यतिरिक्त, सबग्राफला त्याचा डेटा अद्यतनित करायचा असेल कारण साखळीमध्ये नवीन ब्लॉक्स जोडले जातात. हे साध्य करण्यासाठी सबग्राफ प्रत्येक ब्लॉकनंतर किंवा पूर्व-परिभाषित फिल्टरशी जुळणार्‍या ब्लॉक्सनंतर फंक्शन चालवू शकतो.

### समर्थित फिल्टर

```yaml
filter:
  kind: call
```

_परिभाषित हँडलरला प्रत्येक ब्लॉकसाठी एकदा कॉल केला जाईल ज्यात हँडलरने परिभाषित केलेल्या कॉन्ट्रॅक्टला (डेटा स्त्रोत) कॉल असेल._

> **टीप:** `कॉल` फिल्टर सध्या पॅरिटी ट्रेसिंग API वर अवलंबून आहे. काही नेटवर्क, जसे की BNB चेन आणि आर्बिट्रम, या API चे समर्थन करत नाहीत. जर या नेटवर्कपैकी एक सबग्राफ अनुक्रमणिकामध्ये `कॉल` फिल्टरसह एक किंवा अधिक ब्लॉक हँडलर असतील, तर ते समक्रमण सुरू होणार नाही.

ब्लॉक हँडलरसाठी फिल्टरची अनुपस्थिती हे सुनिश्चित करेल की हँडलरला प्रत्येक ब्लॉक म्हटले जाईल. डेटा स्त्रोतामध्ये प्रत्येक फिल्टर प्रकारासाठी फक्त एक ब्लॉक हँडलर असू शकतो.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### मॅपिंग कार्य

मॅपिंग फंक्शनला त्याचा एकमेव युक्तिवाद म्हणून `ethereum.Block` प्राप्त होईल. इव्हेंटसाठी मॅपिंग फंक्शन्सप्रमाणे, हे फंक्शन स्टोअरमधील विद्यमान सबग्राफ घटकांमध्ये प्रवेश करू शकते, स्मार्ट कॉन्ट्रॅक्ट कॉल करू शकते आणि संस्था तयार किंवा अद्यतनित करू शकते.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## अनामिक घटना

तुम्हाला सॉलिडिटीमध्ये निनावी इव्हेंटवर प्रक्रिया करायची असल्यास, ते इव्हेंटचा विषय 0 प्रदान करून प्राप्त केले जाऊ शकते, उदाहरणार्थ:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

जेव्हा स्वाक्षरी आणि विषय 0 दोन्ही जुळतात तेव्हाच इव्हेंट ट्रिगर केला जाईल. डीफॉल्टनुसार, `topic0` इव्हेंट स्वाक्षरीच्या हॅशच्या समान आहे.

## इव्हेंट हँडलर्समधील व्यवहाराच्या पावत्या

`specVersion` `0.0.5` आणि `apiVersion` `0.0.7` पासून प्रारंभ करून, इव्हेंट हँडलर्सना पावतीवर प्रवेश असू शकतो व्यवहार ज्याने त्यांना उत्सर्जित केले.

असे करण्यासाठी, नवीन `पावती: सत्य` की सह सबग्राफ मॅनिफेस्टमध्ये इव्हेंट हँडलर घोषित करणे आवश्यक आहे, जे पर्यायी आहे आणि डीफॉल्ट असत्य आहे.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

हँडलर फंक्शनच्या आत, पावती `Event.receipt` फील्डमध्ये ऍक्सेस केली जाऊ शकते. जेव्हा `पावती` की `false` वर सेट केली जाते किंवा मॅनिफेस्टमध्ये वगळली जाते, तेव्हा त्याऐवजी `null` मूल्य परत केले जाईल.

## प्रायोगिक वैशिष्ट्ये

`specVersion` `0.0.4` पासून सुरू करून, सबग्राफ वैशिष्ट्ये मॅनिफेस्ट फाइलच्या शीर्ष स्तरावरील `वैशिष्ट्ये` विभागात स्पष्टपणे घोषित करणे आवश्यक आहे, त्यांचा वापर करून `camelCase` नाव, खालील तक्त्यामध्ये सूचीबद्ध केल्याप्रमाणे:

| वैशिष्ट्य                                               | नाव                                                 |
| ------------------------------------------------------- | --------------------------------------------------- |
| [गैर-घातक त्रुटी](#non-fatal-errors)                    | `nonFatalErrors`                                    |
| [पूर्ण मजकूर शोध](#defining-fulltext-search-fields)     | `fullTextSearch`                                    |
| [कलम करणे](#grafting-onto-existing-subgraphs)           | `कलम करणे`                                          |
| [इथरियम करारांवर आयपीएफएस](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` or `nonDeterministicIpfs` |

उदाहरणार्थ, जर सबग्राफ **पूर्ण-मजकूर शोध** आणि **नॉन-फेटल एरर** वैशिष्ट्ये वापरत असेल, तर मॅनिफेस्टमधील `वैशिष्ट्ये` फील्ड हे असावे:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

लक्षात ठेवा की वैशिष्ट्य घोषित न करता वापरल्याने सबग्राफ डिप्लॉयमेंट दरम्यान **प्रमाणीकरण त्रुटी** येईल, परंतु वैशिष्ट्य घोषित केले असल्यास परंतु वापरलेले नसल्यास कोणतीही त्रुटी येणार नाही.

### इथरियम करारांवर आयपीएफएस

इथरियमसह IPFS एकत्र करण्यासाठी एक सामान्य वापर केस म्हणजे IPFS वर डेटा संग्रहित करणे जे ऑन-चेन राखण्यासाठी खूप महाग असेल आणि Ethereum कॉन्ट्रॅक्टमध्ये IPFS हॅशचा संदर्भ घ्या.

अशा IPFS हॅश दिल्यास, सबग्राफ `ipfs.cat` आणि `ipfs.map` वापरून IPFS मधील संबंधित फाइल्स वाचू शकतात. हे विश्वासार्हपणे करण्यासाठी, या फायली उच्च उपलब्धता असलेल्या IPFS नोडवर पिन केलेल्या असणे आवश्यक आहे, जेणेकरून [होस्टेड सेवा](https://thegraph.com/hosted-service) IPFS नोड अनुक्रमणिका दरम्यान शोधू शकता.

> **टीप:** ग्राफ नेटवर्क अद्याप `ipfs.cat` आणि `ipfs.map` ला समर्थन देत नाही आणि विकसकांनी उपयोजित करू नये स्टुडिओद्वारे नेटवर्कवर ती कार्यक्षमता वापरून सबग्राफ.

> **[वैशिष्ट्य व्यवस्थापन](#experimental-features):** `ipfsOnEthereumContracts` `वैशिष्ट्ये` अंतर्गत घोषित करणे आवश्यक आहे code> सबग्राफ मॅनिफेस्टमध्ये. ईव्हीएम नसलेल्या साखळ्यांसाठी, `nonDeterministicIpfs` उपनाव देखील त्याच उद्देशासाठी वापरला जाऊ शकतो.

स्थानिक आलेख नोड चालवताना, ही प्रायोगिक कार्यक्षमता वापरून सबग्राफ अनुक्रमित करण्यासाठी `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` पर्यावरण व्हेरिएबल सेट करणे आवश्यक आहे.

### गैर-घातक त्रुटी

आधीच समक्रमित केलेल्या सबग्राफ्सवर अनुक्रमणिका त्रुटी, डीफॉल्टनुसार, सबग्राफ अयशस्वी होण्यास आणि समक्रमण थांबवण्यास कारणीभूत ठरतील. सबग्राफ वैकल्पिकरित्या त्रुटींच्या उपस्थितीत समक्रमण सुरू ठेवण्यासाठी कॉन्फिगर केले जाऊ शकतात, हँडलरने केलेल्या बदलांकडे दुर्लक्ष करून, ज्यामुळे त्रुटी उद्भवली. हे सबग्राफ लेखकांना त्यांचे सबग्राफ दुरुस्त करण्यासाठी वेळ देते जेव्हा की नवीनतम ब्लॉकच्या विरूद्ध क्वेरी चालू ठेवल्या जातात, जरी त्रुटीमुळे परिणाम विसंगत असू शकतात. लक्षात घ्या की काही त्रुटी अजूनही नेहमीच घातक असतात. गैर-घातक होण्यासाठी, त्रुटी निश्चितपणे ज्ञात असणे आवश्यक आहे.

> **टीप:** ग्राफ नेटवर्क अद्याप घातक नसलेल्या त्रुटींना समर्थन देत नाही आणि विकासकांनी स्टुडिओद्वारे नेटवर्कवर ती कार्यक्षमता वापरून सबग्राफ उपयोजित करू नये.

गैर-घातक त्रुटी सक्षम करण्यासाठी सबग्राफ मॅनिफेस्टवर खालील वैशिष्ट्य ध्वज सेट करणे आवश्यक आहे:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

क्वेरीने `subgraphError` युक्तिवादाद्वारे संभाव्य विसंगती असलेल्या डेटाची क्वेरी करणे देखील निवडले पाहिजे. उदाहरणाप्रमाणे सबग्राफ एरर वगळला आहे की नाही हे तपासण्यासाठी `_meta` क्वेरी करण्याची देखील शिफारस केली जाते:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

सबग्राफमध्ये त्रुटी आढळल्यास, ती क्वेरी या उदाहरणाच्या प्रतिसादाप्रमाणे `"indexing_error"` संदेशासह डेटा आणि graphql त्रुटी दोन्ही देईल:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### विद्यमान सबग्राफवर कलम करणे

जेव्हा सबग्राफ प्रथम उपयोजित केला जातो, तेव्हा तो संबंधित साखळीच्या उत्पत्ती ब्लॉकवर (किंवा प्रत्येक डेटा स्त्रोतासह परिभाषित केलेल्या `startBlock` वर) काही परिस्थितींमध्ये इव्हेंट्सचे अनुक्रमणिका सुरू करतो; विद्यमान सबग्राफमधील डेटा पुन्हा वापरणे आणि नंतरच्या ब्लॉकमध्ये अनुक्रमणिका सुरू करणे फायदेशीर आहे. अनुक्रमणिकेच्या या मोडला _ग्राफ्टिंग_ म्हणतात. उदाहरणार्थ, मॅपिंगमध्ये भूतकाळातील साध्या चुका लवकर मिळवण्यासाठी किंवा विद्यमान सबग्राफ अयशस्वी झाल्यानंतर तात्पुरते काम करण्यासाठी विकासादरम्यान ग्राफ्टिंग उपयुक्त आहे.

सबग्राफ बेस सबग्राफवर ग्राफ्ट केला जातो जेव्हा `subgraph.yaml` मधील सबग्राफ मॅनिफेस्टमध्ये शीर्ष-स्तरावर `ग्राफ्ट` ब्लॉक असतो:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

जेव्हा एखादा सबग्राफ ज्याच्या मॅनिफेस्टमध्ये `ग्राफ्ट` ब्लॉक असतो तो उपयोजित केला जातो, तेव्हा आलेख नोड `बेस` सबग्राफचा डेटा कॉपी करेल आणि दिलेल्या `ब्लॉक` सह आणि नंतर त्या ब्लॉकमधून नवीन सबग्राफ अनुक्रमित करणे सुरू ठेवा. बेस सबग्राफ लक्ष्य ग्राफ नोडच्या उदाहरणावर अस्तित्वात असणे आवश्यक आहे आणि कमीतकमी दिलेल्या ब्लॉकपर्यंत अनुक्रमित केलेले असणे आवश्यक आहे. या निर्बंधामुळे, ग्राफ्टिंगचा वापर केवळ विकासादरम्यान किंवा आणीबाणीच्या काळात समतुल्य नॉन-ग्राफ्टेड सबग्राफ तयार करण्यासाठी वेगवान करण्यासाठी केला पाहिजे.

बेस डेटा इंडेक्स करण्याऐवजी कॉपीचे ग्राफ्टिंग केल्यामुळे, सुरवातीपासून इंडेक्स करण्यापेक्षा इच्छित ब्लॉकमध्ये सबग्राफ मिळवणे खूप जलद आहे, जरी सुरुवातीच्या डेटा कॉपीला खूप मोठ्या सबग्राफसाठी बरेच तास लागू शकतात. ग्रॅफ्टेड सबग्राफ सुरू होत असताना, ग्राफ नोड आधीपासून कॉपी केलेल्या घटक प्रकारांबद्दल माहिती लॉग करेल.

ग्राफ्टेड सबग्राफ GraphQL स्कीमा वापरू शकतो जो बेस सबग्राफपैकी एकाशी एकसारखा नसतो, परंतु त्याच्याशी फक्त सुसंगत असतो. ती स्वतःच्या अधिकारात वैध सबग्राफ स्कीमा असणे आवश्यक आहे, परंतु खालील प्रकारे बेस सबग्राफच्या स्कीमापासून विचलित होऊ शकते:

- हे घटक प्रकार जोडते किंवा काढून टाकते
- हे घटक प्रकारातील गुणधर्म काढून टाकते
- हे अस्तित्व प्रकारांमध्ये रद्द करण्यायोग्य विशेषता जोडते
- हे नॉन-नलेबल अॅट्रिब्यूट्सना न्युलेबल अॅट्रिब्यूटमध्ये बदलते
- हे enums मध्ये मूल्ये जोडते
- हे इंटरफेस जोडते किंवा काढून टाकते
- कोणत्या घटकासाठी इंटरफेस लागू केला जातो ते बदलते

> **[वैशिष्ट्य व्यवस्थापन](#experimental-features):** `ग्राफ्टिंग` सबग्राफ मॅनिफेस्टमध्ये `वैशिष्ट्ये` अंतर्गत घोषित करणे आवश्यक आहे.

## फाइल डेटा स्रोत

फाईल डेटा स्रोत ही एक नवीन सबग्राफ कार्यक्षमता आहे जी आयपीएफएसपासून सुरू होणार्‍या, मजबूत, वाढवता येण्याजोग्या पद्धतीने अनुक्रमणिकेदरम्यान ऑफ-चेन डेटामध्ये प्रवेश करण्यासाठी आहे.

> हे ऑफ-चेन डेटाच्या निर्धारवादी अनुक्रमणिकेसाठी तसेच अनियंत्रित HTTP-स्रोत डेटाच्या संभाव्य परिचयासाठी देखील पाया घालते.

### सविश्लेषण

हँडलर कार्यान्वित करताना फाईल्स "इन लाइन" आणण्याऐवजी, हे टेम्पलेट्स सादर करते जे दिलेल्या फाइल आयडेंटिफायरसाठी नवीन डेटा स्रोत म्हणून तयार केले जाऊ शकतात. हे नवीन डेटा स्रोत फाइल्स आणतात, अयशस्वी झाल्यास पुन्हा प्रयत्न करतात, फाइल सापडल्यावर समर्पित हँडलर चालवतात.

हे [विद्यमान डेटा स्रोत टेम्पलेट](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates) सारखे आहे, जे वापरले जातात गतिशीलपणे नवीन साखळी-आधारित डेटा स्रोत तयार करण्यासाठी.

> हे विद्यमान `ipfs.cat` API बदलते

### अपग्रेड मार्गदर्शक

#### `graph-ts` आणि `graph-cli` अपडेट करा

फाइल डेटा स्रोतांना ग्राफ-ts >=0.29.0 आणि ग्राफ-cli>=0.33.1 आवश्यक आहे

#### नवीन अस्तित्व प्रकार जोडा जो फाइल सापडल्यावर अपडेट केला जाईल

फाइल डेटा स्रोत साखळी-आधारित घटकांमध्ये प्रवेश करू शकत नाहीत किंवा अद्यतनित करू शकत नाहीत, परंतु फाइल विशिष्ट घटक अद्यतनित करणे आवश्यक आहे.

याचा अर्थ असा असू शकतो की विद्यमान संस्थांमधून फील्ड एकत्र जोडलेल्या वेगळ्या संस्थांमध्ये विभाजित करणे.

मूळ एकत्रित अस्तित्व:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

नवीन, विभाजित अस्तित्व:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

जर मूळ घटक आणि परिणामी फाइल डेटा स्रोत घटक यांच्यातील संबंध 1:1 असेल तर, आयपीएफएस सीआयडी लुकअप म्हणून वापरून मूळ घटकाला परिणामी फाइल घटकाशी जोडणे हा सर्वात सोपा नमुना आहे. तुम्हाला तुमच्या नवीन फाइल-आधारित घटकांचे मॉडेलिंग करण्यात अडचण येत असल्यास Discord वर संपर्क साधा!

> तुम्ही या नेस्टेड घटकांच्या आधारे मूळ घटक फिल्टर करण्यासाठी [नेस्टेड फिल्टर](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) वापरू शकता.

#### `kind: file/ipfs` सह एक नवीन टेम्पलेट डेटा स्रोत जोडा

हा डेटा स्त्रोत आहे जो जेव्हा स्वारस्य असलेली फाइल ओळखली जाईल तेव्हा तयार होईल.

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> सध्या `abis` आवश्यक आहेत, जरी फाइल डेटा स्रोतांमधून करार कॉल करणे शक्य नाही

फाइल डेटा स्रोताने विशेषत: सर्व घटक प्रकारांचा उल्लेख करणे आवश्यक आहे ज्यांच्याशी तो `संस्था` अंतर्गत संवाद साधेल. अधिक तपशीलांसाठी [मर्यादा](#Limitations) पहा.

#### फाइल्सवर प्रक्रिया करण्यासाठी नवीन हँडलर तयार करा

या हँडलरने एक `बाइट्स` पॅरामीटर स्वीकारला पाहिजे, जो फाइल सापडल्यावर त्यातील सामग्री असेल, ज्यावर नंतर प्रक्रिया केली जाऊ शकते. ही बर्‍याचदा JSON फाइल असेल, ज्यावर `graph-ts` मदतनीस ([दस्तऐवजीकरण](https://thegraph.com/docs/en/developing/assemblyscript-api/#json-api)) सह प्रक्रिया केली जाऊ शकते.

वाचनीय स्ट्रिंग म्हणून फाइलचा CID खालीलप्रमाणे `डेटास्रोत` द्वारे प्रवेश केला जाऊ शकतो:

```typescript
const cid = dataSource.stringParam()
```

उदाहरण हँडलर:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### आवश्यकतेनुसार फाईल डेटा स्रोत तयार करा

साखळी-आधारित हँडलर्सच्या अंमलबजावणीदरम्यान तुम्ही आता फाइल डेटा स्रोत तयार करू शकता:

- स्वयं-निर्मित `टेम्पलेट` मधून टेम्पलेट आयात करा
- मॅपिंगमधून `TemplateName.create(cid: string)` वर कॉल करा, जेथे cid वैध IPFS सामग्री अभिज्ञापक आहे

> सध्या ग्राफ नोड [v0 आणि v1 सामग्री अभिज्ञापकांना](https://docs.ipfs.tech/concepts/content-addressing/), आणि निर्देशिकांसह सामग्री अभिज्ञापकांना समर्थन देते (उदा. `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata`)

उदाहरण:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//This example code is for a Crypto coven subgraph. The above ipfs hash is a directory with token metadata for all crypto coven NFTs.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //This creates a path to the metadata for a single Crypto coven NFT. It concats the directory with "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

हे एक नवीन फाइल डेटा स्रोत तयार करेल, जे ग्राफ नोडच्या कॉन्फिगर केलेल्या IPFS एंडपॉईंटचे मतदान करेल, तो सापडला नाही तर पुन्हा प्रयत्न करेल. फाइल सापडल्यावर, फाइल डेटा स्रोत हँडलर कार्यान्वित केला जाईल.

हे उदाहरण पालक `टोकन` घटक आणि परिणामी `टोकनमेटाडेटा` घटक यांच्यातील लुकअप म्हणून CID वापरत आहे.

> पूर्वी, फाईल आणण्यासाठी सबग्राफ डेव्हलपरने `ipfs.cat(CID)` ला कॉल केला असता

अभिनंदन, तुम्ही फाइल डेटा स्रोत वापरत आहात!

#### तुमचे सबग्राफ उपयोजित करत आहे

तुम्ही आता कोणत्याही ग्राफ नोडवर तुमचा सबग्राफ `बिल्ड` आणि `डिप्लॉय` करू शकता >=v0.30.0-rc.0.

#### मर्यादा

फाइल डेटा स्रोत हँडलर आणि संस्था इतर सबग्राफ संस्थांपासून वेगळ्या केल्या जातात, ते कार्यान्वित केल्यावर ते निर्धारवादी आहेत याची खात्री करून आणि साखळी-आधारित डेटा स्रोतांचे दूषित होणार नाही याची खात्री करतात. विशिष्ट असणे:

- फाइल डेटा स्त्रोतांद्वारे तयार केलेल्या संस्था अपरिवर्तनीय आहेत आणि अद्यतनित केल्या जाऊ शकत नाहीत
- फाइल डेटा स्रोत हँडलर इतर फाइल डेटा स्रोतांमधून संस्थांमध्ये प्रवेश करू शकत नाहीत
- फाईल डेटा स्रोतांशी संबंधित संस्थांमध्ये साखळी-आधारित हँडलर्सद्वारे प्रवेश केला जाऊ शकत नाही

> बहुतेक वापर-प्रकरणांसाठी ही मर्यादा समस्याप्रधान नसावी, परंतु काहींसाठी ते जटिलता आणू शकते. सबग्राफमध्‍ये तुमच्‍या फाईल-आधारित डेटाचे मॉडेल बनवण्‍यात तुम्‍हाला समस्या येत असल्‍यास कृपया डिस्‍कॉर्ड द्वारे संपर्क साधा!

याव्यतिरिक्त, फाइल डेटा स्रोतावरून डेटा स्रोत तयार करणे शक्य नाही, मग ते ऑनचेन डेटा स्रोत असो किंवा अन्य फाइल डेटा स्रोत. भविष्यात हे निर्बंध उठवले जाऊ शकतात.

#### चांगला सराव

तुम्ही एनएफटी मेटाडेटाला संबंधित टोकनशी लिंक करत असल्यास, टोकन एंटिटीमधील मेटाडेटा घटकाचा संदर्भ देण्यासाठी मेटाडेटाचा IPFS हॅश वापरा. आयडी म्हणून IPFS हॅश वापरून मेटाडेटा घटक जतन करा.

फाइल डेटा स्रोत तयार करताना तुम्ही [डेटास्रोत संदर्भ](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) वापरू शकता अतिरिक्त माहिती पास करा जी फाइल डेटा स्रोत हँडलरकडे उपलब्ध असेल.

तुमच्याकडे अनेक वेळा रीफ्रेश केलेल्या संस्था असल्यास, IPFS हॅश वापरून अद्वितीय फाइल-आधारित संस्था तयार करा & एंटिटी आयडी आणि साखळी-आधारित घटकामध्ये व्युत्पन्न फील्ड वापरून त्यांचा संदर्भ द्या.

> आम्ही वरील शिफारसी सुधारण्यासाठी कार्य करत आहोत, त्यामुळे क्वेरी फक्त "सर्वात अलीकडील" आवृत्ती परत करतात

#### ओळखलेले समस्या

फाइल डेटा स्रोतांना सध्या ABI ची आवश्यकता आहे, जरी ABIs वापरले जात नसले तरी ([समस्या](https://github.com/graphprotocol/graph-cli/issues/961)). वर्कअराउंड म्हणजे कोणताही ABI जोडणे.

फाइल डेटा स्रोतांसाठी हँडलर फाईल्समध्ये असू शकत नाहीत जे `eth_call` कॉन्ट्रॅक्ट बाइंडिंग आयात करतात, "अज्ञात आयात: `ethereum::ethereum.call` परिभाषित केले गेले नाहीत" ([ समस्या](https://github.com/graphprotocol/graph-cli/issues/4309)). वर्कअराउंड म्हणजे समर्पित फाइलमध्ये फाइल डेटा स्रोत हँडलर तयार करणे.

#### उदाहरणे

[क्रिप्टो कोव्हन सबग्राफ स्थलांतर](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### संदर्भ

[GIP फाइल डेटा स्रोत](https://forum.thegraph.com/t/gip-file-data-sources/2721)
