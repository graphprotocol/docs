---
title: सबग्राफ तयार करणे
---

A subgraph extracts data from a blockchain, processing it and storing it so that it can be easily queried via GraphQL.

![सबग्राफ परिभाषित करणे](/img/defining-a-subgraph.png)

The subgraph definition consists of a few files:

- `subgraph.yaml`: a YAML file containing the subgraph manifest

- `schema.graphql`: एक GraphQL स्कीमा जो तुमच्या सबग्राफसाठी कोणता डेटा संग्रहित केला जातो आणि GraphQL द्वारे त्याची क्वेरी कशी करावी हे परिभाषित करते

- `AssemblyScript Mappings`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) code that translates from the event data to the entities defined in your schema (e.g. `mapping.ts` in this tutorial)

> In order to use your subgraph on The Graph's decentralized network, you will need to [create an API key](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key). It is recommended that you [add signal](/network/curating/#how-to-signal) to your subgraph with at least [10,000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network).

तुम्ही मॅनिफेस्ट फाइलच्या सामग्रीबद्दल तपशीलात जाण्यापूर्वी, तुम्हाला [ग्राफ CLI](https://github.com/graphprotocol/graph-cli) स्थापित करणे आवश्यक आहे जे तुम्हाला तयार करण्यासाठी आवश्यक असेल. आणि सबग्राफ तैनात करा.

## Install the Graph CLI

आलेख CLI JavaScript मध्ये लिहिलेले आहे, आणि ते वापरण्यासाठी तुम्हाला `यार्न` किंवा `npm` स्थापित करावे लागेल; असे गृहीत धरले जाते की तुमच्याकडे पुढील गोष्टींमध्ये सूत आहे.

तुमच्याकडे `यार्न` आल्यावर, चालवून आलेख CLI स्थापित करा

**यार्नसह स्थापित करा:**

```bash
yarn global add @graphprotocol/graph-cli
```

**सह स्थापित करा npm:**

```bash
npm install -g @graphprotocol/graph-cli
```

एकदा स्थापित केल्यानंतर, `graph init` कमांडचा वापर नवीन सबग्राफ प्रोजेक्ट सेट करण्यासाठी केला जाऊ शकतो, एकतर विद्यमान करारातून किंवा उदाहरण सबग्राफमधून. ही कमांड `graph init --product subgraph-studio` मध्ये पास करून सबग्राफ स्टुडिओवर सबग्राफ तयार करण्यासाठी वापरली जाऊ शकते. जर तुमच्याकडे आधीपासून तुमच्या पसंतीच्या नेटवर्कवर स्मार्ट कॉन्ट्रॅक्ट तैनात केले असेल, तर त्या कॉन्ट्रॅक्टमधून नवीन सबग्राफ बूटस्ट्रॅप करणे हा सुरू करण्याचा एक चांगला मार्ग असू शकतो.

## From An Existing Contract

खालील कमांड एक सबग्राफ तयार करते जे विद्यमान कराराच्या सर्व घटनांना अनुक्रमित करते. ते इथरस्कॅन वरून ABI करार मिळवण्याचा प्रयत्न करते आणि स्थानिक फाइल मार्गाची विनंती करण्यासाठी परत येते. पर्यायी युक्तिवादांपैकी कोणतेही गहाळ असल्यास, ते तुम्हाला परस्परसंवादी फॉर्ममधून घेऊन जाते.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

The `<SUBGRAPH_SLUG>` is the ID of your subgraph in Subgraph Studio, it can be found on your subgraph details page.

## From An Example Subgraph

दुसरा मोड `graph init` सपोर्ट करतो तो उदाहरण सबग्राफमधून नवीन प्रोजेक्ट तयार करतो. खालील कमांड हे करते:

```sh
आलेख init --studio <SUBGRAPH_SLUG>
```

उदाहरण सबग्राफ हे Dani Grant च्या ग्रॅव्हिटी कॉन्ट्रॅक्टवर आधारित आहे जे वापरकर्ता अवतार व्यवस्थापित करते आणि `NewGravatar` किंवा `UpdateGravatar` इव्हेंट जेव्हाही अवतार तयार किंवा अपडेट केले जातात. सबग्राफ ग्राफ नोड स्टोअरमध्ये `Gravatar` संस्था लिहून आणि हे इव्हेंटनुसार अपडेट केले जातील याची खात्री करून हे इव्हेंट हाताळते. या उदाहरणासाठी सबग्राफ मॅनिफेस्ट बनवणार्‍या फाइल्सवर पुढील विभाग जातील.

## Add New dataSources To An Existing Subgraph

Since `v0.31.0` the `graph-cli` supports adding new dataSources to an existing subgraph through the `graph add` command.

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Options:

      --abi <path>              Path to the contract ABI (default: download from Etherscan)
      --contract-name           Name of the contract (default: Contract)
      --merge-entities          Whether to merge entities with the same name (default: false)
      --network-file <path>     Networks config file path (default: "./networks.json")
```

`add` कमांड इथरस्कॅनमधून ABI आणेल (जोपर्यंत ABI पथ `--abi` पर्यायाने निर्दिष्ट केला जात नाही), आणि नवीन `डेटास्रोत` तयार करेल. > त्याच प्रकारे `graph init` कमांड `डेटास्रोत` `---करारातून` तयार करते, त्यानुसार स्कीमा आणि मॅपिंग अद्यतनित करते.

The `--merge-entities` option identifies how the developer would like to handle `entity` and `event` name conflicts:

- If `true`: the new `dataSource` should use existing `eventHandlers` & `entities`.
- If `false`: a new entity & event handler should be created with `${dataSourceName}{EventName}`.

The contract `address` will be written to the `networks.json` for the relevant network.

> **टीप:** परस्परसंवादी क्ली वापरताना, यशस्वीरित्या `ग्राफ इनिट` चालवल्यानंतर, तुम्हाला एक नवीन `डेटास्रोत` जोडण्यासाठी सूचित केले जाईल.

## सबग्राफ मॅनिफेस्ट

सबग्राफ मॅनिफेस्ट `subgraph.yaml` स्मार्ट कॉन्ट्रॅक्ट्स तुमच्या सबग्राफ इंडेक्सेस परिभाषित करतो, या कॉन्ट्रॅक्टमधील कोणत्या इव्हेंट्सकडे लक्ष द्यायचे आणि ग्राफ नोड स्टोअर करत असलेल्या आणि क्वेरी करण्याची परवानगी देणार्‍या घटकांसाठी इव्हेंट डेटा कसा मॅप करायचा. सबग्राफ मॅनिफेस्टसाठी संपूर्ण तपशील [येथे](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md) आढळू शकतात.

For the example subgraph, `subgraph.yaml` is:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
      endBlock: 7175245
    context:
      foo:
        type: Bool
        data: true
      bar:
        type: String
        data: 'bar'
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

मॅनिफेस्टसाठी अद्यतनित करण्याच्या महत्त्वाच्या नोंदी आहेत:

- `description`: a human-readable description of what the subgraph is. This description is displayed by the Graph Explorer when the subgraph is deployed to the hosted service.

- `repository`: the URL of the repository where the subgraph manifest can be found. This is also displayed by The Graph Explorer.

- `वैशिष्ट्ये`: सर्व वापरलेल्या [वैशिष्ट्य](#experimental-features) नावांची सूची.

- `dataSources.source`: स्मार्ट कॉन्ट्रॅक्टचा पत्ता सबग्राफ स्त्रोत आणि वापरण्यासाठी स्मार्ट कॉन्ट्रॅक्टचा ABI. पत्ता ऐच्छिक आहे; ते वगळणे सर्व करारांमधून जुळणारे इव्हेंट अनुक्रमित करण्यास अनुमती देते.

- `dataSources.source.startBlock`: ब्लॉकची पर्यायी संख्या ज्यावरून डेटा स्रोत अनुक्रमणिका सुरू करतो. बहुतेक प्रकरणांमध्ये, आम्ही ज्या ब्लॉकमध्ये करार तयार केला होता तो वापरण्याचा सल्ला देतो.

- `dataSources.source.endBlock`: The optional number of the block that the data source stops indexing at, including that block. Minimum spec version required: `0.0.9`.

- `dataSources.context`: key-value pairs that can be used within subgraph mappings. Supports various data types like `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, and `BigInt`. Each variable needs to specify its `type` and `data`. These context variables are then accessible in the mapping files, offering more configurable options for subgraph development.

- `dataSources.mapping.entities`: the entities that the data source writes to the store. The schema for each entity is defined in the schema.graphql file.

- `dataSources.mapping.abis`: स्त्रोत करारासाठी एक किंवा अधिक नावाच्या ABI फाइल्स तसेच तुम्ही मॅपिंगमधून परस्परसंवाद करता अशा इतर स्मार्ट करारांसाठी.

- `dataSources.mapping.eventHandlers`: या सबग्राफवर प्रतिक्रिया देणारे स्मार्ट कॉन्ट्रॅक्ट इव्हेंट आणि मॅपिंगमधील हँडलर्सची यादी करते—./src/mapping.ts उदाहरणामध्ये—जे या इव्हेंटचे स्टोअरमधील घटकांमध्ये रूपांतर करतात.

- `dataSources.mapping.callHandlers`: या सबग्राफवर प्रतिक्रिया देणारे स्मार्ट कॉन्ट्रॅक्ट फंक्शन्स सूचीबद्ध करते आणि मॅपिंगमधील हँडलर्स जे इनपुट आणि आउटपुटला स्टोअरमधील संस्थांमध्ये फंक्शन कॉलमध्ये रूपांतरित करतात.

- `dataSources.mapping.blockHandlers`: हा सबग्राफ ज्या ब्लॉक्सवर प्रतिक्रिया देतो आणि मॅपिंगमधील हँडलर चेनमध्ये ब्लॉक जोडला जातो तेव्हा रन करण्यासाठी सूचीबद्ध करतो. फिल्टरशिवाय, ब्लॉक हँडलर प्रत्येक ब्लॉकला चालवला जाईल. हँडलरला `kind: call` सह `filter` फील्ड जोडून पर्यायी कॉल-फिल्टर प्रदान केले जाऊ शकते. ब्लॉकमध्ये डेटा स्रोत करारासाठी किमान एक कॉल असेल तरच हे हँडलर चालवेल.

एकच सबग्राफ एकाधिक स्मार्ट कॉन्ट्रॅक्ट्समधील डेटा अनुक्रमित करू शकतो. प्रत्येक करारासाठी एक एंट्री जोडा ज्यामधून डेटा `डेटास्रोत` अॅरेमध्ये अनुक्रमित करणे आवश्यक आहे.

The triggers for a data source within a block are ordered using the following process:

1. Event and call triggers are first ordered by transaction index within the block.
2. समान व्यवहारामधील इव्हेंट आणि कॉल ट्रिगर्स एक नियम वापरून ऑर्डर केले जातात: प्रथम इव्हेंट ट्रिगर नंतर कॉल ट्रिगर, प्रत्येक प्रकार मॅनिफेस्टमध्ये परिभाषित केलेल्या क्रमाचा आदर करतो.
3. Block triggers are run after event and call triggers, in the order they are defined in the manifest.

These ordering rules are subject to change.

### ABIs मिळवणे

The ABI file(s) must match your contract(s). There are a few ways to obtain ABI files:

- If you are building your own project, you will likely have access to your most current ABIs.
- तुम्ही सार्वजनिक प्रकल्पासाठी सबग्राफ तयार करत असल्यास, तुम्ही तो प्रकल्प तुमच्या संगणकावर डाउनलोड करू शकता आणि [`ट्रफल कंपाइल`](https://truffleframework.com/docs/truffle/overview) वापरून किंवा कंपाइल करण्यासाठी सोल्क वापरून ABI मिळवू शकता.
- तुम्ही [Etherscan](https://etherscan.io/) वर ABI देखील शोधू शकता, परंतु हे नेहमीच विश्वसनीय नसते, कारण तेथे अपलोड केलेला ABI कालबाह्य असू शकतो. तुमच्याकडे योग्य ABI असल्याची खात्री करा, अन्यथा तुमचा सबग्राफ चालवणे अयशस्वी होईल.

## ग्राफक्यूएल स्कीमा

तुमच्या सबग्राफसाठी स्कीमा `schema.graphql` फाइलमध्ये आहे. GraphQL स्कीमा GraphQL इंटरफेस व्याख्या भाषा वापरून परिभाषित केले आहेत. तुम्ही कधीही GraphQL स्कीमा लिहिला नसल्यास, GraphQL प्रकार प्रणालीवर हा प्राइमर तपासण्याची शिफारस केली जाते. GraphQL स्कीमासाठी संदर्भ दस्तऐवजीकरण [GraphQL API](/querying/graphql-api) विभागात आढळू शकते.

## संस्था परिभाषित करणे

संस्था परिभाषित करण्यापूर्वी, एक पाऊल मागे घेणे आणि तुमचा डेटा कसा संरचित आणि लिंक केलेला आहे याचा विचार करणे महत्त्वाचे आहे. सबग्राफ स्कीमामध्ये परिभाषित केलेल्या डेटा मॉडेल आणि सबग्राफद्वारे अनुक्रमित घटकांविरुद्ध सर्व क्वेरी केल्या जातील. यामुळे, सबग्राफ स्कीमा तुमच्या dapp च्या गरजांशी जुळेल अशा प्रकारे परिभाषित करणे चांगले आहे. इव्हेंट किंवा फंक्शन्स ऐवजी "डेटा असलेले ऑब्जेक्ट्स" म्हणून घटकांची कल्पना करणे उपयुक्त ठरू शकते.

The Graph सह, तुम्ही फक्त `schema.graphql` मध्ये अस्तित्व प्रकार परिभाषित करता, आणि ग्राफ नोड एकल उदाहरणे आणि त्या घटक प्रकाराच्या संग्रहासाठी क्वेरी करण्यासाठी उच्च स्तरीय फील्ड तयार करेल. प्रत्येक प्रकार जो अस्तित्व असावा त्याला `@entity` निर्देशासह भाष्य करणे आवश्यक आहे. डीफॉल्टनुसार, घटक बदलण्यायोग्य असतात, याचा अर्थ मॅपिंग विद्यमान घटक लोड करू शकतात, त्यामध्ये सुधारणा करू शकतात आणि त्या घटकाची नवीन आवृत्ती संग्रहित करू शकतात. परिवर्तनशीलता किंमतीवर येते आणि ज्या घटकांसाठी हे ज्ञात आहे की ते कधीही सुधारित केले जाणार नाहीत, उदाहरणार्थ, त्यांच्यामध्ये केवळ साखळीतून शब्दशः काढलेला डेटा असतो, त्यांना `@entity सह अपरिवर्तनीय म्हणून चिन्हांकित करण्याची शिफारस केली जाते. (अपरिवर्तनीय: खरे)`. मॅपिंग अपरिवर्तनीय घटकांमध्ये बदल करू शकतात जोपर्यंत ते बदल त्याच ब्लॉकमध्ये होतात ज्यामध्ये अस्तित्व तयार केले गेले होते. अपरिवर्तनीय संस्था लिहिण्यासाठी आणि क्वेरी करण्यासाठी खूप वेगवान असतात आणि म्हणून जेव्हा शक्य असेल तेव्हा वापरल्या पाहिजेत.

### उत्तम उदाहरण

The `Gravatar` entity below is structured around a Gravatar object and is a good example of how an entity could be defined.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### वाईट उदाहरण

खालील उदाहरण `GravatarAccepted` आणि `GravatarDeclined` घटक इव्हेंटवर आधारित आहेत. 1:1 घटकांना इव्हेंट किंवा फंक्शन कॉल मॅप करण्याची शिफारस केलेली नाही.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### पर्यायी आणि आवश्यक फील्ड

घटक फील्ड आवश्यक किंवा पर्यायी म्हणून परिभाषित केले जाऊ शकतात. आवश्यक फील्ड स्कीमामधील `!` द्वारे सूचित केले जातात. मॅपिंगमध्ये आवश्यक फील्ड सेट केले नसल्यास, फील्डची चौकशी करताना तुम्हाला ही त्रुटी प्राप्त होईल:

```
नॉन-नल फील्ड 'नावासाठी शून्य मूल्य सोडवले
```

प्रत्येक घटकामध्ये एक `id` फील्ड असणे आवश्यक आहे, जे `Bytes!` किंवा `String!` प्रकारचे असणे आवश्यक आहे. सामान्यतः `बाइट्स!` वापरण्याची शिफारस केली जाते, जोपर्यंत `id` मध्ये मानवी वाचता येण्याजोगा मजकूर नसतो, कारण `Bytes!` आयडी असलेल्या संस्था लिहिण्यास जलद असतील. आणि `स्ट्रिंग!` `id` सह क्वेरी करा. `id` फील्ड प्राथमिक की म्हणून काम करते आणि समान प्रकारच्या सर्व घटकांमध्ये अद्वितीय असणे आवश्यक आहे. ऐतिहासिक कारणांसाठी, `ID!` हा प्रकार देखील स्वीकारला जातो आणि `String!` साठी समानार्थी शब्द आहे.

काही घटक प्रकारांसाठी `id` हे इतर दोन घटकांच्या आयडीवरून तयार केले जाते; ते `concat` वापरून शक्य आहे, उदा., `left` च्या id वरून id तयार करण्यासाठी `let id = left.id.concat(right.id)` > आणि `उजवीकडे`. त्याचप्रमाणे, विद्यमान घटकाच्या आयडी आणि काउंटर `count` वरून आयडी तयार करण्यासाठी, `let id = left.id.concatI32(count)` वापरता येईल. अशा सर्व घटकांसाठी `left` ची लांबी समान असेल तोपर्यंत युनिक आयडी तयार करण्याची हमी दिली जाते, उदाहरणार्थ, `left.id` हा `पत्ता आहे `.

### अंगभूत स्केलर प्रकार

#### ग्राफक्यूएल समर्थित स्केलर

We support the following scalars in our GraphQL API:

| प्रकार | वर्णन |
| --- | --- |
| `बाइट्स` | Byte array, represented as a hexadecimal string. Commonly used for Ethereum hashes and addresses. |
| `स्ट्रिंग` | Scalar for `string` values. Null characters are not supported and are automatically removed. |
| `बुलियन` | `बूलियन` मूल्यांसाठी स्केलर. |
| `इंट` | GraphQL spec `Int` ला ३२ बाइट्सचा आकार ठरवतो. |
| `Int8` | An 8-byte signed integer, also known as a 64-bit signed integer, can store values in the range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. Prefer using this to represent `i64` from ethereum. |
| `BigInt` | मोठे पूर्णांक. इथरियमच्या `uint32`, `int64`, `uint64`, ..., `uint256` प्रकारांसाठी वापरले जाते. टीप: `uint32` खाली सर्व काही, जसे की `int32`, `uint24` किंवा `int8` `i32` म्हणून प्रस्तुत केले जाते 0>. |
| `बिग डेसिमल` | `BigDecimal` उच्च सुस्पष्टता दशांश एक महत्त्वपूर्ण आणि घातांक म्हणून प्रस्तुत केले जाते. घातांक श्रेणी −6143 ते +6144 पर्यंत आहे. 34 लक्षणीय अंकांपर्यंत पूर्णांक. |

#### एनम्स

You can also create enums within a schema. Enums have the following syntax:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

एकदा enum स्कीमामध्ये परिभाषित केल्यावर, तुम्ही enum मूल्याचे स्ट्रिंग प्रतिनिधित्व एखाद्या घटकावर enum फील्ड सेट करण्यासाठी वापरू शकता. उदाहरणार्थ, तुम्ही प्रथम तुमची संस्था परिभाषित करून आणि नंतर `entity.tokenStatus = "SecondOwner"` सह फील्ड सेट करून `tokenStatus` ला `SecondOwner` वर सेट करू शकता. इनम फील्डसह टोकन अस्तित्व कसे दिसेल हे खालील उदाहरण दाखवते:

एनम्स लिहिण्याबद्दल अधिक तपशील [GraphQL दस्तऐवजीकरण](https://graphql.org/learn/schema/) मध्ये आढळू शकतात.

#### अस्तित्व संबंध

एखाद्या घटकाचा तुमच्या स्कीमामधील एक किंवा अधिक इतर घटकांशी संबंध असू शकतो. हे नातेसंबंध तुमच्या प्रश्नांमध्ये असू शकतात. आलेखामधील संबंध दिशाहीन आहेत. नात्याच्या "शेवट" वर एकदिशात्मक संबंध परिभाषित करून द्विदिशात्मक संबंधांचे अनुकरण करणे शक्य आहे.

Relationships are defined on entities just like any other field except that the type specified is that of another entity.

#### वन-टू-वन संबंध

Define a `Transaction` entity type with an optional one-to-one relationship with a `TransactionReceipt` entity type:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### एक-ते-अनेक संबंध

Define a `TokenBalance` entity type with a required one-to-many relationship with a Token entity type:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### उलटे लुकअप

`@derivedFrom` फील्डद्वारे एखाद्या घटकावर उलट लुकअप परिभाषित केले जाऊ शकतात. हे घटकावर एक आभासी फील्ड तयार करते ज्याची चौकशी केली जाऊ शकते परंतु मॅपिंग API द्वारे व्यक्तिचलितपणे सेट केली जाऊ शकत नाही. उलट, ते इतर घटकावर परिभाषित केलेल्या नातेसंबंधातून प्राप्त झाले आहे. अशा संबंधांसाठी, नातेसंबंधाच्या दोन्ही बाजू संचयित करणे क्वचितच अर्थपूर्ण आहे आणि अनुक्रमणिका आणि क्वेरी कार्यप्रदर्शन दोन्ही चांगले होईल जेव्हा फक्त एक बाजू संग्रहित केली जाते आणि दुसरी साधित केली जाते.

एक-ते-अनेक संबंधांसाठी, संबंध नेहमी 'एका' बाजूला साठवले पाहिजेत आणि 'अनेक' बाजू नेहमी काढल्या पाहिजेत. 'अनेक' बाजूंवर संस्थांचा अ‍ॅरे संचयित करण्याऐवजी अशा प्रकारे नातेसंबंध संचयित केल्याने, अनुक्रमणिका आणि सबग्राफ क्वेरी या दोन्हीसाठी नाटकीयरित्या चांगले कार्यप्रदर्शन होईल. सर्वसाधारणपणे, घटकांचे अ‍ॅरे संग्रहित करणे जितके व्यावहारिक आहे तितके टाळले पाहिजे.

#### उदाहरण

We can make the balances for a token accessible from the token by deriving a `tokenBalances` field:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### अनेक-ते-अनेक संबंध

अनेक-ते-अनेक नातेसंबंधांसाठी, जसे की वापरकर्ते जे कोणत्याही संस्थेशी संबंधित असू शकतात, सर्वात सरळ, परंतु सामान्यतः सर्वात कार्यक्षम नसतात, संबंध मॉडेल करण्याचा मार्ग समाविष्ट असलेल्या दोन घटकांपैकी प्रत्येकामध्ये एक अॅरे आहे. नातेसंबंध सममितीय असल्यास, नातेसंबंधाची फक्त एक बाजू संग्रहित करणे आवश्यक आहे आणि दुसरी बाजू मिळवता येते.

#### उदाहरण

`वापरकर्ता` घटक प्रकारापासून `संस्थे` घटक प्रकारापर्यंत रिव्हर्स लुकअप परिभाषित करा. खालील उदाहरणामध्ये, हे `संस्था` घटकामधील `सदस्य` विशेषता शोधून साध्य केले जाते. क्वेरींमध्ये, `वापरकर्ता` वरील `संस्था` फील्ड वापरकर्त्याचा आयडी समाविष्ट असलेल्या सर्व `संस्था` घटक शोधून सोडवले जाईल.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

A more performant way to store this relationship is through a mapping table that has one entry for each `User` / `Organization` pair with a schema like

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

This approach requires that queries descend into one additional level to retrieve, for example, the organizations for users:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

अनेक-ते-अनेक संबंध संचयित करण्याच्या या अधिक विस्तृत मार्गामुळे सबग्राफसाठी कमी डेटा संग्रहित केला जाईल आणि म्हणूनच अनुक्रमणिका आणि क्वेरीसाठी नाटकीयरित्या वेगवान असलेल्या सबग्राफमध्ये.

#### स्कीमामध्ये टिप्पण्या जोडत आहे

GraphQL स्पेसनुसार, दुहेरी कोटेशन `""` वापरून स्कीमा एंटिटी विशेषतांवर टिप्पण्या जोडल्या जाऊ शकतात. हे खालील उदाहरणात स्पष्ट केले आहे:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## पूर्ण मजकूर शोध फील्ड परिभाषित करणे

मजकूर शोध इनपुटवर आधारित फुलटेक्स्ट शोध क्वेरी फिल्टर आणि रँक घटक. फुलटेक्स्ट क्वेरी अनुक्रमित मजकूर डेटाशी तुलना करण्यापूर्वी स्टेममध्ये क्वेरी मजकूर इनपुटवर प्रक्रिया करून समान शब्दांसाठी जुळणी परत करण्यास सक्षम आहेत.

पूर्ण मजकूर क्वेरी व्याख्येमध्ये क्वेरीचे नाव, मजकूर फील्डवर प्रक्रिया करण्यासाठी वापरला जाणारा भाषा शब्दकोष, परिणाम ऑर्डर करण्यासाठी वापरले जाणारे रँकिंग अल्गोरिदम आणि शोधामध्ये समाविष्ट फील्ड समाविष्ट असतात. प्रत्येक फुलटेक्स्ट क्वेरी एकाधिक फील्डमध्ये असू शकते, परंतु सर्व समाविष्ट फील्ड एकाच घटक प्रकारातील असणे आवश्यक आहे.

To add a fulltext query, include a `_Schema_` type with a fulltext directive in the GraphQL schema.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

The example `bandSearch` field can be used in queries to filter `Band` entities based on the text documents in the `name`, `description`, and `bio` fields. Jump to [GraphQL API - Queries](/querying/graphql-api#queries) for a description of the fulltext search API and more example usage.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[वैशिष्ट्य व्यवस्थापन](#experimental-features):** `specVersion` `0.0.4</code वरून > आणि पुढे, सबग्राफ मॅनिफेस्टमधील <code>वैशिष्ट्ये` विभागांतर्गत `fullTextSearch` घोषित करणे आवश्यक आहे.

### भाषा समर्थित

भिन्न भाषा निवडल्याने पूर्ण मजकूर शोध API वर निश्चित, काहीवेळा सूक्ष्म असले तरी परिणाम होईल. फुलटेक्स्ट क्वेरी फील्डद्वारे कव्हर केलेले फील्ड निवडलेल्या भाषेच्या संदर्भात तपासले जातात, म्हणून विश्लेषण आणि शोध क्वेरीद्वारे तयार केलेले लेक्सेम भाषेनुसार भिन्न असतात. उदाहरणार्थ: समर्थित तुर्की शब्दकोश वापरताना "टोकन" हे "टोक" वर स्टेम केले जाते, तर अर्थातच, इंग्रजी शब्दकोश "टोकन" वर स्टेम करेल.

समर्थित भाषा शब्दकोश:

| कोड  | शब्दकोश    |
| ---- | ---------- |
| सोपे | सामान्य    |
| da   | डॅनिश      |
| nl   | डच         |
| en   | इंग्रजी    |
| fi   | फिनिश      |
| fr   | फ्रेंच     |
| de   | जर्मन      |
| hu   | हंगेरियन   |
| ते   | इटालियन    |
| नाही | नॉर्वेजियन |
| pt   | पोर्तुगीज  |
| ro   | रोमानियन   |
| ru   | रशियन      |
| es   | स्पॅनिश    |
| sv   | स्वीडिश    |
| tr   | तुर्की     |

### रँकिंग अल्गोरिदम

परिणाम ऑर्डर करण्यासाठी समर्थित अल्गोरिदम:

| अल्गोरिदम     | वर्णन                                                                  |
| ------------- | ---------------------------------------------------------------------- |
| रँक           | निकाल ऑर्डर करण्यासाठी फुलटेक्स्ट क्वेरीची जुळणी गुणवत्ता (0-1) वापरा. |
| proximityRank | रँक प्रमाणेच पण सामन्यांच्या समीपतेचाही समावेश आहे.                    |

## मॅपिंग लेखन

मॅपिंग्स एका विशिष्ट स्त्रोताकडून डेटा घेतात आणि आपल्या स्कीमामध्ये परिभाषित केलेल्या घटकांमध्ये त्याचे रूपांतर करतात. मॅपिंग्स [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) नावाच्या [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki) नावाच्या उपसंचात लिहिल्या जातात जे WASM ([WebAssembly](https://webassembly.org/)) मध्ये संकलित केले जाऊ शकतात. असेंबलीस्क्रिप्ट सामान्य TypeScript पेक्षा कठोर आहे, तरीही एक परिचित वाक्यरचना प्रदान करते.

`mapping.eventHandlers` अंतर्गत `subgraph.yaml` मध्ये परिभाषित केलेल्या प्रत्येक इव्हेंट हँडलरसाठी, त्याच नावाचे निर्यात केलेले कार्य तयार करा. प्रत्येक हँडलरने हाताळल्या जात असलेल्या इव्हेंटच्या नावाशी संबंधित प्रकारासह `इव्हेंट` नावाचा एकच पॅरामीटर स्वीकारला पाहिजे.

In the example subgraph, `src/mapping.ts` contains handlers for the `NewGravatar` and `UpdatedGravatar` events:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

पहिला हँडलर `NewGravatar` इव्हेंट घेतो आणि `नवीन Gravatar(event.params.id.toHex())` सह एक नवीन `Gravatar` अस्तित्व तयार करतो, पॉप्युलेट करतो संबंधित इव्हेंट पॅरामीटर्स वापरून संस्था फील्ड. हे घटक उदाहरण `event.params.id.toHex()` च्या id मूल्यासह, व्हेरिएबल `gravatar` द्वारे प्रस्तुत केले जाते.

दुसरा हँडलर ग्राफ नोड स्टोअरमधून विद्यमान `Gravatar` लोड करण्याचा प्रयत्न करतो. ते अद्याप अस्तित्वात नसल्यास, ते मागणीनुसार तयार केले जाते. नंतर `gravatar.save()` वापरून स्टोअरमध्ये परत सेव्ह करण्यापूर्वी नवीन इव्हेंट पॅरामीटर्सशी जुळण्यासाठी घटक अपडेट केला जातो.

### नवीन संस्था तयार करण्यासाठी शिफारस केलेले आयडी

प्रत्येक घटकाकडे एक `id` असणे आवश्यक आहे जे समान प्रकारच्या सर्व घटकांमध्ये अद्वितीय आहे. जेव्हा अस्तित्व तयार केले जाते तेव्हा घटकाचे `id` मूल्य सेट केले जाते. नवीन घटक तयार करताना विचारात घेण्यासाठी खाली काही शिफारस केलेली `id` मूल्ये आहेत. टीप: `id` चे मूल्य `स्ट्रिंग` असणे आवश्यक आहे.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

We provide the [Graph Typescript Library](https://github.com/graphprotocol/graph-ts) which contains utilities for interacting with the Graph Node store and conveniences for handling smart contract data and entities. You can use this library in your mappings by importing `@graphprotocol/graph-ts` in `mapping.ts`.

## कोड जनरेशन

स्मार्ट कॉन्ट्रॅक्ट्स, इव्हेंट्स आणि संस्थांसोबत काम करणे सोपे आणि टाइप-सुरक्षित करण्यासाठी, ग्राफ CLI सबग्राफच्या GraphQL स्कीमा आणि डेटा स्रोतांमध्ये समाविष्ट केलेल्या कॉन्ट्रॅक्ट ABIs मधून असेंबलीस्क्रिप्ट प्रकार व्युत्पन्न करू शकतो.

यासह केले जाते

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

परंतु बर्‍याच प्रकरणांमध्ये, सबग्राफ आधीपासूनच `package.json` द्वारे कॉन्फिगर केलेले असतात जे तुम्हाला ते साध्य करण्यासाठी खालीलपैकी एक चालवण्याची परवानगी देतात:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

हे `subgraph.yaml` मध्ये नमूद केलेल्या ABI फाइल्समधील प्रत्येक स्मार्ट करारासाठी असेंब्लीस्क्रिप्ट क्लास तयार करेल, ज्यामुळे तुम्हाला हे करार मॅपिंगमधील विशिष्ट पत्त्यांवर बंधनकारक करता येतील आणि ब्लॉकच्या विरूद्ध केवळ-वाचनीय करार पद्धती कॉल करता येतील. प्रक्रिया केली. हे प्रत्येक कॉन्ट्रॅक्ट इव्हेंटसाठी इव्हेंट पॅरामीटर्स तसेच ब्लॉक आणि इव्हेंटमधून उद्भवलेल्या व्यवहारासाठी सुलभ प्रवेश प्रदान करण्यासाठी एक वर्ग देखील तयार करेल. हे सर्व प्रकार `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts` वर लिहिलेले आहेत. उदाहरणाच्या सबग्राफमध्ये, हे `generated/Gravity/Gravity.ts` असेल, मॅपिंगना हे प्रकार आयात करण्यास अनुमती देतात.

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

या व्यतिरिक्त, सबग्राफच्या GraphQL स्कीमामध्ये प्रत्येक घटक प्रकारासाठी एक वर्ग तयार केला जातो. हे वर्ग टाइप-सेफ एंटिटी लोडिंग, एंटिटी फील्डमध्ये वाचन आणि लिहिण्याचा अॅक्सेस प्रदान करतात तसेच स्टोअर करण्यासाठी संस्था लिहिण्यासाठी `सेव्ह()` पद्धत प्रदान करतात. सर्व घटक वर्ग `<OUTPUT_DIR>/schema.ts` वर लिहिलेले आहेत, मॅपिंगना ते यासह आयात करण्यास अनुमती देतात

```javascript
import { Gravatar } from '../generated/schema'
```

> **टीप:** मॅनिफेस्टमध्ये समाविष्ट केलेल्या GraphQL स्कीमा किंवा ABI मध्ये प्रत्येक बदलानंतर कोड जनरेशन पुन्हा केले जाणे आवश्यक आहे. सबग्राफ तयार करण्यापूर्वी किंवा उपयोजित करण्यापूर्वी ते किमान एकदा केले जाणे आवश्यक आहे.

कोड जनरेशन तुमचा मॅपिंग कोड `src/mapping.ts` मध्ये तपासत नाही. ग्राफ एक्सप्लोररमध्ये तुमचा सबग्राफ उपयोजित करण्याचा प्रयत्न करण्यापूर्वी तुम्हाला ते तपासायचे असल्यास, तुम्ही `यार्न बिल्ड` चालवू शकता आणि टाइपस्क्रिप्ट कंपायलरला सापडलेल्या कोणत्याही वाक्यरचना त्रुटींचे निराकरण करू शकता.

## डेटा स्रोत टेम्पलेट्स

EVM-सुसंगत स्मार्ट कॉन्ट्रॅक्ट्समधील एक सामान्य नमुना म्हणजे नोंदणी किंवा फॅक्टरी कॉन्ट्रॅक्टचा वापर, जिथे एक करार तयार करतो, व्यवस्थापित करतो किंवा इतर करारांची अनियंत्रित संख्या संदर्भित करतो ज्या प्रत्येकाची स्वतःची स्थिती आणि घटना असतात.

या उप-करारांचे पत्ते कदाचित माहीत नसतील किंवा नसतील आणि यापैकी बरेच करार तयार केले जाऊ शकतात आणि/किंवा कालांतराने जोडले जाऊ शकतात. म्हणूनच, अशा प्रकरणांमध्ये, एकल डेटा स्रोत किंवा डेटा स्त्रोतांची निश्चित संख्या परिभाषित करणे अशक्य आहे आणि अधिक गतिशील दृष्टीकोन आवश्यक आहे: _डेटा स्रोत टेम्पलेट्स_.

### मुख्य करारासाठी डेटा स्रोत

प्रथम, तुम्ही मुख्य करारासाठी नियमित डेटा स्रोत परिभाषित करता. खाली दिलेला स्निपेट [Uniswap](https://uniswap.org) एक्सचेंज फॅक्टरी करारासाठी एक सरलीकृत उदाहरण डेटा स्रोत दर्शवितो. `NewExchange(address,address)` इव्हेंट हँडलर लक्षात ठेवा. जेव्हा कारखाना कराराद्वारे नवीन एक्सचेंज कॉन्ट्रॅक्ट ऑन-चेन तयार केला जातो तेव्हा हे उत्सर्जित होते.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Data Source Templates for Dynamically Created Contracts

त्यानंतर, तुम्ही मॅनिफेस्टमध्ये _डेटा स्रोत टेम्पलेट्स_ जोडता. हे नियमित डेटा स्रोतांसारखेच आहेत, त्याशिवाय त्यांना `स्रोत` अंतर्गत पूर्व-परिभाषित करार पत्ता नाही. सामान्यत:, तुम्ही पालक कराराद्वारे व्यवस्थापित किंवा संदर्भित केलेल्या प्रत्येक प्रकारच्या उप-करारासाठी एक टेम्पलेट परिभाषित कराल.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### डेटा स्रोत टेम्पलेट इन्स्टंट करणे

अंतिम चरणात, तुम्ही टेम्पलेटपैकी एकावरून डायनॅमिक डेटा स्रोत उदाहरण तयार करण्यासाठी तुमचे मुख्य कॉन्ट्रॅक्ट मॅपिंग अपडेट करता. या उदाहरणात, तुम्ही `Exchange` टेम्प्लेट इंपोर्ट करण्यासाठी मुख्य कॉन्ट्रॅक्ट मॅपिंग बदलू शकता आणि नवीन एक्सचेंज कॉन्ट्रॅक्ट इंडेक्सिंग सुरू करण्यासाठी त्यावर `Exchange.create(address)` पद्धत कॉल कराल.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **टीप:** नवीन डेटा स्रोत केवळ तो ज्या ब्लॉकमध्ये तयार केला गेला होता आणि पुढील सर्व ब्लॉकसाठी कॉल्स आणि इव्हेंटवर प्रक्रिया करेल, परंतु ऐतिहासिक डेटावर प्रक्रिया करणार नाही, म्हणजे, डेटावर प्रक्रिया करणार नाही. जे आधीच्या ब्लॉक्समध्ये समाविष्ट आहे.
>
> पूर्वीच्या ब्लॉक्समध्ये नवीन डेटा स्रोताशी संबंधित डेटा असल्यास, कराराची वर्तमान स्थिती वाचून आणि नवीन डेटा स्रोत तयार करताना त्या स्थितीचे प्रतिनिधित्व करणारी संस्था तयार करून तो डेटा अनुक्रमित करणे सर्वोत्तम आहे.

### डेटा स्रोत संदर्भ

डेटा स्रोत संदर्भ टेम्प्लेट इन्स्टंट करताना अतिरिक्त कॉन्फिगरेशन पास करण्याची परवानगी देतात. आमच्या उदाहरणात, समजा एक्सचेंजेस एका विशिष्ट ट्रेडिंग जोडीशी संबंधित आहेत, जे `NewExchange` इव्हेंटमध्ये समाविष्ट आहे. ती माहिती तात्काळ डेटा स्त्रोतामध्ये पास केली जाऊ शकते, जसे की:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Inside a mapping of the `Exchange` template, the context can then be accessed:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

There are setters and getters like `setString` and `getString` for all value types.

## ब्लॉक सुरू करा

`startBlock` ही एक पर्यायी सेटिंग आहे जी तुम्हाला साखळीतील कोणत्या ब्लॉकमधून डेटा स्रोत अनुक्रमणिका सुरू करेल हे परिभाषित करू देते. स्टार्ट ब्लॉक सेट केल्याने डेटा स्त्रोताला अप्रासंगिक असलेले लाखो ब्लॉक्स वगळण्याची परवानगी मिळते. सामान्यतः, सबग्राफ डेव्हलपर `startBlock` सेट करेल ज्या ब्लॉकमध्ये डेटा स्रोताचा स्मार्ट करार तयार केला गेला होता.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Note:** The contract creation block can be quickly looked up on Etherscan:
>
> 1. Search for the contract by entering its address in the search bar.
> 2. Click on the creation transaction hash in the `Contract Creator` section.
> 3. Load the transaction details page where you'll find the start block for that contract.

## हँडलर्सना कॉल करा

इव्हेंट्स कराराच्या स्थितीत संबंधित बदल एकत्रित करण्याचा एक प्रभावी मार्ग प्रदान करतात, तर अनेक करार गॅसच्या किमती ऑप्टिमाइझ करण्यासाठी लॉग तयार करणे टाळतात. या प्रकरणांमध्ये, सबग्राफ डेटा स्त्रोत करारावर केलेल्या कॉलची सदस्यता घेऊ शकतो. फंक्शन सिग्नेचर आणि मॅपिंग हँडलरचा संदर्भ देणारे कॉल हँडलर परिभाषित करून हे साध्य केले जाते जे या फंक्शनवर कॉलवर प्रक्रिया करेल. या कॉल्सवर प्रक्रिया करण्यासाठी, मॅपिंग हँडलरला कॉलमधील टाइप केलेल्या इनपुट आणि आउटपुटसह युक्तिवाद म्हणून `ethereum.Call` प्राप्त होईल. व्यवहाराच्या कॉल साखळीतील कोणत्याही खोलीत केलेले कॉल मॅपिंगला ट्रिगर करतील, प्रॉक्सी कॉन्ट्रॅक्टद्वारे डेटा स्त्रोत करारासह क्रियाकलाप कॅप्चर करण्यास अनुमती देईल.

कॉल हँडलर्स फक्त दोनपैकी एका प्रकरणात ट्रिगर होतील: जेव्हा निर्दिष्ट केलेल्या फंक्शनला कॉन्ट्रॅक्ट व्यतिरिक्त इतर खात्याद्वारे कॉल केले जाते किंवा जेव्हा ते सॉलिडिटीमध्ये बाह्य म्हणून चिन्हांकित केले जाते आणि त्याच कॉन्ट्रॅक्टमधील दुसर्‍या फंक्शनचा भाग म्हणून कॉल केले जाते.

> **टीप:** कॉल हँडलर सध्या पॅरिटी ट्रेसिंग API वर अवलंबून आहेत. काही नेटवर्क, जसे की BNB चेन आणि आर्बिट्रम, या API चे समर्थन करत नाहीत. जर या नेटवर्कपैकी एका सबग्राफ इंडेक्सिंगमध्ये एक किंवा अधिक कॉल हँडलर असतील, तर ते समक्रमण सुरू होणार नाही. सबग्राफ विकसकांनी त्याऐवजी इव्हेंट हँडलर वापरावे. हे कॉल हँडलर्सपेक्षा कितीतरी अधिक कार्यक्षम आहेत, आणि प्रत्येक evm नेटवर्कवर समर्थित आहेत.

### कॉल हँडलरची व्याख्या

To define a call handler in your manifest, simply add a `callHandlers` array under the data source you would like to subscribe to.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`फंक्शन` हे कॉल फिल्टर करण्यासाठी सामान्यीकृत फंक्शन स्वाक्षरी आहे. `हँडलर` गुणधर्म हे तुमच्या मॅपिंगमधील फंक्शनचे नाव आहे जे तुम्ही डेटा सोर्स कॉन्ट्रॅक्टमध्ये टार्गेट फंक्शन कॉल केल्यावर कार्यान्वित करू इच्छिता.

### मॅपिंग कार्य

प्रत्येक कॉल हँडलर एकच पॅरामीटर घेतो ज्याचा प्रकार कॉल फंक्शनच्या नावाशी संबंधित असतो. वरील उदाहरणातील सबग्राफमध्ये, मॅपिंगमध्ये `createGravatar` फंक्शन कॉल केल्यावर आणि वितर्क म्हणून `CreateGravatarCall` पॅरामीटर प्राप्त करण्यासाठी हँडलर असतो:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

`handleCreateGravatar` फंक्शन एक नवीन `CreateGravatarCall` घेते जो `@graphprotocol/graph-ts</ द्वारे प्रदान केलेला <code>ethereum.Call` चा उपवर्ग आहे. code>, ज्यामध्ये कॉलचे टाइप केलेले इनपुट आणि आउटपुट समाविष्ट आहेत. तुम्ही `graph codegen` चालवता तेव्हा तुमच्यासाठी `CreateGravatarCall` प्रकार जनरेट केला जातो.

## ब्लॉक हँडलर

कॉन्ट्रॅक्ट इव्हेंट्स किंवा फंक्शन कॉल्सची सदस्यता घेण्याव्यतिरिक्त, सबग्राफला त्याचा डेटा अद्यतनित करायचा असेल कारण साखळीमध्ये नवीन ब्लॉक्स जोडले जातात. हे साध्य करण्यासाठी सबग्राफ प्रत्येक ब्लॉकनंतर किंवा पूर्व-परिभाषित फिल्टरशी जुळणार्‍या ब्लॉक्सनंतर फंक्शन चालवू शकतो.

### समर्थित फिल्टर

#### Call Filter

```yaml
filter:
  kind: call
```

_The defined handler will be called once for every block which contains a call to the contract (data source) the handler is defined under._

> **Note:** The `call` filter currently depend on the Parity tracing API. Certain networks, such as BNB chain and Arbitrum, does not support this API. If a subgraph indexing one of these networks contain one or more block handlers with a `call` filter, it will not start syncing.

ब्लॉक हँडलरसाठी फिल्टरची अनुपस्थिती हे सुनिश्चित करेल की हँडलरला प्रत्येक ब्लॉक म्हटले जाईल. डेटा स्त्रोतामध्ये प्रत्येक फिल्टर प्रकारासाठी फक्त एक ब्लॉक हँडलर असू शकतो.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

#### Polling Filter

> **Requires `specVersion` >= 0.0.8**

> **Note:** Polling filters are only available on dataSources of `kind: ethereum`.

```yaml
blockHandlers:
  - handler: handleBlock
    filter:
      kind: polling
      every: 10
```

The defined handler will be called once for every `n` blocks, where `n` is the value provided in the `every` field. This configuration allows the subgraph to perform specific operations at regular block intervals.

#### Once Filter

> **Requires `specVersion` >= 0.0.8**

> **Note:** Once filters are only available on dataSources of `kind: ethereum`.

```yaml
blockHandlers:
  - handler: handleOnce
    filter:
      kind: once
```

The defined handler with the once filter will be called only once before all other handlers run. This configuration allows the subgraph to use the handler as an initialization handler, performing specific tasks at the start of indexing.

```ts
export function handleOnce(block: ethereum.Block): void {
  let data = new InitialData(Bytes.fromUTF8('initial'))
  data.data = 'Setup data here'
  data.save()
}
```

### मॅपिंग कार्य

मॅपिंग फंक्शनला त्याचा एकमेव युक्तिवाद म्हणून `ethereum.Block` प्राप्त होईल. इव्हेंटसाठी मॅपिंग फंक्शन्सप्रमाणे, हे फंक्शन स्टोअरमधील विद्यमान सबग्राफ घटकांमध्ये प्रवेश करू शकते, स्मार्ट कॉन्ट्रॅक्ट कॉल करू शकते आणि संस्था तयार किंवा अद्यतनित करू शकते.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## अनामिक घटना

तुम्हाला सॉलिडिटीमध्ये निनावी इव्हेंटवर प्रक्रिया करायची असल्यास, ते इव्हेंटचा विषय 0 प्रदान करून प्राप्त केले जाऊ शकते, उदाहरणार्थ:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

जेव्हा स्वाक्षरी आणि विषय 0 दोन्ही जुळतात तेव्हाच इव्हेंट ट्रिगर केला जाईल. डीफॉल्टनुसार, `topic0` इव्हेंट स्वाक्षरीच्या हॅशच्या समान आहे.

## Transaction Receipts in Event Handlers

`specVersion` `0.0.5` आणि `apiVersion` `0.0.7` पासून प्रारंभ करून, इव्हेंट हँडलर्सना पावतीवर प्रवेश असू शकतो व्यवहार ज्याने त्यांना उत्सर्जित केले.

To do so, event handlers must be declared in the subgraph manifest with the new `receipt: true` key, which is optional and defaults to false.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

हँडलर फंक्शनच्या आत, पावती `Event.receipt` फील्डमध्ये ऍक्सेस केली जाऊ शकते. जेव्हा `पावती` की `false` वर सेट केली जाते किंवा मॅनिफेस्टमध्ये वगळली जाते, तेव्हा त्याऐवजी `null` मूल्य परत केले जाईल.

## प्रायोगिक वैशिष्ट्ये

`specVersion` `0.0.4` पासून सुरू करून, सबग्राफ वैशिष्ट्ये मॅनिफेस्ट फाइलच्या शीर्ष स्तरावरील `वैशिष्ट्ये` विभागात स्पष्टपणे घोषित करणे आवश्यक आहे, त्यांचा वापर करून `camelCase` नाव, खालील तक्त्यामध्ये सूचीबद्ध केल्याप्रमाणे:

| वैशिष्ट्य                                               | नाव                                                 |
| ------------------------------------------------------- | --------------------------------------------------- |
| [गैर-घातक त्रुटी](#non-fatal-errors)                    | `nonFatalErrors`                                    |
| [पूर्ण मजकूर शोध](#defining-fulltext-search-fields)     | `fullTextSearch`                                    |
| [कलम करणे](#grafting-onto-existing-subgraphs)           | `कलम करणे`                                          |
| [इथरियम करारांवर आयपीएफएस](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` or `nonDeterministicIpfs` |

For instance, if a subgraph uses the **Full-Text Search** and the **Non-fatal Errors** features, the `features` field in the manifest should be:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

लक्षात ठेवा की वैशिष्ट्य घोषित न करता वापरल्याने सबग्राफ डिप्लॉयमेंट दरम्यान **प्रमाणीकरण त्रुटी** येईल, परंतु वैशिष्ट्य घोषित केले असल्यास परंतु वापरलेले नसल्यास कोणतीही त्रुटी येणार नाही.

### इथरियम करारांवर आयपीएफएस

इथरियमसह IPFS एकत्र करण्यासाठी एक सामान्य वापर केस म्हणजे IPFS वर डेटा संग्रहित करणे जे ऑन-चेन राखण्यासाठी खूप महाग असेल आणि Ethereum कॉन्ट्रॅक्टमध्ये IPFS हॅशचा संदर्भ घ्या.

अशा IPFS हॅश दिल्यास, सबग्राफ `ipfs.cat` आणि `ipfs.map` वापरून IPFS मधील संबंधित फाइल्स वाचू शकतात. हे विश्वासार्हपणे करण्यासाठी, या फायली उच्च उपलब्धता असलेल्या IPFS नोडवर पिन केलेल्या असणे आवश्यक आहे, जेणेकरून [होस्टेड सेवा](https://thegraph.com/hosted-service) IPFS नोड अनुक्रमणिका दरम्यान शोधू शकता.

> **टीप:** ग्राफ नेटवर्क अद्याप `ipfs.cat` आणि `ipfs.map` ला समर्थन देत नाही आणि विकसकांनी उपयोजित करू नये स्टुडिओद्वारे नेटवर्कवर ती कार्यक्षमता वापरून सबग्राफ.

> **[वैशिष्ट्य व्यवस्थापन](#experimental-features):** `ipfsOnEthereumContracts` `वैशिष्ट्ये` अंतर्गत घोषित करणे आवश्यक आहे code> सबग्राफ मॅनिफेस्टमध्ये. ईव्हीएम नसलेल्या साखळ्यांसाठी, `nonDeterministicIpfs` उपनाव देखील त्याच उद्देशासाठी वापरला जाऊ शकतो.

स्थानिक आलेख नोड चालवताना, ही प्रायोगिक कार्यक्षमता वापरून सबग्राफ अनुक्रमित करण्यासाठी `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` पर्यावरण व्हेरिएबल सेट करणे आवश्यक आहे.

### गैर-घातक त्रुटी

आधीच समक्रमित केलेल्या सबग्राफ्सवर अनुक्रमणिका त्रुटी, डीफॉल्टनुसार, सबग्राफ अयशस्वी होण्यास आणि समक्रमण थांबवण्यास कारणीभूत ठरतील. सबग्राफ वैकल्पिकरित्या त्रुटींच्या उपस्थितीत समक्रमण सुरू ठेवण्यासाठी कॉन्फिगर केले जाऊ शकतात, हँडलरने केलेल्या बदलांकडे दुर्लक्ष करून, ज्यामुळे त्रुटी उद्भवली. हे सबग्राफ लेखकांना त्यांचे सबग्राफ दुरुस्त करण्यासाठी वेळ देते जेव्हा की नवीनतम ब्लॉकच्या विरूद्ध क्वेरी चालू ठेवल्या जातात, जरी त्रुटीमुळे परिणाम विसंगत असू शकतात. लक्षात घ्या की काही त्रुटी अजूनही नेहमीच घातक असतात. गैर-घातक होण्यासाठी, त्रुटी निश्चितपणे ज्ञात असणे आवश्यक आहे.

> **टीप:** ग्राफ नेटवर्क अद्याप घातक नसलेल्या त्रुटींना समर्थन देत नाही आणि विकासकांनी स्टुडिओद्वारे नेटवर्कवर ती कार्यक्षमता वापरून सबग्राफ उपयोजित करू नये.

Enabling non-fatal errors requires setting the following feature flag on the subgraph manifest:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

क्वेरीने `subgraphError` युक्तिवादाद्वारे संभाव्य विसंगती असलेल्या डेटाची क्वेरी करणे देखील निवडले पाहिजे. उदाहरणाप्रमाणे सबग्राफ एरर वगळला आहे की नाही हे तपासण्यासाठी `_meta` क्वेरी करण्याची देखील शिफारस केली जाते:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

सबग्राफमध्ये त्रुटी आढळल्यास, ती क्वेरी या उदाहरणाच्या प्रतिसादाप्रमाणे `"indexing_error"` संदेशासह डेटा आणि graphql त्रुटी दोन्ही देईल:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### विद्यमान सबग्राफवर कलम करणे

> **Note:** it is not recommended to use grafting when initially upgrading to The Graph Network. Learn more [here](/cookbook/grafting/#important-note-on-grafting-when-upgrading-to-the-network).

जेव्हा सबग्राफ प्रथम उपयोजित केला जातो, तेव्हा तो संबंधित साखळीच्या उत्पत्ती ब्लॉकवर (किंवा प्रत्येक डेटा स्त्रोतासह परिभाषित केलेल्या `startBlock` वर) काही परिस्थितींमध्ये इव्हेंट्सचे अनुक्रमणिका सुरू करतो; विद्यमान सबग्राफमधील डेटा पुन्हा वापरणे आणि नंतरच्या ब्लॉकमध्ये अनुक्रमणिका सुरू करणे फायदेशीर आहे. अनुक्रमणिकेच्या या मोडला _ग्राफ्टिंग_ म्हणतात. उदाहरणार्थ, मॅपिंगमध्ये भूतकाळातील साध्या चुका लवकर मिळवण्यासाठी किंवा विद्यमान सबग्राफ अयशस्वी झाल्यानंतर तात्पुरते काम करण्यासाठी विकासादरम्यान ग्राफ्टिंग उपयुक्त आहे.

A subgraph is grafted onto a base subgraph when the subgraph manifest in `subgraph.yaml` contains a `graft` block at the top-level:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

जेव्हा एखादा सबग्राफ ज्याच्या मॅनिफेस्टमध्ये `ग्राफ्ट` ब्लॉक असतो तो उपयोजित केला जातो, तेव्हा आलेख नोड `बेस` सबग्राफचा डेटा कॉपी करेल आणि दिलेल्या `ब्लॉक` सह आणि नंतर त्या ब्लॉकमधून नवीन सबग्राफ अनुक्रमित करणे सुरू ठेवा. बेस सबग्राफ लक्ष्य ग्राफ नोडच्या उदाहरणावर अस्तित्वात असणे आवश्यक आहे आणि कमीतकमी दिलेल्या ब्लॉकपर्यंत अनुक्रमित केलेले असणे आवश्यक आहे. या निर्बंधामुळे, ग्राफ्टिंगचा वापर केवळ विकासादरम्यान किंवा आणीबाणीच्या काळात समतुल्य नॉन-ग्राफ्टेड सबग्राफ तयार करण्यासाठी वेगवान करण्यासाठी केला पाहिजे.

बेस डेटा इंडेक्स करण्याऐवजी कॉपीचे ग्राफ्टिंग केल्यामुळे, सुरवातीपासून इंडेक्स करण्यापेक्षा इच्छित ब्लॉकमध्ये सबग्राफ मिळवणे खूप जलद आहे, जरी सुरुवातीच्या डेटा कॉपीला खूप मोठ्या सबग्राफसाठी बरेच तास लागू शकतात. ग्रॅफ्टेड सबग्राफ सुरू होत असताना, ग्राफ नोड आधीपासून कॉपी केलेल्या घटक प्रकारांबद्दल माहिती लॉग करेल.

ग्राफ्टेड सबग्राफ GraphQL स्कीमा वापरू शकतो जो बेस सबग्राफपैकी एकाशी एकसारखा नसतो, परंतु त्याच्याशी फक्त सुसंगत असतो. ती स्वतःच्या अधिकारात वैध सबग्राफ स्कीमा असणे आवश्यक आहे, परंतु खालील प्रकारे बेस सबग्राफच्या स्कीमापासून विचलित होऊ शकते:

- हे घटक प्रकार जोडते किंवा काढून टाकते
- हे घटक प्रकारातील गुणधर्म काढून टाकते
- हे अस्तित्व प्रकारांमध्ये रद्द करण्यायोग्य विशेषता जोडते
- हे नॉन-नलेबल अॅट्रिब्यूट्सना न्युलेबल अॅट्रिब्यूटमध्ये बदलते
- हे enums मध्ये मूल्ये जोडते
- हे इंटरफेस जोडते किंवा काढून टाकते
- कोणत्या घटकासाठी इंटरफेस लागू केला जातो ते बदलते

> **[Feature Management](#experimental-features):** `grafting` must be declared under `features` in the subgraph manifest.

## फाइल डेटा स्रोत

File data sources are a new subgraph functionality for accessing off-chain data during indexing in a robust, extendable way. File data sources support fetching files from IPFS and from Arweave.

> हे ऑफ-चेन डेटाच्या निर्धारवादी अनुक्रमणिकेसाठी तसेच अनियंत्रित HTTP-स्रोत डेटाच्या संभाव्य परिचयासाठी देखील पाया घालते.

### सविश्लेषण

हँडलर कार्यान्वित करताना फाईल्स "इन लाइन" आणण्याऐवजी, हे टेम्पलेट्स सादर करते जे दिलेल्या फाइल आयडेंटिफायरसाठी नवीन डेटा स्रोत म्हणून तयार केले जाऊ शकतात. हे नवीन डेटा स्रोत फाइल्स आणतात, अयशस्वी झाल्यास पुन्हा प्रयत्न करतात, फाइल सापडल्यावर समर्पित हँडलर चालवतात.

हे [विद्यमान डेटा स्रोत टेम्पलेट](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates) सारखे आहे, जे वापरले जातात गतिशीलपणे नवीन साखळी-आधारित डेटा स्रोत तयार करण्यासाठी.

> हे विद्यमान `ipfs.cat` API बदलते

### Upgrade guide

#### `graph-ts` आणि `graph-cli` अपडेट करा

File data sources requires graph-ts >=0.29.0 and graph-cli >=0.33.1

#### Add a new entity type which will be updated when files are found

File data sources cannot access or update chain-based entities, but must update file specific entities.

This may mean splitting out fields from existing entities into separate entities, linked together.

मूळ एकत्रित अस्तित्व:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

नवीन, विभाजित अस्तित्व:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

जर मूळ घटक आणि परिणामी फाइल डेटा स्रोत घटक यांच्यातील संबंध 1:1 असेल तर, आयपीएफएस सीआयडी लुकअप म्हणून वापरून मूळ घटकाला परिणामी फाइल घटकाशी जोडणे हा सर्वात सोपा नमुना आहे. तुम्हाला तुमच्या नवीन फाइल-आधारित घटकांचे मॉडेलिंग करण्यात अडचण येत असल्यास Discord वर संपर्क साधा!

> You can use [nested filters](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) to filter parent entities on the basis of these nested entities.

#### Add a new templated data source with `kind: file/ipfs` or `kind: file/arweave`

This is the data source which will be spawned when a file of interest is identified.

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> Currently `abis` are required, though it is not possible to call contracts from within file data sources

फाइल डेटा स्रोताने विशेषत: सर्व घटक प्रकारांचा उल्लेख करणे आवश्यक आहे ज्यांच्याशी तो `संस्था` अंतर्गत संवाद साधेल. अधिक तपशीलांसाठी [मर्यादा](#Limitations) पहा.

#### फाइल्सवर प्रक्रिया करण्यासाठी नवीन हँडलर तयार करा

This handler should accept one `Bytes` parameter, which will be the contents of the file, when it is found, which can then be processed. This will often be a JSON file, which can be processed with `graph-ts` helpers ([documentation](https://thegraph.com/docs/en/developing/assemblyscript-api/#json-api)).

The CID of the file as a readable string can be accessed via the `dataSource` as follows:

```typescript
const cid = dataSource.stringParam()
```

उदाहरण हँडलर:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### आवश्यकतेनुसार फाईल डेटा स्रोत तयार करा

You can now create file data sources during execution of chain-based handlers:

- Import the template from the auto-generated `templates`
- call `TemplateName.create(cid: string)` from within a mapping, where the cid is a valid content identifier for IPFS or Arweave

For IPFS, Graph Node supports [v0 and v1 content identifiers](https://docs.ipfs.tech/concepts/content-addressing/), and content identifers with directories (e.g. `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`).

For Arweave, as of version 0.33.0 Graph Node can fetch files stored on Arweave based on their [transaction ID](https://docs.arweave.org/developers/server/http-api#transactions) from an Arweave gateway ([example file](https://bdxujjl5ev5eerd5ouhhs6o4kjrs4g6hqstzlci5pf6vhxezkgaa.arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA)). Arweave supports transactions uploaded via Bundlr, and Graph Node can also fetch files based on [Bundlr manifests](https://docs.bundlr.network/learn/gateways#indexing).

उदाहरण:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//This example code is for a Crypto coven subgraph. The above ipfs hash is a directory with token metadata for all crypto coven NFTs.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //This creates a path to the metadata for a single Crypto coven NFT. It concats the directory with "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

This will create a new file data source, which will poll Graph Node's configured IPFS or Arweave endpoint, retrying if it is not found. When the file is found, the file data source handler will be executed.

This example is using the CID as the lookup between the parent `Token` entity and the resulting `TokenMetadata` entity.

> Previously, this is the point at which a subgraph developer would have called `ipfs.cat(CID)` to fetch the file

Congratulations, you are using file data sources!

#### तुमचे सबग्राफ उपयोजित करत आहे

You can now `build` and `deploy` your subgraph to any Graph Node >=v0.30.0-rc.0.

#### Limitations

फाइल डेटा स्रोत हँडलर आणि संस्था इतर सबग्राफ संस्थांपासून वेगळ्या केल्या जातात, ते कार्यान्वित केल्यावर ते निर्धारवादी आहेत याची खात्री करून आणि साखळी-आधारित डेटा स्रोतांचे दूषित होणार नाही याची खात्री करतात. विशिष्ट असणे:

- Entities created by File Data Sources are immutable, and cannot be updated
- File Data Source handlers cannot access entities from other file data sources
- Entities associated with File Data Sources cannot be accessed by chain-based handlers

> बहुतेक वापर-प्रकरणांसाठी ही मर्यादा समस्याप्रधान नसावी, परंतु काहींसाठी ते जटिलता आणू शकते. सबग्राफमध्‍ये तुमच्‍या फाईल-आधारित डेटाचे मॉडेल बनवण्‍यात तुम्‍हाला समस्या येत असल्‍यास कृपया डिस्‍कॉर्ड द्वारे संपर्क साधा!

याव्यतिरिक्त, फाइल डेटा स्रोतावरून डेटा स्रोत तयार करणे शक्य नाही, मग ते ऑनचेन डेटा स्रोत असो किंवा अन्य फाइल डेटा स्रोत. भविष्यात हे निर्बंध उठवले जाऊ शकतात.

#### चांगला सराव

तुम्ही एनएफटी मेटाडेटाला संबंधित टोकनशी लिंक करत असल्यास, टोकन एंटिटीमधील मेटाडेटा घटकाचा संदर्भ देण्यासाठी मेटाडेटाचा IPFS हॅश वापरा. आयडी म्हणून IPFS हॅश वापरून मेटाडेटा घटक जतन करा.

फाइल डेटा स्रोत तयार करताना तुम्ही [डेटास्रोत संदर्भ](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) वापरू शकता अतिरिक्त माहिती पास करा जी फाइल डेटा स्रोत हँडलरकडे उपलब्ध असेल.

तुमच्याकडे अनेक वेळा रीफ्रेश केलेल्या संस्था असल्यास, IPFS हॅश वापरून अद्वितीय फाइल-आधारित संस्था तयार करा & एंटिटी आयडी आणि साखळी-आधारित घटकामध्ये व्युत्पन्न फील्ड वापरून त्यांचा संदर्भ द्या.

> We are working to improve the above recommendation, so queries only return the "most recent" version

#### ओळखलेले समस्या

File data sources currently require ABIs, even though ABIs are not used ([issue](https://github.com/graphprotocol/graph-cli/issues/961)). Workaround is to add any ABI.

फाइल डेटा स्रोतांसाठी हँडलर फाईल्समध्ये असू शकत नाहीत जे `eth_call` कॉन्ट्रॅक्ट बाइंडिंग आयात करतात, "अज्ञात आयात: `ethereum::ethereum.call` परिभाषित केले गेले नाहीत" ([ समस्या](https://github.com/graphprotocol/graph-cli/issues/4309)). वर्कअराउंड म्हणजे समर्पित फाइलमध्ये फाइल डेटा स्रोत हँडलर तयार करणे.

#### उदाहरणे

[क्रिप्टो कोव्हन सबग्राफ स्थलांतर](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### संदर्भ

[GIP फाइल डेटा स्रोत](https://forum.thegraph.com/t/gip-file-data-sources/2721)
