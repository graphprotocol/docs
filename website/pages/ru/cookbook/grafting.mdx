---
title: Замените контракт и сохраните его историю с помощью Grafting
---

В этом руководстве вы узнаете, как создавать и развертывать новые подграфы путем графтинга существующих подграфов.

## Что такое Grafting?

При графтинге повторно используются данные из существующего подграфа и начинается их индексация в более позднем блоке. Это может быть полезно в период разработки, чтобы быстро устранить простые ошибки в маппинге или временно восстановить работу существующего подграфа после его сбоя. Кроме того, его можно использовать при добавлении в подграф функции, индексация которой с нуля занимает много времени.

Подграф может использовать схему GraphQL, которая не идентична схеме базового подграфа, а просто совместима с ней. Это должна быть автономно действующая схема подграфа, но она может отличаться от схемы базового подграфа следующим образом:

- Она добавляет или удаляет типы объектов
- Она удаляет атрибуты из типов объектов
- Она добавляет nullable атрибуты к типам объектов
- Она превращает non-nullable атрибуты в nullable атрибуты
- Она добавляет определенные значения в энное число
- Она добавляет или удаляет интерфейсы
- Она изменяется в зависимости от того, под какой тип объектов реализован интерфейс

Для получения дополнительной информации вы можете перейти:

- [Grafting](/developing/creating-a-subgraph#grafting-onto-existing-subgraphs)

В этом руководстве мы рассмотрим базовый вариант использования. Мы заменим существующий договор на идентичный договор (с новым адресом, но тем же кодом). Затем привяжем существующий подграф к «базовому» подграфу, который отслеживает новый контракт.

## Important Note on Grafting When Upgrading to the Network

> **Caution**: It is recommended to not use grafting for subgraphs published to The Graph Network

### Why Is This Important?

Grafting is a powerful feature that allows you to "graft" one subgraph onto another, effectively transferring historical data from the existing subgraph to a new version. While this is an effective way to preserve data and save time on indexing, grafting may introduce complexities and potential issues when migrating from a hosted environment to the decentralized network. It is not possible to graft a subgraph from The Graph Network back to the hosted service or Subgraph Studio.

### Best Practices

**Initial Migration**: when you first deploy your subgraph to the decentralized network, do so without grafting. Ensure that the subgraph is stable and functioning as expected.

**Subsequent Updates**: once your subgraph is live and stable on the decentralized network, you may use grafting for future versions to make the transition smoother and to preserve historical data.

By adhering to these guidelines, you minimize risks and ensure a smoother migration process.

## Создание существующего подграфа

Building subgraphs is an essential part of The Graph, described more in depth [here](/quick-start/). To be able to build and deploy the existing subgraph used in this tutorial, the following repo is provided:

- [Репозиторий в качестве примера](https://github.com/t-proctor/grafting-tutorial)

> Примечание: контракт, использованный в подграфе, был взят отсюда [Hackathon Starterkit](https://github.com/schmidsi/hackathon-starterkit).

## Определение манифеста подграфа

Манифест подграфа `subgraph.yaml` определяет источники данных для подграфа, релевантные триггеры и функции, которые должны выполняться в ответ на эти триггеры. Ниже приведен пример манифеста подграфа, который вы будете использовать:

```yaml
specVersion: 0.0.4
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: Lock
    network: goerli
    source:
      address: '0x4Ed995e775D3629b0566D2279f058729Ae6EA493'
      abi: Lock
      startBlock: 7674603
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Withdrawal
      abis:
        - name: Lock
          file: ./abis/Lock.json
      eventHandlers:
        - event: Withdrawal(uint256,uint256)
          handler: handleWithdrawal
      file: ./src/lock.ts
```

- Источник данных `Lock` — это abi и адрес контракта, которые мы получим при компиляции и развертывании контракта
- Сеть должна соответствовать запрашиваемой индексированной сети. Поскольку мы работаем в тестовой сети Goerli, это сеть `goerli`
- Раздел `mapping` определяет интересующие нас триггеры и функции, которые должны запускаться в ответ на эти триггеры. В этом случае мы уделяем внимание событию `Withdrawal` и вызываем функцию `handleWithdrawal` при его возникновении.

## Определение grafting манифеста

Графтинг требует добавления двух новых элементов в исходный манифест подграфа:

```yaml
---
features:
  - grafting # feature name
graft:
  base: Qm... # subgraph ID of base subgraph
  block: 1502122 # block number
```

- `features:` is a list of all used [feature names](/developing/creating-a-subgraph/#experimental-features).
- `graft:` это карта подграфа `base` и блока, к которому применяется графтинг. `block` - это номер блока, с которого начинается индексация. The Graph скопирует данные базового подграфа до указанного блока включительно, а затем продолжит индексацию нового подграфа, начиная с этого блока.

Значения `base` и `block` можно найти, развернув два подграфа: один для базовой индексации, а другой с grafting

## Развертывание базового подграфа

1. Go to [Subgraph Studio](https://thegraph.com/studio/) and create a subgraph on Goerli testnet called `graft-example`
2. Следуйте инструкциям в `AUTH & DEPLOY` на странице подграфа в `graft-example` из репозитория
3. После завершения убедитесь, что подграф правильно индексируется. Если вы запустите следующую команду в тестовой среде The Graph

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Отклик будет подобным этому:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      }
    ]
  }
}
```

Убедившись, что подграф индексируется правильно, вы можете быстро обновить его с помощью графтинга.

## Развертывание grafting подграфа

Замененный subgraph.yaml будет иметь новый адрес контракта. Это может произойти, когда вы обновляете свое децентрализованное приложение, повторно развертываете контракт и т. д.

1. Go to [Subgraph Studio](https://thegraph.com/studio/) and create a subgraph on Goerli testnet called `graft-replacement`
2. Create a new manifest. The `subgraph.yaml` for `graph-replacement` contains a different contract address and new information about how it should graft. These are the `block` of the [last event emitted](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) you care about by the old contract and the `base` of the old subgraph. The `base` subgraph ID is the `Deployment ID` of your original `graph-example` subgraph. You can find this in Subgraph Studio.
3. Следуйте инструкциям в `AUTH & DEPLOY` на странице подграфа в `graft-replacement` из репозитория
4. После завершения убедитесь, что подграф правильно индексируется. Если вы запустите следующую команду в тестовой среде The Graph

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Это должно привести к следующему результату:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      },
      {
        "id": "0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3-22",
        "amount": "0",
        "when": "1664371512"
      }
    ]
  }
}
```

Вы можете видеть, что подграф `graft-replacement` индексируется из старых данных `graph-example` и более новых данных из нового адреса контракта. Исходный контракт генерировал два события `Withdrawal`: [Событие 1](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) и [Событие 2](https:/ /goerli.etherscan.io/address/0x4ed995e775d3629b0566d2279f058729ae6ea493). Новый контракт выдал один `Withdrawal` после [События 3](https://goerli.etherscan.io/tx/0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3). Две ранее проиндексированные транзакции (События 1 и 2) и новая транзакция (Событие 3) были объединены в подграфе `graft-replacement`.

Congrats! You have successfully grafted a subgraph onto another subgraph.

## Дополнительные ресурсы

Если Вы хотите получить больше опыта в графтинге, вот несколько примеров популярных контрактов:

- [Curve](https://github.com/messari/subgraphs/blob/master/subgraphs/curve-finance/protocols/curve-finance/config/templates/curve.template.yaml)
- [ERC-721](https://github.com/messari/subgraphs/blob/master/subgraphs/erc721-metadata/subgraph.yaml)
- [Uniswap](https://github.com/messari/subgraphs/blob/master/subgraphs/uniswap-v3-forks/protocols/uniswap-v3/config/templates/uniswapV3Template.yaml),

To become even more of a Graph expert, consider learning about other ways to handle changes in underlying datasources. Alternatives like [Data Source Templates](/developing/creating-a-subgraph/#data-source-templates) can achieve similar results

> Примечание: многие материалы этой статьи были взяты из ранее опубликованной [статьи по Arweave](/cookbook/arweave/)
