---
title: Категоризация маркетплейсов NFT с использованием Enums (перечислений)
---

Используйте Enums (перечисления), чтобы сделать Ваш код чище и уменьшить вероятность ошибок. Вот полный пример использования перечислений для маркетплейсов NFT.

## Что такое Enums (перечисления)?

Перечисления (или типы перечислений) — это особый тип данных, который позволяет определить набор конкретных допустимых значений.

### Пример использования Enums (перечислений) в Вашей схеме

Если вы создаете субграф для отслеживания истории владения токенами на рынке, каждый токен может переходить через разные стадии владения, такие как `OriginalOwner` (Первоначальный Владелец), `SecondOwner` (Второй Владелец) и `ThirdOwner` (Третий 
Владелец). Используя перечисления (enums), Вы можете определить эти конкретные стадии владения, обеспечивая присвоение только заранее определенных значений.

Вы можете определить перечисления (enums) в своей схеме, и после их определения Вы можете использовать строковое представление значений перечислений для установки значения поля перечисления в объекты.

Вот как может выглядеть определение перечисления (enum) в Вашей схеме, исходя из приведенного выше примера:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Это означает, что когда Вы используете тип `TokenStatus` в своей схеме, Вы ожидаете, что он будет иметь одно из заранее определенных значений: `OriginalOwner` (Первоначальный Владелец), `SecondOwner` (Второй Владелец) или `ThirdOwner` (Третий Владелец), что обеспечивает согласованность и корректность данных.

Чтобы узнать больше о перечислениях (Enums), ознакомьтесь с разделом [Создание субграфа](/developing/creating-a-subgraph/#enums) и с [документацией GraphQL](https://graphql.org/learn/schema/#enumeration-types).

## Преимущества использования перечислений (Enums)

- **Ясность:** Перечисления предоставляют значимые имена для значений, что делает данные более понятными.
- **Валидация:** Перечисления обеспечивают строгие определения значений, предотвращая ввод недопустимых данных.
- **Поддерживаемость:** Когда Вам нужно изменить или добавить новые категории, перечисления позволяют сделать это целенаправленно и удобно.

### Без перечислений (Enums)

Если Вы решите определить тип как строку вместо использования перечисления (Enum), Ваш код может выглядеть следующим образом:

```graphql
type Token @entity {
  id: ID!
  tokenId: BigInt!
  owner: Bytes! # Owner of the token
  tokenStatus: String! # String field to track token status
  timestamp: BigInt!
}
```

В этой схеме `TokenStatus` является простой строкой без конкретных и допустимых значений.

#### Почему это является проблемой?

- Нет никаких ограничений на значения `TokenStatus`, поэтому любое строковое значение может быть назначено случайно. Это усложняет обеспечение того, что устанавливаются только допустимые статусы, такие как `OriginalOwner` (Первоначальный Владелец), `SecondOwner` (Второй Владелец) или `ThirdOwner` (Третий Владелец).
- Легко допустить опечатку, например, `Orgnalowner` вместо `OriginalOwner`, что делает данные и потенциальные запросы ненадежными.

### С перечислениями (Enums)

Вместо присвоения строк произвольной формы Вы можете определить перечисление (Enum) для `TokenStatus` с конкретными значениями: `OriginalOwner`, `SecondOwner` или `ThirdOwner`. Использование перечисления гарантирует, что используются только допустимые значения.

Перечисления обеспечивают безопасность типов, минимизируют риск опечаток и гарантируют согласованные и надежные результаты.

## Определение перечислений (Enums) для Маркетплейсов NFT

> Примечание: Следующее руководство использует смарт-контракт NFT CryptoCoven.

Чтобы определить перечисления для различных маркетплейсов, на которых торгуются NFT, используйте следующее в своей схеме субграфа:

```gql
# Перечисление для маркетплейсов, с которыми взаимодействовал смарт-контракт CryptoCoven (вероятно, торговля или минт)
enum Marketplace {
  OpenSeaV1 # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе OpenSeaV1
  OpenSeaV2 # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе OpenSeaV2
  SeaPort   # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе SeaPort
  LooksRare # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе LooksRare
  # ...и другие рынки
}
```

## Использование перечислений (Enums) для Маркетплейсов NFT

После определения перечисления (enums) могут использоваться в Вашем субграфе для категоризации транзакций или событий.

Например, при регистрации продаж NFT можно указать маркетплейс, на котором произошла сделка, используя перечисление.

### Реализация функции для маркетплейсов NFT

Вот как можно реализовать функцию для получения названия маркетплейса из перечисления (enum) в виде строки:

```ts
export function getMarketplaceName(marketplace: Marketplace): string {
  // Используем операторы if-else для сопоставления значения перечисления со строкой
  if (marketplace === Marketplace.OpenSeaV1) {
    return 'OpenSeaV1' // Если маркетплейс OpenSea, возвращаем его строковое представление
  } else if (marketplace === Marketplace.OpenSeaV2) {
    return 'OpenSeaV2'
  } else if (marketplace === Marketplace.SeaPort) {
    return 'SeaPort' // Если маркетплейс SeaPort, возвращаем его строковое представление
  } else if (marketplace === Marketplace.LooksRare) {
    return 'LooksRare' // Если маркетплейс LooksRare, возвращаем его строковое представление
    // ... и другие маркетплейсы
  }
}
```

## Лучшие практики использования перечислений (Enums)

- **Согласованность в наименованиях:** Используйте четкие, описательные названия для значений перечислений, чтобы улучшить читаемость кода.
- **Централизованное управление:** Храните перечисления в одном файле для обеспечения согласованности. Это облегчает обновление перечислений и гарантирует, что они являются единственным источником достоверной информации.
- **Документация:** Добавляйте комментарии к перечислениям, чтобы прояснить их назначение и использование.

## Использование перечислений (Enums) в запросах

Перечисления в запросах помогают улучшить качество данных и делают результаты более понятными. Они функционируют как фильтры и элементы ответа, обеспечивая согласованность и уменьшая ошибки в значениях маркетплейса.

**Особенности**

- **Фильтрация с помощью перечислений:** Перечисления предоставляют четкие фильтры, позволяя уверенно включать или исключать конкретные маркетплейсы.
- **Перечисления в ответах:** Перечисления гарантируют, что возвращаются только признанные названия маркетплейсов, делая результаты стандартизированными и точными.

### Пример запросов

#### Запрос 1: Аккаунт с наибольшим количеством взаимодействий на маркетплейсе NFT

Этот запрос выполняет следующие действия:

- Он находит аккаунт с наибольшим количеством уникальных взаимодействий с маркетплейсами NFT, что полезно для анализа активности на разных маркетплейсах.
- Поле маркетплейсов использует перечисление маркетплейс, что обеспечивает согласованность и валидацию значений маркетплейсов в ответе.

```gql
{
  accounts(first: 1, orderBy: uniqueMarketplacesCount, orderDirection: desc) {
    id
    sendCount
    receiveCount
    totalSpent
    uniqueMarketplacesCount
    marketplaces {
      marketplace # This field returns the enum value representing the marketplace
    }
  }
}
```

#### Returns

This response provides account details and a list of unique marketplace interactions with enum values for standardized clarity:

```gql
{
  "data": {
    "accounts": [
      {
        "id": "0xb3abc96cb9a61576c03c955d75b703a890a14aa0",
        "sendCount": "44",
        "receiveCount": "44",
        "totalSpent": "1197500000000000000",
        "uniqueMarketplacesCount": "7",
        "marketplaces": [
          {
            "marketplace": "OpenSeaV1"
          },
          {
            "marketplace": "OpenSeaV2"
          },
          {
            "marketplace": "GenieSwap"
          },
          {
            "marketplace": "CryptoCoven"
          },
          {
            "marketplace": "Unknown"
          },
          {
            "marketplace": "LooksRare"
          },
          {
            "marketplace": "NFTX"
          }
        ]
      }
    ]
  }
}
```

#### Query 2: Most Active Marketplace for CryptoCoven transactions

Этот запрос выполняет следующие действия:

- It identifies the marketplace with the highest volume of CryptoCoven transactions.
- It uses the marketplace enum to ensure that only valid marketplace types appear in the response, adding reliability and consistency to your data.

```gql
{
  marketplaceInteractions(first: 1, orderBy: transactionCount, orderDirection: desc) {
    marketplace
    transactionCount
  }
}
```

#### Result 2

The expected response includes the marketplace and the corresponding transaction count, using the enum to indicate the marketplace type:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "Unknown",
        "transactionCount": "222"
      }
    ]
  }
}
```

#### Query 3: Marketplace Interactions with High Transaction Counts

Этот запрос выполняет следующие действия:

- It retrieves the top four marketplaces with over 100 transactions, excluding "Unknown" marketplaces.
- It uses enums as filters to ensure that only valid marketplace types are included, increasing accuracy.

```gql
{
  marketplaceInteractions(
    first: 4
    orderBy: transactionCount
    orderDirection: desc
    where: { transactionCount_gt: "100", marketplace_not: "Unknown" }
  ) {
    marketplace
    transactionCount
  }
}
```

#### Result 3

Expected output includes the marketplaces that meet the criteria, each represented by an enum value:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "NFTX",
        "transactionCount": "201"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "148"
      },
      {
        "marketplace": "CryptoCoven",
        "transactionCount": "117"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "111"
      }
    ]
  }
}
```

## Дополнительные ресурсы

For additional information, check out this guide's [repo](https://github.com/chidubemokeke/Subgraph-Tutorial-Enums).
