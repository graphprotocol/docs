---
title: Subgraph Best Practice 2 - Improve Indexing and Query Responsiveness By Using @derivedFrom
---

## Краткое содержание

Arrays in your schema can really slow down a subgraph's performance as they grow beyond thousands of entries. If possible, the `@derivedFrom` directive should be used when using arrays as it prevents large arrays from forming, simplifies handlers, and reduces the size of individual entities, improving indexing speed and query performance significantly.

## How to Use the `@derivedFrom` Directive

You just need to add a `@derivedFrom` directive after your array in your schema. Like this:

```graphql
comments: [Comment!]! @derivedFrom(field: "post")
```

`@derivedFrom` creates efficient one-to-many relationships, enabling an entity to dynamically associate with multiple related entities based on a field in the related entity. This approach removes the need for both sides of the relationship to store duplicate data, making the subgraph more efficient.

### Пример использования @derivedFrom

Пример динамически растущего массива — это платформа для блогов, где у "Поста" может быть много "Комментариев".

Let’s start with our two entities, `Post` and `Comment`

Without optimization, you could implement it like this with an array:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]!
}

type Comment @entity {
  id: Bytes!
  content: String!
}
```

Arrays like these will effectively store extra Comments data on the Post side of the relationship.

Вот как будет выглядеть оптимизированная версия с использованием @derivedFrom:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]! @derivedFrom(field: "post")
}

type Comment @entity {
  id: Bytes!
  content: String!
  post: Post!
}
```

Just by adding the `@derivedFrom` directive, this schema will only store the “Comments” on the “Comments” side of the relationship and not on the “Post” side of the relationship. Arrays are stored across individual rows, which allows them to expand significantly. This can lead to particularly large sizes if their growth is unbounded.

Это не только сделает наш субграф более эффективным, но и откроет три возможности:

1. We can query the `Post` and see all of its comments.

2. We can do a reverse lookup and query any `Comment` and see which post it comes from.

3. Мы можем использовать [Загрузчики производных полей](/subgraphs/developing/creating/graph-ts/api/#looking-up-derived-entities), чтобы получить возможность напрямую обращаться и манипулировать данными из виртуальных отношений в наших мэппингах субграфа.

## Заключение

Используйте директиву `@derivedFrom` в субграфах для эффективного управления динамически растущими массивами, улучшая эффективность индексирования и извлечения данных.

Для более подробного объяснения стратегий, которые помогут избежать использования больших массивов, ознакомьтесь с блогом Кевина Джонса: [Лучшие практики разработки субграфов: как избежать больших массивов](https://thegraph.com/blog/improve-subgraph-performance-avoiding-large-arrays/).

## Лучшие практики для субграфов 1-6

1. [Увеличение скорости запросов с помощью обрезки субграфов](/subgraphs/cookbook/pruning/)

2. [Улучшение индексирования и отклика запросов с использованием @derivedFrom](/subgraphs/cookbook/derivedfrom/)

3. [Улучшение индексирования и производительности запросов с использованием неизменяемых объектов и байтов в качестве идентификаторов](/subgraphs/cookbook/immutable-entities-bytes-as-ids/)

4. [Увеличение скорости индексирования путем избегания `eth_calls`](/subgraphs/cookbook/avoid-eth-calls/)

5. [Упрощение и оптимизация с помощью временных рядов и агрегаций](/subgraphs/cookbook/timeseries/)

6. [Использование переноса (графтинга) для быстрого развертывания исправлений](/subgraphs/cookbook/grafting-hotfix/)
