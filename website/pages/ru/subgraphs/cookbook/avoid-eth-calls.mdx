---
title: Subgraph Best Practice 4 - Improve Indexing Speed by Avoiding eth_calls
---

## Краткое содержание

`eth_calls` are calls that can be made from a subgraph to an Ethereum node. These calls take a significant amount of time to return data, slowing down indexing. If possible, design smart contracts to emit all the data you need so you don’t need to use `eth_calls`.

## Why Avoiding `eth_calls` Is a Best Practice

Subgraphs are optimized to index event data emitted from smart contracts. A subgraph can also index the data coming from an `eth_call`, however, this can significantly slow down subgraph indexing as `eth_calls` require making external calls to smart contracts. The responsiveness of these calls relies not on the subgraph but on the connectivity and responsiveness of the Ethereum node being queried. By minimizing or eliminating eth_calls in our subgraphs, we can significantly improve our indexing speed.

### What Does an eth_call Look Like?

`eth_calls` часто необходимы, когда данные, требуемые для субграфа, недоступны через сгенерированные события. Например, рассмотрим ситуацию, когда субграфу нужно определить, являются ли токены ERC20 частью определенного пула, но контракт генерирует только базовое событие `Transfer` и не создает событие, содержащее нужные нам данные:

```yaml
event Transfer(address indexed from, address indexed to, uint256 value);
```

Предположим, что принадлежность токенов к пулу определяется переменной состояния с именем `getPoolInfo`. В этом случае нам потребуется использовать `eth_call`, чтобы запросить эти данные:

```typescript
import { Address } from '@graphprotocol/graph-ts'
import { ERC20, Transfer } from '../generated/ERC20/ERC20'
import { TokenTransaction } from '../generated/schema'

export function handleTransfer(event: Transfer): void {
  let transaction = new TokenTransaction(event.transaction.hash.toHex())

  // Привязка экземпляра контракта ERC20 к указанному адресу:
  let instance = ERC20.bind(event.address)

  // Получение информации о пуле с помощью eth_call
  let poolInfo = instance.getPoolInfo(event.params.to)

  transaction.pool = poolInfo.toHexString()
  transaction.from = event.params.from.toHexString()
  transaction.to = event.params.to.toHexString()
  transaction.value = event.params.value

  transaction.save()
}
```

This is functional, however is not ideal as it slows down our subgraph’s indexing.

## How to Eliminate `eth_calls`

Ideally, the smart contract should be updated to emit all necessary data within events. For instance, modifying the smart contract to include pool information in the event could eliminate the need for `eth_calls`:

```
event TransferWithPool(address indexed from, address indexed to, uint256 value, bytes32 indexed poolInfo);
```

С этим обновлением субграф может напрямую индексировать необходимые данные без внешних вызовов:

```typescript
import { Address } from '@graphprotocol/graph-ts'
import { ERC20, TransferWithPool } from '../generated/ERC20/ERC20'
import { TokenTransaction } from '../generated/schema'

export function handleTransferWithPool(event: TransferWithPool): void {
  let transaction = new TokenTransaction(event.transaction.hash.toHex())

  transaction.pool = event.params.poolInfo.toHexString()
  transaction.from = event.params.from.toHexString()
  transaction.to = event.params.to.toHexString()
  transaction.value = event.params.value

  transaction.save()
}
```

This is much more performant as it has eliminated the need for `eth_calls`.

## Как оптимизировать `eth_calls`

If modifying the smart contract is not possible and `eth_calls` are required, read “[Improve Subgraph Indexing Performance Easily: Reduce eth_calls](https://thegraph.com/blog/improve-subgraph-performance-reduce-eth-calls/)” by Simon Emanuel Schmid to learn various strategies on how to optimize `eth_calls`.

## Reducing the Runtime Overhead of `eth_calls`

Для тех `eth_calls`, которые нельзя устранить, накладные расходы на их выполнение можно минимизировать, объявив их в манифесте. Когда `graph-node` обрабатывает блок, все объявленные `eth_calls` выполняются параллельно до запуска обработчиков. Вызовы, не объявленные в манифесте, выполняются последовательно во время работы обработчиков. Улучшение производительности достигается за счет параллельного выполнения вызовов, а не последовательного, что помогает сократить общее время, затраченное на вызовы, но не устраняет его полностью.

В настоящее время `eth_calls` можно объявлять только для обработчиков событий. В манифесте нужно написать

```yaml
event: TransferWithPool(address indexed, address indexed, uint256, bytes32 indexed)
handler: handleTransferWithPool
calls:
  ERC20.poolInfo: ERC20[event.address].getPoolInfo(event.params.to)
```

Часть, выделенная желтым, — это объявление вызова. Часть до двоеточия — это текстовая метка, которая используется только в сообщениях об ошибках. Часть после двоеточия имеет форму `Contract[address].function(params)`. Допустимыми значениями для адреса и параметров являются `event.address` и `event.params.<name>`.

The handler itself accesses the result of this `eth_call` exactly as in the previous section by binding to the contract and making the call. graph-node caches the results of declared `eth_calls` in memory and the call from the handler will retrieve the result from this in memory cache instead of making an actual RPC call.

Примечание: Объявленные `eth_calls` могут быть выполнены только в субграфах с версией спецификации >= 1.2.0.

## Заключение

Вы можете значительно улучшить производительность индексирования, минимизируя или исключая `eth_calls` в своих субграфах.

## Лучшие практики для субграфов 1-6

1. [Увеличение скорости запросов с помощью обрезки субграфов](/subgraphs/cookbook/pruning/)

2. [Улучшение индексирования и отклика запросов с использованием @derivedFrom](/subgraphs/cookbook/derivedfrom/)

3. [Улучшение индексирования и производительности запросов с использованием неизменяемых объектов и байтов в качестве идентификаторов](/subgraphs/cookbook/immutable-entities-bytes-as-ids/)

4. [Увеличение скорости индексирования путем избегания `eth_calls`](/subgraphs/cookbook/avoid-eth-calls/)

5. [Упрощение и оптимизация с помощью временных рядов и агрегаций](/subgraphs/cookbook/timeseries/)

6. [Использование переноса (графтинга) для быстрого развертывания исправлений](/subgraphs/cookbook/grafting-hotfix/)
