---
title: Создание субграфов на NEAR
---

Это руководство является введением в создание субграфов для индексирования смарт-контрактов на [блокчейне NEAR](https://docs.near.org/).

## Что такое NEAR?

[NEAR](https://near.org/) — это платформа для смарт-контрактов, предназначенная для создания децентрализованных приложений. Для получения дополнительной информации ознакомьтесь с [официальной документацией](https://docs.near.org/concepts/basics/protocol).

## Что такое NEAR подграфы?

The Graph предоставляет разработчикам инструменты для обработки событий блокчейна и упрощает доступ к полученным данным через API GraphQL, известный также как субграф. [Graph Node](https://github.com/graphprotocol/graph-node) теперь способен обрабатывать события NEAR, что позволяет разработчикам NEAR создавать субграфы для индексирования своих смарт-контрактов.

Субграфы основаны на событиях, что означает, что они отслеживают и обрабатывают события в блокчейне. В настоящее время для субграфов NEAR поддерживаются два типа обработчиков:

- Обработчики блоков: они запускаются для каждого нового блока
- Обработчики квитанций: запускаются каждый раз, когда сообщение выполняется в указанной учетной записи

[Из документации NEAR](https://docs.near.org/build/data-infrastructure/lake-data-structures/receipt):

> Квитанция - это единственный объект, к которому можно применить действие в системе. Когда мы говорим об "обработке транзакции" на платформе NEAR, это в конечном итоге означает "применение квитанций" в какой-то момент.

## Создание NEAR подграфа

`@graphprotocol/graph-cli` — это инструмент командной строки для создания и развертывания субграфов.

`@graphprotocol/graph-ts` — это библиотека типов, специфичных для субграфов.

Для разработки субграфов на платформе NEAR требуется `graph-cli` версии выше `0.23.0` и `graph-ts` версии выше `0.23.0`.

> Построение NEAR сабграфа очень похоже на построение сабграфа, индексирующего Ethereum.

Существует три аспекта определения подграфа:

**subgraph.yaml:** the subgraph manifest, defining the data sources of interest, and how they should be processed. NEAR is a new `kind` of data source.

**schema.graphql:** a schema file that defines what data is stored for your subgraph, and how to query it via GraphQL. The requirements for NEAR subgraphs are covered by [the existing documentation](/developing/creating-a-subgraph/#the-graphql-schema).

**AssemblyScript Mappings:** [AssemblyScript code](/subgraphs/developing/creating/graph-ts/api/) that translates from the event data to the entities defined in your schema. NEAR support introduces NEAR-specific data types and new JSON parsing functionality.

Во время разработки субграфа есть две ключевые команды:

```bash
$ graph codegen # генерирует типы из файла схемы, указанного в манифесте
$ graph build # генерирует Web Assembly из файлов AssemblyScript и подготавливает все файлы субграфа в папке /build
```

### Определение манифеста субграфа

The subgraph manifest (`subgraph.yaml`) identifies the data sources for the subgraph, the triggers of interest, and the functions that should be run in response to those triggers. See below for an example subgraph manifest for a NEAR subgraph:

```yaml
specVersion: 0.0.2
schema:
  file: ./src/schema.graphql # link to the schema file
dataSources:
  - kind: near
    network: near-mainnet
    source:
      account: app.good-morning.near # This data source will monitor this account
      startBlock: 10662188 # Required for NEAR
    mapping:
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      blockHandlers:
        - handler: handleNewBlock # the function name in the mapping file
      receiptHandlers:
        - handler: handleReceipt # the function name in the mapping file
      file: ./src/mapping.ts # link to the file with the Assemblyscript mappings
```

- NEAR subgraphs introduce a new `kind` of data source (`near`)
- The `network` should correspond to a network on the hosting Graph Node. On Subgraph Studio, NEAR's mainnet is `near-mainnet`, and NEAR's testnet is `near-testnet`
- NEAR data sources introduce an optional `source.account` field, which is a human-readable ID corresponding to a [NEAR account](https://docs.near.org/concepts/protocol/account-model). This can be an account or a sub-account.
- NEAR data sources introduce an alternative optional `source.accounts` field, which contains optional suffixes and prefixes. At least prefix or suffix must be specified, they will match the any account starting or ending with the list of values respectively. The example below would match: `[app|good].*[morning.near|morning.testnet]`. If only a list of prefixes or suffixes is necessary the other field can be omitted.

```yaml
accounts:
  prefixes:
    - app
    - good
  suffixes:
    - morning.near
    - morning.testnet
```

Источники данных NEAR поддерживают два типа обработчиков:

- `blockHandlers`: run on every new NEAR block. No `source.account` is required.
- `receiptHandlers`: run on every receipt where the data source's `source.account` is the recipient. Note that only exact matches are processed ([subaccounts](https://docs.near.org/tutorials/crosswords/basics/add-functions-call#create-a-subaccount) must be added as independent data sources).

### Определение схемы

Определение схемы описывает структуру итоговой базы данных субграфа и отношения между объектами. Это не зависит от исходного источника данных. Более подробную информацию об определении схемы субграфа можно найти [здесь](/developing/creating-a-subgraph/#the-graphql-schema).

### Мэппинги AssemblyScript

Обработчики для обработки событий написаны на [AssemblyScript](https://www.assemblyscript.org/).

NEAR indexing introduces NEAR-specific data types to the [AssemblyScript API](/subgraphs/developing/creating/graph-ts/api/).

```typescript

class ExecutionOutcome {
      gasBurnt: u64,
      blockHash: Bytes,
      id: Bytes,
      logs: Array<string>,
      receiptIds: Array<Bytes>,
      tokensBurnt: BigInt,
      executorId: string,
  }

class ActionReceipt {
      predecessorId: string,
      receiverId: string,
      id: CryptoHash,
      signerId: string,
      gasPrice: BigInt,
      outputDataReceivers: Array<DataReceiver>,
      inputDataIds: Array<CryptoHash>,
      actions: Array<ActionValue>,
  }

class BlockHeader {
      height: u64,
      prevHeight: u64,// Always zero when version < V3
      epochId: Bytes,
      nextEpochId: Bytes,
      chunksIncluded: u64,
      hash: Bytes,
      prevHash: Bytes,
      timestampNanosec: u64,
      randomValue: Bytes,
      gasPrice: BigInt,
      totalSupply: BigInt,
      latestProtocolVersion: u32,
  }

class ChunkHeader {
      gasUsed: u64,
      gasLimit: u64,
      shardId: u64,
      chunkHash: Bytes,
      prevBlockHash: Bytes,
      balanceBurnt: BigInt,
  }

class Block {
      author: string,
      header: BlockHeader,
      chunks: Array<ChunkHeader>,
  }

class ReceiptWithOutcome {
      outcome: ExecutionOutcome,
      receipt: ActionReceipt,
      block: Block,
  }
```

These types are passed to block & receipt handlers:

- Block handlers will receive a `Block`
- Receipt handlers will receive a `ReceiptWithOutcome`

Otherwise, the rest of the [AssemblyScript API](/subgraphs/developing/creating/graph-ts/api/) is available to NEAR subgraph developers during mapping execution.

This includes a new JSON parsing function - logs on NEAR are frequently emitted as stringified JSONs. A new `json.fromString(...)` function is available as part of the [JSON API](/subgraphs/developing/creating/graph-ts/api/#json-api) to allow developers to easily process these logs.

## Развертывание NEAR субграфа

Once you have a built subgraph, it is time to deploy it to Graph Node for indexing. NEAR subgraphs can be deployed to any Graph Node `>=v0.26.x` (this version has not yet been tagged & released).

Subgraph Studio and the upgrade Indexer on The Graph Network currently supports indexing NEAR mainnet and testnet in beta, with the following network names:

- `near-mainnet`
- `near-testnet`

More information on creating and deploying subgraphs on Subgraph Studio can be found [here](/deploying/deploying-a-subgraph-to-studio/).

As a quick primer - the first step is to "create" your subgraph - this only needs to be done once. On Subgraph Studio, this can be done from [your Dashboard](https://thegraph.com/studio/): "Create a subgraph".

После того как субграф создан, его можно развернуть с помощью команды `graph deploy` в CLI:

```sh
$ graph create --node <graph-node-url> <subgraph-name> # creates a subgraph on a local Graph Node (on Subgraph Studio, this is done via the UI)
$ graph deploy --node <graph-node-url> --ipfs https://api.thegraph.com/ipfs/ <subgraph-name> # uploads the build files to a specified IPFS endpoint, and then deploys the subgraph to a specified Graph Node based on the manifest IPFS hash
```

Конфигурация ноды будет зависеть от того, где развертывается подграф.

### Subgraph Studio

```sh
graph auth
graph deploy <subgraph-name>
```

### Local Graph Node (based on default configuration)

```sh
graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 <subgraph-name>
```

Как только ваш подграф будет развернут, он будет проиндексирован Graph Node. Вы можете проверить его прогресс, сделав запрос к самому субграфу:

```graphql
{
  _meta {
    block {
      number
    }
  }
}
```

### Indexing NEAR with a Local Graph Node

Запуск ноды Graph, который индексирует NEAR, имеет следующие эксплуатационные требования:

- Фреймворк NEAR Indexer с инструментарием Firehose
- Компонент(ы) NEAR Firehose
- Graph Node с настроенным эндпоинтом Firehose

В ближайшее время мы предоставим более подробную информацию о запуске вышеуказанных компонентов.

## Запрос NEAR подграфа

The GraphQL endpoint for NEAR subgraphs is determined by the schema definition, with the existing API interface. Please visit the [GraphQL API documentation](/subgraphs/querying/graphql-api/) for more information.

## Примеры субграфов

Вот несколько примеров субграфов для справки:

[NEAR Blocks](https://github.com/graphprotocol/graph-tooling/tree/main/examples/near-blocks)

[NEAR Receipts](https://github.com/graphprotocol/graph-tooling/tree/main/examples/near-receipts)

## Часто задаваемые вопросы

### How does the beta work?

Поддержка NEAR находится в стадии бета-тестирования, что означает, что в API могут быть внесены изменения, поскольку мы продолжаем работать над улучшением интеграции. Пожалуйста, напишите по электронной почте near@thegraph.com чтобы мы могли поддержать вас в создании NEAR подграфов и держать вас в курсе последних разработок!

### Can a subgraph index both NEAR and EVM chains?

Нет, субграф может поддерживать источники данных только из одного чейна/сети.

### Can subgraphs react to more specific triggers?

В настоящее время поддерживаются только триггеры Block и Receipt. Мы исследуем триггеры для вызовов функций к указанной учетной записи. Мы также заинтересованы в поддержке триггеров событий, когда NEAR обладает собственной поддержкой событий.

### Will receipt handlers trigger for accounts and their sub-accounts?

If an `account` is specified, that will only match the exact account name. It is possible to match sub-accounts by specifying an `accounts` field, with `suffixes` and `prefixes` specified to match accounts and sub-accounts, for example the following would match all `mintbase1.near` sub-accounts:

```yaml
accounts:
  suffixes:
    - mintbase1.near
```

### Can NEAR subgraphs make view calls to NEAR accounts during mappings?

Это не поддерживается. Мы оцениваем, требуется ли эта функциональность для индексации.

### Can I use data source templates in my NEAR subgraph?

В настоящее время это не поддерживается. Мы оцениваем, требуется ли эта функциональность для индексации.

### Ethereum subgraphs support "pending" and "current" versions, how can I deploy a "pending" version of a NEAR subgraph?

Ожидающая функциональность еще не поддерживается для NEAR подграфов. Тем временем вы можете развернуть новую версию на другом "именованном" подграфе, а затем, когда она будет синхронизирована с заголовком чейна, вы можете повторно развернуть ее на свой основной "именованный" подграф, который будет использовать тот же базовый идентификатор развертывания, поэтому основной субграф будет мгновенно синхронизирован.

### My question hasn't been answered, where can I get more help building NEAR subgraphs?

If it is a general question about subgraph development, there is a lot more information in the rest of the [Developer documentation](/subgraphs/quick-start/). Otherwise please join [The Graph Protocol Discord](https://discord.gg/graphprotocol) and ask in the #near channel or email near@thegraph.com.

## Ссылки

- [NEAR developer documentation](https://docs.near.org/tutorials/crosswords/basics/set-up-skeleton)
