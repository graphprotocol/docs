---
title: AssemblyScript API
---

> Примечание: если Вы создали субграф `graph-cli`/`graph-ts` версии, предшествующей `0.22.0`, Вы используете более старую версию AssemblyScript. Мы рекомендуем Вам ознакомиться с [`Руководством по миграции`](/release-notes/assemblyscript-migration-guide)

На этой странице описаны встроенные API, которые можно использовать при написании мэппингов субграфов. По умолчанию доступны два вида API:

- [библиотека Graph TypeScript](https://github.com/graphprotocol/graph-ts) (`graph-ts`) и
- код, сгенерированный из файлов субграфов с помощью `graph codegen`.

Также возможно добавлять другие библиотеки в качестве зависимостей, если они совместимы с [AssemblyScript](https://github.com/AssemblyScript/assemblyscript). Поскольку это язык, на котором написаны мэппинги, [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki) является хорошим источником информации о языке и функциях стандартной библиотеки.

## Установка

Субграфы, созданные с помощью [`graph init`](/developing/creating-a-subgraph), поставляются с предварительно настроенными зависимостями. Всё, что требуется для установки этих зависимостей, - это выполнить одну из следующих команд:

```sh
yarn install # Yarn
npm install  # NPM
```

Если субграф был создан с нуля, одна из следующих двух команд установит библиотеку Graph TypeScript в качестве зависимости:

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## Референс API

Библиотека `@graphprotocol/graph-ts` предоставляет следующие API:

- API `ethereum` для работы со смарт-контактами Ethereum, событиями, блоками, транзакциями и значениями Ethereum.
- API `store` для загрузки и сохранения объектов из хранилища ноды The Graph и в него.
- `log` API для регистрации сообщений в выходных данных ноды The Graph и Graph Explorer.
- `ipfs` API для загрузки файлов из IPFS.
- `json` API для анализа данных в формате JSON.
- `crypto` API для использования криптографических функций.
- Низкоуровневые примитивы для перевода между системами различных типов, таких как Ethereum, JSON, GraphQL и AssemblyScript.

### Версии

`apiVersion` в манифесте субграфа указывает версию мэппинга API, которая запускается Graph Node для данного субграфа. Текущая версия мэппинга API - 0.0.6.

| Версия | Примечания к релизу                                                                                                                                                                                                                                      |
|:------:| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0.0.7  | К типам Ethereum добавлены классы `transactionReceipt` и `Log` <br />К объекту Ethereum Event добавлено поле `receivation`                                                                                                                         |
| 0.0.6  | В объект Ethereum Transaction добавлено поле `nonce`<br />В объект Ethereum Block добавлено поле `baseFeePerGas`                                                                                                                                   |
| 0.0.5  | AssemblyScript обновлен до версии 0.19.10 (сюда включены критические изменения, см. [`Руководство по миграции`](/release-notes/assemblyscript-migration-guide))<br />`ethereum.transaction.gasUsed` переименован в `ethereum.transaction.gasLimit` |
| 0.0.4  | В объект Ethereum SmartContractCall добавлено поле `functionSignature`                                                                                                                                                                                   |
| 0.0.3  | В объект Ethereum Call добавлено поле `from`<br />`etherem.call.address` переименован в `ethereum.call.to`                                                                                                                                         |
| 0.0.2  | В объект Ethereum Transaction добавлено поле `input`                                                                                                                                                                                                     |

### Встроенные типы

Документацию по базовым типам, встроенным в AssemblyScript, можно найти в [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types).

Следующие дополнительные типы предоставляются `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` представляет собой массив `u8`.

_Конструкция_

- `fromI32(x: i32): ByteArray` — Разбивает `x` на байты.
- `fromHexString(hex: string): ByteArray` - Длина ввода должна быть четной. Префикс `0x` необязателен.

_Конверсии типов_

- `toHexString(): строка` - Преобразуется в шестнадцатеричную строку с префиксом `0x`.
- `toString(): строка` - Интерпретирует байты как строку UTF-8.
- `to Base 58(): string` - Кодирует байты в строку base58.
- `to U32(): u32` - Интерпретирует байты как little-endian `u32`. Выбрасывает в случае переполнения.
- `to I32(): i32` - Интерпретирует массив байтов как little-endian `i32`. Выбрасывает в случае переполнения.

_Операторы_

- `equals(y: ByteArray): bool` – может быть записано как `x == y`.
- `concat(other: ByteArray) : ByteArray` - возвращает новый `ByteArray`, состоящий из `this`, за которым непосредственно следует `other`
- `concatI32(other: i32) : ByteArray` - возвращает новый `ByteArray`, состоящий из `this`, за которым непосредственно следует байтовое представление `other`

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal` используется для представления десятичных знаков произвольной точности.

> Примечание: [Внутренний](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal` хранится в [формате IEEE-754 decimal128 с плавающей запятой](https://en.wikipedia.org/wiki/Decimal128_floating-point_format), который поддерживает 34 десятичных знака значащего числа. Это делает `BigDecimal` неподходящим для представления типов с фиксированной запятой, которые могут содержать более 34 цифр, таких как Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) или его эквивалентов.

_Конструкция_

- `constructor(bigInt: BigInt)` — создает `BigDecimal` из `BigInt`.
- `static fromString(s: string): BigDecimal` – выполняет синтаксический анализ из десятичной строки.

_Конверсии типов_

- `toString(): string` – выводит в виде десятичной строки.

_Математика_

- `plus(y: BigDecimal): BigDecimal` – может быть записано как `x + y`.
- `minus(y: BigDecimal): BigDecimal` – может быть записано как `x - y`.
- `times(y: BigDecimal): BigDecimal` – может быть записано как `x * y`.
- `div(y: BigDecimal): BigDecimal` – может быть записано как `x / y`.
- `equals(y: BigDecimal): bool` – может быть записано как `x == y`.
- `notEqual(y: BigDecimal): bool` – может быть записано как `x != y`.
- `lt(y: BigDecimal): bool` – может быть записано как `x < y`.
- `le(y: BigDecimal): bool` – может быть записано как `x <= y`.
- `gt(y: BigDecimal): bool` – может быть записано как `x > y`.
- `ge(y: BigDecimal): bool` – может быть записано как `x >= y`.
- `neg(): BigDecimal` - может быть записано как `-x`.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` используется для представления больших целых чисел. Сюда входят значения Ethereum типа от `uint32` до `uint256` и от `int64` до `int256`. Все, что находится ниже `uint32`, например `int32`, `uint24` или `int8`, представлено как `i32`.

Класс `BigInt` имеет следующий API:

_Конструкция_

- `BigInt.fromI32(x: i32): BigInt` – создает `BigInt` из `i32`.
- `BigInt.fromString(s: строка): BigInt`– Анализирует `BigInt` из строки.
- `BigInt.fromUnsignedBytes(x: байты): BigInt` – Интерпретирует `bytes` как little-endian целое число без знака. Если Вы вводите big-endian, сначала вызовите `.reverse()`.
- `BigInt.fromSignedBytes(x: байты): BigInt` – Интерпретирует `bytes` как little-endian целое число со знаком. Если Вы вводите big-endian, сначала вызовите `.reverse()`.

  _Конверсии типов_

- `x.toHex(): string` – преобразует `BigInt` в строку шестнадцатеричных символов.
- `x.toString(): string` – преобразует `BigInt` в строку десятичных чисел.
- `x.toI32(): i32` – возвращает `BigInt` в виде `i32`; завершается с ошибкой, если значение не соответствует `i32`. Рекомендуется сначала проверить `x.is I32()`.
- `x.to BigDecimal(): BigDecimal` - преобразует в десятичное число без дробной части.

_Математика_

- `x.plus(y: BigInt): BigInt` – может быть записано как `x + y`.
- `x.minus(y: BigInt): BigInt` – может быть записано как `x - y`.
- `x.times(y: BigInt): BigInt` – может быть записано как `x * y`.
- `x.div(y: BigInt): BigInt`– может быть записано как `x / y`.
- `x.mod(y: BigInt): BigInt` – может быть записано как `x % y`.
- `x.equals(y: BigInt): bool` – может быть записано как `x == y`.
- `x.NotEqual(y: BigInt): bool` – может быть записано как `x != y`.
- `x.lt (y: BigInt): bool` – может быть записано как `x < y`.
- `x.le(y: BigInt): bool` – может быть записано как `x <= y`.
- `x.gt (y: BigInt): bool` – может быть записано как `x > y`.
- `x.ge(y: BigInt): bool` – может быть записано как `x >= y`.
- `x.neg(): BigInt` – может быть записано как `-x`.
- `x.divDecimal(y: BigDecimal): BigDecimal` – делит на десятичное число, что дает десятичный результат.
- `x.isZero(): bool` – Удобство для проверки, равно ли число нулю.
- `x.isI32(): bool` – Проверяет, соответствует ли число `i32`.
- `x.abs(): BigInt` – Абсолютное значение.
- `x.pow(exp: u8): BigInt` – Возведение в степень.
- `bitOr(x: BigInt, y: BigInt): BigInt` – может быть записан как `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – может быть записан как `x && y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – может быть записан как `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – может быть записан как `x >> y`.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap` может использоваться для хранения пар ключ-значений. Смотрите [ этот пример](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

Класс `TypedMap` имеет следующий API:

- `new TypedMap<K, V>()` создает пустую карту с ключами типа `K` и значениями типа `V`
- `map.set(key: K, value: V): void` – устанавливает значение `key` в `value`
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – возвращает пару ключ-значение для `key` или `null`, если `key` не существует на карте
- `map.get(key: K): V | null` – возвращает значение для `key` или `null`, если `key` не существует на карте
- `map.isSet(key: K): bool` – возвращает `true`, если `key` существует на карте, и `false`, если его нет

#### Bytes

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`Bytes` используется для представления массивов байтов произвольной длины. Сюда входят значения Ethereum типа `bytes`, `bytes32` и т. д.

Класс `Bytes` расширяет [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) в AssemblyScript и это поддерживает все функциональные возможности `Uint8Array`, а также следующие новые методы:

_Конструкция_

- `fromHexString(hex: string) : Bytes` - Преобразует строку `hex`, которая должна состоять из четного числа шестнадцатеричных цифр, в `ByteArray`. Строка `hex` может опционально начинаться с `0x`
- `fromI32(i: i32) : Bytes` - Преобразовывает `i` в массив байтов

_Конверсии типов_

- `b.toHex()` – возвращает шестнадцатеричную строку, представляющую байты в массиве
- `b.toString()` – преобразует байты в массиве в строку символов Unicode
- `b.toBase58()` – преобразует значение Ethereum Bytes в кодировку base58 (используется для хэшей IPFS)

_Операторы_

- `b.concat(other: Bytes) : Bytes` - - возвращает новые `Bytes`, состоящие из `this`, за которым непосредственно следует `other`
- `b.concatI32(other: i32) : ByteArray` - возвращает новые `Bytes`, состоящие из `this`, за которым непосредственно следует байтовое представление `other`

#### Address

```typescript
import { Address } from '@graphprotocol/graph-ts'
```

`Address` расширяет `Bytes` для представления значений Ethereum `address`.

Поверх `Bytes` API добавляется следующий метод:

- `Address.fromString(s: string): Address` – создает `Address` из шестнадцатеричной строки
- `Address.fromBytes(b: Bytes): Address` — создайте `Address` из `b` длиной ровно 20 байт. Передача значения с меньшим или большим количеством байт приведет к ошибке

### Store API

```typescript
import { store } from '@graphprotocol/graph-ts'
```

API `store` позволяет загружать, сохранять и удалять объекты из хранилища the Graph Node и в него.

Объекты, записанные в хранилище, сопоставляются один к одному с типами `@entity`, определенными в схеме субграфов GraphQL. Чтобы сделать работу с этими объектами удобной, команда `graph codegen`, предоставляемая [Graph CLI](https://github.com/graphprotocol/graph-cli) генерирует классы объектов, которые являются подклассами встроенного типа `Entity`, с геттерами и сеттерами свойств для полей в схеме, а также методами загрузки и сохранения этих объектов.

#### Создание объектов

Ниже приведен общий шаблон для создания объектов из событий Ethereum.

```typescript
// Импорт класса событий Transfer, сгенерированного из ERC20 ABI
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// Импорт типа объекта Transfer, сгенерированного из схемы GraphQL 
import { Transfer } from '../generated/schema'
событие
// Обработчик события передачи
экспортирует функцию handleTransfer(event: TransferEvent): void {
  // Создание объекта Transfer, с использованием хеша транзакции в качестве идентификатора объекта
let id = event.transaction.hash
  let transfer = new Transfer(id)

  // Установка свойства объекта, с использованием параметров события
transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Сохранение объекта в хранилище
transfer.save()
}
```

Когда при обработке чейна возникает событие `Transfer`, оно передается обработчику события `handleTransfer`, используя сгенерированный тип `Transfer` (здесь используется псевдоним `TransferEvent`, чтобы избежать конфликта наименования с типом объект). Этот тип позволяет получить доступ к таким данным, как родительская транзакция события и ее параметры.

Каждый объект должен иметь уникальный идентификатор, чтобы избежать коллизий с другими объектами. Довольно часто параметры события включают уникальный идентификатор, который может быть использован. Примечание: Использование хэша транзакции в качестве идентификатора предполагает, что никакие другие события в той же транзакции не создают объекты с этим хэшем в качестве идентификатора.

#### Загрузка объектов из хранилища

Если объект уже существует, его можно загрузить из хранилища следующим образом:

```typescript
let id = event.transaction.hash // или некоторым образом создается идентификатор
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}


// Используйте объект Transfer, как и раньше
```

Поскольку объект может еще не существовать в хранилище, метод `load` возвращает значение типа `Transfer | null`. Таким образом, перед использованием значения может потребоваться проверка на наличие `null`.

> ** Примечание:** Загрузка объектов необходима только в том случае, если изменения, внесенные в мэппинг, зависят от предыдущих данных объекта. В следующем разделе описаны два способа обновления существующих объектов.

#### Поиск объектов, созданных внутри блока

Начиная с `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 и `@graphprotocol/graph-cli` v0.49.0 метод `loadInBlock ` доступен для всех типов объектов.

Хранилище API облегчает поиск объектов, которые были созданы или обновлены в текущем блоке. Типичная ситуация для этого заключается в том, что один обработчик создает транзакцию из некоторого события в чейне, а более поздний обработчик хочет получить доступ к этой транзакции, если она существует. В случае, когда транзакция не была осуществлена, субграфу придется обратиться к базе данных только для того, чтобы узнать, что объект не существует; если же автор субграфа знает, что объект, должен был быть создан в том же блоке, использование loadInBlock позволит избежать этого обхода базы данных. Для некоторых субграфов эти пропущенные запросы могут значительно увеличить время индексации.

```typescript
let id = event.transaction.hash // или некоторым образом создается идентификатор
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}


// Используйте объект Transfer, как и раньше
```

> Примечание: Если в данном блоке не создан объект, `loadInBlock` вернет `null`, даже если в хранилище есть объект с данным идентификатором.

#### Поиск производных объектов

Начиная с `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 и `@graphprotocol/graph-cli` v0.51.0 метод `loadRelated ` доступен.

Это позволяет загружать поля производных объектов из обработчика событий. Например, учитывая следующую схему:

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

Следующий код загрузит объект `Token`, из которого был получен объект `Holder`:

```typescript
let holder = Holder.load('test-id')
// Загрузите объект Token, из которого был получен объект Holder
let token = holder.tokens.load()
```

#### Обновление существующих объектов

Существует два способа обновить существующий объект:

1. Загрузите объект, например, с помощью `Transfer.load(id)`, установите свойства объекта, затем `.save()` верните его обратно в хранилище.
2. Просто создайте объект, например, с помощью `new Transfer(id)`, установите свойства объекта, затем сохраните `.save()` его в хранилище. Если объект уже существует, изменения будут объединены с ним.

Изменение свойств в большинстве случаев не вызывает затруднений благодаря сгенерированным установщикам свойств:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Также можно сбросить свойства с помощью одной из следующих двух инструкций:

```typescript
transfer.from.unset()
transfer.from = null
```

Это работает только с необязательными свойствами, т.е. свойствами, которые объявлены без `!` в GraphQL. Двумя примерами могут служить `owner: Bytes` или `amount: BigInt`.

Обновление свойств массива немного сложнее, поскольку получение массива из объекта создает копию этого массива. Это означает, что после изменения массива свойства массива должны быть снова явно установлены. Далее предполагается, что `entity` имеет поле `numbers: [BigInt!]!`.

```typescript
// Это не сработает
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// Это сработает
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Удаление объектов из хранилища

В настоящее время нет способа удалить объект с помощью сгенерированных типов. Вместо этого для удаления объекта требуется передать имя типа объекта и идентификатор объекта в `store.remove`:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API предоставляет доступ к смарт-контрактам, общедоступным переменным состояния, функциям контрактов, событиям, транзакциям, блокам и кодированию/декодированию данных Ethereum.

#### Поддержка типов Ethereum

Как и в случае с объектами, `graph codegen` генерирует классы для всех смарт-контрактов и событий, используемых в субграфе. Для этого ABI контракта должны быть частью источника данных в манифесте субграфа. Как правило, файлы ABI хранятся в папке `abis/`.

С помощью сгенерированных классов преобразования между типами Ethereum и [встроенными типами](#built-in-types) происходят за кулисами, так что авторам субграфов не нужно беспокоиться о них.

Следующий пример иллюстрирует это. С учётом схемы субграфа, такой как

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

и сигнатура события `Transfer(address,address,uint256)` на Ethereum, значения `from`, `to` и `amount` типа `address`, `address` и `uint256` преобразуются в `Address` и `BigInt`, что позволяет передавать их в свойства `Bytes!` и `BigInt!` объекта `Transfer`:

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### События и данные о блоках/транзакциях

События Ethereum, передаваемые обработчикам событий, такие как событие `Transfer` в предыдущих примерах, предоставляют доступ не только к параметрам события, но и к их родительской транзакции и блоку, частью которого они являются. Следующие данные могут быть получены из экземпляров `event` (эти классы являются частью модуля `ethereum` в `graph-ts`):

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Доступ к состоянию смарт-контракта

Код, сгенерированный с помощью `graph codegen`, также включает классы для смарт-контрактов, используемых в субграфе. Они могут быть использованы для доступа к общедоступным переменным состояния и вызова функций контракта в текущем блоке.

Распространенным шаблоном является доступ к контракту, из которого исходит событие. Это достигается с помощью следующего кода:

```typescript
// Импорт сгенерированного класса контракта и сгенерированного класса события Transfer
import { ERC20Contract, Transfer as TransferEvent } from '../generated/ERC20Contract/ERC20Contract'
// Импорт созданного класса объекта
import { Transfer } from '../generated/schema'

export function handleTransfer(event: TransferEvent) {
  // Привязка контракта к адресу, сгенерировавшему событие
  let contract = ERC20Contract.bind(event.address)

   // Доступ к переменным состояния и функциям путем их вызова
   пусть erc20Symbol = контракт.символ()
}
```

`Transfer` связывается с `TransferEvent`, чтобы избежать конфликта наименований с типом объекта

Пока `ERC20Contract` в Ethereum имеет общедоступную функцию только для чтения, называемую `symbol`, ее можно вызвать с помощью `.symbol()`. Для общедоступных переменных состояния автоматически создается метод с таким же именем.

Любой другой контракт, который является частью субграфа, может быть импортирован из сгенерированного кода и привязан к действительному адресу.

#### Обработка возвращенных вызовов

Если доступные только для чтения методы Вашего контракта могут вызвать откат, то Вам следует справиться с этим, вызвав сгенерированный метод контракта с префиксом `try_`. Например, в контракте Gravity используется метод `gravatarToOwner`. Этот код сможет обработать откат в этом методе:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

Обратите внимание, что Graph Node, подключенная к клиенту Geth или Infura, может обнаруживать не все откаты. Если Вы полагаетесь на это, мы рекомендуем использовать Graph Node, подключенную к клиенту Parity.

#### Кодирование/декодирование ABI

Данные могут быть закодированы и декодированы в соответствии с форматом кодирования ABI Ethereum с использованием функций `encode` и `decode` в модуле `ethereum`.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

Для получения дополнительной информации:

- [[Спецификация ABI](https://crowdin. com/backend/phrases/phrases_as_html? project_id=447430&target_language_id=41&file_id=674)](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Кодирование/декодирование [Библиотека Rust/CLI](https://github.com/rust-ethereum/ethabi)
- Ещё [ сложный пример](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Логирование API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

API `log` позволяет субграфам записывать информацию в стандартный вывод Graph Node, а также в Graph Explorer. Сообщения могут быть зарегистрированы с использованием различных уровней ведения лога. Для составления сообщений лога из аргумента предусмотрен синтаксис строки базового формата.

API `log` включает в себя следующие функции:

- `log.debug(fmt: string, args: Array<string>): void` - регистрирует сообщение об отладке.
- `log.info (fmt: string, args: Array<string>): void` - регистрирует информационное сообщение.
- `log.warning(fmt: string, args: Array<string>): void` - регистрирует предупреждение.
- `log.error(fmt: string, args: Array<string>): void` - регистрирует сообщение об ошибке.
- `log.critical(fmt: string, args: Array<string>): void` – регистрирует критическое сообщение _и_ завершает работу субграфа.

API `log` принимает строку формата и массив строковых значений. Затем он заменяет заполнители строковыми значениями из массива. Первый `{}` заполнитель заменяется первым значением в массиве, второй `{}` заполнитель заменяется вторым значением и так далее.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Logging one or more values

##### Logging a single value

In the example below, the string value "A" is passed into an array to become`['A']` before being logged:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Logging a single entry from an existing array

In the example below, only the first value of the argument array is logged, despite the array containing three values.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"  (Even though three values are passed to `log.info`)
  log.info('My value is: {}', myArray)
}
```

#### Logging multiple entries from an existing array

Each entry in the arguments array requires its own placeholder `{}` in the log message string. The below example contains three placeholders `{}` in the log message. Because of this, all three values in `myArray` are logged.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Logging a specific entry from an existing array

To display a specific value in the array, the indexed value must be provided.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Logging event information

The example below logs the block number, block hash and transaction hash from an event:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Smart contracts occasionally anchor IPFS files on chain. This allows mappings to obtain the IPFS hashes from the contract and read the corresponding files from IPFS. The file data will be returned as `Bytes`, which usually requires further processing, e.g. with the `json` API documented later on this page.

Given an IPFS hash or path, reading a file from IPFS is done as follows:

```typescript
// Put this inside an event handler in the mapping
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Paths like `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// that include files in directories are also supported
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

**Note:** `ipfs.cat` is not deterministic at the moment. If the file cannot be retrieved over the IPFS network before the request times out, it will return `null`. Due to this, it's always worth checking the result for `null`.

It is also possible to process larger files in a streaming fashion with `ipfs.map`. The function expects the hash or path for an IPFS file, the name of a callback, and flags to modify its behavior:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Callbacks can also created entities
  let newItem = new Item(id)
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Set parent to "parentId"
  newitem.save()
}

// Put this inside an event handler in the mapping
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Alternatively, use `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

The only flag currently supported is `json`, which must be passed to `ipfs.map`. With the `json` flag, the IPFS file must consist of a series of JSON values, one value per line. The call to `ipfs.map` will read each line in the file, deserialize it into a `JSONValue` and call the callback for each of them. The callback can then use entity operations to store data from the `JSONValue`. Entity changes are stored only when the handler that called `ipfs.map` finishes successfully; in the meantime, they are kept in memory, and the size of the file that `ipfs.map` can process is therefore limited.

On success, `ipfs.map` returns `void`. If any invocation of the callback causes an error, the handler that invoked `ipfs.map` is aborted, and the subgraph is marked as failed.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

The `crypto` API makes a cryptographic functions available for use in mappings. Right now, there is only one:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON data can be parsed using the `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array interpreted as a valid UTF-8 sequence
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – safe version of `json.fromBytes`, it returns an error variant if the parsing failed
- `json.fromString(data: string): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(data: string): Result<JSONValue, boolean>` – safe version of `json.fromString`, it returns an error variant if the parsing failed

The `JSONValue` class provides a way to pull values out of an arbitrary JSON document. Since JSON values can be booleans, numbers, arrays and more, `JSONValue` comes with a `kind` property to check the type of a value:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

In addition, there is a method to check if the value is `null`:

- `value.isNull(): boolean`

When the type of a value is certain, it can be converted to a [built-in type](#built-in-types) using one of the following methods:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (and then convert `JSONValue` with one of the 5 methods above)

### Type Conversions Reference

| Source(s)            | Destination          | Conversion function          |
| -------------------- | -------------------- | ---------------------------- |
| Address              | Bytes                | none                         |
| Address              | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | none                         |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)    |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Bytes                | String (hexadecimal) | s.toHexString() or s.toHex() |
| Bytes                | String (unicode)     | s.toString()                 |
| Bytes                | String (base58)      | s.toBase58()                 |
| Bytes                | i32                  | s.toI32()                    |
| Bytes                | u32                  | s.toU32()                    |
| Bytes                | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | none                         |
| int32                | i32                  | none                         |
| int32                | BigInt               | BigInt.fromI32(s)            |
| uint24               | i32                  | none                         |
| int64 - int256       | BigInt               | none                         |
| uint32 - uint256     | BigInt               | none                         |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Address              | Address.fromString(s)        |
| Bytes                | Address              | Address.fromBytes(s)         |
| String               | BigInt               | BigInt.fromString(s)         |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Bytes                | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)        |

### Data Source Metadata

You can inspect the contract address, network and context of the data source that invoked the handler through the `dataSource` namespace:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entity and DataSourceContext

The base `Entity` class and the child `DataSourceContext` class have helpers to dynamically set and get fields:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### Common AssemblyScript Issues

There are certain [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) issues that are common to run into during subgraph development. They range in debug difficulty, however, being aware of them may help. The following is a non-exhaustive list of these issues:

- `Private` class variables are not enforced in [AssembyScript](https://www.assemblyscript.org/status.html#language-features). There is no way to protect class variables from being directly changed from the class object.
- Scope is not inherited into [closure functions](https://www.assemblyscript.org/status.html#on-closures), i.e. variables declared outside of closure functions cannot be used. Explanation in [Developer Highlights #3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s).
