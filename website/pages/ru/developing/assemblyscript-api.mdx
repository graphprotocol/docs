---
title: AssemblyScript API
---

> Примечание: если Вы создали субграф `graph-cli`/`graph-ts` версии, предшествующей `0.22.0`, Вы используете более старую версию AssemblyScript. Мы рекомендуем Вам ознакомиться с [`Руководством по миграции`](/release-notes/assemblyscript-migration-guide)

На этой странице описаны встроенные API, которые можно использовать при написании мэппингов субграфов. По умолчанию доступны два вида API:

- [библиотека Graph TypeScript](https://github.com/graphprotocol/graph-ts) (`graph-ts`) и
- код, сгенерированный из файлов субграфов с помощью `graph codegen`.

Также возможно добавлять другие библиотеки в качестве зависимостей, если они совместимы с [AssemblyScript](https://github.com/AssemblyScript/assemblyscript). Поскольку это язык, на котором написаны мэппинги, [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki) является хорошим источником информации о языке и функциях стандартной библиотеки.

## Установка

Субграфы, созданные с помощью [`graph init`](/developing/creating-a-subgraph), поставляются с предварительно настроенными зависимостями. Всё, что требуется для установки этих зависимостей, - это выполнить одну из следующих команд:

```sh
yarn install # Yarn
npm install  # NPM
```

Если субграф был создан с нуля, одна из следующих двух команд установит библиотеку Graph TypeScript в качестве зависимости:

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## Референс API

Библиотека `@graphprotocol/graph-ts` предоставляет следующие API:

- API `ethereum` для работы со смарт-контактами Ethereum, событиями, блоками, транзакциями и значениями Ethereum.
- API `store` для загрузки и сохранения объектов из хранилища ноды The Graph и в него.
- `log` API для регистрации сообщений в выходных данных ноды The Graph и Graph Explorer.
- `ipfs` API для загрузки файлов из IPFS.
- `json` API для анализа данных в формате JSON.
- `crypto` API для использования криптографических функций.
- Низкоуровневые примитивы для перевода между системами различных типов, таких как Ethereum, JSON, GraphQL и AssemblyScript.

### Версии

`apiVersion` в манифесте субграфа указывает версию мэппинга API, которая запускается Graph Node для данного субграфа. Текущая версия мэппинга API - 0.0.6.

| Версия | Примечания к релизу |
| :-: | --- |
| 0.0.7 | К типам Ethereum добавлены классы `transactionReceipt` и `Log` <br />К объекту Ethereum Event добавлено поле `receivation` |
| 0.0.6 | В объект Ethereum Transaction добавлено поле `nonce`<br />В объект Ethereum Block добавлено поле `baseFeePerGas` |
| 0.0.5 | AssemblyScript обновлен до версии 0.19.10 (сюда включены критические изменения, см. [`Руководство по миграции`](/release-notes/assemblyscript-migration-guide))<br />`ethereum.transaction.gasUsed` переименован в `ethereum.transaction.gasLimit` |
| 0.0.4 | В объект Ethereum SmartContractCall добавлено поле `functionSignature` |
| 0.0.3 | В объект Ethereum Call добавлено поле `from`<br />`etherem.call.address` переименован в `ethereum.call.to` |
| 0.0.2 | В объект Ethereum Transaction добавлено поле `input` |

### Встроенные типы

Документацию по базовым типам, встроенным в AssemblyScript, можно найти в [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types).

Следующие дополнительные типы предоставляются `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` представляет собой массив `u8`.

_Конструкция_

- `fromI32(x: i32): ByteArray` — Разбивает `x` на байты.
- `fromHexString(hex: string): ByteArray` - Длина ввода должна быть четной. Префикс `0x` необязателен.

_Конверсии типов_

- `toHexString(): строка` - Преобразуется в шестнадцатеричную строку с префиксом `0x`.
- `toString(): строка` - Интерпретирует байты как строку UTF-8.
- `to Base 58(): string` - Кодирует байты в строку base58.
- `to U32(): u32` - Интерпретирует байты как little-endian `u32`. Выбрасывает в случае переполнения.
- `to I32(): i32` - Интерпретирует массив байтов как little-endian `i32`. Выбрасывает в случае переполнения.

_Операторы_

- `equals(y: ByteArray): bool` – может быть записано как `x == y`.
- `concat(other: ByteArray) : ByteArray` - возвращает новый `ByteArray`, состоящий из `this`, за которым непосредственно следует `other`
- `concatI32(other: i32) : ByteArray` - возвращает новый `ByteArray`, состоящий из `this`, за которым непосредственно следует байтовое представление `other`

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal` используется для представления десятичных знаков произвольной точности.

> Примечание: [Внутренний](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal` хранится в [формате IEEE-754 decimal128 с плавающей запятой](https://en.wikipedia.org/wiki/Decimal128_floating-point_format), который поддерживает 34 десятичных знака значащего числа. Это делает `BigDecimal` неподходящим для представления типов с фиксированной запятой, которые могут содержать более 34 цифр, таких как Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) или его эквивалентов.

_Конструкция_

- `constructor(bigInt: BigInt)` — создает `BigDecimal` из `BigInt`.
- `static fromString(s: string): BigDecimal` – выполняет синтаксический анализ из десятичной строки.

_Конверсии типов_

- `toString(): string` – выводит в виде десятичной строки.

_Математика_

- `plus(y: BigDecimal): BigDecimal` – может быть записано как `x + y`.
- `minus(y: BigDecimal): BigDecimal` – может быть записано как `x - y`.
- `times(y: BigDecimal): BigDecimal` – может быть записано как `x * y`.
- `div(y: BigDecimal): BigDecimal` – может быть записано как `x / y`.
- `equals(y: BigDecimal): bool` – может быть записано как `x == y`.
- `notEqual(y: BigDecimal): bool` – может быть записано как `x != y`.
- `lt(y: BigDecimal): bool` – может быть записано как `x < y`.
- `le(y: BigDecimal): bool` – может быть записано как `x <= y`.
- `gt(y: BigDecimal): bool` – может быть записано как `x > y`.
- `ge(y: BigDecimal): bool` – может быть записано как `x >= y`.
- `neg(): BigDecimal` - может быть записано как `-x`.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` используется для представления больших целых чисел. Сюда входят значения Ethereum типа от `uint32` до `uint256` и от `int64` до `int256`. Все, что находится ниже `uint32`, например `int32`, `uint24` или `int8`, представлено как `i32`.

Класс `BigInt` имеет следующий API:

_Конструкция_

- `BigInt.fromI32(x: i32): BigInt` – создает `BigInt` из `i32`.
- `BigInt.fromString(s: строка): BigInt`– Анализирует `BigInt` из строки.
- `BigInt.fromUnsignedBytes(x: байты): BigInt` – Интерпретирует `bytes` как little-endian целое число без знака. Если Вы вводите big-endian, сначала вызовите `.reverse()`.
- `BigInt.fromSignedBytes(x: байты): BigInt` – Интерпретирует `bytes` как little-endian целое число со знаком. Если Вы вводите big-endian, сначала вызовите `.reverse()`.

  _Конверсии типов_

- `x.toHex(): string` – преобразует `BigInt` в строку шестнадцатеричных символов.
- `x.toString(): string` – преобразует `BigInt` в строку десятичных чисел.
- `x.toI32(): i32` – возвращает `BigInt` в виде `i32`; завершается с ошибкой, если значение не соответствует `i32`. Рекомендуется сначала проверить `x.is I32()`.
- `x.to BigDecimal(): BigDecimal` - преобразует в десятичное число без дробной части.

_Математика_

- `x.plus(y: BigInt): BigInt` – может быть записано как `x + y`.
- `x.minus(y: BigInt): BigInt` – может быть записано как `x - y`.
- `x.times(y: BigInt): BigInt` – может быть записано как `x * y`.
- `x.div(y: BigInt): BigInt`– может быть записано как `x / y`.
- `x.mod(y: BigInt): BigInt` – может быть записано как `x % y`.
- `x.equals(y: BigInt): bool` – может быть записано как `x == y`.
- `x.NotEqual(y: BigInt): bool` – может быть записано как `x != y`.
- `x.lt (y: BigInt): bool` – может быть записано как `x < y`.
- `x.le(y: BigInt): bool` – может быть записано как `x <= y`.
- `x.gt (y: BigInt): bool` – может быть записано как `x > y`.
- `x.ge(y: BigInt): bool` – может быть записано как `x >= y`.
- `x.neg(): BigInt` – может быть записано как `-x`.
- `x.divDecimal(y: BigDecimal): BigDecimal` – делит на десятичное число, что дает десятичный результат.
- `x.isZero(): bool` – Удобство для проверки, равно ли число нулю.
- `x.isI32(): bool` – Проверяет, соответствует ли число `i32`.
- `x.abs(): BigInt` – Абсолютное значение.
- `x.pow(exp: u8): BigInt` – Возведение в степень.
- `bitOr(x: BigInt, y: BigInt): BigInt` – может быть записан как `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – может быть записан как `x && y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – может быть записан как `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – может быть записан как `x >> y`.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap` может использоваться для хранения пар ключ-значений. Смотрите [ этот пример](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

Класс `TypedMap` имеет следующий API:

- `new TypedMap<K, V>()` создает пустую карту с ключами типа `K` и значениями типа `V`
- `map.set(key: K, value: V): void` – устанавливает значение `key` в `value`
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – возвращает пару ключ-значение для `key` или `null`, если `key` не существует на карте
- `map.get(key: K): V | null` – возвращает значение для `key` или `null`, если `key` не существует на карте
- `map.isSet(key: K): bool` – возвращает `true`, если `key` существует на карте, и `false`, если его нет

#### Bytes

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`Bytes` используется для представления массивов байтов произвольной длины. Сюда входят значения Ethereum типа `bytes`, `bytes32` и т. д.

Класс `Bytes` расширяет [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) в AssemblyScript и это поддерживает все функциональные возможности `Uint8Array`, а также следующие новые методы:

_Конструкция_

- `fromHexString(hex: string) : Bytes` - Преобразует строку `hex`, которая должна состоять из четного числа шестнадцатеричных цифр, в `ByteArray`. Строка `hex` может опционально начинаться с `0x`
- `fromI32(i: i32) : Bytes` - Преобразовывает `i` в массив байтов

_Конверсии типов_

- `b.toHex()` – возвращает шестнадцатеричную строку, представляющую байты в массиве
- `b.toString()` – преобразует байты в массиве в строку символов Unicode
- `b.toBase58()` – преобразует значение Ethereum Bytes в кодировку base58 (используется для хэшей IPFS)

_Операторы_

- `b.concat(other: Bytes) : Bytes` - - возвращает новые `Bytes`, состоящие из `this`, за которым непосредственно следует `other`
- `b.concatI32(other: i32) : ByteArray` - возвращает новые `Bytes`, состоящие из `this`, за которым непосредственно следует байтовое представление `other`

#### Address

```typescript
import { Address } from '@graphprotocol/graph-ts'
```

`Address` расширяет `Bytes` для представления значений Ethereum `address`.

Поверх `Bytes` API добавляется следующий метод:

- `Address.fromString(s: string): Address` – создает `Address` из шестнадцатеричной строки
- `Address.fromBytes(b: Bytes): Address` — создайте `Address` из `b` длиной ровно 20 байт. Передача значения с меньшим или большим количеством байт приведет к ошибке

### Store API

```typescript
import { store } from '@graphprotocol/graph-ts'
```

API `store` позволяет загружать, сохранять и удалять объекты из хранилища the Graph Node и в него.

Объекты, записанные в хранилище, сопоставляются один к одному с типами `@entity`, определенными в схеме субграфов GraphQL. Чтобы сделать работу с этими объектами удобной, команда `graph codegen`, предоставляемая [Graph CLI](https://github.com/graphprotocol/graph-cli) генерирует классы объектов, которые являются подклассами встроенного типа `Entity`, с геттерами и сеттерами свойств для полей в схеме, а также методами загрузки и сохранения этих объектов.

#### Создание объектов

Ниже приведен общий шаблон для создания объектов из событий Ethereum.

```typescript
// Импорт класса событий Transfer, сгенерированного из ERC20 ABI
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// Импорт типа объекта Transfer, сгенерированного из схемы GraphQL
import { Transfer } from '../generated/schema'
событие
// Обработчик события передачи
экспортирует функцию handleTransfer(event: TransferEvent): void {
  // Создание объекта Transfer, с использованием хеша транзакции в качестве идентификатора объекта
let id = event.transaction.hash
  let transfer = new Transfer(id)

  // Установка свойства объекта, с использованием параметров события
transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Сохранение объекта в хранилище
transfer.save()
}
```

Когда при обработке чейна возникает событие `Transfer`, оно передается обработчику события `handleTransfer`, используя сгенерированный тип `Transfer` (здесь используется псевдоним `TransferEvent`, чтобы избежать конфликта наименования с типом объект). Этот тип позволяет получить доступ к таким данным, как родительская транзакция события и ее параметры.

Каждый объект должен иметь уникальный идентификатор, чтобы избежать коллизий с другими объектами. Довольно часто параметры события включают уникальный идентификатор, который может быть использован. Примечание: Использование хэша транзакции в качестве идентификатора предполагает, что никакие другие события в той же транзакции не создают объекты с этим хэшем в качестве идентификатора.

#### Загрузка объектов из хранилища

Если объект уже существует, его можно загрузить из хранилища следующим образом:

```typescript
let id = event.transaction.hash // или некоторым образом создается идентификатор
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Используйте объект Transfer, как и раньше
```

Поскольку объект может еще не существовать в хранилище, метод `load` возвращает значение типа `Transfer | null`. Таким образом, перед использованием значения может потребоваться проверка на наличие `null`.

> ** Примечание:** Загрузка объектов необходима только в том случае, если изменения, внесенные в мэппинг, зависят от предыдущих данных объекта. В следующем разделе описаны два способа обновления существующих объектов.

#### Поиск объектов, созданных внутри блока

Начиная с `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 и `@graphprotocol/graph-cli` v0.49.0 метод `loadInBlock ` доступен для всех типов объектов.

Хранилище API облегчает поиск объектов, которые были созданы или обновлены в текущем блоке. Типичная ситуация для этого заключается в том, что один обработчик создает транзакцию из некоторого события в чейне, а более поздний обработчик хочет получить доступ к этой транзакции, если она существует. В случае, когда транзакция не была осуществлена, субграфу придется обратиться к базе данных только для того, чтобы узнать, что объект не существует; если же автор субграфа знает, что объект, должен был быть создан в том же блоке, использование loadInBlock позволит избежать этого обхода базы данных. Для некоторых субграфов эти пропущенные запросы могут значительно увеличить время индексации.

```typescript
let id = event.transaction.hash // или некоторым образом создается идентификатор
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Используйте объект Transfer, как и раньше
```

> Примечание: Если в данном блоке не создан объект, `loadInBlock` вернет `null`, даже если в хранилище есть объект с данным идентификатором.

#### Поиск производных объектов

Начиная с `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 и `@graphprotocol/graph-cli` v0.51.0 метод `loadRelated ` доступен.

Это позволяет загружать поля производных объектов из обработчика событий. Например, учитывая следующую схему:

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

Следующий код загрузит объект `Token`, из которого был получен объект `Holder`:

```typescript
let holder = Holder.load('test-id')
// Загрузите объект Token, из которого был получен объект Holder
let token = holder.tokens.load()
```

#### Обновление существующих объектов

Существует два способа обновить существующий объект:

1. Загрузите объект, например, с помощью `Transfer.load(id)`, установите свойства объекта, затем `.save()` верните его обратно в хранилище.
2. Просто создайте объект, например, с помощью `new Transfer(id)`, установите свойства объекта, затем сохраните `.save()` его в хранилище. Если объект уже существует, изменения будут объединены с ним.

Изменение свойств в большинстве случаев не вызывает затруднений благодаря сгенерированным установщикам свойств:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Также можно сбросить свойства с помощью одной из следующих двух инструкций:

```typescript
transfer.from.unset()
transfer.from = null
```

Это работает только с необязательными свойствами, т.е. свойствами, которые объявлены без `!` в GraphQL. Двумя примерами могут служить `owner: Bytes` или `amount: BigInt`.

Обновление свойств массива немного сложнее, поскольку получение массива из объекта создает копию этого массива. Это означает, что после изменения массива свойства массива должны быть снова явно установлены. Далее предполагается, что `entity` имеет поле `numbers: [BigInt!]!`.

```typescript
// Это не сработает
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// Это сработает
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Удаление объектов из хранилища

В настоящее время нет способа удалить объект с помощью сгенерированных типов. Вместо этого для удаления объекта требуется передать имя типа объекта и идентификатор объекта в `store.remove`:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API предоставляет доступ к смарт-контрактам, общедоступным переменным состояния, функциям контрактов, событиям, транзакциям, блокам и кодированию/декодированию данных Ethereum.

#### Поддержка типов Ethereum

Как и в случае с объектами, `graph codegen` генерирует классы для всех смарт-контрактов и событий, используемых в субграфе. Для этого ABI контракта должны быть частью источника данных в манифесте субграфа. Как правило, файлы ABI хранятся в папке `abis/`.

С помощью сгенерированных классов преобразования между типами Ethereum и [встроенными типами](#built-in-types) происходят за кулисами, так что авторам субграфов не нужно беспокоиться о них.

Следующий пример иллюстрирует это. С учётом схемы субграфа, такой как

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

и сигнатура события `Transfer(address,address,uint256)` на Ethereum, значения `from`, `to` и `amount` типа `address`, `address` и `uint256` преобразуются в `Address` и `BigInt`, что позволяет передавать их в свойства `Bytes!` и `BigInt!` объекта `Transfer`:

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### События и данные о блоках/транзакциях

События Ethereum, передаваемые обработчикам событий, такие как событие `Transfer` в предыдущих примерах, предоставляют доступ не только к параметрам события, но и к их родительской транзакции и блоку, частью которого они являются. Следующие данные могут быть получены из экземпляров `event` (эти классы являются частью модуля `ethereum` в `graph-ts`):

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Доступ к состоянию смарт-контракта

Код, сгенерированный с помощью `graph codegen`, также включает классы для смарт-контрактов, используемых в субграфе. Они могут быть использованы для доступа к общедоступным переменным состояния и вызова функций контракта в текущем блоке.

Распространенным шаблоном является доступ к контракту, из которого исходит событие. Это достигается с помощью следующего кода:

```typescript
// Импорт сгенерированного класса контракта и сгенерированного класса события Transfer
import { ERC20Contract, Transfer as TransferEvent } from '../generated/ERC20Contract/ERC20Contract'
// Импорт созданного класса объекта
import { Transfer } from '../generated/schema'

export function handleTransfer(event: TransferEvent) {
  // Привязка контракта к адресу, сгенерировавшему событие
  let contract = ERC20Contract.bind(event.address)

   // Доступ к переменным состояния и функциям путем их вызова
   пусть erc20Symbol = контракт.символ()
}
```

`Transfer` связывается с `TransferEvent`, чтобы избежать конфликта наименований с типом объекта

Пока `ERC20Contract` в Ethereum имеет общедоступную функцию только для чтения, называемую `symbol`, ее можно вызвать с помощью `.symbol()`. Для общедоступных переменных состояния автоматически создается метод с таким же именем.

Любой другой контракт, который является частью субграфа, может быть импортирован из сгенерированного кода и привязан к действительному адресу.

#### Обработка возвращенных вызовов

Если доступные только для чтения методы Вашего контракта могут вызвать откат, то Вам следует справиться с этим, вызвав сгенерированный метод контракта с префиксом `try_`. Например, в контракте Gravity используется метод `gravatarToOwner`. Этот код сможет обработать откат в этом методе:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

Обратите внимание, что Graph Node, подключенная к клиенту Geth или Infura, может обнаруживать не все откаты. Если Вы полагаетесь на это, мы рекомендуем использовать Graph Node, подключенную к клиенту Parity.

#### Кодирование/декодирование ABI

Данные могут быть закодированы и декодированы в соответствии с форматом кодирования ABI Ethereum с использованием функций `encode` и `decode` в модуле `ethereum`.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

Для получения дополнительной информации:

- [[Спецификация ABI](https://crowdin. com/backend/phrases/phrases_as_html? project_id=447430&target_language_id=41&file_id=674)](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Кодирование/декодирование [Библиотека Rust/CLI](https://github.com/rust-ethereum/ethabi)
- Ещё [ сложный пример](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Регистрация API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

API `log` позволяет субграфам записывать информацию в стандартный вывод Graph Node, а также в Graph Explorer. Сообщения могут быть зарегистрированы с использованием различных уровней ведения лога. Для составления сообщений лога из аргумента предусмотрен синтаксис строки базового формата.

API `log` включает в себя следующие функции:

- `log.debug(fmt: string, args: Array<string>): void` - регистрирует сообщение об отладке.
- `log.info (fmt: string, args: Array<string>): void` - регистрирует информационное сообщение.
- `log.warning(fmt: string, args: Array<string>): void` - регистрирует предупреждение.
- `log.error(fmt: string, args: Array<string>): void` - регистрирует сообщение об ошибке.
- `log.critical(fmt: string, args: Array<string>): void` – регистрирует критическое сообщение _и_ завершает работу субграфа.

API `log` принимает строку формата и массив строковых значений. Затем он заменяет заполнители строковыми значениями из массива. Первый `{}` заполнитель заменяется первым значением в массиве, второй `{}` заполнитель заменяется вторым значением и так далее.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Регистрация одного или нескольких значений

##### Регистрация одного значения

В приведенном ниже примере строковое значение "A" передается в массив, чтобы стать`['A']` до регистрации:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Отображает: "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Регистрация одной записи из существующего массива

В приведенном ниже примере регистрируется только первое значение массива аргументов, несмотря на то, что массив содержит три значения.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Отображает : "My value is: A" (Несмотря на то, что в `log.info` передаются три значения)
  log.info('My value is: {}', myArray)
}
```

#### Регистрация нескольких записей из существующего массива

Each entry in the arguments array requires its own placeholder `{}` in the log message string. The below example contains three placeholders `{}` in the log message. Because of this, all three values in `myArray` are logged.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Отображает : "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Регистрация конкретной записи из существующего массива

Чтобы отобразить определенное значение в массиве, необходимо указать индексированное значение.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Отображает : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Регистрация информации о событии

В приведенном ниже примере регистрируется номер блока, хэш блока и хэш транзакции из события:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Смарт-контракты иногда привязывают файлы IPFS к чейну. Это позволяет мэппингам получать хэши IPFS из контракта и считывать соответствующие файлы из IPFS. Данные файла будут возвращены в виде `Bytes`, что обычно требует дальнейшей обработки, например, с помощью `json` API, описанного далее на этой странице.

При наличии хеша или пути IPFS чтение файла из IPFS выполняется следующим образом:

```typescript
// Поместите это в обработчик события в мэппинге
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Пути, подобные `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`,
// которые включают файлы в директориях, также поддерживаются
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

** Примечание:** `pfs.cat ` на данный момент не является детерминированным. Если файл не может быть получен по сети IPFS до истечения времени ожидания запроса, он вернет `null`. В связи с этим всегда стоит проверять результат на наличие `null`.

С помощью `ipfs.map` можно также обрабатывать файлы большего размера в потоковом режиме. Функция ожидает, что хэш или путь к файлу IPFS, имя обратного вызова и флаги изменят его поведение:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // Смотрите документацию по JsonValue для получения подробной информации о работе
  // со значениями JSON
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Обратные вызовы также могут создавать объекты
  let newItem = new Item(id)
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Установите для родителя значение "parentId"
  newitem.save()
}

// Поместите это внутри обработчика событий в мэппинге
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// В качестве альтернативы, используйте `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

Единственным поддерживаемым в настоящее время флагом является `json`, который должен быть передан в `ipfs.map`. С флагом `json` файл IPFS должен состоять из серии значений JSON, по одному значению в строке. Вызов `ipfs.map` прочитает каждую строку в файле, десериализует ее в `JsonValue` и совершит обратный вызов для каждой из них. Затем обратный вызов может использовать операции с объектами для хранения данных из `JsonValue`. Изменения объекта сохраняются только после успешного завершения обработчика, вызвавшего `ipfs.map`; в то же время они хранятся в памяти, и поэтому размер файла, который может обработать `ipfs.map`, ограничен.

При успешном завершении `ipfs.map` возвращает `void`. Если какое-либо совершение обратного вызова вызывает ошибку, обработчик, вызвавший `ipfs.map`, прерывается, а субграф помечается как неудавшийся.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

The `crypto` API makes a cryptographic functions available for use in mappings. Right now, there is only one:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON data can be parsed using the `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array interpreted as a valid UTF-8 sequence
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – safe version of `json.fromBytes`, it returns an error variant if the parsing failed
- `json.fromString(data: string): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(data: string): Result<JSONValue, boolean>` – safe version of `json.fromString`, it returns an error variant if the parsing failed

The `JSONValue` class provides a way to pull values out of an arbitrary JSON document. Since JSON values can be booleans, numbers, arrays and more, `JSONValue` comes with a `kind` property to check the type of a value:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

In addition, there is a method to check if the value is `null`:

- `value.isNull(): boolean`

When the type of a value is certain, it can be converted to a [built-in type](#built-in-types) using one of the following methods:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (and then convert `JSONValue` with one of the 5 methods above)

### Type Conversions Reference

| Source(s)            | Destination          | Conversion function          |
| -------------------- | -------------------- | ---------------------------- |
| Address              | Bytes                | none                         |
| Address              | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | none                         |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)    |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Bytes                | String (hexadecimal) | s.toHexString() or s.toHex() |
| Bytes                | String (unicode)     | s.toString()                 |
| Bytes                | String (base58)      | s.toBase58()                 |
| Bytes                | i32                  | s.toI32()                    |
| Bytes                | u32                  | s.toU32()                    |
| Bytes                | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | none                         |
| int32                | i32                  | none                         |
| int32                | BigInt               | BigInt.fromI32(s)            |
| uint24               | i32                  | none                         |
| int64 - int256       | BigInt               | none                         |
| uint32 - uint256     | BigInt               | none                         |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Address              | Address.fromString(s)        |
| Bytes                | Address              | Address.fromBytes(s)         |
| String               | BigInt               | BigInt.fromString(s)         |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Bytes                | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)        |

### Data Source Metadata

You can inspect the contract address, network and context of the data source that invoked the handler through the `dataSource` namespace:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entity and DataSourceContext

The base `Entity` class and the child `DataSourceContext` class have helpers to dynamically set and get fields:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### Common AssemblyScript Issues

There are certain [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) issues that are common to run into during subgraph development. They range in debug difficulty, however, being aware of them may help. The following is a non-exhaustive list of these issues:

- `Private` class variables are not enforced in [AssembyScript](https://www.assemblyscript.org/status.html#language-features). There is no way to protect class variables from being directly changed from the class object.
- Scope is not inherited into [closure functions](https://www.assemblyscript.org/status.html#on-closures), i.e. variables declared outside of closure functions cannot be used. Explanation in [Developer Highlights #3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s).
