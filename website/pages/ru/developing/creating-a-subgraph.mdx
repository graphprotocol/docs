---
title: Создание субграфа
---

Субграф извлекает данные из блокчейна, обрабатывает их и сохраняет таким образом, чтобы их можно было легко запросить с помощью GraphQL.

![Определение субграфа](/img/defining-a-subgraph.png)

Определение субграфа состоит из нескольких файлов:

- `subgraph.yaml`: файл YAML, содержащий манифест субграфа

- `schema.graphql`: схема GraphQL, которая определяет, какие данные хранятся для Вашего субграфа и как их запрашивать через GraphQL

- `AssemblyScript Mappings`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript), который преобразует данные события в объекты, определенные в Вашей схеме (например, `mapping.ts` в этом руководстве)

> Чтобы использовать свой субграф в децентрализованной сети The Graph, Вам необходимо [создать ключ API](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key). Рекомендуется [добавить сигнал](/network/curating/#how-to-signal) в свой субграф как минимум с [3000 GRT](/sunrise/#how-can-i-ensure-high-quality-of-service-and-redundancy-for-subgraphs-on-the-graph-network).

Прежде чем Вы перейдете к подробному описанию содержимого файла манифеста, Вам необходимо установить[Graph CLI](https://github.com/graphprotocol/graph-tooling), который понадобится для создания и развертывания субграфа.

## Установка Graph CLI

The Graph CLI написан на JavaScript, и для его использования необходимо установить либо `yarn`, либо `npm`; в дальнейшем предполагается, что у Вас есть yarn.

Получив `yarn`, установите Graph CLI, запустив следующие команды

**Установка с помощью yarn:**

```bash
yarn global add @graphprotocol/graph-cli
```

**Установка с помощью npm:**

```bash
npm install -g @graphprotocol/graph-cli
```

После установки команду `graph init` можно использовать для настройки нового проекта субграфа либо из существующего контракта, либо из примера субграфа. Эту команду можно использовать для создания субграфа в Subgraph Studio, передав в `graph init --product subgraph-studio`. Если у Вас уже есть смарт-контракт, развернутый в выбранной Вами сети, загрузка нового субграфа из этого контракта может быть хорошим способом начать работу.

## Из существующего контракта

Следующая команда создает субграф, который индексирует все события существующего контракта. Он пытается получить ABI контракта из Etherscan и возвращается к запросу пути к локальному файлу. Если какой-либо из необязательных аргументов отсутствует, он проведет Вас через интерактивную форму.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>` - это идентификатор Вашего субграфа в Subgraph Studio, его можно найти на странице сведений о субграфе.

## Из примера субграфа

Второй режим, который поддерживает `graph init`, - это создание нового проекта из примера субграфа. Это делает следующая команда:

```sh
graph init --studio <SUBGRAPH_SLUG>
```

[Пример субграфа](https://github.com/graphprotocol/example-subgraph) основан на контракте Gravity Дэни Гранта, который управляет пользовательскими аватарами и генерирует события `NewGravatar` или `UpdateGravatar` при создании или обновлении аватаров. Субграф обрабатывает эти события, записывая объекты `Gravatar` в хранилище Graph Node и обеспечивая их обновление в соответствии с событиями. В следующих разделах будут рассмотрены файлы, составляющие манифест субграфа для этого примера.

## Добавление новых источников данных к существующему субграфу

Начиная с `v0.31.0` `graph-cli` поддерживает добавление новых источников данных к существующему субграфу с помощью команды `graph add`.

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Опции:

      --abi <path>            Путь к контракту ABI (default: download from Etherscan)
      --contract-name           Имя контракта (default: Contract)
      --merge-entities        Следует ли объединять объекты с одинаковым именем (default: false)
      --network-file <path>     Путь к файлу конфигурации сети (default: "./networks.json")
```

Команда `add` извлечёт ABI из Etherscan (если путь к ABI не указан с помощью опции `--abi`) и создаст новый `dataSource` таким же образом, как `graph init` создает `dataSource` `--from-contract`, соответствующим образом обновляя схему и мэппинги.

Параметр `--merge-entities` определяет, как разработчик хотел бы обрабатывать конфликты имен `entity` и `event`:

- Если `true`: новый ` dataSource ` должен использовать существующие ` eventHandlers` & `entities`.
- Если `false`: следует создать новую сущность и обработчик событий с помощью `${dataSourceName}{EventName}`.

Контракт `address` будет записан в `networks.json` для соответствующей сети.

> **Примечание:** При использовании интерактивного интерфейса командной строки после успешного запуска `graph init` Вам будет предложено добавить новый `dataSource`.

## Манифест субграфа

Манифест субграфа `subgraph.yaml` определяет смарт-контракты, которые индексирует Ваш субграф, на какие события из этих контрактов следует обращать внимание и как сопоставлять данные событий с объектами, которые хранит и позволяет запрашивать Graph Node. Полную спецификацию манифестов субграфов можно найти [здесь](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

Для примера субграфа `subgraph.yaml`:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
indexerHints:
  prune: auto
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
      endBlock: 7175245
    context:
      foo:
        type: Bool
        data: true
      bar:
        type: String
        data: 'bar'
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

Важными элементами манифеста, которые необходимо обновить, являются:

- `specVersion`: a semver version that identifies the supported manifest structure and functionality for the subgraph. The latest version is `1.2.0`. See [specVersion releases](#specversion-releases) section to see more details on features & releases.

- `description`: понятное описание того, что представляет собой субграф. Это описание отображается в Graph Explorer при развертывании субграфа в Subgraph Studio.

- ` repository `: URL-адрес репозитория, в котором можно найти манифест субграфа. Это также отображается в The Graph Explorer.

- `features`: список всех используемых имен [функций](#experimental-features).

- `indexerHints.prune`: определяет срок хранения исторических данных блока для субграфа. См. [сокращение](#prune) в разделе [indexerHints](#indexer-hints).

- `dataSources.source`: адрес смарт-контракта, источники субграфа и ABI смарт-контракта для использования. Адрес необязателен; отсутствие этого параметра позволяет индексировать совпадающие события из всех контрактов.

- `dataSources.source.startBlock`: необязательный номер блока, с которого источник данных начинает индексацию. В большинстве случаев мы предлагаем использовать блок, в котором был создан контракт.

- `dataSources.source.endBlock`: необязательный номер блока, индексирование которого прекращается источником данных, включая этот блок. Минимальная требуемая версия спецификации: `0.0.9`.

- `dataSources.context`: пары «ключ-значение», которые можно использовать внутри мэппингов субграфов. Поддерживает различные типы данных, такие как `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List` и `BigInt`. Для каждой переменной нужно указать ее `type` и `data`. Эти контекстные переменные затем становятся доступными в файлах мэппинга, предлагая больше настраиваемых параметров для разработки субграфов.

- `dataSources.mapping.entities`: объекты, которые источник данных записывает в хранилище. Схема для каждого объекта определена в файле schema.graphql.

- `dataSources.mapping.abis`: один или несколько именованных файлов ABI для исходного контракта, а также любых других смарт-контрактов, с которыми Вы взаимодействуете из мэппингов.

- `DataSources.mapping.EventHandlers`: перечисляет события смарт—контракта, на которые реагирует этот субграф, и обработчики в мэппинге —./src/mapping.ts в примере - которые преобразуют эти события в объекты в хранилище.

- `DataSources.mapping.callHandlers`: перечисляет функции смарт-контракта, на которые реагирует этот субграф, и обработчики в мэппинге, которые преобразуют входные и выходные данные для вызовов функций в объекты в хранилище.

- `dataSources.mapping.blockHandlers`: перечисляет блоки, на которые реагирует этот субграф, и обработчики в мэппинг, которые запускаются при добавлении блока в чейн. Без фильтра обработчик блока будет запускаться для каждого блока. Дополнительный фильтр вызовов может быть предоставлен путем добавления в обработчик поля `filter` с `kind: call `. Обработчик будет запущен только в том случае, если блок содержит хотя бы один вызов контракта источника данных.

Один субграф может индексировать данные из нескольких смарт-контрактов. Добавьте в массив `dataSources` запись для каждого контракта, данные которого нужно проиндексировать.

### Порядок запуска обработчиков

Триггеры для источника данных внутри блока упорядочиваются с помощью следующего процесса:

1. Триггеры событий и вызовов сначала упорядочиваются по индексу транзакции внутри блока.
2. Триггеры событий и вызовов в рамках одной транзакции упорядочиваются по следующему принципу: сначала триггеры событий, затем триггеры вызовов, причем для каждого типа соблюдается тот порядок, в котором они определены в манифесте.
3. Триггеры блоков запускаются после триггеров событий и вызовов в том порядке, в котором они определены в манифесте.

Эти правила оформления заказа могут быть изменены.

> **Примечание:** При создании нового [динамического источника данных](#data-source-templates-for-dynamically-created-contracts) обработчики, определенные для динамических источников данных, начнут обработку только после обработки всех существующих обработчиков источников данных и будут повторяться в той же последовательности при каждом запуске.

### SpecVersion Releases

| Версия | Примечания к релизу                                                                                                                                                    |
|:------:| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1.2.0  | Added support for [Indexed Argument Filtering](/#indexed-argument-filters--topic-filters) & declared `eth_call`                                                        |
| 1.1.0  | Supports [Timeseries & Aggregations](#timeseries-and-aggregations). Added support for type `Int8` for `id`.                                                            |
| 1.0.0  | Supports [`indexerHints`](/developing/creating-a-subgraph/#indexer-hints) feature to prune subgraphs                                                                   |
| 0.0.9  | Supports `endBlock` feature                                                                                                                                            |
| 0.0.8  | Added support for polling [Block Handlers](developing/creating-a-subgraph/#polling-filter) and [Initialisation Handlers](developing/creating-a-subgraph/#once-filter). |
| 0.0.7  | Added support for [File Data Sources](developing/creating-a-subgraph/#file-data-sources).                                                                              |
| 0.0.6  | Supports fast [Proof of Indexing](/network/indexing/#what-is-a-proof-of-indexing-poi) calculation variant.                                                             |
| 0.0.5  | Added support for event handlers having access to transaction receipts.                                                                                                |
| 0.0.4  | Added support for managing subgraph features.                                                                                                                          |

### Получение ABIs

Файл(ы) ABI должен(ы) соответствовать Вашему контракту (контрактам). Существует несколько способов получения файлов ABI:

- Если Вы создаете свой собственный проект, у Вас, скорее всего, будет доступ к наиболее актуальным ABIS.
- Если Вы создаете субграф для публичного проекта, Вы можете загрузить этот проект на свой компьютер и получить ABI, используя [`truffle compile`](https://truffleframework.com/docs/truffle/overview) или используя solc для компиляции.
- Вы также можете найти ABI на [Etherscan](https://etherscan.io/), но это не всегда надежно, так как загруженный туда ABI может быть устаревшим. Убедитесь, что у Вас есть нужный ABI, в противном случае запуск Вашего субграфа будет неудачным.

## Схема GraphQL

Схема для Вашего субграфа находится в файле `schema.graphql`. Схемы GraphQL определяются с использованием языка определения интерфейса GraphQL. Если Вы никогда ранее не писали схему GraphQL, рекомендуем ознакомиться с этим руководством по системе типов GraphQL. Справочную документацию по схемам GraphQL можно найти в разделе [GraphQL API](/querying/graphql-api).

## Определение Объектов

Прежде чем определять объекты, важно сделать шаг назад и подумать о том, как структурированы и связаны Ваши данные. Все запросы будут выполняться к модели данных, определенной в схеме субграфа, и объектам, проиндексированным этим субграфом. Для этого рекомендуется определить схему субграфа таким образом, чтобы она соответствовала потребностям Вашего децентрализованного приложения. Может быть полезно представить объекты как "объекты, содержащие данные", а не как события или функции.

С помощью The Graph Вы просто определяете типы объектов в `schema.graphql`, и узел The Graph будет генерировать поля верхнего уровня для запроса отдельных экземпляров и коллекций этого типа объектов. Каждый тип, который должен быть объектом, должен быть аннотирован директивой `@entity`. По умолчанию объекты изменяемы, что означает, что мэппинги могут загружать существующие объекты, изменять их и сохранять их новую версию. Измененяемость имеет свою цену, и для типов объектов, для которых известно, что они никогда не будут изменены, например, потому что они просто содержат данные, идентично извлеченные из чейна, рекомендуется помечать их как неизменяемые с помощью `@entity(immutable: true)`. Мэппинги могут вносить изменения в неизменяемые объекты до тех пор, пока эти изменения происходят в том же блоке, в котором был создан объект. Неизменяемые объекты гораздо быстрее записываются и запрашиваются, и поэтому их следует использовать каждый раз, когда это возможно.

### Удачный пример

Приведенный ниже объект `Gravatar` структурирован вокруг объекта Gravatar и является хорошим примером того, как объект может быть определен.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Неудачный пример

Приведенные ниже примеры объектов `GravatarAccepted` и `GravatarDeclined` основаны на событиях. Не рекомендуется сопоставлять события или вызовы функций с объектами 1:1.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Дополнительные и обязательные поля

Поля объекта могут быть определены как обязательные или необязательные. Обязательные поля обозначены символом `!` в схеме. Если в мэппинге не задано обязательное поле, то при запросе к нему будет выдана эта ошибка:

```
Null value resolved for non-null field 'name'
```

У каждого объекта должно быть поле `id`, у которого должен быть тип `Bytes!` или `String!`. Обычно рекомендуется использовать `Bytes!`, если только `id` не содержит удобочитаемый текст, поскольку объекты с `!` будут записываться и запрашиваться быстрее, чем объекты с `String!``id`. Поле `id` служит первичным ключом и должно быть уникальным среди всех объектов одного типа. В силу исторических причин тип `ID!` также принимается и является синонимом `String!`.

Для некоторых типов объектов `id` создается из идентификаторов двух других объектов; этому способствует `concat`, например, для формирования id `let id = left.id.concat(right.id)` из идентификаторов `left` и `right`. Аналогично этому, чтобы создать идентификатор из идентификатора существующего объекта и счетчика `count`, можно использовать `let id = left.id.concatI32(count)`. Объединение гарантированно приведёт к созданию уникальных идентификаторов, если длина `left` одинакова для всех таких объектов, например, потому что `left.id` является `Address`.

### Встроенные скалярные типы

#### Поддерживаемые GraphQL скаляры

Мы поддерживаем следующие скаляры в нашем GraphQL API:

| Тип          | Описание                                                                                                                                                                                                                                                  |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Bytes`      | Массив байтов, представленный в виде шестнадцатеричной строки. Обычно используется для хэшей и адресов Ethereum.                                                                                                                                          |
| `String`     | Скаляр для значений `string`. Нулевые символы не поддерживаются и автоматически удаляются.                                                                                                                                                                |
| `Boolean`    | Скаляр для значений `boolean`.                                                                                                                                                                                                                            |
| `Int`        | Спецификация GraphQL определяет `Int` как имеющий размер 32 байта.                                                                                                                                                                                        |
| `Int8`       | 8-байтовое целое число со знаком, также называемое 64-битным целым числом со знаком, может хранить значения в диапазоне от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807. Предпочтительно использовать это для представления `i64` из Ethereum. |
| `BigInt`     | Большие целые числа. Используются для типов Ethereum `uint32`, `int64`, `uint64`, ..., `uint256`. Примечание: Все, что находится ниже `uint32`, например, `int32`, `uint24` или `int8`, представлено как `i32`.                                           |
| `BigDecimal` | `BigDecimal` Десятичные дроби высокой точности, представленные в виде значащего числа и экспоненты. Диапазон значений экспоненты от -6143 до +6144. Округляется до 34 значащих цифр.                                                                      |

#### Перечисления

Вы также можете создавать перечисления внутри схемы. Перечисления имеют следующий синтаксис:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Как только перечисление определено в схеме, Вы можете использовать строковое представление значения перечисления, чтобы задать поле перечисления для объекта. Например, Вы можете установить для `tokenStatus` значение `SecondOwner`, сначала определив свой объект, а затем установив в поле `entity.tokenStatus = "SecondOwner"`. Приведенный ниже пример демонстрирует, как будет выглядеть объект Token с полем enum:

Более подробную информацию о написании перечислений можно найти в [Документации по GraphQL](https://graphql.org/learn/schema/).

#### Связи объектов

Объект может иметь связь с одним или несколькими другими объектами в Вашей схеме. Эти связи могут быть использованы в Ваших запросах. Связи в The Graph являются однонаправленными. Можно смоделировать двунаправленные связи, определив однонаправленную связь на любом "конце" связи.

Связи определяются для объектов точно так же, как и для любого другого поля, за исключением того, что в качестве типа указывается тип другого объекта.

#### Связи "Один к одному"

Определите тип объекта `Transaction` с необязательной связью "один к одному" с типом объекта `transactionReceipt`:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### Связи "Один ко многим"

Определите тип объекта `TokenBalance` с обязательной связью "один ко многим" с типом объекта Token:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Обратные запросы

Обратные зпросы могут быть определены для объекта с помощью поля `@derivedFrom`. При этом в объекте создается виртуальное поле, которое можно запрашивать, но нельзя задать вручную через API мэппингов. Скорее, оно вытекает из отношений, определенных для другого объекта. Для таких отношений редко имеет смысл сохранять обе стороны связи, а производительность как индексирования, так и запросов будет выше, когда сохраняется только одна сторона, а другая является производной.

Для связей "один ко многим" связь всегда должна храниться на стороне "один", а сторона "многие" всегда должна быть производной. Такое сохранение связи, вместо хранения массива объектов на стороне "многие", приведет к значительному повышению производительности как при индексации, так и при запросах к субграфам. В общем, следует избегать хранения массивов объектов настолько, насколько это возможно.

#### Пример

Мы можем сделать балансы для токена доступными из самого токена, создав поле `tokenBalances`:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Связи "Многие ко многим"

Для связей "многие ко многим", таких, например, как пользователи, каждый из которых может принадлежать к любому числу организаций, наиболее простым, но, как правило, не самым производительным способом моделирования связей является создание массива в каждом из двух задействованных объектов. Если связь симметрична, то необходимо сохранить только одну сторону связи, а другая сторона может быть выведена.

#### Пример

Определите обратный запрос от типа объекта `User` к типу объекта `Organization`. В приведенном ниже примере это достигается путем поиска атрибута `members` внутри объекта `Organization`. В запросах поле `organizations` в `User` будет разрешено путем поиска всех объектов `Organization`, включающих идентификатор пользователя.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Более эффективный способ сохранить эту взаимосвязь - с помощью таблицы мэппинга, которая содержит по одной записи для каждой пары `User` / `Organization` со схемой, подобной

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

Этот подход требует, чтобы запросы опускались на один дополнительный уровень для получения, например, сведений об организациях для пользователей:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

Такой более сложный способ хранения связей "многие ко многим" приведет к уменьшению объема хранимых данных для субграфа и, следовательно, к тому, что субграф будет значительно быстрее индексироваться и запрашиваться.

#### Добавление комментариев к схеме

As per GraphQL spec, comments can be added above schema entity attributes using the hash symble `#`. This is illustrated in the example below:

```graphql
type MyFirstEntity @entity {
  # unique identifier and primary key of the entity
  id: Bytes!
  address: Bytes!
}
```

## Определение полей полнотекстового поиска

Полнотекстовые поисковые запросы фильтруют и ранжируют объекты на основе введенных данных текстового запроса. Полнотекстовые запросы способны возвращать совпадения по схожим словам путем обработки текста запроса в виде строк перед сравнением с индексированными текстовыми данными.

Определение полнотекстового запроса включает в себя название запроса, словарь языка, используемый для обработки текстовых полей, алгоритм ранжирования, используемый для упорядочивания результатов, и поля, включенные в поиск. Каждый полнотекстовый запрос может охватывать несколько полей, но все включенные поля должны относиться к одному типу объекта.

Чтобы добавить полнотекстовый запрос, включите тип `_Schema_` с полнотекстовой директивой в схему GraphQL.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

Поле example `bandSearch` можно использовать в запросах для фильтрации объектов `Band` на основе текстовых документов в `name`, `description` и `bio`.> поля. Перейдите к [GraphQL API - запросы](/querying/graphql-api#queries) для описания API полнотекстового поиска и дополнительных примеров использования.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Управление функциями](#experimental-features):** Начиная с `specVersion` `0.0.4` и далее, ` fullTextSearch ` должно быть объявлено в разделе `features` в манифесте субграфа.

### Поддерживаемые языки

Выбор другого языка окажет решающее, хотя иногда и неуловимое влияние на API полнотекстового поиска. Поля, охватываемые полем полнотекстового запроса, рассматриваются в контексте выбранного языка, поэтому лексемы, полученные в результате анализа и поисковых запросов, варьируются от языка к языку. Например: при использовании поддерживаемого турецкого словаря "token" переводится как "toke", в то время как, конечно, словарь английского языка переводит его в "token".

Поддерживаемые языковые словари:

| Код     | Словарь       |
| ------- | ------------- |
| простой | Общий         |
| da      | Датский       |
| nl      | Голландский   |
| en      | Английский    |
| fi      | Финский       |
| fr      | Французский   |
| de      | Немецкий      |
| hu      | Венгерский    |
| it      | Итальянский   |
| no      | Норвежский    |
| pt      | Португальский |
| ro      | Румынский     |
| ru      | Русский       |
| es      | Испанский     |
| sv      | Шведский      |
| tr      | Турецкий      |

### Алгоритмы ранжирования

Поддерживаемые алгоритмы для упорядочивания результатов:

| Алгоритм      | Описание                                                                                       |
| ------------- | ---------------------------------------------------------------------------------------------- |
| rank          | Используйте качество соответствия (0-1) полнотекстового запроса, чтобы упорядочить результаты. |
| proximityRank | Аналогично рангу, но также включает в себя близость совпадений.                                |

## Написание мэппингов

Мэппинги берут данные из определенного источника и преобразуют их в объекты, которые определены в Вашей схеме. Мэппинги записываются в подмножестве [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html), которое называется [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki), и которое может быть скомпилировано в WASM ([ WebAssembly ](https://webassembly.org/)). AssemblyScript более строг, чем обычный TypeScript, но при этом предоставляет знакомый синтаксис.

Для каждого обработчика событий, определенного в `subgraph.yaml` в разделе `mapping.EventHandlers`, создайте экспортируемую функцию с тем же именем. Каждый обработчик должен принимать один параметр с именем `event` с типом, соответствующим имени обрабатываемого события.

В примере субграф `src/mapping.ts` содержит обработчики для событий `NewGravatar` и `UpdatedGravatar`:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

Первый обработчик принимает событие `NewGravatar` и создает новый объект `Gravatar` с помощью `new Gravatar(event.params.id.toHex())`, заполняя поля объекта, используя соответствующие параметры события. Этот экземпляр объекта представлен переменной `gravatar` со значением идентификатора `event.params.id.toHex()`.

Второй обработчик пытается загрузить существующий `Gravatar` из хранилища узлов The Graph. Если его еще нет, он создается по требованию. Затем объект обновляется в соответствии с новыми параметрами события, прежде чем он будет сохранен обратно в хранилище с помощью `gravatar.save()`.

### Рекомендуемые идентификаторы для создания новых объектов

Настоятельно рекомендуется использовать `Bytes` в качестве типа для полей `id` и использовать `String` только для атрибутов, которые действительно содержат удобочитаемый текст, например имя токена. Ниже приведены некоторые рекомендуемые значения `id`, которые следует учитывать при создании новых объектов.

- `transfer.id = event.transaction.hash`

- `let id = event.transaction.hash.concatI32(event.logIndex.toI32())`

- Для объектов, которые хранят агрегированные данные, например ежедневные объемы торгов, `id` обычно содержит номер дня. В данном случае полезно использовать `Bytes` в качестве `id`. Определение `id` будет выглядеть следующим образом:

```typescript
let dayID = event.block.timestamp.toI32() / 86400
let id = Bytes.fromI32(dayID)
```

- Преобразуйте постоянные адреса в `Bytes`.

`const id = Bytes.fromHexString('0xdead...beef')`

Существует [Библиотека Typescript Graph](https://github.com/graphprotocol/graph-tooling/tree/main/packages/ts), которая содержит утилиты для взаимодействия с хранилищем Graph Node и удобства для обработки данных и объектов смарт-контрактов. Её можно импортировать в `mapping.ts` из `@graphprotocol/graph-ts`.

### Обработка объектов с одинаковыми идентификаторами

При создании и сохранении нового объекта, если объект с таким же идентификатором уже существует, в процессе слияния приоритетны свойства нового объекта. Это означает, что существующий объект будет обновлен значениями из нового объекта.

Если для поля нового объекта с тем же идентификатором намеренно установлено нулевое значение, существующий объект будет обновлен с использованием нулевого значения.

Если для поля в новом объекте с тем же идентификатором не установлено значение, поле также будет иметь значение null.

## Генерация кода

Для упрощения и обеспечения безопасности типов при работе со смарт-контрактами, событиями и объектами Graph CLI может генерировать типы AssemblyScript на основе схемы GraphQL субграфа и ABI контрактов, включенных в источники данных.

Это делается с помощью

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

но в большинстве случаев субграфы уже предварительно сконфигурированы с помощью `package.json`, что позволяет Вам просто запустить одно из следующих действий для достижения того же результата:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

Это сгенерирует класс AssemblyScript для каждого смарт-контракта в файлах ABI, упомянутых в `subgraph.yaml`, позволяя Вам привязывать эти контракты к определенным адресам в мэппигах и вызывать контрактные методы, доступные только для чтения, для обрабатываемого блока. Кроме того, для каждого события контракта генерируется класс, обеспечивающий удобный доступ к параметрам события, а также к блоку и транзакции, от которых произошло событие. Все эти типы записываются в `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts`. В примере субграфа это будет код `generated/Gravity/Gravity.ts`, позволяющий импортировать эти типы с помощью мэппинга.

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

В дополнение к этому, для каждого типа объекта в схеме GraphQL субграфа генерируется по одному классу. Эти классы обеспечивают безопасную для типов загрузку объектов, доступ к чтению и записи в поля объекта, а также метод `save()` для записи объектов в хранилище. Все классы объектов записываются в `<OUTPUT_DIR>/schema.ts`, что позволяет мэппингам импортировать с их помощью

```javascript
import { Gravatar } from '../generated/schema'
```

> **Примечание:** Генерация кода должна выполняться повторно после каждого изменения схемы GraphQL или ABIS, включенного в манифест. Это также должно быть выполнено по крайней мере один раз перед сборкой или развертыванием субграфа.

Генерация кода не проверяет Ваш мэппинг код в `src/mapping.ts`. Если Вы хотите проверить это, прежде чем пытаться развернуть свой субграф в Graph Explorer, Вы можете запустить `yarn build` и исправить любые синтаксические ошибки, которые может обнаружить компилятор TypeScript.

## Шаблоны источников данных

Распространенным шаблоном в смарт-контрактах, совместимых с EVM, является использование реестровых или заводских контрактов, когда один контракт создает, управляет или ссылается на произвольное количество других контрактов, каждый из которых имеет свое собственное состояние и события.

Адреса этих субконтрактов могут быть известны или не известны заранее, и многие из этих контрактов могут быть созданы и/или добавлены с течением времени. Поэтому в таких случаях определение одного источника данных или фиксированного количества источников данных невозможно и необходим более динамичный подход: _data source templates_.

### Источник данных для основного контракта

Сначала Вы определяете обычный источник данных для основного контракта. Во фрагменте ниже показан упрощенный пример источника данных для контракта фабрики обмена [Uniswap](https://uniswap.org). Обратите внимание на обработчик события `New Exchange(address,address)`. Этот сигнал выдается, когда новый контракт обмена создается в цепочке с помощью заводского контракта.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Шаблоны источников данных для динамически создаваемых контрактов

Затем Вы добавляете _data source templates_ в манифест. Они идентичны обычным источникам данных, за исключением того, что в них отсутствует предопределенный адрес контракта в `source`. Как правило, Вы определяете один шаблон для каждого типа субконтракта, управляемого родительским контрактом, или на который ссылается родительский контракт.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Создание шаблона источника данных

На заключительном шаге Вы обновляете мэппинг основного контракта, чтобы создать экземпляр динамического источника данных из одного из шаблонов. В данном примере в отображение основного контракта импортируется шаблон `Exchange` и вызывается метод `Exchange.create(address)`, чтобы начать индексирование нового контракта обмена.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **Примечание:** Новый источник данных будет обрабатывать только вызовы и события для блока, в котором он был создан, и всех последующих блоков, но не будет обрабатывать исторические данные, т.е. данные, которые содержатся в предыдущих блоках.
> 
> Если предыдущие блоки содержат данные, относящиеся к новому источнику данных, лучше всего проиндексировать эти данные, считывая текущее состояние контракта и создавая объекты, представляющие это состояние на момент создания нового источника данных.

### Контекст источника данных

Контексты источника данных позволяют передавать дополнительную конфигурацию при создании экземпляра шаблона. В нашем примере предположим, что биржи связаны с определенной торговой парой, которая включена в событие `newExchange`. Эта информация может быть передана в созданный экземпляр источника данных, например, следующим образом:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Внутри мэппинга шаблона `Exchange` затем можно получить доступ к контексту:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Существуют установщики и получатели, такие как `setString` и `getString` для всех типов значений.

## Стартовые блоки

`startBlock` - это необязательный параметр, который позволяет Вам определить, с какого блока в цепочке источник данных начнет индексацию. Установка начального блока позволяет источнику данных пропускать потенциально миллионы блоков, которые не имеют отношения к делу. Как правило, разработчик субграфа устанавливает `startBlock` в блок, в котором был создан смарт-контракт источника данных.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Примечание:** Блок создания контракта можно быстро найти в Etherscan:
> 
> 1. Найдите контракт, введя его адрес в строке поиска.
> 2. Нажмите на хэш транзакции создания в разделе `Contract Creator`.
> 3. Загрузите страницу сведений о транзакции, где Вы найдете начальный блок для этого контракта.

## Подсказки индексатору

Параметр `indexerHints` в манифесте субграфа содержит директивы для индексаторов по обработке и управлению субграфом. Это влияет на оперативные решения по обработке данных, стратегиям индексации и оптимизации. В настоящее время в нем предусмотрена опция `prune` для управления сохранением или сокращением исторических данных.

> Эта функция доступна начиная с `specVersion: 1.0.0`

### Сокращение

`indexerHints.prune`: определяет срок хранения исторических данных блока для субграфа. Опции включают в себя:

1. `"never"`: удаление исторических данных не производится; хранит всю историю.
2. `"auto"`: сохраняет минимально необходимую историю, заданную индексатором, оптимизируя производительность запросов.
3. Конкретное число: устанавливает индивидуальный лимит на количество сохраняемых исторических блоков.

```
 indexerHints:
  prune: auto
```

> The term "history" in this context of subgraphs is about storing data that reflects the old states of mutable entities.

History as of a given block is required for:

- [Time travel queries](/querying/graphql-api/#time-travel-queries), which enable querying the past states of these entities at specific blocks throughout the subgraph's history
- Using the subgraph as a [graft base](/developing/creating-a-subgraph/#grafting-onto-existing-subgraphs) in another subgraph, at that block
- Rewinding the subgraph back to that block

If historical data as of the block has been pruned, the above capabilities will not be available.

> Обычно рекомендуется использовать `"auto"`, поскольку оно максимально увеличивает производительность запросов и достаточно для большинства пользователей, которым не требуется доступ к обширным историческим данным.

Для субграфов, использующих [запросы о путешествиях во времени](/querying/graphql-api/#time-travel-queries), рекомендуется либо установить определенное количество блоков для хранения исторических данных, либо использовать `prune: never`, чтобы сохранить все исторические состояния объектов. Ниже приведены примеры того, как настроить оба параметра в настройках вашего субграфа:

Чтобы сохранить определенный объем исторических данных:

```
 indexerHints:
  prune: 1000 # Замените 1000 на желаемое количество блоков, которые нужно сохранить
```

Чтобы сохранить полную историю состояний объекта, выполните следующее:

```
indexerHints:
  prune: never
```

Вы можете проверить самый ранний блок (с историческим состоянием) для данного субграфа, выполнив запрос к [API статуса индексирования](/deploying/deploying-a-subgraph-to-hosted/#checking-subgraph-health):

```
{
  indexingStatuses(subgraphs: ["Qm..."]) {
    subgraph
    synced
    health
    chains {
      earliestBlock {
        number
      }
      latestBlock {
        number
      }
      chainHeadBlock { number }
    }
  }
}
```

Обратите внимание на то, что `earliestBlock` — это самый ранний блок с историческими данными, который будет более поздним, чем `startBlock`, указанный в манифесте, если субграф был удален.

## Обработчики событий

Обработчики событий в субграфе реагируют на конкретные события, генерируемые смарт-контрактами в блокчейне, и запускают обработчики, определенные в манифесте подграфа. Это позволяет субграфам обрабатывать и хранить данные о событиях в соответствии с определенной логикой.

### Определение обработчика событий

Обработчик событий объявлен внутри источника данных в конфигурации YAML субграфа. Он определяет, какие события следует прослушивать, и соответствующую функцию, которую необходимо выполнить при обнаружении этих событий.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: Approval(address,address,uint256)
          handler: handleApproval
        - event: Transfer(address,address,uint256)
          handler: handleTransfer
          topic1: ['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', '0xc8dA6BF26964aF9D7eEd9e03E53415D37aA96325'] # Optional topic filter which filters only events with the specified topic.
```

### Фильтры индексированных аргументов/фильтры тем

> **Требуется `specVersion` >= 1.2.0**

Фильтры тем, также известные как фильтры индексированных аргументов, представляют собой мощную функцию в субграфах, которая позволяет точно фильтровать события блокчейна на основе значений их индексированных аргументов. Эти фильтры особенно полезны для выделения конкретных событий из огромного потока событий в блокчейне, позволяя субграфам работать более эффективно, сосредотачиваясь только на соответствующих данных. Это может быть исключительно полезно для таких случаев использования, как создание персональных субграфов, которые отслеживают определенные адреса и их взаимодействие с различными смарт-контрактами в блокчейне.

#### Как работают фильтры тем

Когда смарт-контракт генерирует событие, любые аргументы, помеченные как индексированные, могут использоваться в качестве фильтров в манифесте субграфа. Это позволяет субграфу выборочно прослушивать события, соответствующие этим индексированным аргументам. Первый индексированный аргумент события соответствует `topic1`, второй — `topic2` и т. д. до `topic3`, поскольку виртуальная машина Ethereum (EVM) допускает до трех индексированных аргументов на одно событие.

```solidity
// Идентификатор лицензии SPDX: MIT
pragma solidity ^0.8.0;

contract Token {
    // Объявление события с индексируемыми параметрами для адресов
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Функция для имитации передачи токенов
    function transfer(address to, uint256 value) public {
        // Генерация события Transfer с указанием from, to и value
        emit Transfer(msg.sender, to, value);
    }
}
```

В этом примере:

- Событие `Transfer` используется для протоколирования транзакций токенов между адресами.
- Параметры `from` и `to` индексируются, что позволяет прослушивателям событий фильтровать и отслеживать передачи, включающие определенные адреса.
- Функция `transfer` — это простое представление действия передачи токена, которое генерирует событие Transfer при каждом вызове.

#### Конфигурация в субграфах

Фильтры тем определяются непосредственно в конфигурации обработчика событий в манифесте субграфа. Вот как они настроены:

```yaml
eventHandlers:
  - event: SomeEvent(indexed uint256, indexed address, indexed uint256)
    handler: handleSomeEvent
    topic1: ['0xValue1', '0xValue2']
    topic2: ['0xAddress1', '0xAddress2']
    topic3: ['0xValue3']
```

В этой настройке:

- `topic1` соответствует первому индексированному аргументу события, `topic2` — второму, а `topic3` — третьему.
- Каждая тема может иметь одно или несколько значений, и событие обрабатывается только в том случае, если оно соответствует одному из значений в каждой указанной теме.

##### Логика фильтра

- В рамках одной темы: логика действует как условие OR. Событие будет обработано, если оно соответствует любому из перечисленных значений в данной теме.
- Между разными темами: логика функционирует как условие AND. Событие должно удовлетворять всем указанным условиям в разных темах, чтобы вызвать соответствующий обработчик.

### Пример 1. Отслеживание трансферных транзакций по одному адресу

```yaml
eventHandlers:
  - event: Transfer(indexed address,indexed address,uint256)
    handler: handleTransfer
    topic1: ['0xSpecificAddress']
  - event: Transfer(indexed address,indexed address,uint256)
    handler: handleTransfer
    topic2: ['0xSpecificAddress']
```

В данной конфигурации:

- `topic1` фильтрует события передачи на основе адреса отправителя, а `topic2` фильтрует события на основе адреса получателя.
- Субграф будет индексировать транзакции, в которых указанный адрес участвует либо в качестве отправителя, либо в качестве получателя.

### Пример 2. Отслеживание прямых переводов с адреса A на адрес B

```yaml
eventHandlers:
  - event: Transfer(indexed address,indexed address,uint256)
    handler: handleDirectedTransfer
    topic1: ['0xAddressA'] # Sender Address
    topic2: ['0xAddressB'] # Receiver Address
```

В данной конфигурации:

- `topic1` настроен на фильтрацию событий `Transfer`, где `0xAddressA` является отправителем.
- `topic2` настроен на фильтрацию событий `Transfer`, где `0xAddressB` является получателем.
- Субграф будет индексировать только транзакции, которые происходят непосредственно от `0xAddressA` к `0xAddressB`.

### Пример 3. Отслеживание транзакций в любом направлении между двумя адресами

```
eventHandlers:
  - event: Transfer(indexed address,indexed address,uint256)
    handler: handleTransferToOrFrom
    topic1: ["0xAddressA"]  # Sender or Receiver Address
    topic2: ["0xAddressB"]  # Sender or Receiver Address
```

В данной конфигурации:

- `topic1` настроен на фильтрацию событий `Transfer`, где `0xAddressA` — это либо отправитель, либо получатель.
- `topic2` настроен на фильтрацию событий `Transfer`, где `0xAddressB` — это отправитель или получатель.
- Субграф будет индексировать транзакции, происходящие в любом направлении между `0xAddressA` и `0xAddressB`, что позволяет осуществлять комплексный мониторинг взаимодействий с участием обоих адресов.

## Обработчики вызовов

Хотя события обеспечивают эффективный способ сбора соответствующих изменений в состоянии контракта, многие контракты избегают создания логов для оптимизации затрат на газ. В этих случаях субграф может подписаться на обращения к контракту источника данных. Это достигается путем определения обработчиков вызовов, ссылающихся на сигнатуру функции, и обработчика мэппинга, который будет обрабатывать вызовы этой функции. Чтобы обработать эти вызовы, обработчик мэппинга получит `ethereum.Call` в качестве аргумента, содержащего типизированные входы и выходы вызова. Вызовы, выполненные на любой глубине цепочки вызовов транзакции, запускают мэппинг, позволяя фиксировать действия с контрактом источника данных через прокси-контракты.

Обработчики вызовов срабатывают только в одном из двух случаев: когда указанная функция вызывается учетной записью, отличной от самого контракта, или когда она помечена как внешняя в Solidity и вызывается как часть другой функции в том же контракте.

> **Примечание:** Обработчики вызовов в настоящее время зависят от Parity tracing API. Некоторые сети, такие как BNB chain и Arbitrium, не поддерживают этот API. Если субграф, индексирующий одну из этих сетей, содержит один или несколько обработчиков вызовов, синхронизация не начнется. Разработчикам субграфов следует вместо этого использовать обработчики событий. Они гораздо более производительны, чем обработчики вызовов, и поддерживаются в каждой сети evm.

### Определение обработчика вызова

Чтобы определить обработчика вызовов в Вашем манифесте, просто добавьте массив `callHandlers` под источником данных, на который Вы хотели бы подписаться.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

` function ` - это нормализованная сигнатура функции, по которой можно фильтровать вызовы. Свойство `handler` - это имя функции в Вашем мэппинге, которую Вы хотели бы выполнить при вызове целевой функции в контракте источника данных.

### Функция мэппинга

Каждый обработчик вызова принимает один параметр, тип которого соответствует имени вызываемой функции. В приведенном выше примере субграфа мэппинг содержит обработчик для случаев, когда вызывается функция `createGravatar` и получает параметр `CreateGravatarCall` в качестве аргумента:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

Функция `handleCreateGravatar` принимает новый `CreateGravatarCall`, который является подклассом `ethereum.Call`, предоставляемый `@graphprotocol/graph-ts`, который включает в себя введенные входы и выходы о звонке. Тип `CreateGravatarCall` генерируется для Вас при запуске `graph codegen`.

## Обработчики блоков

В дополнение к подписке на события контракта или вызовы функций, субграф может захотеть обновить свои данные по мере добавления в цепочку новых блоков. Чтобы добиться этого, субграф может запускать функцию после каждого блока или после блоков, соответствующих заранее определенному фильтру.

### Поддерживаемые фильтры

#### Фильтр вызовов

```yaml
filter:
  kind: call
```

_Определенный обработчик будет вызван один раз для каждого блока, содержащего обращение к контракту (источнику данных), в соответствии с которым определен обработчик._

> **Примечание:** Фильтр `call` в настоящее время зависит от Parity tracing API. Некоторые сети, такие как BNB chain и Arbitrium, не поддерживают этот API. Если субграф, индексирующий одну из этих сетей, содержит один или несколько обработчиков блоков с фильтром `call`, синхронизация не начнется.

Отсутствие фильтра для обработчика блоков гарантирует, что обработчик вызывается для каждого блока. Источник данных может содержать только один обработчик блоков для каждого типа фильтра.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

#### Фильтр опроса

> **Требуется `specVersion` >= 0.0.8**

> **Примечание.** Фильтры опроса доступны только для источников данных `kind: ethereum`.

```yaml
blockHandlers:
  - handler: handleBlock
    filter:
      kind: polling
      every: 10
```

Определенный обработчик будет вызываться один раз для каждого блока `n`, где `n` — это значение, указанное в поле `every`. Эта конфигурация позволяет субграфу выполнять определенные операции через регулярные интервалы блоков.

#### Однократный фильтр

> **Требуется `specVersion` >= 0.0.8**

> **Примечание.** Однократные фильтры доступны только для источников данных `kind: ethereum`.

```yaml
blockHandlers:
  - handler: handleOnce
    filter:
      kind: once
```

Определенный обработчик с однократным фильтром будет вызываться только один раз перед запуском всех остальных обработчиков. Эта конфигурация позволяет субграфу использовать обработчик в качестве обработчика инициализации, выполняя определенные задачи в начале индексирования.

```ts
export function handleOnce(block: ethereum.Block): void {
  let data = new InitialData(Bytes.fromUTF8('initial'))
  data.data = 'Setup data here'
  data.save()
}
```

### Функция мэппинга

Функция мэппинга получит `ethereum.Block` в качестве своего единственного аргумента. Подобно функциям мэппинга событий, эта функция может получать доступ к существующим в хранилище объектам субграфа, вызывать смарт-контракты и создавать или обновлять объекты.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## Анонимные события

Если Вам нужно обрабатывать анонимные события в Solidity, это можно сделать, указав тему события 0, как показано в примере:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

Событие будет запущено только в том случае, если подпись и тема 0 совпадают. По умолчанию `topic0` равен хэшу сигнатуры события.

## Подтверждения транзакций в обработчиках событий

Начиная с `specVersion` `0.0.5` и `apiVersion` `0.0.7` обработчики событий могут иметь доступ к подтверждению транзакции, которая их отправила.

Для этого обработчики событий должны быть объявлены в манифесте субграфа с новым ключом `receipt: true`, который является необязательным и по умолчанию имеет значение false.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

Внутри функции обработчика доступ к подтверждению можно получить в поле `Event.receipt`. Если для ключа `receipt` установлено значение`false` или оно опущено в манифесте, вместо него будет возвращено значение `null`.

## Экспериментальные функции

Начиная с `specVersion` `0.0.4`, функции субграфа должны быть явно объявлены в разделе `features` на верхнем уровне файла манифеста, используя их имя `camelCase`, как указано в таблице ниже:

| Функция                                                    | Имя                                                  |
| ---------------------------------------------------------- | ---------------------------------------------------- |
| [Нефатальные ошибки](#non-fatal-errors)                    | `nonFatalErrors`                                     |
| [Полнотекстовый поиск](#defining-fulltext-search-fields)   | `fullTextSearch`                                     |
| [Графтинг](#grafting-onto-existing-subgraphs)              | `grafting`                                           |
| [IPFS на контрактах Ethereum](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` или `nonDeterministicIpfs` |

Например, если в субграфе используются функции **Full-Text Search** и **Non-fatal Errors**, поле `features` в манифесте должно быть:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Обратите внимание, что использование функции без ее объявления приведет к **ошибке проверки** во время развертывания субграфа, но никаких ошибок не возникнет, если функция объявлена, но не используется.

### IPFS на контрактах Ethereum

Распространенным вариантом сочетания IPFS с Ethereum является хранение данных в IPFS, которые было бы слишком дорого поддерживать в он-чейне, и ссылка на хэш IPFS в контрактах Ethereum.

Учитывая такие хэши IPFS, субграфы могут считывать соответствующие файлы из IPFS, используя `ipfs.cat ` и `ipfs.map`. Для надежного выполнения этой задачи необходимо, чтобы эти файлы были привязаны к узлу IPFS с высокой доступностью, так чтобы[хостинговый сервис](https://thegraph.com/hosted-service) узла IPFS мог найти их при индексировании.

> **Примечание:** Сеть The Graph пока не поддерживает `ipfs.cat` и `ipfs.map`, и разработчикам не следует разворачивать субграфы, использующие эту функциональность, в сети через Studio.

> **[Управление функционалом](#experimental-features):** `ipfsOnEthereumContracts` должны быть объявлены в разделе `features` в манифесте субграфа. Для чейнов, отличных от EVM, псевдоним `nonDeterministicIpfs` также может использоваться с той же целью.

При запуске локального узла The Graph необходимо установить переменную окружения `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS`, чтобы индексировать субграфы, используя эту экспериментальную функциональность.

### Нефатальные ошибки

Ошибки индексирования в уже синхронизированных субграфах по умолчанию приведут к сбою субграфа и прекращению синхронизации. В качестве альтернативы субграфы можно настроить на продолжение синхронизации при наличии ошибок, игнорируя изменения, внесенные обработчиком, который спровоцировал ошибку. Это дает авторам субграфов время на исправление своих субграфов, в то время как запросы к последнему блоку продолжают обрабатываться, хотя результаты могут быть противоречивыми из-за бага, вызвавшего ошибку. Обратите внимание на то, что некоторые ошибки всё равно всегда будут фатальны. Чтобы быть нефатальной, ошибка должна быть детерминированной.

> **Примечание:** Сеть The Graph пока не поддерживает нефатальные ошибки, и разработчикам не следует разворачивать субграфы, использующие эту функциональность, в сети через Studio.

Для включения нефатальных ошибок необходимо установить в манифесте субграфа следующий флаг функции:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

В запросе также необходимо разрешить запрос данных с потенциальными несоответствиями с помощью аргумента `subgraphError`. Также рекомендуется запросить `_meta`, для проверки того, что субграф пропустил ошибки, как в примере:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

Если субграф обнаруживает ошибку, этот запрос вернет как данные, так и ошибку graphql с сообщением `"indexing_error"`, как в данном примере ответа:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Графтинг (перенос) на существующие субграфы

> **Примечание:** не рекомендуется использовать графтинг при первоначальном переходе на сеть The Graph. Подробнее [здесь](/cookbook/grafting/#important-note-on-grafting-when-upgrading-to-the-network).

Когда субграф развертывается впервые, он начинает индексировать события в блоке genesis соответствующего чейна (или в `startBlock`, определенном для каждого источника данных). В некоторых обстоятельствах полезно повторно использовать данные из существующего субграфа и начинать индексацию с гораздо более позднего блока. Этот режим индексации называется _Grafting_. Графтинг, например, полезен во время разработки, чтобы быстро устранить простые ошибки в отображениях или временно возобновить работу существующего субграфа после его сбоя.

Субграф графтится (переносится) к базовому субграфу, когда манифест субграфа в `subgraph.yaml` содержит блок `graft` на верхнем уровне:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

Когда развертывается субграф, манифест которого содержит блок `graft`, узел The Graph скопирует данные `base` субграфа вплоть до указанного `block` включительно, а затем продолжит индексирование нового субграфа начиная с этого блока. Базовый субграф должен существовать на целевом экземпляре узла The Graph и должен быть проиндексирован по крайней мере до заданного блока. Из-за этого ограничения графтинг следует использовать только в процессе разработки или в экстренных случаях, чтобы ускорить создание эквивалентного графтового субграфа.

Поскольку графтинг копирует, а не индексирует базовые данные, гораздо быстрее перенести субграф в нужный блок, чем индексировать с нуля, хотя для очень больших субграфов копирование исходных данных может занять несколько часов. Пока графтовый субграф инициализируется, узел The Graph будет регистрировать информацию о типах объектов, которые уже были скопированы.

Графтовый субграф может использовать схему GraphQL, которая не идентична схеме базового субграфа, а просто совместима с ней. Она сама по себе должна быть допустимой схемой субграфа, но может отличаться от схемы базового субграфа следующими способами:

- Она добавляет или удаляет типы объектов
- Она удаляет атрибуты из типов объектов
- Она добавляет в типы объектов атрибуты с возможностью обнуления
- Она превращает ненулевые атрибуты в нулевые
- Она добавляет значения в перечисления
- Она добавляет или удаляет интерфейсы
- Она изменяется в зависимости от того, для каких типов объектов реализован тот или иной интерфейс

> **[Управление функционалом](#experimental-features):** `grafting` должен быть объявлен в разделе `features` в манифесте субграфа.

## Источники файловых данных

Источники файловых данных — это новая функциональность субграфа для надежного и расширенного доступа к данным вне чейна во время индексации. Источники данных файлов поддерживают получение файлов из IPFS и Arweave.

> Это также закладывает основу для детерминированного индексирования данных вне сети, а также потенциального введения произвольных данных из HTTP-источников.

### Обзор

Вместо извлечения файлов «по очереди» во время выполнения обработчика вводятся шаблоны, которые могут создаваться как новые источники данных для заданного идентификатора файла. Эти новые источники данных извлекают файлы, повторяя попытки, если они не увенчались успехом, и запускают специальный обработчик, когда файл найден.

Это похоже на [существующие шаблоны источников данных](/developing/creating-a-subgraph/#data-source-templates), которые используются для динамического создания новых источников данных на чейн-основе.

> Это заменяет существующий API `ipfs.cat`

### Руководство по обновлению

#### Обновите `graph-ts` и `graph-cli`

Для файловых источников данных требуется graph-ts >=0.29.0 и graph-cli >=0.33.1

#### Добавьте новый тип объекта, который будет обновляться при обнаружении файлов

Источники файловых данных не могут получать доступ к объектам на чейн-основе или обновлять их, но должны обновлять объекты, специфичные для файлов.

Это может означать разделение полей существующих объектов на отдельные объекты, связанные между собой.

Исходный объединенный объект:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

Новый разделенный объект:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

Если между родительским объектом и результирующим объектом-источником данных существует связь1:1, то наиболее простым вариантом будет связать родительский объект с результирующим файловым объектом, используя в качестве поиска IPFS CID. Свяжитесь с нами в Discord, если у Вас возникли трудности с моделированием новых объектов на основе файлов!

> Вы можете использовать [вложенные фильтры](/querying/graphql-api/#example-for-nested-entity-filtering) для фильтрации родительских объектов на основе этих вложенных объектов.

#### Добавьте новый шаблонный источник данных с помощью `kind: file/ipfs` или `kind: file/arweave`.

Это источник данных, который будет создан при обнаружении интересующего файла.

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> В настоящее время требуется `abis`, хотя невозможно вызывать контракты из файловых источников данных

В файле-источнике данных должны быть конкретно указаны все типы объектов, с которыми он будет взаимодействовать в рамках `entities`. Дополнительные сведения см. в разделе [ограничения](#limitations).

#### Создание нового обработчика для обработки файлов

Этот обработчик должен принимать один параметр `Bytes`, который будет содержимым файла, когда он будет найден, который затем можно будет обработать. Часто это файл JSON, который можно обработать с помощью помощников `graph-ts` ([документация](/developing/assemblyscript-api/#json-api)).

Доступ к CID файла в виде читаемой строки можно получить через `dataSource` следующим образом:

```typescript
const cid = dataSource.stringParam()
```

Пример обработчика:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### Создание файловых источников данных при необходимости

Теперь вы можете создавать файловые источники данных во время выполнения обработчиков на чейн-основе:

- Импортируйте шаблон из автоматически созданных `templates`
- вызовите `TemplateName.create(cid: string)` из мэппинга, где cid является действительным идентификатором контента для IPFS или Arweave

Для IPFS Graph Node поддерживает [идентификаторы контента v0 и v1](https://docs.ipfs.tech/concepts/content-addressing/), а также идентификаторы контента с каталогами (например, `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`).

Что касается Arweave, то начиная с версии 0.33.0 Graph Node может извлекать файлы, хранящиеся в Arweave, на основе их [ID транзакции](https://docs.arweave.org/developers/arweave-node-server/http-api#transactions) из шлюза Arweave ([файл примера](https://bdxujjl5ev5eerd5ouhhs6o4kjrs4g6hqstzlci5pf6vhxezkgaa.arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA)). Arweave поддерживает транзакции, загруженные через Irys (ранее Bundlr), а Graph Node также может получать файлы на основе [манифестов Irys](https://docs.irys.xyz/overview/gateways#indexing).

Пример:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//Этот пример кода предназначен для сборщика субграфа Crypto. Приведенный выше хеш ipfs представляет собой каталог с метаданными токена для всех NFT криптоковена.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //Это создает путь к метаданным для одного сборщика NFT Crypto. Он объединяет каталог с "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

Это создаст новый источник данных файла, который будет опрашивать настроенную конечную точку IPFS или Arweave Graph Node, повторяя попытку, если она не найдена. Когда файл будет найден, будет выполнен обработчик источника данных файла.

В этом примере CID используется для поиска между родительским объектом `Token` и результирующим объектом `TokenMetadata`.

> Раньше это была точка, в которой разработчик субграфа вызывал `ipfs.cat(CID)` для извлечения файла

Поздравляем, Вы используете файловые источники данных!

#### Развертывание субграфов

Теперь Вы можете `build` (построить) и `deploy` (развернуть) свой субграф на любом узле The Graph >=v0.30.0-rc.0.

#### Ограничения

Обработчики и объекты файловых источников данных изолированы от других объектов субграфа, что гарантирует их детерминированность при выполнении и исключает загрязнение источников данных на чейн-основе. В частности:

- Объекты, созданные с помощью файловых источников данных, неизменяемы и не могут быть обновлены
- Обработчики файловых источников данных не могут получить доступ к объектам из других файловых источников данных
- Объекты, связанные с источниками данных файлов, не могут быть доступны обработчикам на чейн-основе

> Хотя это ограничение не должно вызывать проблем в большинстве случаев, для некоторых оно может вызвать сложности. Если у Вас возникли проблемы с моделированием Ваших файловых данных в субграфе, свяжитесь с нами через Discord!

Кроме того, невозможно создать источники данных из файлового источника данных, будь то источник данных onchain или другой файловый источник данных. Это ограничение может быть снято в будущем.

#### Лучшие практики

Если Вы связываете метаданные NFT с соответствующими токенами, используйте хэш IPFS метаданных для ссылки на объект Metadata из объекта Token. Сохраните объект Metadata, используя хэш IPFS в качестве идентификатора.

Вы можете использовать [DataSource context](/developing/graph-ts/api/#entity-and-datasourcecontext) при создании файловых источников данных для передачи дополнительной информации, которая будет доступна обработчику файлового источника данных.

Если у Вас есть объекты, которые обновляются несколько раз, создайте уникальные объекты на основе файлов, используя хэш IPFS и идентификатор объекта, и ссылайтесь на них, используя производное поле в объекте на чейн-основе.

> Мы работаем над улучшением приведенной выше рекомендации, поэтому запросы возвращают только "самую последнюю" версию

#### Известные проблемы

Файловые источники данных в настоящее время требуют ABI, даже если ABI не используются ([проблема](https://github.com/graphprotocol/graph-cli/issues/961)). Обходным решением является добавление любого ABI.

Обработчики для файловых источников данных не могут находиться в файлах, которые импортируют привязки контракта `eth_call`, с ошибкой "unknown import: `ethereum::ethereum.call` has not been defined" ([проблема](https://github.com/graphprotocol/graph-node/issues/4309)). Обходным решением является создание обработчиков файловых источников данных в специальном файле.

#### Примеры

[Миграция субграфа Crypto Coven](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### Ссылки

[Источники данных GIP-файла](https://forum.thegraph.com/t/gip-file-data-sources/2721)

## Тайм-серии и агрегации

### Обзор

Тайм-серии и агрегации позволяют Вашему субграфу отслеживать такие статистические данные, как средняя цена за день, общий объем переводов за час и т. д.

Эта функция представляет два новых типа объектов субграфов. Объекты тайм-серий записывают точки данных с временными метками. Объекты агрегирования выполняют заранее объявленные вычисления над точками данных тайм-серий ежечасно или ежедневно, а затем сохраняют результаты для быстрого доступа через GraphQL.

#### Пример схемы

```graphql
type Data @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  price: BigDecimal!
}

type Stats @aggregation(intervals: ["hour", "day"], source: "Data") {
  id: Int8!
  timestamp: Timestamp!
  sum: BigDecimal! @aggregate(fn: "sum", arg: "price")
}
```

### Определение тайм-серий и агрегаций

Объекты тайм-серий определяются с помощью `@entity(timeseries: true)` в schema.graphql. Каждый объект тайм-серии должен иметь уникальный идентификатор типа int8, метку времени типа Timestamp и включать данные, которые будут использоваться для вычислений объектами агрегации. Эти объекты тайм-серий могут быть сохранены в обычных обработчиках триггеров и выступать в качестве «необработанных данных» для объектов агрегации.

Объекты агрегации определяются с помощью `@aggregation` в schema.graphql. Каждый объект агрегирования определяет источник, из которого он будет собирать данные (который должен быть объектом тайм-серии), устанавливает интервалы (например, час, день) и указывает функцию агрегирования, которую он будет использовать (например, сумма, количество, минимум, максимум, первый, последний). Объекты агрегации рассчитываются автоматически на основе указанного источника в конце необходимого интервала.

#### Доступные интервалы агрегации

- `hour`: устанавливает период тайм-серии каждый час, в час.
- `day`: устанавливает период тайм-серий ежедневный, который начинается и заканчивается в 00:00.

#### Доступные функции агрегации

- `sum`: сумма всех значений.
- `count`: количество значений.
- `min`: минимальное значение.
- `max`: максимальное значение.
- `first`: первое значение в периоде.
- `last`: последнее значение за период.

#### Пример запроса агрегации

```graphql
{
  stats(interval: "hour", where: { timestamp_gt: 1704085200 }) {
    id
    timestamp
    sum
  }
}
```

Примечание:

Чтобы использовать тайм-серии и агрегации, субграф должен иметь версию спецификации ≥1.1.0. Обратите внимание, что эта функция может претерпеть значительные изменения, которые могут повлиять на обратную совместимость.

[Подробнее](https://github.com/graphprotocol/graph-node/blob/master/docs/aggregations.md) о тайм-сериях и агрегациях.
