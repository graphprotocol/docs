---
title: Интеграция новых чейнов
---

Чейны могут обеспечить поддержку субграфов в своей экосистеме, начав новую интеграцию `graph-node`. Субграфы — это мощный инструмент индексирования, открывающий перед разработчиками целый мир возможностей. Graph Node уже индексирует данные из перечисленных здесь чейнов. Если Вы заинтересованы в новой интеграции, для этого существуют 2 стратегии:

1. **EVM JSON-RPC**
2. **Firehose**: все решения по интеграции Firehose включают Substreams, крупномасштабный механизм потоковой передачи на базе Firehose со встроенной поддержкой `graph-node`, позволяющий выполнять распараллеленные преобразования.

> Обратите внимание на то, что хотя рекомендуемый подход заключается в разработке нового Firehose для всех новых чейнов, он требуется только для чейнов, не поддерживающих EVM.

## Интеграционные стратегии

### 1. EVM JSON-RPC

Если блокчейн эквивалентен EVM и клиент/нода предоставляет стандартный API EVM JSON-RPC, Graph Node должен иметь возможность индексировать новый чейн.

#### Тестирование EVM JSON-RPC

Чтобы Graph Node мог принимать данные из чейна EVM, нода RPC должна предоставлять следующие методы EVM JSON-RPC:

- `eth_getLogs`
- `eth_call` (для исторических блоков, с EIP-1898 - требуется архивная нода)
- `eth_getBlockByNumber`
- `eth_getBlockByHash`
- `net_version`
- `eth_getTransactionReceipt` в пакетном запросе JSON-RPC
- `trace_filter` _(необязателен для Graph Node для поддержки обработчиков вызовов)_

### 2. Интеграция Firehose

[Firehose](https://firehose.streamingfast.io/firehose-setup/overview) — это слой извлечения нового поколения. Он собирает историю в плоских файлах и передает ее в реальном времени. Технология Firehose заменяет эти вызовы API опросов потоком данных с использованием модели push, которая быстрее отправляет данные на ноду индексирования. Это помогает увеличить скорость синхронизации и индексирования.

Основной метод интеграции Firehose в чейны — использование стратегии опроса RPC. Наш алгоритм опроса предсказывает, когда поступит новый блок, и увеличивает скорость проверки наличия нового блока в ближайшее время, что делает его эффективным решением с очень низкой задержкой. За помощью по интеграции и обслуживанию Firehose обращайтесь к [команде StreamingFast] (https://www.streamingfast.io/firehose-integration-program). Новые чейны и их интеграторы по достоинству оценят [осведомленность о форках](https://substreams.streamingfast.io/documentation/consume/reliability-guarantees) и огромные возможности параллельного индексирования, которые Firehose и Substreams привносят в их экосистему.

> ПРИМЕЧАНИЕ: Все интеграции, выполненные командой StreamingFast, включают обслуживание протокола репликации Firehose в кодовой базе чейна. StreamingFast отслеживает любые изменения и выпускает двоичные файлы, когда Вы изменяете код и когда StreamingFast изменяет код. Сюда входит выпуск двоичных файлов Firehose/Substreams для протокола, поддержка модулей Substreams для блочной модели чейна и выпуск двоичных файлов для ноды блокчейна с оснащением инструментами, если это необходимо.

#### Специальное оснащение Firehose для чейнов EVM (`geth`)

Для чейнов EVM существует более глубокий уровень данных, который может быть достигнут с помощью `geth` [live-tracer](https://github.com/ethereum/go-ethereum/releases/tag/v1.14.0), сотрудничества между Go-Ethereum и StreamingFast, для создания высокопроизводительной и богатой системы отслеживания транзакций. Live Tracer — наиболее комплексное решение, позволяющее получать [Расширенные](https://streamingfastio.medium.com/new-block-model-to-accelerate-chain-integration-9f65126e5425) детали блоков. Это позволяет использовать новые парадигмы индексирования, такие как сопоставление шаблонов событий на основе изменений состояния, вызовов, деревьев вызовов более высокого уровня или запуск событий на основе изменений фактических переменных в смарт-контракте.

![Базовый блок vs Расширенный блок](/img/extended-vs-base-substreams-blocks.png)

> ПРИМЕЧАНИЕ: Для этого улучшения Firehose требуется, чтобы в чейнах использовался движок EVM `geth version 1.13.0` и выше.

## Рекомендации по EVM — разница между JSON-RPC & Firehose

Хотя как JSON-RPC, так и Firehose оба подходят для субграфов, Firehose всегда востребован разработчиками, желающими создавать с помощью [Substreams](https://substreams.streamingfast.io). Поддержка Substreams позволяет разработчикам создавать [субграфы на основе субпотоков](/subgraphs/cookbook/substreams-powered-subgraphs/) для нового чейна и потенциально может повысить производительность Ваших субграфов. Кроме того, Firehose — в качестве замены уровня извлечения JSON-RPC `graph-node` — сокращает на 90 % количество вызовов RPC, необходимых для общего индексирования.

- Все эти вызовы `getLogs` и циклические передачи заменяются единым потоком, поступающим в сердце `graph-node`; единой блочной моделью для всех обрабатываемых ею субграфов.

> ПРИМЕЧАНИЕ: Интеграция на основе Firehose для чейнов EVM по-прежнему будет требовать от Индексаторов запуска ноды архива RPC чейна для правильного индексирования субрафов. Это происходит из-за неспособности Firehose предоставить состояние смарт-контракта, обычно доступное с помощью метода RPC `eth_call`. (Стоит напомнить, что `eth_calls` не является хорошей практикой для разработчиков)

## Конфигурация Graph Node

Настроить Graph Node так же просто, как подготовить локальную среду. После того, как Ваша локальная среда настроена, Вы можете протестировать интеграцию, локально развернув субграф.

1. [Клонировать Graph Node](https://github.com/graphprotocol/graph-node)

2. Измените [эту строку](https://github.com/graphprotocol/graph-node/blob/master/docker/docker-compose.yml#L22), включив в неё новое имя сети и URL-адрес, совместимый с EVM JSON-RPC

   > Не меняйте само имя переменной env. Оно должно оставаться `ethereum`, даже если имя сети отличается.

3. Запустите ноду IPFS или используйте ту, которая используется The Graph: https://api.thegraph.com/ipfs/

### Тестирование EVM JSON-RPC посредством локального развертывания субграфа

1. Установите [graph-cli](https://github.com/graphprotocol/graph-cli)
2. Создайте простой пример субграфа. Несколько вариантов приведены ниже:
   1. Предварительно упакованные смарт-контракт [Gravitar](https://github.com/graphprotocol/example-subgraph/tree/f89bdd4628efa4badae7367d4919b3f648083323) и субграф являются хорошей отправной точкой
   2. Загрузите локальный субграф из любого существующего смарт-контракта или среды разработки Solidity [используя Hardhat с плагином Graph](https://github.com/graphprotocol/hardhat-graph)
3. Адаптируйте полученный `subgraph.yaml`, изменив `dataSources.network` на то же имя, которое ранее было передано в Graph Node.
4. Создайте свой субграф в Graph Node: `graph create $SUBGRAPH_NAME --node $GRAPH_NODE_ENDPOINT`
5. Опубликуйте свой субграф в Graph Node: `graph deploy $SUBGRAPH_NAME --ipfs $IPFS_ENDPOINT --node $GRAPH_NODE_ENDPOINT`

Graph нода должна синхронизировать развернутый субграф, если нет ошибок. Дайте ему время на синхронизацию, затем отправьте несколько запросов GraphQL на API-эндпоинт, указанный в логах.

## Субграфы, работающие на основе субпотоков (Substreams)

Для интеграции Firehose/Substreams под управлением StreamingFast включена базовая поддержка фундаментальных модулей Substreams (например, декодированные транзакции, логи и события смарт-контрактов) и инструментов генерации кодов Substreams. Эти инструменты позволяют включать [субграфы на базе субпотоков](/substreams/sps/introduction/). Следуйте [Практическому руководству] (https://substreams.streamingfast.io/documentation/how-to-guides/intro-your-first-application) и запустите `substreams codegen subgraph`, чтобы самостоятельно испробовать инструменты кодирования.
