---
title: Indexování
---

Indexery jsou operátoři uzlů v síti Graf, kteří sázejí graf tokeny (GRT), aby mohli poskytovat služby indexování a zpracování dotazů. Indexátoři za své služby získávají poplatky za dotazy a odměny za indexování. Získávají také poplatky za dotazy, které jsou vráceny podle exponenciální funkce vrácení.

GRT, který je v protokolu založen, podléhá období rozmrazování a může být zkrácen, pokud jsou indexátory škodlivé a poskytují aplikacím nesprávná data nebo pokud indexují nesprávně. Indexátoři také získávají odměny za delegované sázky od delegátů, aby přispěli do sítě.

Indexátory vybírají podgrafy k indexování na základě signálu kurátorů podgrafů, přičemž kurátoři sázejí na GRT, aby určili, které podgrafy jsou vysoce kvalitní a měly by být upřednostněny. Spotřebitelé (např. aplikace) mohou také nastavit parametry, podle kterých indexátoři zpracovávají dotazy pro jejich podgrafy, a nastavit preference pro stanovení ceny poplatků za dotazy.

<Difficulty level="ADVANCED" />

## FAQ

### Jaký je minimální podíl potřebný k tomu, abyste se mohli stát indexátorem v síti?

Minimální vklad pro indexátora je v současné době nastaven na 100k GRT.

### Jaké jsou toky příjmů pro indexátora?

**Slevy z poplatků za dotazy** - Platby za obsluhu dotazů v síti. Tyto platby jsou zprostředkovány prostřednictvím stavových kanálů mezi indexerem a bránou. Každý dotazový požadavek z brány obsahuje platbu a odpovídající odpověď doklad o platnosti výsledku dotazu.

**Odměny za indexování** - Odměny za indexování, generované prostřednictvím 3% roční inflace v rámci celého protokolu, jsou rozdělovány indexátorům, kteří indexují rozmístění podgrafů pro síť.

### Jak se rozdělují odměny za indexaci?

Odměny za indexaci pocházejí z protokolární inflace, která je stanovena na 3 % ročně. Rozdělují se mezi podgrafy na základě podílu všech kurátorských signálů na každém z nich a poté se poměrně rozdělí indexátorům na základě jejich přiděleného podílu na daném podgrafu. **Alokace musí být uzavřena platným důkazem indexace (POI), který splňuje standardy stanovené rozhodčí chartou, aby bylo možné získat odměny.**

Komunita vytvořila řadu nástrojů pro výpočet odměn; jejich sbírku najdete ve sbírce [Průvodci komunity](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). Aktuální seznam nástrojů najdete také v kanálech #Delegators a #Indexers na serveru [Discord](https://discord.gg/graphprotocol). Zde uvádíme odkaz na [doporučený optimalizátor alokace](https://github.com/graphprotocol/AllocationOpt.jl) integrovaný se softwarovým zásobníkem indexátorů.

### Co je Důkaz indexování (POI)?

V síti se používají Proofy indexování (POI) k ověření, zda indexátor skutečně indexuje podgrafy, na které má alokovanou kapacitu. Pro uzavření alokace a možnost získat odměny za indexování je nutné při uzavírání alokace předložit POI pro první blok aktuální epochy. POI pro daný blok je souhrn všech transakcí v úložišti entit pro konkrétní nasazení podgrafu, a to až do tohoto bloku včetně.

### Kdy se rozdělují odměny za indexaci?

Za přidělení se průběžně připisují odměny, dokud jsou aktivní a přidělené během 28 epoch. Odměny jsou shromažďovány indexátory a rozdělovány vždy, když jsou jejich alokace uzavřeny. To se děje buď ručně, kdykoli je chce indexátor násilně uzavřít, nebo po 28 epochách může alokaci za indexátora uzavřít delegát, což však nevede k žádným odměnám. 28 epoch je maximální doba životnosti alokace (právě teď trvá jedna epocha ~24 hodin).

### Lze sledovat čekající odměny za indexaci?

Smlouva RewardsManager obsahuje funkci [getRewards](https://github.com/graphprotocol/contracts/blob/master/contracts/rewards/RewardsManager.sol#L317) pouze pro čtení, kterou lze použít ke zjištění čekajících odměn pro konkrétní příděl.

Mnoho informačních panelů vytvořených komunitou obsahuje hodnoty čekajících odměn a lze je snadno zkontrolovat ručně podle následujících kroků:

1. Dotazem na podgraf [mainnet](https://thegraph.com/hosted-service/subgraph/graphprotocol/graph-network-mainnet) získáte ID všech aktivních alokací:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Pomocí funkce Etherscan zavolejte `getRewards()`:

- Přejděte na [Etherscan rozhraní na smlouvu odměny](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)

* Volání funkce `getRewards()`:
  - Rozbalte rozevírací seznam **10. getRewards**.
  - Do vstupu zadejte **allocationID**.
  - Klikněte na tlačítko **Dotaz**.

### Co jsou to spory a kde si je mohu prohlédnout?

Dotazy indexátoru i alokace lze v grafu zpochybnit během sporného období. Období sporu se liší v závislosti na typu sporu. Dotazy/atesty mají 7 epochové sporné okno, zatímco alokace mají 56 epoch. Po uplynutí těchto období nelze zahájit spor ani proti alokacím, ani proti dotazům. Při zahájení sporu musí rybáři složit zálohu v minimální výši 10,000 GRT, která bude zablokována až do ukončení sporu a vydání rozhodnutí. Rybáři jsou všichni účastníci sítě, kteří otevírají spory.

Spory mají **tři** možné výsledky, stejně tak vklad rybářů.

- Pokud bude spor zamítnut, GRT složené rybáři budou spáleny a sporný indexátor nebude krácen.
- Pokud je spor vyřešen nerozhodně, bude Fishermen's vklad vrácen a sporný indexátor nebude penalizován snížením stake.
- Pokud je spor uznán, bude Fishermen's vklad vrácen, sporný indexátor bude penalizován snížením stake a Fishermen obdrží 50 % sníženého stake.

Spory lze zobrazit v UI na stránce profilu indexátora na kartě `Spory`.

### Co jsou to slevy z poplatků za dotaz a kdy se rozdělují?

Poplatky za dotazy vybírá brána a rozděluje je indexátorům podle exponenciální funkce rabatu (viz GIP [zde](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). Exponenciální funkce rabatu je navržena jako způsob, jak zajistit, aby indexátory dosáhly nejlepšího výsledku věrným obsloužením dotazů. Funguje tak, že motivuje indexátory, aby přidělovali velké množství podílu (který může být snížen za chybu při obsluze dotazu) v poměru k výši poplatků za dotazy, které mohou inkasovat.

Po uzavření přídělu může indexátor požádat o slevy. Po uplatnění nároku jsou slevy z poplatku za dotaz rozděleny mezi indexátora a jeho delegáty na základě snížení poplatku za dotaz a exponenciální funkce slevy.

### Co je to snížení poplatku za dotaz a snížení odměny za indexaci?

Hodnoty `queryFeeCut` a `indexingRewardCut` jsou parametry delegování, které může indexátor nastavit spolu s bloky cooldownBlocks a řídit tak rozdělení GRT mezi indexátor a jeho delegáty. Pokyny k nastavení parametrů delegování naleznete v posledních krocích v části [Zadání protokolu](/network/indexing#stake-in-the-protocol).

- **queryFeeCut** - % slev z poplatků za dotaz, které budou rozděleny mezi indexátory. Pokud je tato hodnota nastavena na 95%, obdrží indexátor 95% poplatků za dotaz získaných při uzavření přídělu a zbylých 5% připadne delegátům.

- **indexingRewardCut** - % odměn za indexování, které budou rozděleny indexátoru. Pokud je tato hodnota nastavena na 95 %, obdrží indexátor při uzavření přídělu 95 % odměn za indexování a zbylých 5 % si rozdělí delegáti.

### Jak indexátory poznají, které podgrafy mají indexovat?

Indexátory se mohou odlišovat použitím pokročilých technik pro rozhodování o indexaci podgrafů, ale pro obecnou představu probereme několik klíčových metrik používaných k hodnocení podgrafů v síti:

- **Signál kurátorství** - Podíl signálu kurátorství sítě aplikovaného na určitý podgraf je dobrým ukazatelem zájmu o tento podgraf, zejména během zaváděcí fáze, kdy se zvyšuje objem dotazů.

- **Vybrané poplatky za dotazy** - Historické údaje o objemu vybraných poplatků za dotazy pro určitý podgraf jsou dobrým ukazatelem budoucí poptávky.

- **Amount staked** - Sledování chování ostatních indexátorů nebo podílů celkového vkladu přiděleného konkrétním podgrafům může indexátoru umožnit sledovat stranu nabídky pro dotazy na podgrafy a identifikovat podgrafy, kterým síť důvěřuje, nebo podgrafy, které mohou vykazovat potřebu větší nabídky.

- **Podgrafy bez odměn za indexování** - Některé podgrafy negenerují odměny za indexování především proto, že používají nepodporované funkce, jako je IPFS, nebo protože se dotazují na jinou síť mimo hlavní síť. Pokud podgraf negeneruje odměny za indexování, zobrazí se u něj tato zpráva.

### Jaké jsou požadavky na hardware?

- **Malý** - Dostatečný pro začátek indexování několika podgrafů, pravděpodobně bude třeba jej rozšířit.
- **Standard** - Výchozí nastavení, které je použito v ukázkových manifestech nasazení k8s/terraform.
- **Střední** - produkční indexer podporující 100 podgrafů a 200-500 požadavků za sekundu.
- **Large** - Připraveno k indexování všech aktuálně nepoužívaných příbuzných podgrafů.

| Nastavení | Postgres<br />(CPUs) | Postgres<br />(paměť v GBs) | Postgres<br />(disk v TBs) | VMs<br />(CPUs) | VMs<br />(paměť v GBs) |
| --- | :-: | :-: | :-: | :-: | :-: |
| Malé | 4 | 8 | 1 | 4 | 16 |
| Standard | 8 | 30 | 1 | 12 | 48 |
| Střední | 16 | 64 | 2 | 32 | 64 |
| Velký | 72 | 468 | 3.5 | 48 | 184 |

### Jaká jsou základní bezpečnostní opatření, která by měl indexátor přijmout?

- **Peněženka operátora** - Nastavení peněženky operátora je důležitým opatřením, protože umožňuje indexátorovi udržovat oddělení mezi klíči, které kontrolují sázky, a klíči, které řídí každodenní operace. Pokyny naleznete v části [Podíl na protokolu](/network/indexing#stake-in-the-protocol).

- **Firewall** - Pouze služba Indexer musí být vystavena veřejně a zvláštní pozornost by měla být věnována uzamčení portů pro správu a přístupu k databázi: koncový bod JSON-RPC uzlu Graf (výchozí port: 8030), koncový bod API pro správu Indexeru (výchozí port: 18000) a koncový bod databáze Postgres (výchozí port: 5432) by neměly být vystaveny.

## Infrastruktura

Centrem infrastruktury indexeru je uzel Graf, který monitoruje indexované sítě, extrahuje a načítá data podle definice podgrafu a poskytuje je jako [GraphQL API](/about/#how-the-graph-works). Uzel Graf musí být připojen ke koncovému bodu vystavujícímu data z každé indexované sítě, uzlu IPFS pro získávání dat, databázi PostgreSQL pro jejich ukládání a komponentám Indexeru, které usnadňují jeho interakci se sítí.

- **Databáze PostgreSQL** - Hlavní úložiště pro uzel Graf kde jsou uložena data dílčích grafů. Služba Indexer a agent také používají databázi k ukládání dat stavového kanálu, nákladových modelů, indexačních pravidel a alokačních akcí.

- **Datový koncový bod** - Pro sítě kompatibilní s EVM musí být graf uzel připojen ke koncovému bodu, který vystavuje API JSON-RPC kompatibilní s EVM. To může mít podobu jediného klienta nebo může jít o složitější nastavení, které vyrovnává zátěž mezi více. Je důležité si uvědomit, že některé dílčí grafy budou vyžadovat konkrétní schopnosti klienta, jako je archivační režim a/nebo API pro sledování parity.

- **Vuzel IPFS (verze menší než 5)** - Metadata nasazení podgrafů jsou uložena v síti IPFS. Uzel Graf přistupuje během nasazení podgrafu primárně k uzlu IPFS, aby načetl manifest podgrafu a všechny propojené soubory. Síťové indexátory nemusí hostovat vlastní uzel IPFS, uzel IPFS pro síť je hostován na adrese https://ipfs.network.thegraph.com.

- **Služba indexeru** - Zpracovává veškerou požadovanou externí komunikaci se sítí. Sdílí nákladové modely a stavy indexace, předává požadavky na dotazy z bran na uzel Graga spravuje platby za dotazy prostřednictvím stavových kanálů s branou.

- **Indexer agent** - Usnadňuje interakce indexerů v řetězci, včetně registrace v síti, správy nasazení podgrafů do jejich grafových uzlů a správy alokací.

- **Server metrik Prometheus** - Komponenty Uzel grafu a Indexer zaznamenávají své metriky na metrický server.

Poznámka: Pro podporu agilního škálování se doporučuje oddělit dotazování a indexování mezi různé sady uzlů: dotazovací uzly a indexovací uzly.

### Přehled portů

> **Důležité**: Dávejte pozor na veřejné vystavování portů - **administrační porty** by měly být uzamčeny. To zahrnuje koncové body JSON-RPC uzlu Graf a koncové body správy Indexeru, které jsou podrobně popsány níže.

#### Uzel Graf

| Port | Účel | Trasy | CLI Argument | Proměnná prostředí |
| --- | --- | --- | --- | --- |
| 8000 | GraphQL HTTP server<br />(pro dotazy podgrafy) | /subgraphs/id/...<br />/subgraphs/name/.../... | --http-port | - |
| 8001 | GraphQL WS<br />(pro odběry podgrafů) | /subgraphs/id/...<br />/subgraphs/name/.../... | --ws-port | - |
| 8020 | JSON-RPC<br />(pro správu nasazení) | / | --admin-port | - |
| 8030 | Stav indexování podgrafů API | /graphql | --index-node-port | - |
| 8040 | Metriky Prometheus | /metrics | --metrics-port | - |

#### Služba Indexer

| Port | Účel | Trasy | CLI Argument | Proměnná prostředí |
| --- | --- | --- | --- | --- |
| 7600 | GraphQL HTTP server<br />(pro placené dotazy na podgrafy) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | --port | `INDEXER_SERVICE_PORT` |
| 7300 | Metriky Prometheus | /metrics | --metrics-port | - |

#### Agent indexátoru

| Port | Účel                      | Trasy | CLI Argument              | Proměnná prostředí                      |
| ---- | ------------------------- | ----- | ------------------------- | --------------------------------------- |
| 8000 | API pro správu indexátoru | /     | --indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Nastavení serverové infrastruktury pomocí Terraformu ve Google Cloud

> Poznámka: Indexéry mohou alternativně používat AWS, Microsoft Azure nebo Alibaba.

#### Instalace předpokladů

- Google Cloud SDK
- Nástroj příkazového řádku Kubectl
- Terraform

#### Vytvoření projektu Google Cloud

- Klonujte nebo přejděte do úložiště Indexer.

- Přejděte do adresáře ./terraform, kde by se měly spouštět všechny příkazy.

```sh
cd terraform
```

- Ověřte se pomocí služby Google Cloud a vytvořte nový projekt.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Pomocí fakturační stránky konzoly Google Cloud Console povolte fakturaci pro nový projekt.

- Vytvořte konfiguraci služby Google Cloud.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Povolte požadované Google Cloud API.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Vytvoření účtu služby.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Povolte peering mezi databází a clusterem Kubernetes, který bude vytvořen v dalším kroku.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Vytvořte minimální konfigurační soubor terraformu (aktualizujte jej podle potřeby).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database passowrd>"
EOF
```

#### Použití nástroje Terraform k vytvoření infrastruktury

Před spuštěním jakýchkoli příkazů si přečtěte soubor [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) a vytvořte v tomto adresáři soubor `terraform.tfvars` (nebo upravte soubor vytvořený v minulém kroku). Pro každou proměnnou, u které chcete přepsat výchozí hodnotu nebo u které potřebujete nastavit hodnotu, zadejte nastavení do `terraform.tfvars`.

- Pro vytvoření infrastruktury spusťte následující příkazy.

```sh
# Install required plugins
terraform init

# View plan for resources to be created
terraform plan

# Create the resources (expect it to take up to 30 minutes)
terraform apply
```

Stáhněte pověření pro nový cluster do souboru `~/.kubeconfig` a nastavte jej jako výchozí kontext.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Vytvoření komponent Kubernetes pro Indexer

- Zkopírujte adresář `k8s/overlays` do nového adresáře `$dir,` a upravte položku `bases` v `$dir/kustomization.yaml` tak, aby ukazovala na adresář `k8s/base`.

- Přečtěte si všechny soubory v `$dir` a upravte všechny hodnoty uvedené v komentářích.

Všechny prostředky nasadíte pomocí `kubectl apply -k $dir`.

### Uzel Grafu

[Uzel Graf](https://github.com/graphprotocol/graph-node) je open source implementace Rust, která využívá zdrojové kódy událostí v blockchainu Ethereum k deterministické aktualizaci datového úložiště, na které se lze dotazovat prostřednictvím koncového bodu GraphQL. Vývojáři používají podgrafy k definici svého schématu a sadu mapování pro transformaci dat získaných z blokového řetězce a Uzel Graf se stará o synchronizaci celého řetězce, monitorování nových bloků a jejich obsluhu prostřednictvím koncového bodu GraphQL.

#### Začínáme od zdroje

#### Instalace předpokladů

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Další požadavky pro uživatele Ubuntu** - Pro spuštění Uzel Graf v Ubuntu může být potřeba několik dalších balíčků.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Nastavení

1. Spuštění databázového serveru PostgreSQL

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Klonujte repozitář [Uzel Graf](https://github.com/graphprotocol/graph-node) a sestavte zdrojový kód spuštěním příkazu `cargo build`

3. Nyní, když jsou všechny závislosti nastaveny, spusťte uzel Graf:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Začínáme používat Docker

#### Požadavky

- **Ethereum Uzel** - Ve výchozím nastavení docker compose použije mainnet: [http://host.docker.internal:8545](http://host.docker.internal:8545) pro připojení k uzlu Ethereum na hostitelském počítači. Tento název sítě a url můžete nahradit aktualizací souboru `docker-compose.yaml`.

#### Nastavení

1. Klonujte graf uzel a najděte cestu do adresáře Docker:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Pouze pro uživatele Linux- Použijte IP adresu hostitele místo `host.docker.internal` v `docker-compose.yaml` pomocí přiloženého skript:

```sh
./setup.sh
```

3. Spusťte místní uzel Graf, který se připojí ke koncovému bodu Ethereum:

```sh
docker-compose up
```

### Součásti indexeru

Úspěšná účast v síti vyžaduje téměř neustálé sledování a interakci, proto jsme vytvořili sadu aplikací Typescript pro usnadnění účasti v síti Indexers. K dispozici jsou tři komponenty Indexer:

- **Agent indexátoru** - Agent monitoruje síť a vlastní infrastrukturu indexátoru a spravuje, která dílčí nasazení jsou indexována a alokována do řetězce a kolik je jim přiděleno.

- **Služba indexeru** - Jediná komponenta, která musí být vystavena externě, služba předává dotazy na podgraf uzlu grafu, spravuje stavové kanály pro platby dotazů, sdílí důležité rozhodovací informace klientům, jako jsou brány.

- **Indexer CLI** - Rozhraní příkazového řádku pro správu agenta Indexer. Umožňuje indexátorům spravovat nákladové modely, ruční přidělování, frontu akcí a pravidla indexování.

#### Začínáme

Agent Indexer a služba Indexer by měly být umístěny společně s infrastrukturou graf uzlu. Existuje mnoho způsobů, jak nastavit virtuální prováděcí prostředí pro komponenty Indexer; zde vysvětlíme, jak je spustit na baremetalu pomocí balíčků NPM nebo zdrojových kódů, nebo pomocí kubernetes a docker na Google Cloud Kubernetes Engine. Pokud se tyto příklady nastavení nedají dobře převést na vaši infrastrukturu, bude pravděpodobně existovat komunitní příručka, na kterou se můžete odkázat, přijďte ji pozdravit na [Discord](https://discord.gg/graphprotocol)! Před spuštěním komponent Indexeru nezapomeňte [zakázat protokol](/network/indexing#stake-in-the-protocol)!

#### Z balíčků NPM

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### Ze zdroje

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Použití docker

- Stažení obrázků z registru

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Nebo sestavte obrazy lokálně ze zdrojových kódů

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Spustit komponenty

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**POZNÁMKA**: Po spuštění kontejnerů by měla být služba Indexer dostupná na adrese [http://localhost:7600](http://localhost:7600) a agent Indexer by měl vystavovat API pro správu Indexeru na adrese [http://localhost:18000/](http://localhost:18000/).

#### Použití K8s a Terraform

Viz část [Nastavení serverové infrastruktury pomocí Terraformu ve službě Google Cloud](/network/indexing#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Použití

> **POZNÁMKA**: Všechny konfigurační proměnné za běhu mohou být použity buď jako parametry příkazu při spuštění, nebo pomocí proměnných prostředí ve formátu `NÁZEV_PŘÍKAZU_VARIABLE_NAME`(např. `INDEXER_AGENT_ETHEREUM`).

#### Agent indexátoru

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Služba Indexer

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  | pino-pretty
```

#### Indexer CLI

Indexer CLI je zásuvný modul pro [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) přístupný v terminál na adrese `graf indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Správa indexeru pomocí Indexer CLI

Navrhovaným nástrojem pro interakci s **Indexer Management API** je **Indexer CLI**, rozšíření **Graph CLI**. Agent Indexer potřebuje vstup od Indexeru, aby mohl autonomně komunikovat se sítí jménem Indexeru. Mechanismem pro definování chování agenta Indexer jsou **režim správy přidělování** a **pravidla indexování**. V automatickém režimu může indexátor použít **indexační pravidla** k použití své specifické strategie pro výběr podgrafů k indexování a obsluze dotazů. Pravidla jsou spravována prostřednictvím GraphQL API obsluhovaného agentem a známého jako rozhraní API pro správu indexátoru. V manuálním režimu může indexátor vytvářet alokační akce pomocí **akční fronty** a explicitně je schvalovat před jejich provedením. V režimu dohledu se k naplnění **akční fronty** používají **indexační pravidla**, která rovněž vyžadují explicitní schválení pro provedení.

#### Použití

**Indexer CLI** se připojuje k agentovi Indexer, obvykle prostřednictvím přesměrování portů, takže CLI nemusí běžet na stejném serveru nebo clusteru. Abychom vám usnadnili začátek a poskytli vám určitý kontext, bude zde CLI stručně popsáno.

- `graf indexer připojit <url>` - Připojení k API pro správu indexeru. Obvykle se připojení k serveru otevírá pomocí přesměrování portů, takže CLI lze snadno ovládat na dálku. (Příklad: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `pravidla indexování grafů získat [možnosti] <deployment-id> [<key1> ...]` - Získá jedno nebo více indexovacích pravidel pomocí `all` jako `<deployment-id>` pro získání všech pravidel nebo `global` pro získání globálních výchozích hodnot. Pomocí doplňkového argumentu `--merged` lze určit, že pravidla specifická pro nasazení budou sloučena s globálním pravidlem. Takto se použijí v agentu Indexer.

- `pravidla indexování grafů získat [možnosti]<deployment-id><key1><value1> ...` -Nastavení jednoho nebo více pravidel indexování.

- `pravidla indexování grafů získat [možnosti] <deployment-id>` - Spustí indexování nasazení podgrafů, pokud je k dispozici, a nastaví jeho `decisionBasis` na `always`, takže agent Indexer vždy zvolí jeho indexování. Pokud je globální pravidlo nastaveno na vždy, pak budou indexovány všechny dostupné podgrafy v síti.

- `zastavení pravidel indexování grafů [možnosti]<deployment-id>` - Zastaví indexování nasazení a nastaví jeho `decisionBasis` na never, takže při rozhodování o nasazeních k indexování toto nasazení přeskočí.

- `možná pravidla indexování grafů [možnosti] <deployment-id>` - Nastaví `decisionBasis` pro nasazení na `rules`, takže agent Indexer bude při rozhodování o indexování tohoto nasazení používat pravidla indexování.

- `Akce indexátoru grafu získají [možnosti] <action-id>` - Získá jednu nebo více akcí pomocí `all` nebo ponechá `action-id` prázdné pro získání všech akcí. Přídavný argument `--status` lze použít pro vypsání všech akcí určitého stavu.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Akce přidělení fronty

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Akce přerozdělení fronty

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Akce odalokování fronty

- `Akce indexátoru grafů zrušit [<action-id> ...]` - Zruší všechny akce ve frontě, pokud není id zadáno, jinak zruší pole id s mezerou jako oddělovačem

- `schvalovat akce indexátoru grafů[<action-id> ...]` - Schválení více akcí k provedení

- `akce indexátoru grafu provést schválit` - Vynutí, aby pracovník okamžitě provedl schválené akce

Všechny příkazy, které zobrazují pravidla na výstupu, mohou pomocí argumentu `-output` volit mezi podporovanými výstupními formáty (`table`, `yaml` a `json`).

#### Pravidla indexování

Pravidla indexování lze použít buď jako globální výchozí, nebo pro konkrétní nasazení podgrafů pomocí jejich ID. Pole `nasazení` a `podklad pro rozhodování` jsou povinná, zatímco všechna ostatní pole jsou nepovinná. Pokud má indexovací pravidlo `pravidla` jako `základnu rozhodování`, pak agent Indexer porovná nenulové prahové hodnoty tohoto pravidla s hodnotami získanými ze sítě pro příslušné nasazení. Pokud má dílčí nasazení grafu hodnoty vyšší (nebo nižší) než některá z prahových hodnot, bude vybráno pro indexaci.

Pokud má například globální pravidlo `minStake` hodnotu **5** (GRT), bude indexováno každé nasazení podgrafu, kterému je přiděleno více než 5 (GRT) podílů. Mezi prahová pravidla patří `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake` a `minAverageQueryFees`.

Datový model:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Příklad použití indexovacího pravidla:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Fronta akcí CLI

Indexer-cli poskytuje modul `actions` pro ruční práci s frontou akcí. K interakci s frontou akcí používá **Graphql API**, které je hostováno serverem pro správu indexeru.

Pracovník pro provádění akcí převezme položky z fronty k provedení pouze tehdy, pokud mají `ActionStatus = approved`. V doporučené cestě jsou akce přidány do fronty se stavem ActionStatus = queued, takže pak musí být schváleny, aby mohly být provedeny v řetězci. Obecný průběh bude vypadat takto:

- Akce přidaná do fronty nástrojem optimalizace třetí strany nebo uživatelem indexer-cli
- Indexer může pomocí `indexer-cli` zobrazit všechny akce ve frontě
- Indexer (nebo jiný software) může akce ve frontě schválit nebo zrušit pomocí příkazu `indexer-cli`. Příkazy approve a cancel přijímají jako vstup pole id akcí.
- Pracovník provádějící operace pravidelně kontroluje frontu schválených akcí. Vezme z fronty `schválené` akce, pokusí se je provést a aktualizuje hodnoty v db v závislosti na stavu provedení na `úspěšné` nebo `neúspěšné`.
- Pokud je akce úspěšná, pracovník zajistí, že je přítomno pravidlo indexování, které agentovi říká, jak má alokaci dále spravovat, což je užitečné při provádění ručních akcí, když je agent v režimu `auto` nebo `oversight`.
- Indexer může sledovat frontu akcí a zobrazit historii jejich provádění a v případě potřeby znovu schválit a aktualizovat položky akcí, pokud se nepodařilo je provést. Fronta akcí poskytuje historii všech akcí zařazených do fronty a provedených.

Datový model:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Příklad použití ze zdroje:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Všimněte si, že podporované typy akcí pro správu přidělování mají různé vstupní požadavky:

- `Allocate` - přidělí podíl konkrétnímu nasazení podgrafu

  - požadované parametry akce:
    - deploymentID
    - částka

- `Unallocate` - uzavře alokaci, čímž uvolní podíl k přerozdělení jinam

  - požadované parametry akce:
    - allocationID
    - deploymentID
  - volitelné parametry akce:
    - poi
    - síla (vynutí pomocí poskytnutého POI, i když neodpovídá tomu, co poskytuje uzel graf)

- `Přerozdělit` – atomicky uzavřít alokaci a otevřít novou alokaci pro stejné nasazení podgrafu

  - požadované parametry akce:
    - allocationID
    - deploymentID
    - částka
  - volitelné parametry akce:
    - poi
    - síla (vynutí pomocí poskytnutého POI, i když neodpovídá tomu, co poskytuje uzel graf)

#### Nákladové modely

Cost models provide dynamic pricing for queries based on market and query attributes. The Indexer Service shares a cost model with the gateways for each subgraph for which they intend to respond to queries. The gateways, in turn, use the cost model to make Indexer selection decisions per query and to negotiate payment with chosen Indexers.

#### Agora

The Agora language provides a flexible format for declaring cost models for queries. An Agora price model is a sequence of statements that execute in order for each top-level query in a GraphQL query. For each top-level query, the first statement which matches it determines the price for that query.

A statement is comprised of a predicate, which is used for matching GraphQL queries, and a cost expression which when evaluated outputs a cost in decimal GRT. Values in the named argument position of a query may be captured in the predicate and used in the expression. Globals may also be set and substituted in for placeholders in an expression.

Example cost model:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Example query costing using the above model:

| Query                                                                        | Price   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#123; tokens &#125; symbol &#125; &#125; | 0.6 GRT |

#### Applying the cost model

Cost models are applied via the Indexer CLI, which passes them to the Indexer Management API of the Indexer agent for storing in the database. The Indexer Service will then pick them up and serve the cost models to gateways whenever they ask for them.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interacting with the network

### Stake in the protocol

The first steps to participating in the network as an Indexer are to approve the protocol, stake funds, and (optionally) set up an operator address for day-to-day protocol interactions. _ **Note**: For the purposes of these instructions Remix will be used for contract interaction, but feel free to use your tool of choice ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), and [MyCrypto](https://www.mycrypto.com/account) are a few other known tools)._

Once an Indexer has staked GRT in the protocol, the [Indexer components](/network/indexing#indexer-components) can be started up and begin their interactions with the network.

#### Approve tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **GraphToken.abi** with the [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. With `GraphToken.abi` selected and open in the editor, switch to the Deploy and `Run Transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the GraphToken contract address - Paste the GraphToken contract address (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) next to `At Address` and click the `At address` button to apply.

6. Call the `approve(spender, amount)` function to approve the Staking contract. Fill in `spender` with the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) and `amount` with the tokens to stake (in wei).

#### Stake tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **Staking.abi** with the staking ABI.

3. With `Staking.abi` selected and open in the editor, switch to the `Deploy` and `Run Transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the Staking contract address - Paste the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) next to `At Address` and click the `At address` button to apply.

6. Call `stake()` to stake GRT in the protocol.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their indexingRewardCut (parts per million), queryFeeCut (parts per million), and cooldownBlocks (number of blocks). To do so call `setDelegationParameters()`. The following example sets the queryFeeCut to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the indexingRewardCutto distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set `thecooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### The life of an allocation

After being created by an Indexer a healthy allocation goes through four states.

- **Active** - Once an allocation is created on-chain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a subgraph deployment, which allows them to claim indexing rewards and serve queries for that subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - An Indexer is free to close an allocation once 1 epoch has passed ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) or their Indexer agent will automatically close the allocation after the **maxAllocationEpochs** (currently 28 days). When an allocation is closed with a valid proof of indexing (POI) their indexing rewards are distributed to the Indexer and its Delegators (see "how are rewards distributed?" below to learn more).

Indexers are recommended to utilize offchain syncing functionality to sync subgraph deployments to chainhead before creating the allocation on-chain. This feature is especially useful for subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
