---
title: Vytvoření podgraf
---

Podgraf získává data z blockchain, zpracovává je a ukládá tak, aby se na ně dalo snadno dotazovat prostřednictvím jazyka GraphQL.

![Definování podgrafu](/img/defining-a-subgraph.png)

Definice podgraf se skládá z několika souborů:

- `subgraph.yaml`: soubor YAML obsahující manifest podgraf

- `schema.graphql`: schéma GraphQL, které definuje, jaká data jsou uložena pro váš podgraf a jak se na ně dotazovat prostřednictvím jazyka GraphQL

- `Mapování skriptů sestavy`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) kód, který převádí data událostí na entity definované ve vašem schématu (např. `mapping.ts` v tomto tutoriálu)

> Abyste mohli svůj podgraf používat v decentralizované síti The Graph, musíte si [vytvořit klíč API](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key). Doporučujeme, abyste [přidali signál](/network/curating/#how-to-signal) do svého podgraf s minimálně [10,000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network).

Než se podrobněji seznámíte s obsahem souboru manifest, je třeba nainstalovat [Graph CLI](https://github.com/graphprotocol/graph-cli), které budete potřebovat k sestavení a nasazení podgraf.

## Instalace Graf CLI

Graf CLI je napsáno v jazyce JavaScript a k jeho použití je třeba nainstalovat buď `yarn`, nebo `npm`; v následujícím se předpokládá, že máte yarn.

Once you have `yarn`, install the Graph CLI by running

**Instalace pomocí yarn:**

```bash
yarn global add @graphprotocol/graph-cli
```

**Instalace pomocí npm:**

```bash
npm install -g @graphprotocol/graph-cli
```

Po instalaci lze příkazem `graph init` nastavit nový projekt podgraf, a to buď z existující smlouvy, nebo z příkladu podgraf. Tento příkaz lze použít k vytvoření subgrafu v podgraf Studio předáním příkazu `graph init --product subgraph-studio`. Pokud již máte inteligentní kontrakt nasazený v preferované síti, může být zavedení nového podgraf z tohoto kontraktu dobrým způsobem, jak začít.

## Ze stávající smlouvy

Následující příkaz vytvoří podgraf, který indexuje všechny události existující smlouvy. Pokusí se načíst ABI smlouvy z Etherscan a vrátí se k požadavku na cestu k místnímu souboru. Pokud některý z nepovinných argumentů chybí, projde příkaz interaktivním formulářem.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>` je ID vašeho podgraf ve Studio podgraph, najdete ho na stránce s podrobnostmi o podgrafu.

## Z příkladu podgraf

Druhý režim `graf init` podporuje vytvoření nového projektu z příkladového podgraf. To provede následující příkaz:

```sh
graph init --studio <SUBGRAPH_SLUG>
```

Ukázkový podgraf je založen na smlouvě Gravity od Daniho Granta, která spravuje uživatelské avatary a vysílá události `NewGravatar` nebo `UpdateGravatar`, kdykoli jsou avatary vytvořeny nebo aktualizovány. Podgraf tyto události zpracovává tak, že zapisuje entity `Gravatar` do úložiště Graf Uzel a zajišťuje jejich aktualizaci podle událostí. V následujících částech budou rozebrány soubory, které tvoří manifest podgrafu pro tento příklad.

## Přidání nových zdrojů dat do existujícího podgraf

Od verze `v0.31.0` podporuje `graf-cli` přidávání nových zdrojů dat do existujícího podgrafu pomocí příkazu `graf add`.

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Možnosti:

      --abi <path> Cesta k ABI smlouvy (výchozí: stažení z Etherscan)
      --contract-name Název kontraktu (výchozí: Contract)
      --merge-entities Zda sloučit entity se stejným názvem (výchozí: false)
      --network-file <path> Cesta ke konfiguračnímu souboru sítě (výchozí: "./networks.json")
```

Příkaz `add` načte ABI z Etherscan (pokud není zadána cesta k ABI pomocí volby `--abi`) a vytvoří nový `dataSource` stejným způsobem jako příkaz `graph init` vytvoří `dataSource` `--from-contract`, přičemž odpovídajícím způsobem aktualizuje schéma a mapování.

Volba `--merge-entities` určuje, jak chce vývojář řešit konflikty názvů `entity` a `event`:

- Pokud `true`: nový `dataSource` by měl používat stávající `eventHandlers` & `entity`.
- Pokud `false`: měla by být vytvořena nová entita & obsluha události s `${dataSourceName}{EventName}`.

Smlouva `adresa` bude zapsána do souboru `networks.json` pro příslušnou síť.

> **Poznámka:** Při použití interaktivního klienta budete po úspěšném spuštění `graf init` vyzváni k přidání nového `dataSource`.

## Manifest podgrafu

Manifest podgrafu `subgraph.yaml` definuje inteligentní smlouvy, které váš podgraf indexuje, kterým událostem z těchto smluv má věnovat pozornost a jak mapovat data událostí na entity, které Graf uzel ukládá a umožňuje dotazovat. Úplnou specifikaci manifestů podgrafu naleznete [zde](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

Pro příklad podgraf `subgraph.yaml` je:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
      endBlock: 7175245
    context:
      foo:
        type: Bool
        data: true
      bar:
        type: String
        data: 'bar'
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

Důležité položky, které je třeba v manifestu aktualizovat, jsou:

- `popis`: lidsky čitelný popis toho, co je podgraf. Tento popis zobrazí Průzkumník grafů při nasazení podgrafu do hostované služby.

- `úložiště`: adresa URL úložiště, kde lze manifest podgrafů nalézt. Tento údaj zobrazuje také Průzkumník graf.

- `features`: seznam všech použitých názvů [feature](#experimental-features).

- `dataSources.source`: adresa inteligentní smlouvy, ze které podgraf pochází, a ABI inteligentní smlouvy, která se má použít. Adresa je nepovinná; její vynechání umožňuje indexovat odpovídající události ze všech smluv.

- `dataSources.source.startBlock`: nepovinné číslo bloku, od kterého zdroj dat začíná indexovat. Ve většině případů doporučujeme použít blok, ve kterém byl kontrakt vytvořen.

- `dataSources.source.endBlock`: Nepovinné číslo bloku, ve kterém zdroj dat přestane indexovat, včetně tohoto bloku. Minimální požadovaná verze specifikace: `0.0.9`.

- `dataSources.context`: páry klíč-hodnota, které lze použít v rámci mapování podgrafů. Podporuje různé datové typy, například `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List` a `BigInt`. U každé proměnné je třeba uvést její `typ` a `údaj`. Tyto kontextové proměnné jsou pak přístupné v mapovacích souborech a nabízejí více konfigurovatelných možností pro vývoj podgrafů.

- `dataSources.mapping.entities`: entity, které zdroj dat zapisuje do úložiště. Schéma pro každou entita je definováno v souboru schema.graphql.

- `dataSources.mapping.abis`: jeden nebo více pojmenovaných souborů ABI pro zdrojový kontrakt a všechny ostatní chytré kontrakty, se kterými se pracuje v rámci mapování.

- `dataSources.mapping.eventHandlers`: uvádí seznam událostí inteligentních smluv, na které tento podgraf reaguje, a obslužných programů v mapování - v příkladu./src/mapping.ts - které tyto události transformují na entity v úložišti.

- `dataSources.mapping.callHandlers`: obsahuje seznam funkcí inteligentních smluv, na které tento podgraf reaguje, a obsluhovače v mapování, které transformují vstupy a výstupy volání funkcí na entity v úložišti.

- `dataSources.mapping.blockHandlers`: lists the blocks this subgraph reacts to and handlers in the mapping to run when a block is appended to the chain. Without a filter, the block handler will be run every block. An optional call-filter can be provided by adding a `filter` field with `kind: call` to the handler. This will only run the handler if the block contains at least one call to the data source contract.

Jeden subgraf může indexovat data z více inteligentní smluv. Do pole `dataSources` přidejte položku pro každou smlouvu, ze které je třeba indexovat data.

Spouštěče pro zdroj dat v rámci bloku jsou seřazeny podle následujícího postupu:

1. Spouštěče událostí a volání jsou nejprve seřazeny podle indexu transakce v rámci bloku.
2. Spouštěče událostí a volání v rámci jedné transakce jsou seřazeny podle konvence: nejprve spouštěče událostí a poté spouštěče volání, přičemž každý typ dodržuje pořadí, v jakém jsou definovány v manifestu.
3. Spouštěče bloků jsou spuštěny po spouštěčích událostí a volání, v pořadí, v jakém jsou definovány v manifestu.

Tato pravidla objednávání se mohou změnit.

### Získání ABI

Soubor(y) ABI se musí shodovat s vaší smlouvou. Soubory ABI lze získat několika způsoby:

- Pokud vytváříte vlastní projekt, budete mít pravděpodobně přístup k nejaktuálnějším ABI.
- Pokud vytváříte podgraf pro veřejný projekt, můžete si tento projekt stáhnout do počítače a získat ABI pomocí [`truffle compile`](https://truffleframework.com/docs/truffle/overview) nebo pomocí solc pro kompilaci.
- ABI můžete také najít na stránce [Etherscan](https://etherscan.io/), ale ta není vždy spolehlivá, protože ABI, které je tam nahráno, může být zastaralé. Ujistěte se, že máte správné ABI, jinak spuštění podgrafu selže.

## Schéma GraphQL

Schéma vašeho podgrafu je v souboru `schema.graphql`. Schémata GraphQL se definují pomocí jazyka pro definici rozhraní GraphQL. Pokud jste ještě nikdy schéma GraphQL nepsali, doporučujeme vám přečíst si tento úvodní článek o systému typů GraphQL. Referenční dokumentaci ke schématům GraphQL naleznete v části [GraphQL API](/querying/graphql-api).

## Definice entit

Před definováním entit je důležité udělat krok zpět a zamyslet se nad tím, jak jsou vaše data strukturována a propojena. Všechny dotazy budou prováděny proti datovému modelu definovanému ve schématu podgrafu a entitám indexovaným podgrafem. Z tohoto důvodu je dobré definovat schéma podgrafu způsobem, který odpovídá potřebám vaší dapp. Může být užitečné představit si entity spíše jako "objekty obsahující data" než jako události nebo funkce.

V nástroji The Graf stačí definovat typy entit v `schema.graphql` a Graf Uzel vygeneruje pole nejvyšší úrovně pro dotazování jednotlivých instancí a kolekcí daného typu entit. Každý typ, který má být entitou, je nutné anotovat direktivou `@entity`. Ve výchozím nastavení jsou entity mutovatelné, což znamená, že mapování může načíst existující entity, upravit je a uložit novou verzi dané entity. Mutabilita má svou cenu a u typů entit, u nichž je známo, že nebudou nikdy modifikovány, například proto, že jednoduše obsahují data doslovně extrahovaná z řetězce, se doporučuje označit je jako neměnné pomocí `@entity(immutable: true)`. Mapování může provádět změny v neměnných entitách, pokud k nim dojde ve stejném bloku, ve kterém byla entita vytvořena. Neměnné entity se mnohem rychleji zapisují a dotazují, a proto by se měly používat, kdykoli je to možné.

### Dobrý příklad

Níže uvedená entita `Gravatar` je strukturována kolem objektu Gravatar a je dobrým příkladem toho, jak lze entitu definovat.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Špatný příklad

Níže uvedené příklady entit `GravatarAccepted` a `GravatarDeclined` jsou založeny na událostech. Nedoporučuje se mapovat události nebo volání funkcí na entity 1:1.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Nepovinná a povinná pole

Pole entit lze definovat jako povinná nebo nepovinná. Povinná pole jsou ve schématu označena `!`. Pokud není povinné pole v mapování nastaveno, zobrazí se při dotazu na toto pole tato chyba:

```
Vyřešení nulové hodnoty pro pole 'name', které není nulové
```

Každá entita musí mít pole `id`, které musí být typu `Bajty!` nebo `Řetězec!`. Obecně se doporučuje používat `Bytes!`, pokud `id` neobsahuje lidsky čitelný text, protože entity s `Bytes!` id se zapisují a dotazují rychleji než entity s `String!` `id`. Pole `id` slouží jako primární klíč a musí být jedinečné mezi všemi entitami stejného typu. Z historických důvodů je akceptován také typ `ID!`, který je synonymem pro `String!`.

U některých typů entit je `id` vytvořeno z id dvou jiných entit; to je možné pomocí `concat`, např. `let id = left.id.concat(right.id)` pro vytvoření id z id `left` a `right`. Podobně lze použít `let id = left.id.concatI32(count)` pro vytvoření id z id existující entity a čítače `count`. Konkatenace zaručeně vytvoří jedinečné id, pokud je délka `left` pro všechny takové entity stejná, například proto, že `left.id` je `Adresa`.

### Vestavěné typy skalárů

#### Podporované skaláry GraphQL

V našem GraphQL API podporujeme následující skaláry:

| Typ | Popis |
| --- | --- |
| `Bajtů` | Pole bajtů reprezentované jako hexadecimální řetězec. Běžně se používá pro hashe a adresy Ethereum. |
| `Řetězec` | Skalár pro hodnoty `řetězce`. Nulové znaky nejsou podporovány a jsou automaticky odstraněny. |
| `Boolean` | Skalár pro hodnoty `boolean`. |
| `Int` | Specifikace GraphQL definuje `Int` na velikost 32 bajtů. |
| `Int8` | Celé číslo se znaménkem o velikosti 8 bajtů, známé také jako 64bitové celé číslo se znaménkem, může uchovávat hodnoty v rozsahu od -9 223 372 036 854 775 808 do 9 223 372 036 854 775 807. Přednostně se používá k reprezentaci `i64` z ethereum. |
| `BigInt` | Velká celá čísla. Používá se pro typy `uint32`, `int64`, `uint64`, ..., `uint256` společnosti Ethereum. Poznámka: Vše pod `uint32`, jako například `int32`, `uint24` nebo `int8`, je reprezentováno jako `i32`. |
| `BigDecimal` | `BigDecimal` Desetinná čísla s vysokou přesností reprezentovaná jako signifikand a exponent. Rozsah exponentu je od -6143 do +6144. Zaokrouhleno na 34 významných číslic. |

#### Enums

Výčty můžete vytvářet také v rámci schématu. Syntaxe enumů je následující:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Jakmile je enum definován ve schématu, můžete použít řetězcovou reprezentaci hodnoty výčtu k nastavení pole výčtu u entity. Například můžete nastavit `tokenStatus` na `SecondOwner` tak, že nejprve definujete svou entitu a následně nastavíte pole pomocí `entity.tokenStatus = "SecondOwner"`. Níže uvedený příklad ukazuje, jak by vypadala entita Token s výčtovým polem:

Podrobnější informace o zápisu enum najdete v dokumentaci [GraphQL](https://graphql.org/learn/schema/).

#### Vztahy entit

Entita může mít vztah k jedné nebo více jiným entitám ve vašem schématu. Tyto vztahy lze procházet v dotazech. Vztahy v Graf jsou jednosměrné. Obousměrné vztahy je možné simulovat definováním jednosměrného vztahu na obou "koncích" vztahu.

Vztahy se definují u entit stejně jako u jiných polí s tím rozdílem, že zadaný typ je typ jiné entity.

#### Vztahy jeden na jednoho

Definujte typ entity `Transaction` s volitelným vztahem jedna ku jedné s typemem entity `TransactionReceipt`:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### Vztahy jeden k mnoha

Definujte typ entity `TokenBalance` s požadovaným vztahem one-to-many s typem entity Token:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Zpětné vyhledávání

Reverzní vyhledávání lze u entity definovat prostřednictvím pole `@derivedFrom`. Tím se na entitě vytvoří virtuální pole, na které se lze dotazovat, ale které nelze nastavit ručně prostřednictvím API mapování. Spíše je odvozeno ze vztahu definovaného na jiné entitě. U takových vztahů má zřídkakdy smysl ukládat obě strany vztahu a indexace i výkonnost dotazů budou lepší, když bude uložena pouze jedna strana a druhá bude odvozená.

U vztahů typu "jeden k mnoha" by měl být vztah vždy uložen na straně "jeden" a strana "mnoho" by měla být vždy odvozena. Uložení vztahu tímto způsobem namísto uložení pole entit na straně "mnoho" povede k výrazně lepšímu výkonu jak při indexování, tak při dotazování na podgraf. Obecně platí, že ukládání polí entit je třeba se vyhnout, pokud je to praktické.

#### Příklad

Zůstatky token můžeme zpřístupnit z token odvozením pole `tokenBalances`:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### Vztahy mnoho k mnoha

Pro vztahy mnoho-více, jako jsou uživatelé, z nichž každý může patřit do libovolného počtu organizací, je nejjednodušší, ale obecně ne nejvýkonnější, modelovat vztah jako pole v každé z obou zúčastněných entit. Pokud je vztah symetrický, je třeba uložit pouze jednu stranu vztahu a druhou stranu lze odvodit.

#### Příklad

Definujte zpětné vyhledávání z typu entity `User` na typ entity `Organization`. V příkladu níže je toho dosaženo vyhledáním atributu `members` z entity `Organization`. V dotazech bude pole `organizations` na `User` vyřešeno vyhledáním všech entit `Organization`, které obsahují ID uživatele.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Výkonnějším způsobem uložení tohoto vztahu je mapovací tabulka, která má pro každou dvojici `Uživatel` / `Organizace` jeden záznam se schématem, jako je např

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

Tento přístup vyžaduje, aby dotazy sestupovaly do další úrovně, aby bylo možné získat například organizace pro uživatele:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

Tento propracovanější způsob ukládání vztahů mnoho-více vede k menšímu množství dat uložených pro podgraf, a tedy k podgrafu, který je často výrazně rychlejší při indexování a dotazování.

#### Přidání komentářů do schématu

Podle specifikace GraphQL lze komentáře přidávat nad atributy entit schématu pomocí dvojitých uvozovek `""`. To je znázorněno v příkladu níže:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## Definování polí fulltextového vyhledávání

Fulltextové vyhledávací dotazy filtrují a řadí entity na základě textového vyhledávacího vstupu. Fulltextové dotazy jsou schopny vracet shody podobných slov tím, že zpracovávají vstupní text dotazu do kmenů před jejich porovnáním s indexovanými textovými daty.

Definice fulltextového dotazu obsahuje název dotazu, jazykový slovník použitý ke zpracování textových polí, algoritmus řazení použitý k seřazení výsledků a pole zahrnutá do vyhledávání. Každý fulltextový dotaz může zahrnovat více polí, ale všechna zahrnutá pole musí být z jednoho typu entity.

Chcete-li přidat fulltextový dotaz, zahrňte do schématu GraphQL typ `_Schema_` s direktivou fulltext.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

Příklad pole `bandSearch` lze použít v dotazech k filtrování entit `Band` na základě textových dokumentů v polích `name`, `description` a `bio`. Přejděte na [GraphQL API - dotazy](/querying/graphql-api#queries), kde najdete popis API pro fulltextové vyhledávání a další příklady použití.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Správa funkcí](#experimental-features):** Od `specVersion` `0.0.4` musí být `fullTextSearch` deklarováno v sekci `features` v manifestu podgrafů.

### Podporované jazyky

Výběr jiného jazyka bude mít na rozhraní API fulltextového vyhledávání rozhodující, i když někdy nenápadný vliv. Pole zahrnutá do pole fulltextového dotazu jsou zkoumána v kontextu zvoleného jazyka, takže lexémy vytvořené analýzou a vyhledávacími dotazy se v jednotlivých jazycích liší. Například: při použití podporovaného tureckého slovníku je "token" odvozeno od "toke", zatímco anglický slovník jej samozřejmě odvozuje od "token".

Podporované jazykové slovníky:

| Kód        | Slovník    |
| ---------- | ---------- |
| jednoduchý | Obecné     |
| da         | Danish     |
| nl         | Dutch      |
| en         | English    |
| fi         | Finnish    |
| fr         | French     |
| de         | German     |
| hu         | Hungarian  |
| it         | Italian    |
| no         | Norwegian  |
| pt         | Portuguese |
| ro         | Romanian   |
| ru         | Russian    |
| es         | Spanish    |
| sv         | Swedish    |
| tr         | Turkish    |

### Algoritmy řazení

Podporované algoritmy pro řazení výsledků:

| Algoritmus    | Popis                                                                    |
| ------------- | ------------------------------------------------------------------------ |
| hodnost       | Pro seřazení výsledků použijte kvalitu shody (0-1) fulltextového dotazu. |
| proximityRank | Podobně jako pořadí, ale zahrnuje také blízkost zápasů.                  |

## Psát mapování

Mapování přebírá data z určitého zdroje a transformuje je na entity definované ve vašem schématu. Mapování jsou zapsána v podmnožině jazyka [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) nazvané [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki), kterou lze zkompilovat do jazyka WASM ([WebAssembly](https://webassembly.org/)). AssemblyScript je přísnější než běžný TypeScript, přesto poskytuje známou syntaxi.

Pro každou obsluhu události definovanou v souboru `subgraph.yaml` v části `mapping.eventHandlers` vytvořte exportovanou funkci stejného jména. Každá obslužná funkce musí přijímat jeden parametr nazvaný `událost` s typem odpovídajícím názvu události, která je obsluhována.

V příkladovém podgrafu `src/mapping.ts` obsahuje obsluhy událostí `NewGravatar` a `UpdatedGravatar`:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

První obslužný program přijme událost `NewGravatar` a vytvoří novou entitu `Gravatar` s `new Gravatar(event.params.id.toHex())`, přičemž pole entity vyplní pomocí odpovídajících parametrů události. Tato instance entity je reprezentována proměnnou `gravatar` s hodnotou id `event.params.id.toHex()`.

Druhá obslužná rutina se pokusí načíst existující `Gravatar` z úložiště Graf Uzel. Pokud ještě neexistuje, je vytvořen na vyžádání. Entita je poté aktualizována tak, aby odpovídala novým parametrům události, a poté je uložena zpět do úložiště pomocí `gravatar.save()`.

### Doporučené IDa pro vytváření nových Entity

Každá entita musí mít `id`, které je jedinečné mezi všemi entitami stejného typu. Hodnota `id` entity je nastavena při jejím vytvoření. Níže jsou uvedeny některé doporučené hodnoty `id`, které je třeba vzít v úvahu při vytváření nových entit. POZNÁMKA: Hodnota `id` musí být `řetězec`.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

Poskytujeme knihovnu [Graf Typescript Library](https://github.com/graphprotocol/graph-ts), která obsahuje nástroje pro interakci s úložištěm Graf Uzel a usnadnění pro práci s daty a entitami chytrých smluv. Tuto knihovnu můžete používat ve svých mapováních importem `@graphprotocol/graph-ts` v souboru `mapping.ts`.

## Generování kódu

Aby byla práce s inteligentními smlouvami, událostmi a entitami snadná a typově bezpečná, může Graf CLI generovat typy AssemblyScript ze schématu GraphQL podgrafu a ABI smluv obsažených ve zdrojích dat.

To se provádí pomocí

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

ale ve většině případů jsou podgrafy již předkonfigurovány prostřednictvím souboru `package.json`, takže pro dosažení téhož stačí spustit jeden z následujících příkazů:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

Tím se vygeneruje třída AssemblyScript pro každou chytrou smlouvu v souborech ABI uvedených v `subgraph.yaml`, což vám umožní svázat tyto smlouvy s konkrétními adresami v mapování a volat metody smlouvy pouze pro čtení proti zpracovávanému bloku. Pro každou událost kontraktu také vygeneruje třídu, která umožní snadný přístup k parametrům události a také k bloku a transakci, ze které událost pochází. Všechny tyto typy se zapisují do souboru `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts`. V příkladovém podgrafu by to bylo `generated/Gravity/Gravity.ts`, což umožňuje mapování, kterým lze tyto typy importovat.

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

Kromě toho je pro každý typ entity ve schématu GraphQL podgrafu vygenerována jedna třída. Tyto třídy zajišťují typově bezpečné načítání entit, přístup k polím entit pro čtení a zápis a také metodu `save()` pro zápis entit do úložiště. Všechny třídy entit jsou zapsány do souboru `<OUTPUT_DIR>/schema.ts`, což umožňuje mapování importovat je pomocí funkce

```javascript
import { Gravatar } from '../generated/schema'
```

> **Poznámka:** Po každé změně schématu jazyka GraphQL nebo ABI obsažených v manifestu je nutné provést generování kódu znovu. Musí být také provedeno alespoň jednou před sestavením nebo nasazením podgrafu.

Generování kódu nekontroluje váš mapovací kód v souboru `src/mapping.ts`. Pokud jej chcete zkontrolovat před pokusem o nasazení podgrafu do Graf Explorer, můžete spustit `yarn build` a opravit případné syntaktické chyby, které by kompilátor jazyka TypeScript mohl najít.

## Šablony zdrojů dat

Běžným vzorem v inteligentních smlouvách kompatibilních s EVM je používání registrů nebo továrních smluv, kdy jedna smlouva vytváří, spravuje nebo odkazuje na libovolný počet dalších smluv, z nichž každá má svůj vlastní stav a události.

Adresy těchto dílčích smluv mohou, ale nemusí být známy předem a mnoho z těchto smluv může být vytvořeno a/nebo přidáno v průběhu času. Proto v takových případech není možné definovat jediný zdroj dat nebo pevný počet zdrojů dat a je zapotřebí dynamičtější přístup: _šablony zdrojů dat_.

### Zdroj dat pro hlavní smlouvu

Nejprve definujete běžný zdroj dat pro hlavní smlouvu. Níže uvedený úryvek ukazuje zjednodušený příklad zdroje dat pro smlouvu [Uniswap](https://uniswap.org) exchange factory. Všimněte si obsluhy události `NewExchange(address,address)`. Ta je emitována, když je v řetězci vytvořena nová směnná smlouva tovární smlouvou.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Šablony zdrojů dat pro dynamicky vytvářené smlouvy

Poté do manifestu přidáte _šablony datových zdrojů_. Ty jsou totožné s běžnými zdroji dat, pouze postrádají předdefinovanou adresu smlouvy v položce `zdroj`. Obvykle byste definovali jednu šablonu pro každý typ dílčí smlouvy spravované nebo odkazované nadřazenou smlouvou.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Instancování šablony zdroje dat

V posledním kroku aktualizujete mapování hlavní smlouvy a vytvoříte dynamickou instanci zdroje dat z jedné ze šablon. V tomto příkladu byste změnili mapování hlavní smlouvy tak, abyste importovali šablonu `Exchange` a zavolali na ní metodu `Exchange.create(address)`, abyste zahájili indexování nové smlouvy exchange.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **Poznámka:** Nový zdroj dat bude zpracovávat pouze volání a události pro blok, ve kterém byl vytvořen, a všechny následující bloky, ale nebude zpracovávat historická data, tj. data obsažená v předchozích blocích.
>
> Pokud předchozí bloky obsahují data relevantní pro nový zdroj dat, je nejlepší tato data indexovat načtením aktuálního stavu smlouvy a vytvořením entit reprezentujících tento stav v době vytvoření nového zdroje dat.

### Kontext zdroje dat

Kontexty zdrojů dat umožňují předávat další konfiguraci při instanci šablony. V našem příkladu řekněme, že burzy jsou spojeny s konkrétním obchodním párem, který je obsažen v události `NewExchange`. Tuto informaci lze předat do instancovaného zdroje dat takto:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Uvnitř mapování šablony `výměna` lze pak přistupovat ke kontextu:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Pro všechny typy hodnot existují setter a getter jako `setString` a `getString`.

## Výchozí bloky

`startBlock` je volitelné nastavení, které umožňuje určit, od kterého bloku v řetězci začne zdroj dat indexovat. Nastavení počátečního bloku umožňuje zdroji dat přeskočit potenciálně miliony bloků, které jsou irelevantní. Typicky vývojář podgrafu nastaví `startBlock` na blok, ve kterém byl vytvořen inteligentní kontrakt zdroje dat.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Poznámka:** Blok pro vytvoření smlouvy lze rychle vyhledat v Etherscan:
>
> 1. Vyhledejte smlouvu zadáním její adresy do vyhledávacího řádku.
> 2. Klikněte na hash transakce vytvoření v sekci `Tvůrce smlouvy`.
> 3. Načtěte stránku s podrobnostmi o transakci, kde najdete počáteční blok pro danou smlouvu.

## Zpracovatelé hovorů

Události sice představují účinný způsob, jak shromažďovat relevantní změny stavu smlouvy, ale mnoho smluv se vyhýbá generování protokolů, aby se optimalizovaly náklady na plyn. V těchto případech se dílčí graf může přihlásit k odběru volání provedených na smlouvu se zdrojem dat. Toho lze dosáhnout definováním obsluhy volání odkazující na signaturu funkce a obsluhu mapování, která bude zpracovávat volání této funkce. Pro zpracování těchto volání obdrží mapovací obsluha jako argument `ethereum.Call` s typizovanými vstupy do volání a výstupy z volání. Volání uskutečněná v libovolné hloubce řetězce volání transakce spustí mapování, což umožní zachytit aktivitu se smlouvou zdroje dat prostřednictvím proxy smluv.

Obsluhy volání se spustí pouze v jednom ze dvou případů: když je zadaná funkce volána jiným účtem než samotnou smlouvou nebo když je v Solidity označena jako externí a volána jako součást jiné funkce ve stejné smlouvě.

> **Poznámka:** Zpracovatelé volání jsou v současné době závislí na API pro sledování parity. Některé sítě, například řetězec BNB a Arbitrum, toto API nepodporují. Pokud podgraf indexující některou z těchto sítí obsahuje jeden nebo více zpracovatelů volání, nezačne se synchronizovat. Vývojáři podgrafů by místo toho měli používat obsluhy událostí. Ty jsou mnohem výkonnější než obsluhy volání a jsou podporovány v každé síti evm.

### Definice obsluhy volání

Chcete-li v manifestu definovat obsluhu volání, jednoduše přidejte pole `callHandlers` pod zdroj dat, ke kterému se chcete přihlásit.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`funkce` je normalizovaná signatura funkce, podle které se filtrují volání. Vlastnost `handler` je název funkce ve vašem mapování, kterou chcete spustit při volání cílové funkce v kontraktu zdroje dat.

### Funkce mapování

Každá obslužná funkce volání přijímá jeden parametr, který má typ odpovídající názvu volané funkce. Ve výše uvedeném příkladu podgraf obsahuje mapování obslužnou rutinu pro případ, kdy je volána funkce `createGravatar` a jako argument přijímá parametr `CreateGravatarCall`:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

Funkce `handleCreateGravatar` přebírá novou `CreateGravatarCall`, což je podtřída `ethereum.Call`, kterou poskytuje `@graphprotocol/graph-ts`, která obsahuje typizované vstupy a výstupy volání. Typ `CreateGravatarCall` je pro vás vygenerován při spuštění `graph codegen`.

## Obsluha bloků

Kromě přihlášení k událostem smlouvy nebo volání funkcí může podgraf chtít aktualizovat svá data, když jsou do řetězce přidány nové bloky. Za tímto účelem může podgraf spustit funkci po každém bloku nebo po blocích, které odpovídají předem definovanému filtru.

### Podporované filtry

#### Filtr volání

```yaml
filter:
  kind: call
```

_Definovat obslužná rutina bude zavolána jednou pro každý blok, který obsahuje volání smlouvy (zdroje dat), pod kterou je rutina definovát._

> **Poznámka:** Filtr `call` v současné době závisí na API pro sledování parity. Některé sítě, například řetězec BNB a Arbitrum, toto API nepodporují. Pokud podgraf indexující jednu z těchto sítí obsahuje jeden nebo více blokových manipulátorů s filtrem `call`, nezačne se synchronizovat.

Protože pro obsluhu bloku neexistuje žádný filtr, zajistí, že obsluha bude volána každý blok. Zdroj dat může obsahovat pouze jednu blokovou obsluhu pro každý typ filtru.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

#### Filtr dotazování

> **Vyžaduje `specVersion`&#062 >= 0.0.8**

> **Poznámka:** Filtry zdroj dat jsou k dispozici pouze pro zdroje dat `druhu: ethereum`.

```yaml
blockHandlers:
  - handler: handleBlock
    filter:
      kind: polling
      every: 10
```

Definovaný obslužná rutina bude zavolána jednou pro každých `n` bloků, kde `n` je hodnota uvedená v poli `every`. Tato konfigurace umožňuje dílčímu graf provádět specifické operace v pravidelných intervalech bloků.

#### Jednou Filtr

> **Vyžaduje `specVersion`&#062 >= 0.0.8**

> **Poznámka:** Jednou použité filtry jsou dostupné pouze pro zdroje dat `druhu: ethereum`.

```yaml
blockHandlers:
  - handler: handleOnce
    filter:
      kind: once
```

Definovaný obslužná rutina s filtrem once bude zavolána pouze jednou před spuštěním všech ostatních rutin. Tato konfigurace umožňuje, aby podgraf používal obslužný program jako inicializační obslužný, který provádí specifické úlohy na začátku indexování.

```ts
export function handleOnce(block: ethereum.Block): void {
  let data = new InitialData(Bytes.fromUTF8('initial'))
  data.data = 'Setup data here'
  data.save()
}
```

### Funkce mapování

Funkce mapování obdrží jako jediný argument `ethereum.Block`. Stejně jako mapovací funkce pro události může tato funkce přistupovat k existujícím entitám subgrafu v úložišti, volat chytré kontrakty a vytvářet nebo aktualizovat entity.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## Anonymní události

Pokud potřebujete v Solidity zpracovávat anonymní události, lze toho dosáhnout zadáním tématu 0 události, jak je uvedeno v příkladu:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

Událost se spustí pouze tehdy, když se shoduje signatura i téma 0. Ve výchozím nastavení se `téma0` rovná hash signatury události.

## Potvrzení transakcí v obslužných rutinách událostí

Počínaje `specVersion` `0.0.5` a `apiVersion` `0.0.7` mohou mít obsluhy událostí přístup k potvrzení transakce, která je vyvolala.

Za tímto účelem musí být obsluhy událostí deklarovány v manifestu podgrafů pomocí nového klíče `receipt: true`, který je nepovinný a výchozí hodnota je není pravda.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

Uvnitř obslužné funkce je příjem přístupný v poli `Event.receipt`. Pokud je klíč `receipt` nastaven na `false` nebo je v manifestu vynechán, bude místo něj vrácena hodnota `null`.

## Experimentální funkce

Starting from `specVersion` `0.0.4`, subgraph features must be explicitly declared in the `features` section at the top level of the manifest file, using their `camelCase` name, as listed in the table below:

| Feature                                                   | Name                                                |
| --------------------------------------------------------- | --------------------------------------------------- |
| [Nefatální](#non-fatal-errors)                            | `nonFatalErrors`                                    |
| [Full-text Search](#defining-fulltext-search-fields)      | `fullTextSearch`                                    |
| [Roubování](#grafting-onto-existing-subgraphs)            | `grafting`                                          |
| [IPFS on Ethereum Contracts](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` or `nonDeterministicIpfs` |

For instance, if a subgraph uses the **Full-Text Search** and the **Non-fatal Errors** features, the `features` field in the manifest should be:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Note that using a feature without declaring it will incur a **validation error** during subgraph deployment, but no errors will occur if a feature is declared but not used.

### IPFS on Ethereum Contracts

A common use case for combining IPFS with Ethereum is to store data on IPFS that would be too expensive to maintain on-chain, and reference the IPFS hash in Ethereum contracts.

Given such IPFS hashes, subgraphs can read the corresponding files from IPFS using `ipfs.cat` and `ipfs.map`. To do this reliably, it is required that these files are pinned to an IPFS node with high availability, so that the [hosted service](https://thegraph.com/hosted-service) IPFS node can find them during indexing.

> **Note:** The Graph Network does not yet support `ipfs.cat` and `ipfs.map`, and developers should not deploy subgraphs using that functionality to the network via the Studio.

> **[Feature Management](#experimental-features):** `ipfsOnEthereumContracts` must be declared under `features` in the subgraph manifest. For non EVM chains, the `nonDeterministicIpfs` alias can also be used for the same purpose.

When running a local Graph Node, the `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` environment variable must be set in order to index subgraphs using this experimental functionality.

### Nefatální

Indexing errors on already synced subgraphs will, by default, cause the subgraph to fail and stop syncing. Subgraphs can alternatively be configured to continue syncing in the presence of errors, by ignoring the changes made by the handler which provoked the error. This gives subgraph authors time to correct their subgraphs while queries continue to be served against the latest block, though the results might be inconsistent due to the bug that caused the error. Note that some errors are still always fatal. To be non-fatal, the error must be known to be deterministic.

> **Note:** The Graph Network does not yet support non-fatal errors, and developers should not deploy subgraphs using that functionality to the network via the Studio.

Enabling non-fatal errors requires setting the following feature flag on the subgraph manifest:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

The query must also opt-in to querying data with potential inconsistencies through the `subgraphError` argument. It is also recommended to query `_meta` to check if the subgraph has skipped over errors, as in the example:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

If the subgraph encounters an error, that query will return both the data and a graphql error with the message `"indexing_error"`, as in this example response:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Grafting onto Existing Subgraphs

> **Note:** it is not recommended to use grafting when initially upgrading to The Graph Network. Learn more [here](/cookbook/grafting/#important-note-on-grafting-when-upgrading-to-the-network).

When a subgraph is first deployed, it starts indexing events at the genesis block of the corresponding chain (or at the `startBlock` defined with each data source) In some circumstances; it is beneficial to reuse the data from an existing subgraph and start indexing at a much later block. This mode of indexing is called _Grafting_. Grafting is, for example, useful during development to get past simple errors in the mappings quickly or to temporarily get an existing subgraph working again after it has failed.

A subgraph is grafted onto a base subgraph when the subgraph manifest in `subgraph.yaml` contains a `graft` block at the top-level:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

When a subgraph whose manifest contains a `graft` block is deployed, Graph Node will copy the data of the `base` subgraph up to and including the given `block` and then continue indexing the new subgraph from that block on. The base subgraph must exist on the target Graph Node instance and must have indexed up to at least the given block. Because of this restriction, grafting should only be used during development or during an emergency to speed up producing an equivalent non-grafted subgraph.

Because grafting copies rather than indexes base data, it is much quicker to get the subgraph to the desired block than indexing from scratch, though the initial data copy can still take several hours for very large subgraphs. While the grafted subgraph is being initialized, the Graph Node will log information about the entity types that have already been copied.

The grafted subgraph can use a GraphQL schema that is not identical to the one of the base subgraph, but merely compatible with it. It has to be a valid subgraph schema in its own right, but may deviate from the base subgraph's schema in the following ways:

- It adds or removes entity types
- It removes attributes from entity types
- It adds nullable attributes to entity types
- It turns non-nullable attributes into nullable attributes
- It adds values to enums
- It adds or removes interfaces
- It changes for which entity types an interface is implemented

> **[Feature Management](#experimental-features):** `grafting` must be declared under `features` in the subgraph manifest.

## File Data Sources

File data sources are a new subgraph functionality for accessing off-chain data during indexing in a robust, extendable way. File data sources support fetching files from IPFS and from Arweave.

> This also lays the groundwork for deterministic indexing of off-chain data, as well as the potential introduction of arbitrary HTTP-sourced data.

### Přehled

Rather than fetching files "in line" during handler exectuion, this introduces templates which can be spawned as new data sources for a given file identifier. These new data sources fetch the files, retrying if they are unsuccessful, running a dedicated handler when the file is found.

This is similar to the [existing data source templates](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates), which are used to dynamically create new chain-based data sources.

> This replaces the existing `ipfs.cat` API

### Upgrade guide

#### Update `graph-ts` and `graph-cli`

File data sources requires graph-ts >=0.29.0 and graph-cli >=0.33.1

#### Add a new entity type which will be updated when files are found

File data sources cannot access or update chain-based entities, but must update file specific entities.

This may mean splitting out fields from existing entities into separate entities, linked together.

Original combined entity:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

New, split entity:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

If the relationship is 1:1 between the parent entity and the resulting file data source entity, the simplest pattern is to link the parent entity to a resulting file entity by using the IPFS CID as the lookup. Get in touch on Discord if you are having difficulty modelling your new file-based entities!

> You can use [nested filters](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) to filter parent entities on the basis of these nested entities.

#### Add a new templated data source with `kind: file/ipfs` or `kind: file/arweave`

This is the data source which will be spawned when a file of interest is identified.

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> Currently `abis` are required, though it is not possible to call contracts from within file data sources

The file data source must specifically mention all the entity types which it will interact with under `entities`. See [limitations](#Limitations) for more details.

#### Create a new handler to process files

This handler should accept one `Bytes` parameter, which will be the contents of the file, when it is found, which can then be processed. This will often be a JSON file, which can be processed with `graph-ts` helpers ([documentation](https://thegraph.com/docs/en/developing/assemblyscript-api/#json-api)).

The CID of the file as a readable string can be accessed via the `dataSource` as follows:

```typescript
const cid = dataSource.stringParam()
```

Example handler:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### Spawn file data sources when required

You can now create file data sources during execution of chain-based handlers:

- Import the template from the auto-generated `templates`
- call `TemplateName.create(cid: string)` from within a mapping, where the cid is a valid content identifier for IPFS or Arweave

For IPFS, Graph Node supports [v0 and v1 content identifiers](https://docs.ipfs.tech/concepts/content-addressing/), and content identifers with directories (e.g. `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`).

For Arweave, as of version 0.33.0 Graph Node can fetch files stored on Arweave based on their [transaction ID](https://docs.arweave.org/developers/server/http-api#transactions) from an Arweave gateway ([example file](https://bdxujjl5ev5eerd5ouhhs6o4kjrs4g6hqstzlci5pf6vhxezkgaa.arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA)). Arweave supports transactions uploaded via Bundlr, and Graph Node can also fetch files based on [Bundlr manifests](https://docs.bundlr.network/learn/gateways#indexing).

Příklad:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//This example code is for a Crypto coven subgraph. The above ipfs hash is a directory with token metadata for all crypto coven NFTs.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //This creates a path to the metadata for a single Crypto coven NFT. It concats the directory with "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

This will create a new file data source, which will poll Graph Node's configured IPFS or Arweave endpoint, retrying if it is not found. When the file is found, the file data source handler will be executed.

This example is using the CID as the lookup between the parent `Token` entity and the resulting `TokenMetadata` entity.

> Previously, this is the point at which a subgraph developer would have called `ipfs.cat(CID)` to fetch the file

Congratulations, you are using file data sources!

#### Deploying your subgraphs

You can now `build` and `deploy` your subgraph to any Graph Node >=v0.30.0-rc.0.

#### Limitations

File data source handlers and entities are isolated from other subgraph entities, ensuring that they are deterministic when executed, and ensuring no contamination of chain-based data sources. To be specific:

- Entities created by File Data Sources are immutable, and cannot be updated
- File Data Source handlers cannot access entities from other file data sources
- Entities associated with File Data Sources cannot be accessed by chain-based handlers

> While this constraint should not be problematic for most use-cases, it may introduce complexity for some. Please get in touch via Discord if you are having issues modelling your file-based data in a subgraph!

Additionally, it is not possible to create data sources from a file data source, be it an onchain data source or another file data source. This restriction may be lifted in the future.

#### Best practices

If you are linking NFT metadata to corresponding tokens, use the metadata's IPFS hash to reference a Metadata entity from the Token entity. Save the Metadata entity using the IPFS hash as an ID.

You can use [DataSource context](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) when creating File Data Sources to pass extra information which will be available to the File Data Source handler.

If you have entities which are refreshed multiple times, create unique file-based entities using the IPFS hash & the entity ID, and reference them using a derived field in the chain-based entity.

> We are working to improve the above recommendation, so queries only return the "most recent" version

#### Known issues

File data sources currently require ABIs, even though ABIs are not used ([issue](https://github.com/graphprotocol/graph-cli/issues/961)). Workaround is to add any ABI.

Handlers for File Data Sources cannot be in files which import `eth_call` contract bindings, failing with "unknown import: `ethereum::ethereum.call` has not been defined" ([issue](https://github.com/graphprotocol/graph-cli/issues/4309)). Workaround is to create file data source handlers in a dedicated file.

#### Examples

[Crypto Coven Subgraph migration](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### Odkazy:

[GIP File Data Sources](https://forum.thegraph.com/t/gip-file-data-sources/2721)
