---
title: AssemblyScript API
---

> Poznámka: pokud jste vytvořili subgraf před verzí `graph-cli`/`graph-ts` `0.22.0`, používáte starší verzi jazyka AssemblyScript, doporučujeme se podívat do [`Migration Guide`](/release-notes/assemblyscript-migration-guide)

Tato stránka dokumentuje, jaké vestavěné API lze použít při psaní mapování podgrafů. Dva druhy API jsou k dispozici hned po vybalení:

- [Graph TypeScript library](https://github.com/graphprotocol/graph-ts) (`graph-ts`) a
- kód generovaný ze souborů podgrafů pomocí `graph codegen`.

Jako závislosti je možné přidat i další knihovny, pokud jsou kompatibilní s [AssemblyScript](https://github.com/AssemblyScript/assemblyscript). Vzhledem k tomu, že mapování je psáno v tomto jazyce, je [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki) dobrým zdrojem informací o funkcích jazyka a standardních knihoven.

## Reference API

Knihovna `@graphprotocol/graph-ts` poskytuje následující API:

- API `ethereum` pro práci s inteligentními kontrakty Ethereum, událostmi, bloky, transakcemi a hodnotami Ethereum.
- API `store` pro načítání a ukládání entit z a do úložiště Graf uzel.
- API `log` pro protokolování zpráv na výstupu uzlu Graph a v Průzkumníku grafu.
- API `ipfs` pro načítání souborů ze IPFS.
- API `json` pro rozbor dat JSON.
- API `crypto` pro použití kryptografických funkcí.
- Nízkoúrovňové primitivy pro překlad mezi různými typovými systémy, jako je Ethereum, JSON, GraphQL a AssemblyScript.

### Verze

`apiVersion` v manifestu podgrafu určuje verzi mapovacího API, kterou pro daný podgraf používá uzel Graf.

| Verze | Poznámky vydání |
| :-: | --- |
| 0.0.7 | Přidání tříd `TransactionReceipt` a `Log` do typů Ethereum\<0/Přidání pole `receipt` do objektu Ethereum událost |
| 0.0.6 | Přidáno pole `nonce` do objektu Ethereum Transaction<br />Přidáno `baseFeePerGas` do objektu Ethereum bloku |
| 0.0.5 | AssemblyScript povýšen na verzi 0.19.10 (obsahuje rozbíjející změny, viz [`Migration Guide`](/release-notes/assemblyscript-migration-guide))<br />`ethereum.transaction.gasUsed` přejmenováno na `ethereum.transaction.gasLimit` |
| 0.0.4 | Přidání pole `functionSignature` do objektu Ethereum SmartContractCall |
| 0.0.3 | Do objektu Ethereum Call přidáno pole `from`<br />`etherem.call.address` přejmenováno na `ethereum.call.to` |
| 0.0.2 | Přidání pole `input` do objektu Ethereum Transackce |

### Vestavěné typy

Dokumentaci k základním typům zabudovaným do jazyka AssemblyScript najdete na [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types).

Následující doplňkové typy poskytuje `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` představuje pole `u8`.

_Construction_

- `fromI32(x: i32): ByteArray` - Rozebrat `x` na bajty.
- `fromHexString(hex: string): - Vstupní délka musí být sudá. Předpona `0x\` je nepovinná.

_Type conversions_

- `toHexString(): string` - Převede na hexadecimální řetězec s předponou `0x`.
- `toString(): string` - čte bajty jako řetězec UTF-8.
- `toBase58(): string` - Zakóduje bajty do řetězce base58.
- `toU32(): u32` - Interpretuje bajty jako little-endian `u32`. Hodí v případě přetečení.
- `toI32(): i32` - Interpretuje pole bajtů jako little-endian `i32`. V případě přetečení hází.

_Operators_

- `equals(y: ByteArray): bool` – lze zapsat jako`x == y`.
- `concat(other: ByteArray) : ByteArray` - vrátí nové `ByteArray` složené z `this` přímo následované `other`
- `concatI32(other: i32) : ByteArray` - vrátí nové `ByteArray` složené z `this` přímo následované bytovou reprezentací `other`

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

\`BigDecimal se používá k reprezentaci libovolně přesných desetinných míst.

> Poznámka: [Interně](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal` je uložen ve formátu [IEEE-754 decimal128 s plovoucí desetinnou čárkou](https://en.wikipedia.org/wiki/Decimal128_floating-point_format), který podporuje 34 desetinných číslic significand. Proto je `BigDecimal` nevhodný pro reprezentaci typů s pevnou desetinnou čárkou, které mohou mít větší rozsah než 34 číslic, jako je například Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) nebo ekvivalent.

_Construction_

- `constructor(bigInt: BigInt)` - vytvoří `BigDecimal` z `BigInt`.
- `static fromString(s: string): BigDecimal` – parses from a decimal string.

_Type conversions_

- `toString(): string` - vypisuje do desetinného řetězce.

_Math_

- `plus(y: BigDecimal): BigDecimal` – lze zapsat jako `x + y`.
- `minus(y: BigDecimal): BigDecimal` – lze zapsat jako `x - y`.
- `times(y: BigDecimal): BigDecimal` – lze zapsat jako `x * y`.
- `div(y: BigDecimal): BigDecimal` – lze zapsat jako`x / y`.
- `equals(y: BigDecimal): bool` – lze zapsat jako`x == y`.
- `notEqual(y: BigDecimal): bool` – can be written as `x != y`.
- `lt(y: BigDecimal): bool` – lze zapsat jako`x < y`.
- `le(y: BigDecimal): bool` – lze zapsat jako `x <= y`.
- `gt(y: BigDecimal): bool` – lze zapsat jako `x > y`.
- `ge(y: BigDecimal): bool` – lze zapsat jako `x >= y`.
- `neg(): BigDecimal - lze zapsat jako -x`.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` se používá k reprezentaci velkých celých čísel. Patří sem hodnoty Etherea typu `uint32` až `uint256` a `int64` až `int256`. Vše pod `uint32`, jako například `uint32`, `uint24` nebo `uint8`, je reprezentováno jako `i32`.

Třída `BigInt` má následující API:

_Construction_

- `BigInt.fromI32(x: i32): BigInt` - vytvoří `BigInt` z `i32`.

- `BigInt.fromString(s: string): BigInt`- Zpracuje `BigInt` z řetězce.

- `BigInt.fromUnsignedBytes(x: Bytes): - Interpretuje `bytes`jako celé číslo bez znaménka, little-endian. Pokud je váš vstup big-endian, zavolejte nejprve`.reverse()\`.

- `BigInt.fromSignedBytes(x: Bytes): - Interpretuje `bytes`jako celé číslo se znaménkem, little-endian. Pokud je váš vstup big-endian, zavolejte nejprve`.reverse()\`.

  _Type conversions_

- `x.toHex(): string` - změní `BigInt` na řetězec hexadecimálních znaků.

- `x.toString(): string` - změní `BigInt` na řetězec desetinných čísel.

- `x.toI32(): i32` - vrátí `BigInt` jako `i32`; selže, pokud se hodnota nevejde do `i32`. Je dobré nejprve zkontrolovat `x.isI32()`.

- `x.toBigDecimal(): BigDecimal` - převede na desetinné číslo bez zlomkové části.

_Math_

- `x.plus(y: BigInt): BigInt` – lze zapsat jako `x + y`.
- `x.minus(y: BigInt): BigInt` – lze zapsat jako `x - y`.
- `x.times(y: BigInt): BigInt` – lze zapsat jako `x * y`.
- `x.div(y: BigInt): BigInt` – lze zapsat jako `x / y`.
- `x.mod(y: BigInt): BigInt` – lze zapsat jako `x % y`.
- `x.equals(y: BigInt): bool` – lze zapsat jako `x == y`.
- `x.notEqual(y: BigInt): bool` –lze zapsat jako `x != y`.
- `x.lt(y: BigInt): bool` – lze zapsat jako `x < y`.
- `x.le(y: BigInt): bool` – lze zapsat jako `x <= y`.
- `x.gt(y: BigInt): bool` – lze zapsat jako `x > y`.
- `x.ge(y: BigInt): bool` – lze zapsat jako `x >= y`.
- `x.neg(): BigInt` – lze zapsat jako `-x`.
- `x.divDecimal(y: BigDecimal): BigDecimal` – dělí desetinným číslem, čímž získá desetinný výsledek.
- `x.isZero(): bool` – Slouží ke kontrole, zda je číslo rovno nule.
- `x.isI32(): bool` – Zjistí, zda se číslo vejde do `i32`.
- `x.abs(): BigInt` – absolutní hodnota.
- `x.pow(exp: u8): BigInt` – umocňování.
- `bitOr(x: BigInt, y: BigInt): BigInt` – lze zapsat jako `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – lze zapsat jako `x & y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – lze zapsat jako `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – lze zapsat jako `x >> y`.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap` lze použít k ukládání dvojic klíč-hodnota. Viz [tento příklad](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

Třída `TypedMap` má následující API:

- `new TypedMap<K, V>()` – vytvoří prázdnou mapu s klíči typu `K` a hodnotami typu`V`
- `map.set(key: K, value: V): void` – nastaví hodnotu `key` na `value`
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – vrátí dvojici klíč-hodnota pro `key` nebo `null`, pokud `key` v mapě neexistuje
- `map.get(key: K): V | null` – vrací hodnotu pro `key` nebo `null`, pokud `key` v mapě neexistuje
- `map.isSet(key: K): bool` – vrací `true`, pokud `klíč` v mapě existuje, a `false`, pokud ne

#### Bajtů

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`Bytes` se používá k reprezentaci libovolně dlouhých polí bajtů. Patří sem hodnoty Ethereum typu `bytes`, `bytes32` atd.

Třída `Bytes` rozšiřuje třídu AssemblyScript [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) a podporuje všechny funkce třídy `Uint8Array` a navíc následující nové metody:

_Construction_

- `fromHexString(hex: string) : Bytes` - Převede řetězec `hex`, který se musí skládat ze sudého počtu hexadecimálních číslic, na `ByteArray`. Řetězec `hex` může volitelně začínat znakem `0x`
- `fromI32(i: i32) : Bytes` - Převod `i` na pole bajtů

_Type conversions_

- `b.toHex()` – vrací hexadecimální řetězec reprezentující bajty v poli
- `b.toString()` – převede bajty v poli na řetězec unicode znaků
- `b.toBase58()` –změní hodnotu Ethereum Bytes na kódování base58 (používá se pro IPFS hashe)

_Operators_

- `b.concat(other: Bytes) : Bytes` - - "Vrátit nový `Bytes` skládající se z `this`, který je přímo následován `other`."
- `b.concatI32(other: i32) : ByteArray` - vrátí nový `Bytes` složený z `this` přímo následovaný bajtovou reprezentací `other`

#### Adresa

```typescript
import { Address } from '@graphprotocol/graph-ts'
```

`Address` rozšiřuje `Bytes` pro reprezentaci hodnot `adresa` Ethereum.

Přidává následující metodu nad API `Bytes`:

- `Address.fromString(s: string): Address` - vytvoří `Address` z hexadecimálního řetězce
- `Address.fromBytes(b: Bytes): Adresa` - vytvoří `Adresu` z `b`, která musí být dlouhá přesně 20 bajtů. Předání hodnoty s menším nebo větším počtem bajtů bude mít za následek chybu

### API ukládat

```typescript
import { store } from '@graphprotocol/graph-ts'
```

API `store` umožňuje načítat, ukládat a odebírat entity z a do úložiště Graf uzel.

Entity zapsané do úložiště se mapují jedna ku jedné na typy `@entity` definované ve schématu GraphQL podgrafu. Pro pohodlnou práci s těmito entitami generuje příkaz `graph codegen`, který poskytuje [Graph CLI](https://github.com/graphprotocol/graph-cli), třídy entit, které jsou podtřídami vestavěného typu `Entity`, s gettery a settery vlastností pro pole ve schématu a také s metodami pro načítání a ukládání těchto entit.

#### Vytváření entity

Následuje běžný vzor pro vytváření entity z událostí Ethereum.

```typescript
// Importovat třídu události Transfer vygenerovanou z ERC20 ABI
import { Transfer as TransferEvent } z '../generated/ERC20/ERC20'

// Importovat typ entity Transfer vygenerovaný ze schématu GraphQL
import { Transfer } z '../generated/schema'

// Obsluha události Transfer
export function handleTransfer(event: TransferEvent): void {
  // Vytvoří entitu Transfer s použitím hashe transakce jako ID entity
  let id = event.transaction.hash
  let transfer = new Transfer(id)

  // Nastavte vlastnosti entity pomocí parametrů události
  transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Uložení entity do úložiště
  transfer.save()
}
```

Pokud se při zpracování řetězce vyskytne událost `Transfer`, je předána obsluze události `handleTransfer` pomocí vygenerovaného typu `Transfer` (zde alias `TransferEvent`, aby nedošlo ke konfliktu názvů s typem entity). Tento typ umožňuje přístup k datům, jako je nadřazená transakce události a její parametr.

Každá entita musí mít jedinečné ID, aby nedocházelo ke kolizím s jinými entitami. Je poměrně běžné, že parametry událostí obsahují jedinečný identifikátor, který lze použít. Poznámka: Použití hashe transakce jako ID předpokládá, že žádné jiné události ve stejné transakci nevytvářejí entity s tímto hashem jako ID.

#### Načítání entity z úložiště

Pokud již entita existuje, lze ji z úložiště načíst pomocí následujících příkazů:

```typescript
let id = event.transaction.hash // nebo jakkoli je ID konstruováno
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Použijte entitu Transfer jako dříve
```

Protože entita ještě nemusí v ukládat existovat, metoda `load` vrátí hodnotu typu `Transfer | null`. Proto může být nutné před použitím hodnoty zkontrolovat, zda se nejedná o případ `null`.

> **Poznámka:** Načtení entit je nutné pouze v případě, že změny provedené v mapování závisí na předchozích datech entity. Dva způsoby aktualizace existujících entit naleznete v následující části.

#### Vyhledávání entit vytvořených v rámci bloku

Od verzí `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 a `@graphprotocol/graph-cli` v0.49.0 je metoda `loadInBlock` dostupná pro všechny typy entit.

API úložiště usnadňuje načítání entit, které byly vytvořeny nebo aktualizovány v aktuálním bloku. Typickou situací je, že jeden obslužný program vytvoří transakci z nějaké události v řetězci a pozdější obslužný program chce k této transakci přistupovat, pokud existuje. V případě, že transakce neexistuje, bude muset podgraf jít do databáze, jen aby zjistil, že entita neexistuje; pokud autor podgrafu již ví, že entita musela být vytvořena v tomtéž bloku, použitím funkce loadInBlock se této okružní cestě do databáze vyhne. U některých podgrafů mohou tato zmeškaná vyhledávání významně přispět k prodloužení doby indexace.

```typescript
let id = event.transaction.hash // or however the ID is constructed
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Use the Transfer entity as before
```

> Poznámka: Pokud v daném bloku není vytvořena žádná entita, vrátí `loadInBlock` hodnotu `null`, i když v úložišti existuje entita s daným ID.

#### Vyhledávání odvozených entity

Od verzí `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 a `@graphprotocol/graph-cli` v0.51.0 je k dispozici metoda `loadRelated`.

To umožňuje načítání odvozených polí entityh z obsluhy události. Například při následujícím schématu:

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

Následující kód načte entitu `Token`, ze které byla odvozena entita `Holder`:

```typescript
let holder = Holder.load('test-id')
// Načtení entit tokenů přidružených k danému držiteli
let tokens = holder.tokens.load()
```

#### Aktualizace stávajících entity

Existují dva způsoby, jak aktualizovat existující entity:

1. Načtěte entitu např. pomocí `Transfer.load(id)`, nastavte vlastnosti entity a poté ji `.save()` uložte zpět do úložiště.
2. Jednoduše vytvořte entitu např. pomocí `new Transfer(id)`, nastavte vlastnosti entity a poté ji `.save()` uložte do úložiště. Pokud entita již existuje, změny se do ní sloučí.

Změna vlastností je ve většině případů jednoduchá díky generovaným nastavovačům vlastností:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Vlastnosti lze také zrušit jedním z následujících dvou příkazů:

```typescript
transfer.from.unset()
transfer.from = null
```

To funguje pouze u nepovinných vlastností, tj. vlastností, které jsou v jazyce GraphQL deklarovány bez znaku `!`. Dva příklady: `owner: Bytes` nebo `amount: BigInt`.

Aktualizace vlastností pole je trochu složitější, protože získání pole z entity vytvoří kopii tohoto pole. To znamená, že vlastnosti pole je třeba po změně pole znovu explicitně nastavit. Následující příklad předpokládá, že `entita` má `čísla: [BigInt!]!` pole.

```typescript
// Tohle nebude fungovat
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// Toto bude fungovat
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Odstranění entit z úložiště

V současné době není možné odstranit entitu prostřednictvím generovaných typů. Místo toho je pro odstranění entity nutné předat název typu entity a ID entity příkazu `store.remove`:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API poskytuje přístup k inteligentním smlouvám, veřejným stavovým proměnným, funkcím smluv, událostem, transakcím, blokům a kódování/dekódování dat Etherea.

#### Podpora typů Ethereum

Stejně jako u entit generuje `graph codegen` třídy pro všechny inteligentní smlouvy a události používané v podgrafu. Za tímto účelem musí být ABI kontraktu součástí zdroje dat v manifestu podgrafu. Obvykle jsou soubory ABI uloženy ve složce `abis/`.

Ve vygenerovaných třídách probíhají konverze mezi typy Ethereum [built-in-types](#built-in-types) v pozadí, takže se o ně autoři podgraf nemusí starat.

To ilustruje následující příklad. Je dáno schéma podgrafu, jako je

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

a podpis události `Transfer(address,address,uint256)` na platformě Ethereum jsou hodnoty `from`, `to` a `amount` typu `adresa`, `adresa` a `uint256` převedeny na `Address` a `BigInt`, což umožňuje jejich předání do vlastností `Bytes!` a `BigInt!` entity `Transfer`:

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### Události a bloková/transakční data

Události Ethereum předávané obsluze událostí, jako je událost `Transfer` v předchozích příkladech, poskytují přístup nejen k parametrům události, ale také k nadřazené transakci a bloku, jehož jsou součástí. Z instancí `event` (tyto třídy jsou součástí modulu `ethereum` v `graph-ts`) lze získat následující údaje:

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Přístup ke stavu inteligentní smlouvy

Kód vygenerovaný nástrojem `graph codegen` obsahuje také třídy pro inteligentní smlouvy používané v podgrafu. Ty lze použít k přístupu k veřejným stavovým proměnným a k volání funkcí kontraktu v aktuálním bloku.

Běžným vzorem je přístup ke smlouvě, ze které událost pochází. Toho lze dosáhnout pomocí následujícího kódu:

```typescript
// Import vygenerované třídy smlouvy a vygenerované třídy události Transfer
import { ERC20Contract, Transfer as TransferEvent } z '../generated/ERC20Contract/ERC20Contract'
// Importovat vygenerovanou třídu entit
import { Transfer } z "../generated/schema

export function handleTransfer(event: TransferEvent) {
  // Vázat smlouvu na adresu, která událost vyslala
  let contract = ERC20Contract.bind(event.address)

  // Přístup ke stavovým proměnným a funkcím jejich voláním
  let erc20Symbol = contract.symbol()
}
```

`Transfer` je zde aliasován na `TransferEvent`, aby nedošlo ke konfliktu názvů s typ entity

Pokud má smlouva `ERC20Contract` na platformě Ethereum veřejnou funkci pouze pro čtení s názvem `symbol`, lze ji volat pomocí `.symbol()`. Pro veřejné stavové proměnné se automaticky vytvoří metoda se stejným názvem.

Jakákoli jiná smlouva, která je součástí podgrafu, může být importována z vygenerovaného kódu a může být svázána s platnou adresou.

#### Zpracování vrácených volání

Pokud se metody vaší smlouvy určené pouze pro čtení mohou vrátit, měli byste to řešit voláním vygenerované metody smlouvy s předponou `try_`. Například kontrakt Gravity vystavuje metodu `gravatarToOwner`. Tento kód by byl schopen zvládnout revert v této metodě:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

Všimněte si, že uzel Graf připojený ke klientovi Geth nebo Infura nemusí detekovat všechny reverty, pokud na to spoléháte, doporučujeme použít uzel Graf připojený ke klientovi Parity.

#### Kódování/dekódování ABI

Data lze kódovat a dekódovat podle formátu kódování ABI Ethereum pomocí funkcí `encode` a `decode` v modulu `ethereum`.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

Více informací:

- [ABI Spec](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Encoding/decoding [Rust library/CLI](https://github.com/rust-ethereum/ethabi)
- Více [složitý příklad](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Logging API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

API `log` umožňuje dílčím grafům zaznamenávat informace do standardního výstupu uzlu Graf uzel a do Průzkumníka grafů. Zprávy lze protokolovat pomocí různých úrovní protokolu. Pro sestavení zpráv protokolu z argumentu je k dispozici základní syntaxe formátovacího řetězce.

`log` API obsahuje následující funkce:

- `log.debug(fmt: string, args: Array<string>): void` - zaznamená ladicí zprávu.
- `log.info(fmt: string, args: Array<string>): void` - zaznamená informační zprávu.
- `log.warning(fmt: string, args: Array<string>): void` - zaznamená varování.
- `log.error(fmt: string, args: Array<string>): void` - zaznamená chybovou zprávu.
- `log.critical(fmt: string, args: Array<string>): void` - zaznamená kritickou zprávu _a_ ukončí podgraf.

`log` API přebírá formátovací řetězec a pole řetězcových hodnot. Poté nahradí zástupné symboly řetězcovými hodnotami z pole. První zástupný symbol „{}“ bude nahrazen první hodnotou v poli, druhý zástupný symbol „{}“ bude nahrazen druhou hodnotou a tak dále.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Zaznamenávání jedné nebo více hodnot

##### Zaznamenávání jedné hodnoty

V níže uvedeném příkladu je řetězcová hodnota "A" předána do pole a stane se z ní `['A']`, než je zapsána:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Protokolování jedné položky z existujícího pole

V příkladu níže je zaznamenána pouze první hodnota pole argumentů, přestože pole obsahuje tři hodnoty.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"  (Even though three values are passed to `log.info`)
  log.info('My value is: {}', myArray)
}
```

#### Protokolování více záznamů z existujícího pole

Each entry in the arguments array requires its own placeholder `{}` in the log message string. The below example contains three placeholders `{}` in the log message. Because of this, all three values in `myArray` are logged.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Logging a specific entry from an existing array

To display a specific value in the array, the indexed value must be provided.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Zaznamenávání informací o událostech

Níže uvedený příklad zaznamenává číslo bloku, hash bloku a hash transakce z události:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Chytré smlouvy příležitostně ukotvují soubory IPFS v řetězci. To umožňuje mapování získat hashe IPFS ze smlouvy a načíst odpovídající soubory z IPFS. Data souborů budou vrácena jako `Bajty`, což obvykle vyžaduje další zpracování, např. pomocí API `json` zdokumentovaného později na této stránce.

Při zadání hashe nebo cesty IPFS se čtení souboru ze systému IPFS provádí následujícím způsobem:

```typescript
// Vložte to do obsluhy události v mapování
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Cesty jako `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// které obsahují soubory v adresářích, jsou také podporovány
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(cesta)
```

**Poznámka:** `ipfs.cat` není v současné době deterministický. Pokud se soubor nepodaří načíst přes síť IPFS před vypršením požadavku, vrátí se `null`. Z tohoto důvodu se vždy vyplatí zkontrolovat výsledek na `null`.

Pomocí nástroje `ipfs.map` je také možné zpracovávat větší soubory proudovým způsobem. Funkce očekává hash nebo cestu k souboru IPFS, název zpětného volání a příznaky pro úpravu chování:

```typescript
import { JSONValue, Value } z '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // Podrobnosti o zpracování viz dokumentace k JSONValue
  // s hodnotami JSON
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Callbacky mohou také vytvářet entity
  let newItem = new Item(id)
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Nastavit rodiče na "parentId"
  newitem.save()
}

// Toto vložte do obsluhy události v mapování
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Případně použijte `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

V současné době je podporován pouze příznak `json`, který musí být předán souboru `ipfs.map`. S příznakem `json` se soubor IPFS musí skládat z řady hodnot JSON, jedna hodnota na řádek. Volání příkazu `ipfs.map` přečte každý řádek souboru, deserializuje jej do hodnoty `JSONValue` a pro každou z nich zavolá zpětné volání. Zpětné volání pak může použít operace entit k uložení dat z `JSONValue`. Změny entit se uloží až po úspěšném ukončení obsluhy, která volala `ipfs.map`; do té doby se uchovávají v paměti, a velikost souboru, který může `ipfs.map` zpracovat, je proto omezená.

Při úspěchu vrátí `ipfs.map` hodnotu `void`. Pokud vyvolání zpětného volání způsobí chybu, obslužná rutina, která vyvolala `ipfs.map`, se přeruší a podgraf se označí jako neúspěšný.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

API `crypto` zpřístupňuje kryptografické funkce pro použití v mapování. Nyní je k dispozici pouze jedna:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

Data JSON lze analyzovat pomocí API `json`:

- `json.fromBytes(data: Bytes): JSONValue` - analyzuje data JSON z pole `Bytes` interpretovaného jako platná posloupnost UTF-8
- `json.try_fromBytes(data: Bytes): Výsledek<JSONValue, boolean>` - bezpečná verze `json.fromBytes`, vrací chybovou variantu, pokud se parsování nezdařilo
- `json.fromString(data: string): JSONValue` - analyzuje data JSON z platného UTF-8 `Řetězce`
- `json.try_fromString(data: string): Výsledek<JSONValue, boolean>` - bezpečná verze `json.fromString`, vrací chybovou variantu, pokud se parsování nezdařilo

Třída `JSONValue` poskytuje způsob, jak vytáhnout hodnoty z libovolného dokumentu JSON. Protože hodnoty JSON mohou být logické, číselné, pole a další, je `JSONValue` vybavena vlastností `kind` pro kontrolu typu hodnoty:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

Kromě toho existuje metoda pro kontrolu, zda je hodnota `null`:

- `value.isNull(): boolean`

Pokud je typ hodnoty jistý, lze ji převést na [vestavěný typ](#built-in-types) pomocí jedné z následujících metod:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (a poté převést `JSONValue` pomocí jedné z 5 výše uvedených metod)

### Převody typů Reference

| Zdroj(e)             | Destinace            | Funkce převodu               |
| -------------------- | -------------------- | ---------------------------- |
| Address              | Bytes                | none                         |
| Address              | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | none                         |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)    |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Bytes                | String (hexadecimal) | s.toHexString() or s.toHex() |
| Bytes                | String (unicode)     | s.toString()                 |
| Bytes                | String (base58)      | s.toBase58()                 |
| Bytes                | i32                  | s.toI32()                    |
| Bytes                | u32                  | s.toU32()                    |
| Bytes                | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | none                         |
| int32                | i32                  | none                         |
| int32                | BigInt               | BigInt.fromI32(s)            |
| uint24               | i32                  | none                         |
| int64 - int256       | BigInt               | none                         |
| uint32 - uint256     | BigInt               | none                         |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Address              | Address.fromString(s)        |
| Bytes                | Address              | Address.fromBytes(s)         |
| String               | BigInt               | BigInt.fromString(s)         |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Bytes                | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)        |

### Data Source Metadata

You can inspect the contract address, network and context of the data source that invoked the handler through the `dataSource` namespace:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entity and DataSourceContext

The base `Entity` class and the child `DataSourceContext` class have helpers to dynamically set and get fields:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### DataSourceContext in Manifest

The `context` section within `dataSources` allows you to define key-value pairs that are accessible within your subgraph mappings. The available types are `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, and `BigInt`.

Here is a YAML example illustrating the usage of various types in the `context` section:

```yaml
dataSources:
  - kind: ethereum/contract
    name: ContractName
    network: mainnet
    context:
      bool_example:
        type: Bool
        data: true
      string_example:
        type: String
        data: 'hello'
      int_example:
        type: Int
        data: 42
      int8_example:
        type: Int8
        data: 127
      big_decimal_example:
        type: BigDecimal
        data: '10.99'
      bytes_example:
        type: Bytes
        data: '0x68656c6c6f'
      list_example:
        type: List
        data:
          - type: Int
            data: 1
          - type: Int
            data: 2
          - type: Int
            data: 3
      big_int_example:
        type: BigInt
        data: '1000000000000000000000000'
```

- `Bool`: Specifies a Boolean value (`true` or `false`).
- `String`: Specifies a String value.
- `Int`: Specifies a 32-bit integer.
- `Int8`: Specifies an 8-bit integer.
- `BigDecimal`: Specifies a decimal number. Must be quoted.
- `Bytes`: Specifies a hexadecimal string.
- `List`: Specifies a list of items. Each item needs to specify its type and data.
- `BigInt`: Specifies a large integer value. Must be quoted due to its large size.

This context is then accessible in your subgraph mapping files, enabling more dynamic and configurable subgraphs.
