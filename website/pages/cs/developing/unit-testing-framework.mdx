---
title: Rámec pro testování jednotek
---

Matchstick je framework pro jednotkové testování vyvinutý společností [LimeChain](https://limechain.tech/), který umožňuje vývojářům podgrafu testovat logika mapování v prostředí sandbox a spolehlivě nasazovat své podgraf!

## Začínáme

### Instalace závislostí

Abyste mohli používat pomocné metody testy a spouštět testy, je třeba nainstalovat následující závislosti:

```sh
yarn add --dev matchstick-as
```

❗ `graph-node` závisí na PostgreSQL, takže pokud jej ještě nemáte, musíte si jej nainstalovat. Důrazně doporučujeme použít níže uvedené příkazy, protože jeho přidání jiným způsobem může způsobit neočekávané chyby!

#### MacOS

Instalační příkaz Postgres:

```sh
brew instalovat postgresql
```

Vytvoření symlinku na nejnovější verzi libpq.5.lib _Musíte nejprve vytvořit tento adresář_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Instalační příkaz Postgres (závisí na distribuci):

```sh
sudo apt install postgresql
```

### WSL (Subsystém Windows pro Linux)

Matchstick můžete na WSL používat jak pomocí přístupu Docker, tak pomocí binárního přístupu. Protože WSL může být trochu složitější, přinášíme několik tipů pro případ, že narazíte na problémy, jako např

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

nebo

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Ujistěte se, že používáte novější verzi Node.js graph-cli již nepodporuje **v10.19.0** a tato verze je stále výchozí pro nové obrazy Ubuntu na WSL. Například je potvrzeno, že Matchstick funguje na WSL s **v18.1.0**, můžete na něj přepnout buď přes **nvm**, nebo pokud aktualizujete globální Node.js. Nezapomeňte smazat `node_modules` a po aktualizaci nodejs znovu spustit `npm install`! Poté se ujistěte, že máte nainstalovaný **libpq**, což můžete provést spuštěním příkazu

```
sudo apt-get install libpq-dev
```

A konečně, nepoužívejte `graph test` (který používá globální instalaci graph-cli a z nějakého důvodu to vypadá, že je na WSL momentálně nefunkční), místo toho použijte `yarn test` nebo `npm run test` (které použijí lokální instanci graph-cli na úrovni projektu, což funguje jako kouzlo). K tomu byste samozřejmě potřebovali mít v souboru `package.json` skript `"test"`, což může být něco tak jednoduchého, jako např

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.30.0",
    "@graphprotocol/graph-ts": "^0.27.0",
    "matchstick-as": "^0.5.0"
  }
}
```

### Použití

Pro použití **Matchsticku** v projektu subgrafu stačí otevřít terminál, přejít do kořenové složky projektu a jednoduše spustit `graph test [options] <datasource>` - stáhne se nejnovější binární soubor **Matchsticku** a spustí se zadaný test nebo všechny testy ve složce testů (nebo všechny existující testy, pokud není zadán příznak datasource).

### Možnosti CLI

Tím se spustí všechny testy ve složce testů:

```sh
test graf
```

Spustí se test s názvem gravity.test.ts a/nebo všechny testy uvnitř složky s názvem gravity:

```sh
testovací gravitace graf
```

Spustí se pouze tento konkrétní testovací soubor:

```sh
graph test path/to/file.test.ts
```

**Možnosti:**

```sh
-c, --coverage Spustit testy v režimu pokrytí
-d, --docker Spustit testy v kontejneru docker (Poznámka: Spusťte z kořenové složky podgrafu).
-f, --force Binární: Znovu stáhne binární soubor. Docker: Znovu stáhne soubor dockeru a obnoví obraz dockeru.
-h, --help Zobrazí informace o použití
-l, --logs Zaznamená do konzole informace o operačním systému, modelu procesoru a url adrese pro stahování (pro účely ladění).
-r, --recompile Vynutí překompilování testů.
-v, --version <tag> Zvolte verzi binárního souboru rust, která se má stáhnout/použít
```

### Docker

Od verze `graph-cli 0.25.2` podporuje příkaz `graph test` spuštění `matchstick` v kontejneru docker s příznakem `-d`. Implementace dockeru používá příkaz [bind mount](https://docs.docker.com/storage/bind-mounts/), takže nemusí při každém spuštění příkazu `graph test -d` obnovovat obraz dockeru. Případně můžete postupovat podle pokynů z repozitáře [matchstick](https://github.com/LimeChain/matchstick#docker-) a spustit docker ručně.

❗ Pokud jste dříve spustili `graph test`, můžete se při sestavování dockeru setkat s následující chybou:

```sh
  chyba odesílatele: nepodařilo se provést xattr node_modules/binary-install-raw/binary/binary-<platform>: oprávnění odepřeno
```

V tomto případě vytvořte v kořenové složce `.dockerignore` a přidejte `node_modules/binary-install-raw/bin`

### Konfigurace

Matchstick lze nakonfigurovat tak, aby používal vlastní testy, knihovny a cestu k manifestu prostřednictvím konfiguračního souboru `matchstick.yaml`:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Ukázkový podgraf

Příklady z této příručky si můžete vyzkoušet a pohrát si s nimi naklonováním repozitáře [Ukázkový podgraf](https://github.com/LimeChain/demo-subgraph)

### Videonávody

Můžete se také podívat na sérii videí ["Jak používat Matchstick k psaní unit test pro vaše podgrafy"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Struktura testů (>=0.5.0)

_**DŮLEŽITÉ: Vyžaduje matchstick-as >=0.5.0**_

### describe()

`describe(name: String , () => {})` - Definuje skupinu test.

**_Poznámky:_**

- _Popisy nejsou povinné. Test() můžete stále používat starým způsobem, mimo bloky describe()_

Příklad:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

Vnořený příklad `describe()`:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Definuje případ test. Funkci test() můžete použít uvnitř bloků describe() nebo samostatně.

Příklad:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

nebo

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Spustí blok kódu před kterýmkoli testem v souboru. Pokud je `beforeAll` deklarováno uvnitř bloku `describe`, spustí se na začátku tohoto bloku `describe`.

Příklady:

Kód uvnitř `beforeAll` se provede jednou před _všemi_ testy v souboru.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = “First Gravatar”
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

Kód uvnitř `beforeAll` se provede jednou před všemi testy v prvním bloku popisu

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = “First Gravatar”
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Spustí blok kódu po všech test v souboru. Pokud je `afterAll` deklarováno uvnitř bloku `describe`, spustí se na konci tohoto bloku `describe`.

Příklad:

Kód uvnitř `afterAll` se provede jednou po _všech_ testech v souboru.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

Kód uvnitř `afterAll` se provede jednou po všech test v prvním bloku popisu

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Před každým test spustí blok kódu. Pokud je `beforeEach` deklarován uvnitř bloku `describe`, spustí se před každým test v tomto bloku `describe`.

Příklady: Příklady: Kód uvnitř `beforeEach` se provede před každým test.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

Kód uvnitř `beforeEach` se provede pouze před každým test v tomto popisu

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Po každém test spustí blok kódu. Pokud je `afterEach` deklarován uvnitř bloku `describe`, spustí se po každém test v tomto bloku `describe`.

Příklady:

Kód uvnitř `afterEach` se provede po každém test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = “First Gravatar”
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Kód uvnitř `afterEach` se provede po každém test v tomto popisu

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Tvrdí

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

## Napsat jednotkový test

Podívejme se, jak by vypadal jednoduchý jednotkový test s použitím příkladů Gravatar v [Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

Předpokládejme, že máme následující obslužnou funkci (spolu se dvěma pomocnými funkcemi, které nám usnadní život):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Nejprve musíme v projektu vytvořit testovací soubor. Toto je příklad, jak by to mohlo vypadat:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})
```

To je spousta věcí, které je třeba vybalit! Nejprve je důležité si všimnout, že importovat věci z `matchstick-as`, naší pomocné knihovny AssemblyScript (distribuované jako modul npm). Repozitář najdete [zde](https://github.com/LimeChain/matchstick-as). Knihovna `matchstick-as` nám poskytuje užitečné testovací metody a také definuje funkci `test()`, kterou budeme používat k sestavování našich testovacích bloků. Zbytek je poměrně jednoduchý - zde je uvedeno, co se stane:

- Nastavujeme počáteční stav a přidáváme jednu vlastní entita Gravatar;
- Pomocí funkce `createNewGravatarEvent()` definujeme dva objekty událostí `NewGravatar` a jejich data;
- Voláme metody obsluhy těchto událostí - `handleNewGravatars()` a předáváme seznam našich vlastních událostí;
- Ujišťujeme se o stavu obchodu. Jak to funguje? - Předáváme jedinečnou kombinaci typu Entity a id. Pak zkontrolujeme konkrétní pole této entity a potvrdíme, že má hodnotu, kterou očekáváme. Toto provádíme jak pro počáteční Entitu Gravatar, kterou jsme přidali do úložiště, tak pro dvě entity Gravatar, které se přidají při volání funkce obsluhy;
- A nakonec - vyčistíme úložiště pomocí `clearStore()`, aby náš další test mohl začít s novým a prázdným objektem úložiště. Můžeme definovat libovolný počet testovacích bloků.

A je to tady - vytvořili jsme první test! 👏

Pro spuštění našich testů nyní stačí v kořenové složce podgrafu spustit následující příkaz:

`test graf gravitace`

A pokud vše proběhne v pořádku, měli byste se setkat s následujícím:

![Matchstick říká: "Všechny testy splněny!"](/img/matchstick-tests-passed.png)

## Běžné testovací scénáře

### Hydratace obchodu s určitým stavem

Uživatelé mohou hydratovat sklad známou sadou entit. Zde je příklad inicializace úložiště pomocí entity Gravatar:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Volání funkce mapování pomocí události

Uživatel může vytvořit vlastní událost a předat ji funkci mapování, která je svázána s úložištěm:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Volání všech mapování pomocí příslušenství událostí

Uživatelé mohou mapování vyvolat pomocí testovacích přípravků.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Zesměšňování smluvních volání

Uživatelé mohou zesměšňovat smluvní hovory:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Jak bylo ukázáno, aby bylo možné zesměšnit volání smlouvy a hardcore návratovou hodnotu, musí uživatel zadat adresu smlouvy, název funkce, signaturu funkce, pole argumentů a samozřejmě návratovou hodnotu.

Uživatelé mohou také zesměšňovat vracení funkcí:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Zesměšňování souborů IPFS (od matchstick 0.4.1)

Uživatelé mohou soubory IPFS napodobovat pomocí funkce `mockIpfsFile(hash, filePath)`. Funkce přijímá dva argumenty, prvním je hash/cesta k souboru IPFS a druhým je cesta k místnímu souboru.

POZNÁMKA: Při testování `ipfs.map/ipfs.mapJSON` musí být funkce zpětného volání exportována z testovacího souboru, aby ji matchstck detekoval, jako například funkci `processGravatar()` v testovacím příkladu níže:

`.test.ts` soubor

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Export ipfs.map() callback in order for matchstck to detect it
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` soubor

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// ipfs.map callback
export function processGravatar(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Callbacks can also created entities
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// function that calls ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Zjištění stavu skladu

Uživatelé mohou potvrdit konečný (nebo střední) stav úložiště prostřednictvím potvrzujících entit. K tomu musí uživatel zadat typ entity, konkrétní ID entity, název pole této entity a očekávanou hodnotu pole. Zde je rychlý příklad:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Spuštěním funkce assert.fieldEquals() se zkontroluje rovnost zadaného pole se zadanou očekávanou hodnotou. Pokud se hodnoty **NENÍ** rovnají, test selže a vypíše se chybové hlášení. V opačném případě test úspěšně projde.

### Interakce s metadaty událostí

Uživatelé mohou použít výchozí metadata transakce, která mohou být vrácena jako ethereum.Event pomocí funkce `newMockEvent()`. Následující příklad ukazuje, jak lze číst/zapisovat do těchto polí na objektu Event:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Potvrzení rovnosti proměnných

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Tvrzení, že entita **není** v úložišti

Uživatelé mohou tvrdit, že entita v úložišti neexistuje. Funkce přebírá typ entity a id. Pokud se entita v úložišti skutečně nachází, test selže s příslušným chybovým hlášením. Zde je rychlý příklad použití této funkce:

```typescript
assert.notInStore('Gravatar', '23')
```

### Tisk celého úložiště (pro účely ladění)

Pomocí této pomocné funkce můžete vypsat celý obchod na konzolu:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

### Očekávané selhání

Uživatelé mohou očekávat selhání test pomocí příznaku shouldFail ve funkcích test():

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Pokud je test označen hodnotou shouldFail = true, ale NESPADNE, zobrazí se to v protokolech jako chyba a blok test selže. Pokud je také označen shouldFail = false (výchozí stav), dojde k pádu spouštěče test.

### Protokolování

Vlastní protokoly v jednotkových test jsou úplně stejné jako protokoly v mapování. Rozdíl je v tom, že objekt logu je třeba importovat z matchstick-as, nikoli z graph-ts. Zde je jednoduchý příklad se všemi nekritickými typy log:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Uživatelé mohou také simulovat kritickou poruchu, například takto:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Zaznamenáním kritických chyb se provádění testů zastaví a vše se pokazí. Koneckonců - chceme mít jistotu, že váš kód nemá při nasazení kritické log, a pokud by se tak stalo, měli byste si toho okamžitě všimnout.

### Testování odvozených polí

Testování odvozených polí je funkce, která (jak ukazuje příklad níže) umožňuje uživateli nastavit pole v určité entit a nechat automaticky aktualizovat jinou entita, pokud je jedno z jejích polí odvozeno od první entity. Důležité je si uvědomit, že první entita musí být znovu načtena, protože automatická aktualizace probíhá v úložišti v rustu, jehož kód AS je agnostický.

```typescript
test('Derived fields example test', () => {
  let mainAccount = new GraphAccount('12')
  mainAccount.save()
  let operatedAccount = new GraphAccount('1')
  operatedAccount.operators = ['12']
  operatedAccount.save()
  let nst = new NameSignalTransaction('1234')
  nst.signer = '12'
  nst.save()

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  mainAccount = GraphAccount.load('12')!

  assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
  assert.stringEquals('1', mainAccount.operatorOf[0])
})
```

### Testování dynamických zdrojů dat

Testování dynamických zdrojů dat lze provést pomocí posměchu návratové hodnoty funkcí `context()`, `address()` a `network()` oboru názvů dataSource. Tyto funkce v současné době vracejí následující hodnoty: `context()` - vrací prázdnou entitu (DataSourceContext), `address()` - vrací `0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, `network()` - vrací `mainnet`. a `createWithContext(...)` jsou zesměšněny tak, že nic nedělají, takže je v testech vůbec není třeba volat. Změny návratových hodnot lze provádět prostřednictvím funkcí jmenného prostoru `dataSourceMock` v `matchstick-as` (verze 0.3.0+).

Příklad níže:

Nejprve máme následující obsluhu události (která byla záměrně přepracována za účelem předvedení posměchu datovému zdroji):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

A pak máme test, který používá jednu z metod v oboru názvů dataSourceMock k nastavení nové návratové hodnoty pro všechny funkce dataSource:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Všimněte si, že na konci je volána funkce dataSourceMock.resetValues(). To proto, že hodnoty se při změně pamatují a je třeba je resetovat, pokud se chcete vrátit k výchozím hodnotám.

## Pokrytí test

Pomocí nástroje **Matchstick** mohou vývojáři podgrafů spustit skript, který vypočítá pokrytí testů napsaných jednotkových test.

The test coverage tool takes the compiled test `wasm` binaries and converts them to `wat` files, which can then be easily inspected to see whether or not the handlers defined in `subgraph.yaml` have been called. Since code coverage (and testing as whole) is in very early stages in AssemblyScript and WebAssembly, **Matchstick** cannot check for branch coverage. Instead we rely on the assertion that if a given handler has been called, the event/function for it have been properly mocked.

### Požadavky

To run the test coverage functionality provided in **Matchstick**, there are a few things you need to prepare beforehand:

#### Export your handlers

In order for **Matchstick** to check which handlers are being run, those handlers need to be exported from the **test file**. So for instance in our example, in our gravity.test.ts file we have the following handler being imported:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

In order for that function to be visible (for it to be included in the `wat` file **by name**) we need to also export it, like this:

```typescript
export { handleNewGravatar }
```

### Použití

Once that's all set up, to run the test coverage tool, simply run:

```sh
graph test -- -c
```

You could also add a custom `coverage` command to your `package.json` file, like so:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

That will execute the coverage tool and you should see something like this in the terminal:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 ️
Reading generated test modules... 🔎️

Generating coverage report 📝

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Test run time duration in the log output

The log output includes the test run duration. Here's an example:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Common compiler errors

> Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined

This means you have used `console.log` in your code, which is not supported by AssemblyScript. Please consider using the [Logging API](/developing/assemblyscript-api/#logging-api)

> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
>
> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

The mismatch in arguments is caused by mismatch in `graph-ts` and `matchstick-as`. The best way to fix issues like this one is to update everything to the latest released version.

## Feedback

If you have any questions, feedback, feature requests or just want to reach out, the best place would be The Graph Discord where we have a dedicated channel for Matchstick, called 🔥| unit-testing.
