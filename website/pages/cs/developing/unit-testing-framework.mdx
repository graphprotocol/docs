---
title: R√°mec pro testov√°n√≠ jednotek
---

Matchstick je framework pro jednotkov√© testov√°n√≠ vyvinut√Ω spoleƒçnost√≠ [LimeChain](https://limechain.tech/), kter√Ω umo≈æ≈àuje v√Ωvoj√°≈ô≈Øm podgrafu testovat logika mapov√°n√≠ v prost≈ôed√≠ sandbox a spolehlivƒõ nasazovat sv√© podgraf!

## Zaƒç√≠n√°me

### Instalace z√°vislost√≠

Abyste mohli pou≈æ√≠vat pomocn√© metody testy a spou≈°tƒõt testy, je t≈ôeba nainstalovat n√°sleduj√≠c√≠ z√°vislosti:

```sh
yarn add --dev matchstick-as
```

‚ùó `graph-node` z√°vis√≠ na PostgreSQL, tak≈æe pokud jej je≈°tƒõ nem√°te, mus√≠te si jej nainstalovat. D≈Øraznƒõ doporuƒçujeme pou≈æ√≠t n√≠≈æe uveden√© p≈ô√≠kazy, proto≈æe jeho p≈ôid√°n√≠ jin√Ωm zp≈Øsobem m≈Ø≈æe zp≈Øsobit neoƒçek√°van√© chyby!

#### MacOS

Instalaƒçn√≠ p≈ô√≠kaz Postgres:

```sh
brew instalovat postgresql
```

Vytvo≈ôen√≠ symlinku na nejnovƒõj≈°√≠ verzi libpq.5.lib _Mus√≠te nejprve vytvo≈ôit tento adres√°≈ô_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Instalaƒçn√≠ p≈ô√≠kaz Postgres (z√°vis√≠ na distribuci):

```sh
sudo apt install postgresql
```

### WSL (Subsyst√©m Windows pro Linux)

Matchstick m≈Ø≈æete na WSL pou≈æ√≠vat jak pomoc√≠ p≈ô√≠stupu Docker, tak pomoc√≠ bin√°rn√≠ho p≈ô√≠stupu. Proto≈æe WSL m≈Ø≈æe b√Ωt trochu slo≈æitƒõj≈°√≠, p≈ôin√°≈°√≠me nƒõkolik tip≈Ø pro p≈ô√≠pad, ≈æe naraz√≠te na probl√©my, jako nap≈ô

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

nebo

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Ujistƒõte se, ≈æe pou≈æ√≠v√°te novƒõj≈°√≠ verzi Node.js graph-cli ji≈æ nepodporuje **v10.19.0** a tato verze je st√°le v√Ωchoz√≠ pro nov√© obrazy Ubuntu na WSL. Nap≈ô√≠klad je potvrzeno, ≈æe Matchstick funguje na WSL s **v18.1.0**, m≈Ø≈æete na nƒõj p≈ôepnout buƒè p≈ôes **nvm**, nebo pokud aktualizujete glob√°ln√≠ Node.js. Nezapome≈àte smazat `node_modules` a po aktualizaci nodejs znovu spustit `npm install`! Pot√© se ujistƒõte, ≈æe m√°te nainstalovan√Ω **libpq**, co≈æ m≈Ø≈æete prov√©st spu≈°tƒõn√≠m p≈ô√≠kazu

```
sudo apt-get install libpq-dev
```

A koneƒçnƒõ, nepou≈æ√≠vejte `graph test` (kter√Ω pou≈æ√≠v√° glob√°ln√≠ instalaci graph-cli a z nƒõjak√©ho d≈Øvodu to vypad√°, ≈æe je na WSL moment√°lnƒõ nefunkƒçn√≠), m√≠sto toho pou≈æijte `yarn test` nebo `npm run test` (kter√© pou≈æij√≠ lok√°ln√≠ instanci graph-cli na √∫rovni projektu, co≈æ funguje jako kouzlo). K tomu byste samoz≈ôejmƒõ pot≈ôebovali m√≠t v souboru `package.json` skript `"test"`, co≈æ m≈Ø≈æe b√Ωt nƒõco tak jednoduch√©ho, jako nap≈ô

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.30.0",
    "@graphprotocol/graph-ts": "^0.27.0",
    "matchstick-as": "^0.5.0"
  }
}
```

### Pou≈æit√≠

Pro pou≈æit√≠ **Matchsticku** v projektu subgrafu staƒç√≠ otev≈ô√≠t termin√°l, p≈ôej√≠t do ko≈ôenov√© slo≈æky projektu a jednodu≈°e spustit `graph test [options] <datasource>` - st√°hne se nejnovƒõj≈°√≠ bin√°rn√≠ soubor **Matchsticku** a spust√≠ se zadan√Ω test nebo v≈°echny testy ve slo≈æce test≈Ø (nebo v≈°echny existuj√≠c√≠ testy, pokud nen√≠ zad√°n p≈ô√≠znak datasource).

### Mo≈ænosti CLI

T√≠m se spust√≠ v≈°echny testy ve slo≈æce test≈Ø:

```sh
test graf
```

Spust√≠ se test s n√°zvem gravity.test.ts a/nebo v≈°echny testy uvnit≈ô slo≈æky s n√°zvem gravity:

```sh
testovac√≠ gravitace graf
```

Spust√≠ se pouze tento konkr√©tn√≠ testovac√≠ soubor:

```sh
graph test path/to/file.test.ts
```

**Mo≈ænosti:**

```sh
-c, --coverage Spustit testy v re≈æimu pokryt√≠
-d, --docker Spustit testy v kontejneru docker (Pozn√°mka: Spus≈•te z ko≈ôenov√© slo≈æky podgrafu).
-f, --force Bin√°rn√≠: Znovu st√°hne bin√°rn√≠ soubor. Docker: Znovu st√°hne soubor dockeru a obnov√≠ obraz dockeru.
-h, --help Zobraz√≠ informace o pou≈æit√≠
-l, --logs Zaznamen√° do konzole informace o operaƒçn√≠m syst√©mu, modelu procesoru a url adrese pro stahov√°n√≠ (pro √∫ƒçely ladƒõn√≠).
-r, --recompile Vynut√≠ p≈ôekompilov√°n√≠ test≈Ø.
-v, --version <tag> Zvolte verzi bin√°rn√≠ho souboru rust, kter√° se m√° st√°hnout/pou≈æ√≠t
```

### Docker

Od verze `graph-cli 0.25.2` podporuje p≈ô√≠kaz `graph test` spu≈°tƒõn√≠ `matchstick` v kontejneru docker s p≈ô√≠znakem `-d`. Implementace dockeru pou≈æ√≠v√° p≈ô√≠kaz [bind mount](https://docs.docker.com/storage/bind-mounts/), tak≈æe nemus√≠ p≈ôi ka≈æd√©m spu≈°tƒõn√≠ p≈ô√≠kazu `graph test -d` obnovovat obraz dockeru. P≈ô√≠padnƒõ m≈Ø≈æete postupovat podle pokyn≈Ø z repozit√°≈ôe [matchstick](https://github.com/LimeChain/matchstick#docker-) a spustit docker ruƒçnƒõ.

‚ùó Pokud jste d≈ô√≠ve spustili `graph test`, m≈Ø≈æete se p≈ôi sestavov√°n√≠ dockeru setkat s n√°sleduj√≠c√≠ chybou:

```sh
  chyba odes√≠latele: nepoda≈ôilo se prov√©st xattr node_modules/binary-install-raw/binary/binary-<platform>: opr√°vnƒõn√≠ odep≈ôeno
```

V tomto p≈ô√≠padƒõ vytvo≈ôte v ko≈ôenov√© slo≈æce `.dockerignore` a p≈ôidejte `node_modules/binary-install-raw/bin`

### Konfigurace

Matchstick lze nakonfigurovat tak, aby pou≈æ√≠val vlastn√≠ testy, knihovny a cestu k manifestu prost≈ôednictv√≠m konfiguraƒçn√≠ho souboru `matchstick.yaml`:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Uk√°zkov√Ω podgraf

P≈ô√≠klady z t√©to p≈ô√≠ruƒçky si m≈Ø≈æete vyzkou≈°et a pohr√°t si s nimi naklonov√°n√≠m repozit√°≈ôe [Uk√°zkov√Ω podgraf](https://github.com/LimeChain/demo-subgraph)

### Videon√°vody

M≈Ø≈æete se tak√© pod√≠vat na s√©rii vide√≠ ["Jak pou≈æ√≠vat Matchstick k psan√≠ unit test pro va≈°e podgrafy"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Struktura test≈Ø (>=0.5.0)

_**D≈ÆLE≈ΩIT√â: Vy≈æaduje matchstick-as >=0.5.0**_

### describe()

`describe(name: String , () => {})` - Definuje skupinu test.

**_Pozn√°mky:_**

- _Popisy nejsou povinn√©. Test() m≈Ø≈æete st√°le pou≈æ√≠vat star√Ωm zp≈Øsobem, mimo bloky describe()_

P≈ô√≠klad:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

Vno≈ôen√Ω p≈ô√≠klad `describe()`:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Definuje p≈ô√≠pad test. Funkci test() m≈Ø≈æete pou≈æ√≠t uvnit≈ô blok≈Ø describe() nebo samostatnƒõ.

P≈ô√≠klad:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

nebo

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Spust√≠ blok k√≥du p≈ôed kter√Ωmkoli testem v souboru. Pokud je `beforeAll` deklarov√°no uvnit≈ô bloku `describe`, spust√≠ se na zaƒç√°tku tohoto bloku `describe`.

P≈ô√≠klady:

K√≥d uvnit≈ô `beforeAll` se provede jednou p≈ôed _v≈°emi_ testy v souboru.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

K√≥d uvnit≈ô `beforeAll` se provede jednou p≈ôed v≈°emi testy v prvn√≠m bloku popisu

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Spust√≠ blok k√≥du po v≈°ech test v souboru. Pokud je `afterAll` deklarov√°no uvnit≈ô bloku `describe`, spust√≠ se na konci tohoto bloku `describe`.

P≈ô√≠klad:

K√≥d uvnit≈ô `afterAll` se provede jednou po _v≈°ech_ testech v souboru.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

K√≥d uvnit≈ô `afterAll` se provede jednou po v≈°ech test v prvn√≠m bloku popisu

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

P≈ôed ka≈æd√Ωm test spust√≠ blok k√≥du. Pokud je `beforeEach` deklarov√°n uvnit≈ô bloku `describe`, spust√≠ se p≈ôed ka≈æd√Ωm test v tomto bloku `describe`.

P≈ô√≠klady: P≈ô√≠klady: K√≥d uvnit≈ô `beforeEach` se provede p≈ôed ka≈æd√Ωm test.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

K√≥d uvnit≈ô `beforeEach` se provede pouze p≈ôed ka≈æd√Ωm test v tomto popisu

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Po ka≈æd√©m test spust√≠ blok k√≥du. Pokud je `afterEach` deklarov√°n uvnit≈ô bloku `describe`, spust√≠ se po ka≈æd√©m test v tomto bloku `describe`.

P≈ô√≠klady:

K√≥d uvnit≈ô `afterEach` se provede po ka≈æd√©m test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

K√≥d uvnit≈ô `afterEach` se provede po ka≈æd√©m test v tomto popisu

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Tvrd√≠

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

## Napsat jednotkov√Ω test

Pod√≠vejme se, jak by vypadal jednoduch√Ω jednotkov√Ω test s pou≈æit√≠m p≈ô√≠klad≈Ø Gravatar v [Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

P≈ôedpokl√°dejme, ≈æe m√°me n√°sleduj√≠c√≠ obslu≈ænou funkci (spolu se dvƒõma pomocn√Ωmi funkcemi, kter√© n√°m usnadn√≠ ≈æivot):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Nejprve mus√≠me v projektu vytvo≈ôit testovac√≠ soubor. Toto je p≈ô√≠klad, jak by to mohlo vypadat:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})
```

To je spousta vƒõc√≠, kter√© je t≈ôeba vybalit! Nejprve je d≈Øle≈æit√© si v≈°imnout, ≈æe importovat vƒõci z `matchstick-as`, na≈°√≠ pomocn√© knihovny AssemblyScript (distribuovan√© jako modul npm). Repozit√°≈ô najdete [zde](https://github.com/LimeChain/matchstick-as). Knihovna `matchstick-as` n√°m poskytuje u≈æiteƒçn√© testovac√≠ metody a tak√© definuje funkci `test()`, kterou budeme pou≈æ√≠vat k sestavov√°n√≠ na≈°ich testovac√≠ch blok≈Ø. Zbytek je pomƒõrnƒõ jednoduch√Ω - zde je uvedeno, co se stane:

- Nastavujeme poƒç√°teƒçn√≠ stav a p≈ôid√°v√°me jednu vlastn√≠ entita Gravatar;
- Pomoc√≠ funkce `createNewGravatarEvent()` definujeme dva objekty ud√°lost√≠ `NewGravatar` a jejich data;
- Vol√°me metody obsluhy tƒõchto ud√°lost√≠ - `handleNewGravatars()` a p≈ôed√°v√°me seznam na≈°ich vlastn√≠ch ud√°lost√≠;
- Uji≈°≈•ujeme se o stavu obchodu. Jak to funguje? - P≈ôed√°v√°me jedineƒçnou kombinaci typu Entity a id. Pak zkontrolujeme konkr√©tn√≠ pole t√©to entity a potvrd√≠me, ≈æe m√° hodnotu, kterou oƒçek√°v√°me. Toto prov√°d√≠me jak pro poƒç√°teƒçn√≠ Entitu Gravatar, kterou jsme p≈ôidali do √∫lo≈æi≈°tƒõ, tak pro dvƒõ entity Gravatar, kter√© se p≈ôidaj√≠ p≈ôi vol√°n√≠ funkce obsluhy;
- A nakonec - vyƒçist√≠me √∫lo≈æi≈°tƒõ pomoc√≠ `clearStore()`, aby n√°≈° dal≈°√≠ test mohl zaƒç√≠t s nov√Ωm a pr√°zdn√Ωm objektem √∫lo≈æi≈°tƒõ. M≈Ø≈æeme definovat libovoln√Ω poƒçet testovac√≠ch blok≈Ø.

A je to tady - vytvo≈ôili jsme prvn√≠ test! üëè

Pro spu≈°tƒõn√≠ na≈°ich test≈Ø nyn√≠ staƒç√≠ v ko≈ôenov√© slo≈æce podgrafu spustit n√°sleduj√≠c√≠ p≈ô√≠kaz:

`test graf gravitace`

A pokud v≈°e probƒõhne v po≈ô√°dku, mƒõli byste se setkat s n√°sleduj√≠c√≠m:

![Matchstick ≈ô√≠k√°: "V≈°echny testy splnƒõny!"](/img/matchstick-tests-passed.png)

## Bƒõ≈æn√© testovac√≠ sc√©n√°≈ôe

### Hydratace obchodu s urƒçit√Ωm stavem

U≈æivatel√© mohou hydratovat sklad zn√°mou sadou entit. Zde je p≈ô√≠klad inicializace √∫lo≈æi≈°tƒõ pomoc√≠ entity Gravatar:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Vol√°n√≠ funkce mapov√°n√≠ pomoc√≠ ud√°losti

U≈æivatel m≈Ø≈æe vytvo≈ôit vlastn√≠ ud√°lost a p≈ôedat ji funkci mapov√°n√≠, kter√° je sv√°z√°na s √∫lo≈æi≈°tƒõm:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Vol√°n√≠ v≈°ech mapov√°n√≠ pomoc√≠ p≈ô√≠slu≈°enstv√≠ ud√°lost√≠

U≈æivatel√© mohou mapov√°n√≠ vyvolat pomoc√≠ testovac√≠ch p≈ô√≠pravk≈Ø.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Zesmƒõ≈°≈àov√°n√≠ smluvn√≠ch vol√°n√≠

U≈æivatel√© mohou zesmƒõ≈°≈àovat smluvn√≠ hovory:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Jak bylo uk√°z√°no, aby bylo mo≈æn√© zesmƒõ≈°nit vol√°n√≠ smlouvy a hardcore n√°vratovou hodnotu, mus√≠ u≈æivatel zadat adresu smlouvy, n√°zev funkce, signaturu funkce, pole argument≈Ø a samoz≈ôejmƒõ n√°vratovou hodnotu.

U≈æivatel√© mohou tak√© zesmƒõ≈°≈àovat vracen√≠ funkc√≠:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Zesmƒõ≈°≈àov√°n√≠ soubor≈Ø IPFS (od matchstick 0.4.1)

U≈æivatel√© mohou soubory IPFS napodobovat pomoc√≠ funkce `mockIpfsFile(hash, filePath)`. Funkce p≈ôij√≠m√° dva argumenty, prvn√≠m je hash/cesta k souboru IPFS a druh√Ωm je cesta k m√≠stn√≠mu souboru.

POZN√ÅMKA: P≈ôi testov√°n√≠ `ipfs.map/ipfs.mapJSON` mus√≠ b√Ωt funkce zpƒõtn√©ho vol√°n√≠ exportov√°na z testovac√≠ho souboru, aby ji matchstck detekoval, jako nap≈ô√≠klad funkci `processGravatar()` v testovac√≠m p≈ô√≠kladu n√≠≈æe:

`.test.ts` soubor

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Export ipfs.map() callback in order for matchstck to detect it
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` soubor

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// ipfs.map callback
export function processGravatar(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Callbacks can also created entities
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// function that calls ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Zji≈°tƒõn√≠ stavu skladu

U≈æivatel√© mohou potvrdit koneƒçn√Ω (nebo st≈ôedn√≠) stav √∫lo≈æi≈°tƒõ prost≈ôednictv√≠m potvrzuj√≠c√≠ch entit. K tomu mus√≠ u≈æivatel zadat typ entity, konkr√©tn√≠ ID entity, n√°zev pole t√©to entity a oƒçek√°vanou hodnotu pole. Zde je rychl√Ω p≈ô√≠klad:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Spu≈°tƒõn√≠m funkce assert.fieldEquals() se zkontroluje rovnost zadan√©ho pole se zadanou oƒçek√°vanou hodnotou. Pokud se hodnoty **NEN√ç** rovnaj√≠, test sel≈æe a vyp√≠≈°e se chybov√© hl√°≈°en√≠. V opaƒçn√©m p≈ô√≠padƒõ test √∫spƒõ≈°nƒõ projde.

### Interakce s metadaty ud√°lost√≠

U≈æivatel√© mohou pou≈æ√≠t v√Ωchoz√≠ metadata transakce, kter√° mohou b√Ωt vr√°cena jako ethereum.Event pomoc√≠ funkce `newMockEvent()`. N√°sleduj√≠c√≠ p≈ô√≠klad ukazuje, jak lze ƒç√≠st/zapisovat do tƒõchto pol√≠ na objektu Event:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Potvrzen√≠ rovnosti promƒõnn√Ωch

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Tvrzen√≠, ≈æe entita **nen√≠** v √∫lo≈æi≈°ti

U≈æivatel√© mohou tvrdit, ≈æe entita v √∫lo≈æi≈°ti neexistuje. Funkce p≈ôeb√≠r√° typ entity a id. Pokud se entita v √∫lo≈æi≈°ti skuteƒçnƒõ nach√°z√≠, test sel≈æe s p≈ô√≠slu≈°n√Ωm chybov√Ωm hl√°≈°en√≠m. Zde je rychl√Ω p≈ô√≠klad pou≈æit√≠ t√©to funkce:

```typescript
assert.notInStore('Gravatar', '23')
```

### Tisk cel√©ho √∫lo≈æi≈°tƒõ (pro √∫ƒçely ladƒõn√≠)

Pomoc√≠ t√©to pomocn√© funkce m≈Ø≈æete vypsat cel√Ω obchod na konzolu:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

### Oƒçek√°van√© selh√°n√≠

U≈æivatel√© mohou oƒçek√°vat selh√°n√≠ test pomoc√≠ p≈ô√≠znaku shouldFail ve funkc√≠ch test():

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Pokud je test oznaƒçen hodnotou shouldFail = true, ale NESPADNE, zobraz√≠ se to v protokolech jako chyba a blok test sel≈æe. Pokud je tak√© oznaƒçen shouldFail = false (v√Ωchoz√≠ stav), dojde k p√°du spou≈°tƒõƒçe test.

### Protokolov√°n√≠

Vlastn√≠ protokoly v jednotkov√Ωch test jsou √∫plnƒõ stejn√© jako protokoly v mapov√°n√≠. Rozd√≠l je v tom, ≈æe objekt logu je t≈ôeba importovat z matchstick-as, nikoli z graph-ts. Zde je jednoduch√Ω p≈ô√≠klad se v≈°emi nekritick√Ωmi typy log:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

U≈æivatel√© mohou tak√© simulovat kritickou poruchu, nap≈ô√≠klad takto:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Zaznamen√°n√≠m kritick√Ωch chyb se prov√°dƒõn√≠ test≈Ø zastav√≠ a v≈°e se pokaz√≠. Koneckonc≈Ø - chceme m√≠t jistotu, ≈æe v√°≈° k√≥d nem√° p≈ôi nasazen√≠ kritick√© log, a pokud by se tak stalo, mƒõli byste si toho okam≈æitƒõ v≈°imnout.

### Testov√°n√≠ odvozen√Ωch pol√≠

Testov√°n√≠ odvozen√Ωch pol√≠ je funkce, kter√° (jak ukazuje p≈ô√≠klad n√≠≈æe) umo≈æ≈àuje u≈æivateli nastavit pole v urƒçit√© entit a nechat automaticky aktualizovat jinou entita, pokud je jedno z jej√≠ch pol√≠ odvozeno od prvn√≠ entity. D≈Øle≈æit√© je si uvƒõdomit, ≈æe prvn√≠ entita mus√≠ b√Ωt znovu naƒçtena, proto≈æe automatick√° aktualizace prob√≠h√° v √∫lo≈æi≈°ti v rustu, jeho≈æ k√≥d AS je agnostick√Ω.

```typescript
test('Derived fields example test', () => {
  let mainAccount = new GraphAccount('12')
  mainAccount.save()
  let operatedAccount = new GraphAccount('1')
  operatedAccount.operators = ['12']
  operatedAccount.save()
  let nst = new NameSignalTransaction('1234')
  nst.signer = '12'
  nst.save()

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  mainAccount = GraphAccount.load('12')!

  assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
  assert.stringEquals('1', mainAccount.operatorOf[0])
})
```

### Testov√°n√≠ dynamick√Ωch zdroj≈Ø dat

Testov√°n√≠ dynamick√Ωch zdroj≈Ø dat lze prov√©st pomoc√≠ posmƒõchu n√°vratov√© hodnoty funkc√≠ `context()`, `address()` a `network()` oboru n√°zv≈Ø dataSource. Tyto funkce v souƒçasn√© dobƒõ vracej√≠ n√°sleduj√≠c√≠ hodnoty: `context()` - vrac√≠ pr√°zdnou entitu (DataSourceContext), `address()` - vrac√≠ `0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, `network()` - vrac√≠ `mainnet`. a `createWithContext(...)` jsou zesmƒõ≈°nƒõny tak, ≈æe nic nedƒõlaj√≠, tak≈æe je v testech v≈Øbec nen√≠ t≈ôeba volat. Zmƒõny n√°vratov√Ωch hodnot lze prov√°dƒõt prost≈ôednictv√≠m funkc√≠ jmenn√©ho prostoru `dataSourceMock` v `matchstick-as` (verze 0.3.0+).

P≈ô√≠klad n√≠≈æe:

Nejprve m√°me n√°sleduj√≠c√≠ obsluhu ud√°losti (kter√° byla z√°mƒõrnƒõ p≈ôepracov√°na za √∫ƒçelem p≈ôedveden√≠ posmƒõchu datov√©mu zdroji):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

A pak m√°me test, kter√Ω pou≈æ√≠v√° jednu z metod v oboru n√°zv≈Ø dataSourceMock k nastaven√≠ nov√© n√°vratov√© hodnoty pro v≈°echny funkce dataSource:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

V≈°imnƒõte si, ≈æe na konci je vol√°na funkce dataSourceMock.resetValues(). To proto, ≈æe hodnoty se p≈ôi zmƒõnƒõ pamatuj√≠ a je t≈ôeba je resetovat, pokud se chcete vr√°tit k v√Ωchoz√≠m hodnot√°m.

## Pokryt√≠ test

Pomoc√≠ n√°stroje **Matchstick** mohou v√Ωvoj√°≈ôi podgraf≈Ø spustit skript, kter√Ω vypoƒç√≠t√° pokryt√≠ test≈Ø napsan√Ωch jednotkov√Ωch test.

N√°stroj pro pokryt√≠ test vezme zkompilovan√© bin√°rn√≠ soubory `wasm` a p≈ôevede je na soubory `wat`, kter√© lze pot√© snadno zkontrolovat a zjistit, zda byly zavol√°ny obslu≈æn√© programy definovan√© v souboru `subgraph.yaml`. Vzhledem k tomu, ≈æe pokryt√≠ k√≥du (a testov√°n√≠ jako celek) je v jazyc√≠ch AssemblyScript a WebAssembly ve velmi ran√© f√°zi, nem≈Ø≈æe **Matchstick** kontrolovat pokryt√≠ vƒõtv√≠. M√≠sto toho se spol√©h√°me na tvrzen√≠, ≈æe pokud byla dan√° obslu≈æn√° funkce zavol√°na, byly ud√°lost/funkce pro ni spr√°vnƒõ zesmƒõ≈°nƒõny.

### Po≈æadavky

Chcete-li spustit funkci pokryt√≠ test poskytovanou v n√°stroji **Matchstick**, mus√≠te si p≈ôedem p≈ôipravit nƒõkolik vƒõc√≠:

#### Exportov√°n√≠ zpracovatel≈Ø

Aby **Matchstick** mohl zkontrolovat, kter√© obslu≈æn√© programy jsou spu≈°tƒõny, mus√≠ b√Ωt tyto obslu≈æn√© programy exportov√°ny ze souboru **test**. Tak≈æe nap≈ô√≠klad v na≈°em p≈ô√≠kladu m√°me v souboru gravity.test.ts importov√°n n√°sleduj√≠c√≠ handler:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

Aby byla tato funkce viditeln√° (aby byla obsa≈æena **podle n√°zvu**), mus√≠me ji tak√© exportovat, nap≈ô√≠klad takto:

```typescript
export { handleNewGravatar }
```

### Pou≈æit√≠

Jakmile je v≈°e nastaveno, spus≈•te n√°stroj pro pokryt√≠ test:

```sh
graph test -- -c
```

Do souboru `package.json` m≈Ø≈æete tak√© p≈ôidat vlastn√≠ p≈ô√≠kaz `coverage`, nap≈ô√≠klad takto:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

T√≠m se spust√≠ n√°stroj pro pokryt√≠ a v termin√°lu by se mƒõlo zobrazit nƒõco takov√©ho:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 Ô∏è
Reading generated test modules... üîéÔ∏è

Generating coverage report üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Doba trv√°n√≠ test ve v√Ωstupu protokolu

V√Ωstup protokolu obsahuje dobu trv√°n√≠ test. Zde je p≈ô√≠klad:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Bƒõ≈æn√© chyby p≈ôekladaƒçe

> Kritick√©: Nelze vytvo≈ôit WasmInstance z platn√©ho modulu s kontextem: nezn√°m√Ω import: wasi_snapshot_preview1::fd_write nebyl definov√°n

To znamen√°, ≈æe jste ve sv√©m k√≥du pou≈æili `console.log`, co≈æ nen√≠ podporov√°no jazykem AssemblyScript. Zva≈æte pros√≠m pou≈æit√≠ [Logging API](/developing/assemblyscript-api/#logging-api)

> ERROR TS2554: Expected ? arguments, but got ?.
> 
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
> 
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
> 
> ERROR TS2554: Expected ? arguments, but got ?.
> 
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
> 
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

Neshoda v argumentech je zp≈Øsobena neshodou v `graph-ts` a `matchstick-as`. Nejlep≈°√≠ zp≈Øsob, jak opravit probl√©my, jako je tento, je aktualizovat v≈°e na nejnovƒõj≈°√≠ vydanou verzi.

## Zpƒõtn√° vazba

Pokud m√°te nƒõjak√© dotazy, zpƒõtnou vazbu, po≈æadavky na funkce nebo se jen chcete ozvat, nejl√©pe na Graf Discord, kde m√°me pro Matchstick vyhrazen√Ω kan√°l s n√°zvem üî•| unit-testing.
