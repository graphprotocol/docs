---
title: Indexeren
---

Indexeers zijn node-operators in The Graph Netwerk die Graph Tokens (GRT) inzetten om indexing- en queryverwerkingsdiensten te leveren. Indexeerders verdienen querykosten en indexingsbeloningen voor hun diensten. Ze verdienen ook querykosten die worden terugbetaald volgens een exponentiële functie.

GRT dat in het protocol wordt ingezet, is onderheven aan een ontdooiperiode en kan worden geslashed als Indexers schadelijke acties ondernemen, onjuiste data aan applicaties leveren of als ze onjuist indexeren. Indexers verdienen ook beloningen voor gedelegeerde inzet van Delegators om te contributeren aan het netwerk.

Indexeerders selecteren subgraphs om te indexeren op basis van het curatiesignaal van de subgraph, waar Curatoren GRT inzetten om aan te geven welke subgraphs van hoge kwaliteit zijn en prioriteit moeten krijgen. Consumenten (bijv. applicaties) kunnen ook parameters instellen voor welke Indexeerders queries voor hun subgraphs verwerken en voorkeuren instellen voor de prijs van querykosten.

<Difficulty level="ADVANCED" />

## FAQ

### Wat is de minimale inzet vereist om een Indexeerder op het netwerk te zijn?

De minimale inzet voor een Indexeerder is momenteel vastgesteld op 100K GRT.

### Wat zijn de inkomstenstromen voor een Indexeerder?

**Querykostenrebates** - Betalingen voor het verwerken van queries op het netwerk. Deze betalingen worden bemiddeld via state channels tussen een Indexeerder en een gateway. Elke query-aanvraag van een gateway bevat een betaling en de bijbehorende reactie een bewijs van geldigheid van het queryresultaat.

**Indexeringsbeloningen** - De indexeringsbeloningen worden gegenereerd via de 3% jaarlijkse protocolbrede inflatie en verdeeld onder de Indexeerders die subgraphs voor het netwerk indexeren.

### Hoe worden indexeringsbeloningen verdeeld?

Indexeringsbeloningen komen van de protocolinflatie die is vastgesteld op 3% jaarlijkse uitgifte. Ze worden verdeeld over de subgraphs op basis van de verhouding van al het curatiesignaal, en vervolgens proportioneel verdeeld onder de Indexers op basis van hun toegewezen inzet op die subgraph. **Een allocatie moet worden gesloten met een geldig bewijs van indexering (Proof of Indexing) dat voldoet aan de normen die door het arbitrage charter zijn vastgesteld om in aanmerking te komen voor beloningen. **

Vele hulpmiddelen zijn gecreëerd door de community voor het berekenen van beloningen; je vindt een verzameling ervan georganiseerd in de [Community Guides collectie](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). Je kunt ook een actuele lijst van hulpmiddelen vinden in de #Delegators en #indexers kanalen op de [Discord server](https://discord.gg/graphprotocol). Hier is een link naar de [aanbevolen allocatie optimalisator](https://github.com/graphprotocol/allocation-optimizer) die is geïntegreerd met de Indexeerder-softwarestack.

### Wat is een bewijs van indexering (Proof of Indexing)?

POI's worden in het netwerk gebruikt om te verifiëren dat een indexer aan het indexeren is op de subgraph waaraan zij zijn toegewezen. Een POI voor het eerste blok van de huidige epoch moet opgegeven worden tijdens het sluiten van een allocatie, zodat die allocatie in aanmerking komt voor indexeringsbeloningen. Een POI voor een blok is een verwerking van alle entiteitwinkeltransacties voor een specifieke subgraph-implementatie tot aan en inclusief dat blok.

### Wanneer worden indexeringsbeloningen verdeeld?

Allocaties verzamelen voortdurend beloningen terwijl ze actief zijn tot een maximum duur van 28 epochs. Beloningen worden verzameld door de Indexers en verdeeld wanneer ze hun allocaties sluiten. Dat gebeurt handmatig wanneer de Indexeerder ze wil sluiten of, na 28 epochs kan een Delagator de allocatie voor de Indexeerder sluiten, maar dit resulteerd in geen beloningen. 28 epochs is de maximale duur van een allocatie (momenteel duurt één epoch ongeveer 24 uur).

### Kunnen ongerealiseerde indexeringsbeloningen worden bekeken?

Het RewardsManager-contract heeft een read-only [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316) functie die kan worden gebruikt om te controleren hoeveel ongerealiseerde beloningen er zijn voor een specifieke allocatie.

Veel van de door de community gemaakte dashboards bevatten waarden van ongerealiseerde beloningen en ze kunnen gemakkelijk handmatig worden gecontroleerd door deze stappen te volgen:

1. Query de [mainnet subgraph](https://thegraph.com/hosted-service/subgraph/graphprotocol/graph-network-mainnet) om de ID's te krijgen voor alle actieve allocaties:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Gebruik Etherscan om `getRewards()` aan te roepen:

- Navigeer naar de [Etherscan-interface naar het Rewards-contract](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)

* Om `getRewards()` aan te roepen:
  - Klap het dropdown-menu van **9. getRewards** uit.
  - Voer het **allocationID** in het invoerveld in.
  - Klik op de **Query** knop.

### Wat zijn geschillen en waar kan ik ze bekijken?

Een indexers query's en allocaties kunnen beide betwist worden op The Graph tijdens de dispuutperiode. De dispuutperiode varieert afhankelijk van het type dispuut. Query's/attestaties hebben een 7 epochs dispuutperiode waarbij allocaties 56 epochs hebben. Nadat deze periodes aflopen kunnen disputen niet meer geopnd worde thegen allocaties of query's. Wanneer een dispuut geopend is, is een storting van minimaal 10,000 GRT vereist door de Fisherman, welke vergrendeld zal worden to het dipuut gefinalizeerd is en een resolutie gegeven is. Fisherman zijn alle netwerkdeelnemers die disputen openen.

Disputen hebben **drie** mogelijke uitkomsten, net als de storting van de Fishermen.

- Als het dispuut wordt verworpen, wordt de door de Fishermen gestorte GRT verbrand, en de betwiste Indexeerder zal niet worden geslashed.
- Als het dispuut wordt beoordeeld als een gelijkspel, wordt de storting van de Fishermen teruggestort, en de betwiste Indexeerder zal niet worden geslashed.
- Als het dispuut wordt geaccepteerd, wordt de door de Fishermen gestorte GRT teruggestort, de betwiste Indexeerder zal worden geslashed. De Fishermen ontvangen 50% van de GRT die geslashed is.

Disputen kunnen in de UI op de profielpagina van de Indexeerder onder het tabblad `Disputen` worden bekeken.

### Wat zijn query kosten rebates en wanneer worden ze uitgedeeld?

Querykosten worden verzameld door de gateway en verdeeld aan Indexeerders volgens de exponentiële rebate-functie (zie de GIP [hier](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). De exponentiële rebate-functie is voorgesteld als een manier om ervoor te zorgen dat Indexeerders het beste resultaat behalen door trouw query's te verwerken. Het werkt door het voor Indexeerders aantrekkelijk the maken om een grote hoeveelheid in te zetten (die kan worden geslashed voor fouten bij het verwerken van een query) in verhouding tot de hoeveelheid querykosten die ze kunnen innen.

Zodra een allocatie is gesloten, zijn de rebates beschikbaar om door de Indexeerder te worden geclaimd. Bij het claimen worden de query rebates verdeeld aan de Indexeerder en hun Delegators op basis van de query fee cut en de exponentiële rebate-functie.

### Wat is de Query Fee Cut en de Indexing Reward Cut?

De `queryFeeCut` en `indexingRewardCut` waarden zijn delegatie parameters die de Indexer kan instellen samen met de cooldownBlocks om de verdeling GRT te controleren tussen de Indexer en hun Delegators. Zie de laatste stappen in [Inzetten in het Protocol](/network/indexing#stake-in-the-protocol) voor instructies op delegatie parameters in the stellen.

- **queryFeeCut** - het % van de query kosten rebates die worden verdeeld aan de Indexeerder. Als dit is ingesteld op 95%, ontvangt de Indexeerder 95% van de query kosten die zijn verdiend wanneer een allocatie wordt gesloten, met de overige 5% gaande naar Delegators.

- **indexingRewardCut** - het % van de indexeringsbeloningen die worden verdeeld aan de Indexeerder. Als dit is ingesteld op 95%, ontvangt de Indexeerder 95% van de indexeringsbeloningen wanneer een allocatie wordt gesloten, met de overige 5% verdeeld onder de Delegators.

### Hoe weten Indexeerders welke subgraphs te indexeren?

Indexeerders kunnen zich onderscheiden door geavanceerde technieken toe te passen bij het maken van beslissingen over subgraph indexering maar om een algemeen idee te geven, bespreken we enkele belangrijke meetpunten die worden gebruikt om subgraphs te evalueren in het netwerk:

- **Curatie Signaal** - De proportie van het netwerk curatie signaal dat is gesignaleerd op een bepaalde subgraph is een goede indicator van de interesse in die subgraph, vooral tijdens de bootstrap fase wanneer het query volume toeneemt.

- **Verzamelde query kosten** - De historische data voor het volume van verzamelde query kosten voor een specifieke subgraph is een goede indicator voor toekomstige vraag.

- **Hoeveelheid inzet** - Het monitoren van het gedrag van andere Indexeerders of het bekijken van verhoudingen van het totaal aan inzet naar specifieke subgraphs kan een Indexeerder helpen de aanbodzijde voor subgraph query's te monitoren om subgraphs te identificeren waarin het netwerk vertrouwen toont of subgraphs die mogelijk meer aanbod nodig hebben.

- **Subgraphs zonder indexeringsbeloningen** - Sommige subgraphs genereren geen indexeringsbeloningen, meestal omdat ze niet-ondersteunde functies zoals IPFS gebruiken of query's versturen naar een netwerk buiten het mainnet. Je zult een bericht zien op een subgraph als deze geen indexeringsbeloningen genereert.

### Wat zijn de hardware vereisten?

- **Klein** - Genoeg om te beginnen met het indexeren van enkele subgraphs, zal waarschijnlijk uitgebreid moeten worden.
- **Standaard** - Standaard setup, dit wordt gebruikt in het voorbeeld k8s/terraform uitvoeringsmanifest.
- **Middel** - Indexer die 100 subgraphs ondersteund en 200-500 query's per seconde verwerkt.
- **Groot** - Voorbereid om alle momenteel gebruikte subgraphs te indexeren en de bijbehorende query's te verwerken.

| Setup     | Postgres<br />(CPUs) | Postgres<br />(Geheugen in GBs) | Postgres<br />(schijf in TBs) | VMs<br />(CPUs) | VMs<br />(geheugen in GBs) |
| --------- |:--------------------------:|:-------------------------------------:|:-----------------------------------:|:---------------------:|:--------------------------------:|
| Klein     |             4              |                   8                   |                  1                  |           4           |                16                |
| Standaard |             8              |                  30                   |                  1                  |          12           |                48                |
| Middel    |             16             |                  64                   |                  2                  |          32           |                64                |
| Groot     |             72             |                  468                  |                 3.5                 |          48           |               184                |

### Wat zijn enkele basisveiligheidsmaatregelen die een Indexeerder moet nemen?

- **Operator wallet** - Het opzetten van een operator wallet is een belangrijke voorzorgsmaatregel omdat het een Indexeerder in staat stelt om scheiding te behouden tussen de sleutels die de GRT beheren en degenen die de dagelijkse operaties beheren. Zie [Inzet in het Protocol](/network/indexing#stake-in-the-protocol) voor instructies.

- **Firewall** - Alleen de Indexer service hoeft openbaar te worden blootgesteld en er moet extra aandacht worden besteed aan het vergrendelen van de admin poorten en database toegang: de Graph Node Jason-RPC endpoint (standaardpoort: 8030), de Indexer management API endpoint (standaardpoort: 18000), en de Postgres database endpoint (standaardpoort: 5432) mogen niet worden blootgesteld.

## Infrastructuur

Het hart van de infrastructuur van een Indexeerder is de Graph Node, die de geïndexeerde netwerken monitort, data extract en laadt volgens een subgraphdefinitie en deze dient als een [GraphQL API](/about/#how-the-graph-works). De Graph Node moet verbonden zijn met een eindpunt dat gegevens van elke geïndexeerd netwerk blootstelt; een IPFS-node voor het verkrijgen van data, een PostgreSQL database voor de opslag; en de Indexer-componenten die de interacties met het netwerk faciliteren.

- **PostgreSQL database** - De hoofdopslag voor de Graph Node, hier wordt subgraph data opgeslagen. De Indexer-service en -agent gebruiken de database ook om gegevens van state channels, kostenmodellen, indexatieregels en allocatieacties op te slaan.

- **Data eindpunt** Voor EVM-compatibele netwerken moet de Graph Node verbonden zijn met een eindpunt dat een EVM-compatibele JSON-RPC API blootstelt. Dit kan de vorm aannemen van een enkele client of een complexere setup die de belasting verdeeld over meerdere clients. Het is belangrijk om te weten dat sommige subgraphs specifieke eisen hebben voor de client, zoals archiefmodus en/of de parity tracing API.

- **IPFS node (versie lager dan 5)** - Subgraph implementatie metadata is opgeslagen op het IPFS netwerk. De Graph Node communiceert voornamelijk met de IPFS-node tijdens de implementatie van subgraphs om het subgraph manifest en alle gelinkte bestanden op te vragen. Netwerk Indexers hoeven geen eigen IPFS-node te hosten, een IPFS-node voor het netwerk wordt gehost op https://ipfs.network.thegraph.com.

- **Indexer service** - Beheert alle vereiste externe communicatie met het netwerk. Deelt kostenmodellen en indexeerstatussen, stuurt query's van gateways door naar een Graph Node en beheert de query betalingen via state channels met de gateway.

- **Indexer agent** - Faciliteert de interacties van de Indexeerders op de chain, inclusief registratie op het netwerk, beheer van subgraph implementaties op de Graph Node(s) en beheer van allocaties.

- **Prometheus metrics-server** - De Graph Node en Indexer-componenten versturen hun metrics naar de metrics-server.

Tip: Om wendbare schaalvergroting te ondersteunen, wordt aanbevolen om Query- en Indexeringszaken te scheiden tussen verschillende sets nodes: Query Nodes en Index Nodes.

### Poorten overzicht

> **Belangrijk**: Wees voorzichtig met het openbaar blootstellen van poorten - **admin poorten** moeten vergrendeld blijven. Dit is inclusief de Graph Node JSON-RPC en de Indexer management endpoints, zoals hieronder beschreven.

#### Graph Node

| Poort | Doel                                                      | Routes                                               | CLI-Argument      | Omgevingsvariabele |
| ----- | --------------------------------------------------------- | ---------------------------------------------------- | ----------------- | ------------------ |
| 8000  | GraphQL HTTP server<br />(voor subgraph query's)    | /subgraphs/id/...<br />/subgraphs/name/.../... | --http-port       | -                  |
| 8001  | GraphQL WS<br />(voor subgraph abonnementen)        | /subgraphs/id/...<br />/subgraphs/name/.../... | --ws-port         | -                  |
| 8020  | JSON-RPC<br />(voor het beheren van implementaties) | /                                                    | --admin-port      | -                  |
| 8030  | Subgraph indexeerstatus API                               | /graphql                                             | --index-node-port | -                  |
| 8040  | Prometheus metrics                                        | /metrics                                             | --metrics-port    | -                  |

#### Indexer Service

| Poort | Doel                                                            | Routes                                                                  | CLI-Argument   | Omgevingsvariabele     |
| ----- | --------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------- | ---------------------- |
| 7600  | GraphQL HTTP server<br />(voor betaalde subgraph query's) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | --port         | `INDEXER_SERVICE_PORT` |
| 7300  | Prometheus metrics                                              | /metrics                                                                | --metrics-port | -                      |

#### Indexer Agent

| Poort | Doel                   | Routes | CLI-Argument              | Omgevingsvariabele                      |
| ----- | ---------------------- | ------ | ------------------------- | --------------------------------------- |
| 8000  | Indexer management API | /      | --indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Het opzetten van server infrastructuur met Terraform op Google Cloud

> Let op: Indexeerders kunnen als alternatief AWS, Microsoft Azure or Alibaba gebruiken.

#### Installeer vereisten

- Google Cloud SDK
- Kubectl command line tool
- Terraform

#### Maak een Google Cloud project aan

- Kloon of navigeer naar de [ Indexer repository](https://github.com/graphprotocol/indexer).

- Navigeer naar de `./terraform` map, dit is waar alle commando's moeten worden uitgevoerd.

```sh
cd terraform
```

- Authenticeer met Google Cloud en maak een nieuw project.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Gebruik de factureringspagina van Google Cloud Console om facturering voor het nieuwe project in te schakelen.

- Maak een Google Cloud configuratie.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Schakel de vereiste Google Cloud API's in.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Maak een serviceaccount.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Schakel peering in tussen de database en de Kubernetes cluster die in de volgende stap wordt gemaakt.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Maak het minimaal terraform-configuratiebestand (update indien nodig).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database passowrd>"
EOF
```

#### Gebruik Terraform om infrastructuur te creëren

Voordat commandos worden uitgevoerd, lees [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) door en maak een bestand genaamd `terraform.tfvars` in deze map (of pas het bestand dat is gemaakt in de laatste stap aan). Voer voor elke variable waar u de standaard wilt overschrijven of waar u waarde moet instellen, een waarde in `terraform.tfvars` in.

- Voer de volgende commandos in om de infrastructuur te creëren.

```sh
# Installeer vereiste plug-ins
terraform init

# Bekijk het plan voor bronnen die gecreëerd worden
terraform plan

# Creëer de bronnen (verwacht dat het tot 30 minuten duurt)
terraform apply
```

Download de inloggegevens voor de nieuwe cluster in `~/.kube/config` en stel het in als uw standaardcontext.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Creëer de Kubernetes-componenten voor de Indexer

- Kopieer de map `k8s/overlays` naar een nieuwe map `$dir,` en pas de `bases` invoer in `$dir/kustomization.yaml` aan zodat deze wijst naar de map `k8s/base`.

- Lees alle bestanden in `$dir` door en pas eventueel waarden aan zoals aangegeven in de opmerkingen.

Implementeer alle bronnen met `kubectl apply -k $dir`.

### Graph Node

[Graph Node](https://github.com/graphprotocol/graph-node) is een open source Rust-implementatie die de data van de Ethereum blockchain deterministisch update naar een database, zodat de data kan worden opgevraagd via het GraphQL eindpunt. Developers gebruiken subgraphs om hun schema te creëren, een reeks mappings voor het transformeren van de blockchain data, en Graph Node synchroniseerd de volledige blockchain, monitort voor een aantal nieuwe blocks, en verwerkt dit via een GraphQL eindpunt.

#### Starten vanuit source

#### Installeer vereisten

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Aanvullende vereisten voor Ubuntu gebruikers** - Om een Graph Node op Ubuntu te laten werken, zijn mogelijke enkele aanvullende updates nodig.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Setup

1. Start een PostgreSQL database server

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Kloon de [Graph Node](https://github.com/graphprotocol/graph-node) map en bouw de bron door `cargo build` uit te voeren

3. Nu alle afhankelijkheden zijn ingesteld, start de Graph Node:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Starten met Docker

#### Vereisten

- **Ethereum node** - De docker compose setup zal als standaard mainnet gebruiken: gebruik [http://host.docker.internal:8545](http://host.docker.internal:8545) om verbinding te maken met de Ethereum node op uw host machine.U kunt deze netwerknaam en url vervangen door `docker-compose.yaml` bij te werken.

#### Setup

1. Kloon Graph Node en navigeer naar de Docker map:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Alleen voor Linux gebruikers - Gebruik het IP-adres van de host in plaats van `host.docker.internal` in de `docker-compose.yaml` door dit script uit te voeren:

```sh
./setup.sh
```

3. Start een lokale Graph Node die verbeiding maakt met uw Ethereum endpoint:

```sh
docker-compose up
```

### De componenten van de Indexer

Om succesvol deel te nemen aan het netwerk is bijna constante monitoring en interactie nodig, dus we hebben een reeks Typescript applicaties ontwikkeld om deelname van Indexeerders aan het netwerk te vergemakkelijken. De indexer heeft drie componenten:

- **Indexer agent** - De agent monitort het netwerk en de Indexers eigen infrastructuur en beheert welke subgraph implementaties worden geïndexeerd en allocaties naar on chain en hoe veel naar elk toegewezen wordt.

- **Indexer service** - Het enige component dat extern moet worden blootgesteld. De Indexer service geeft subgraph query's door aan de Graph Node, beheert state channels voor betalingen van query's en deelt belangrijke besluitvormingsinformatie met cliënten zoals de gateways.

- **Indexer CLI** - De command line interface voor het beheren van de Indexer agent. Hiermee kunnen Indexeerders kostenmodellen, handmatige allocaties, wachtrijen voor acties en regels voor het indexeren beheren.

#### Aan de slag

De indexer agent en indexer service moeten zich op de zelfde locatie bevinden als de Graph Node. Er zijn vele manieren om de virtuele uitvoeromgeving voor uw indexer-componenten op te zetten; we zullen uitleggen hoe ze op baremetal uit te voeren zijn met NPM-pakketten of de source code, of via Kubernetes en Docker op de Google Cloud Kubernetes Engine. Als deze voorbeelden niet goed zullen werken op uw infrastructuur, is er waarschijnlijk een community guide om als alternatief te gebruiken. Kom gerust hallo zeggen op [Discord](https://discord.gg/graphprotocol)! Onthoud om [GRT in the zetten](/network/indexing#stake-in-the-protocol) in het protocol voordat u uw indexer-componenten start!

#### Met NPM-pakketten

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is een plug-in voor Graph CLI, dus beide moeten worden geïnstalleerd:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
# Stuur de poort van uw agent pod door als u Kubernetes gebruikt
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### Met source-code

```sh
# Vanuit de hoofdmap van de repository
yarn

# Indexer service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Met Docker

- Haal de images uit het register

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Of bouw imagines lokaal vanuit source

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Zet de componenten aan

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**OPMERKING**: Na het starten van de containers, moet de Indexer service toegankelijk zijn op [http://localhost:7600](http://localhost:7600) en de Indexer agent zou de Indexer management API moeten bloodstellen op [http://localhost:18000/](http://localhost:18000/).

#### Met K8s en Terraform

Zie de sectie [Infrastructuur van de server instellen met behulp van Terraform op Google Cloud](/network/indexing#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Gebruik

> **OPMERKING**: Alle configuratievariabelen tijdens runtime kunnen worden toegepast als parameters bij het opstartcommando of met behulp van omgevingsvariabelen in het format `COMPONENT_NAME_VARIABLE_NAME`(bijv. `INDEXER_AGENT_ETHEREUM`).

#### Indexer Agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer Service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  | pino-pretty
```

#### Indexer CLI

De Indexer CLI is een plug-in voor [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) toegankelijk in de terminal op `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Indexer management using Indexer CLI

The suggested tool for interacting with the **Indexer Management API** is the **Indexer CLI**, an extension to the **Graph CLI**. The Indexer agent needs input from an Indexer in order to autonomously interact with the network on the behalf of the Indexer. The mechanism for defining Indexer agent behavior are **allocation management** mode and **indexing rules**. Under auto mode, an Indexer can use **indexing rules** to apply their specific strategy for picking subgraphs to index and serve queries for. Rules are managed via a GraphQL API served by the agent and known as the Indexer Management API. Under manual mode, an Indexer can create allocation actions using **actions queue** and explicitly approve them before they get executed. Under oversight mode, **indexing rules** are used to populate **actions queue** and also require explicit approval for execution.

#### Usage

The **Indexer CLI** connects to the Indexer agent, typically through port-forwarding, so the CLI does not need to run on the same server or cluster. To help you get started, and to provide some context, the CLI will briefly be described here.

- `graph indexer connect <url>` - Connect to the Indexer management API. Typically the connection to the server is opened via port forwarding, so the CLI can be easily operated remotely. (Example: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Get one or more indexing rules using `all` as the `<deployment-id>` to get all rules, or `global` to get the global defaults. An additional argument `--merged` can be used to specify that deployment specific rules are merged with the global rule. This is how they are applied in the Indexer agent.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Set one or more indexing rules.

- `graph indexer rules start [options] <deployment-id>` - Start indexing a subgraph deployment if available and set its `decisionBasis` to `always`, so the Indexer agent will always choose to index it. If the global rule is set to always then all available subgraphs on the network will be indexed.

- `graph indexer rules stop [options] <deployment-id>` - Stop indexing a deployment and set its `decisionBasis` to never, so it will skip this deployment when deciding on deployments to index.

- `graph indexer rules maybe [options] <deployment-id>` — Set the `decisionBasis` for a deployment to `rules`, so that the Indexer agent will use indexing rules to decide whether to index this deployment.

- `graph indexer actions get [options] <action-id>` - Fetch one or more actions using `all` or leave `action-id` empty to get all actions. An additonal argument `--status` can be used to print out all actions of a certain status.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Queue allocation action

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Queue reallocate action

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Queue unallocate action

- `graph indexer actions cancel [<action-id> ...]` - Cancel all action in the queue if id is unspecified, otherwise cancel array of id with space as separator

- `graph indexer actions approve [<action-id> ...]` - Approve multiple actions for execution

- `graph indexer actions execute approve` - Force the worker to execute approved actions immediately

All commands which display rules in the output can choose between the supported output formats (`table`, `yaml`, and `json`) using the `-output` argument.

#### Indexing rules

Indexing rules can either be applied as global defaults or for specific subgraph deployments using their IDs. The `deployment` and `decisionBasis` fields are mandatory, while all other fields are optional. When an indexing rule has `rules` as the `decisionBasis`, then the Indexer agent will compare non-null threshold values on that rule with values fetched from the network for the corresponding deployment. If the subgraph deployment has values above (or below) any of the thresholds it will be chosen for indexing.

For example, if the global rule has a `minStake` of **5** (GRT), any subgraph deployment which has more than 5 (GRT) of stake allocated to it will be indexed. Threshold rules include `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, and `minAverageQueryFees`.

Data model:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Example usage of indexing rule:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Actions queue CLI

The indexer-cli provides an `actions` module for manually working with the action queue. It uses the **Graphql API** hosted by the indexer management server to interact with the actions queue.

The action execution worker will only grab items from the queue to execute if they have `ActionStatus = approved`. In the recommended path actions are added to the queue with ActionStatus = queued, so they must then be approved in order to be executed on-chain. The general flow will look like:

- Action added to the queue by the 3rd party optimizer tool or indexer-cli user
- Indexer can use the `indexer-cli` to view all queued actions
- Indexer (or other software) can approve or cancel actions in the queue using the `indexer-cli`. The approve and cancel commands take an array of action ids as input.
- The execution worker regularly polls the queue for approved actions. It will grab the `approved` actions from the queue, attempt to execute them, and update the values in the db depending on the status of execution to `success` or `failed`.
- If an action is successful the worker will ensure that there is an indexing rule present that tells the agent how to manage the allocation moving forward, useful when taking manual actions while the agent is in `auto` or `oversight` mode.
- The indexer can monitor the action queue to see a history of action execution and if needed re-approve and update action items if they failed execution. The action queue provides a history of all actions queued and taken.

Data model:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Example usage from source:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Note that supported action types for allocation management have different input requirements:

- `Allocate` - allocate stake to a specific subgraph deployment

  - required action params:
    - deploymentID
    - amount

- `Unallocate` - close allocation, freeing up the stake to reallocate elsewhere

  - required action params:
    - allocationID
    - deploymentID
  - optional action params:
    - poi
    - force (forces using the provided POI even if it doesn’t match what the graph-node provides)

- `Reallocate` - atomically close allocation and open a fresh allocation for the same subgraph deployment

  - required action params:
    - allocationID
    - deploymentID
    - amount
  - optional action params:
    - poi
    - force (forces using the provided POI even if it doesn’t match what the graph-node provides)

#### Cost models

Cost models provide dynamic pricing for queries based on market and query attributes. The Indexer Service shares a cost model with the gateways for each subgraph for which they intend to respond to queries. The gateways, in turn, use the cost model to make Indexer selection decisions per query and to negotiate payment with chosen Indexers.

#### Agora

The Agora language provides a flexible format for declaring cost models for queries. An Agora price model is a sequence of statements that execute in order for each top-level query in a GraphQL query. For each top-level query, the first statement which matches it determines the price for that query.

A statement is comprised of a predicate, which is used for matching GraphQL queries, and a cost expression which when evaluated outputs a cost in decimal GRT. Values in the named argument position of a query may be captured in the predicate and used in the expression. Globals may also be set and substituted in for placeholders in an expression.

Example cost model:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Example query costing using the above model:

| Query                                                                        | Price   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#123; tokens &#125; symbol &#125; &#125; | 0.6 GRT |

#### Applying the cost model

Cost models are applied via the Indexer CLI, which passes them to the Indexer Management API of the Indexer agent for storing in the database. The Indexer Service will then pick them up and serve the cost models to gateways whenever they ask for them.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interacting with the network

### Stake in the protocol

The first steps to participating in the network as an Indexer are to approve the protocol, stake funds, and (optionally) set up an operator address for day-to-day protocol interactions.

> Note: For the purposes of these instructions Remix will be used for contract interaction, but feel free to use your tool of choice ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), and [MyCrypto](https://www.mycrypto.com/account) are a few other known tools).

Once an Indexer has staked GRT in the protocol, the [Indexer components](/network/indexing#indexer-components) can be started up and begin their interactions with the network.

#### Approve tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **GraphToken.abi** with the [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. With `GraphToken.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the GraphToken contract address - Paste the GraphToken contract address (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) next to `At Address` and click the `At address` button to apply.

6. Call the `approve(spender, amount)` function to approve the Staking contract. Fill in `spender` with the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) and `amount` with the tokens to stake (in wei).

#### Stake tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **Staking.abi** with the staking ABI.

3. With `Staking.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the Staking contract address - Paste the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) next to `At Address` and click the `At address` button to apply.

6. Call `stake()` to stake GRT in the protocol.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their indexingRewardCut (parts per million), queryFeeCut (parts per million), and cooldownBlocks (number of blocks). To do so call `setDelegationParameters()`. The following example sets the queryFeeCut to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the indexingRewardCutto distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set `thecooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### Setting delegation parameters

The `setDelegationParameters()` function in the [staking contract](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) is essential for Indexers, allowing them to set parameters that define their interactions with Delegators, influencing their reward sharing and delegation capacity.

### How to set delegation parameters

To set the delegation parameters using Graph Explorer interface, follow these steps:

1. Navigate to [Graph Explorer](https://thegraph.com/explorer/).
2. Connect your wallet. Choose multisig (such as Gnosis Safe) and then select mainnet. Note: You will need to repeat this process for Arbitrum One.
3. Connect the wallet you have as a signer.
4. Navigate to the 'Settings' section and select 'Delegation Parameters'. These parameters should be configured to achieve an effective cut within the desired range. Upon entering values in the provided input fields, the interface will automatically calculate the effective cut. Adjust these values as necessary to attain the desired effective cut percentage.
5. Submit the transaction to the network.

> Note: This transaction will need to be confirmed by the multisig wallet signers.

### The life of an allocation

After being created by an Indexer a healthy allocation goes through four states.

- **Active** - Once an allocation is created on-chain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a subgraph deployment, which allows them to claim indexing rewards and serve queries for that subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - An Indexer is free to close an allocation once 1 epoch has passed ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) or their Indexer agent will automatically close the allocation after the **maxAllocationEpochs** (currently 28 days). When an allocation is closed with a valid proof of indexing (POI) their indexing rewards are distributed to the Indexer and its Delegators ([learn more](/network/indexing/#how-are-indexing-rewards-distributed)).

Indexers are recommended to utilize offchain syncing functionality to sync subgraph deployments to chainhead before creating the allocation on-chain. This feature is especially useful for subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
