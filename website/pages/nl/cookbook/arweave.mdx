---
title: Bouwen van Subgraphs op Arweave
---

> Arweave support in Graph Node and on Subgraph Studio is in beta: please reach us on [Discord](https://discord.gg/graphprotocol) with any questions about building Arweave subgraphs!

In deze gids, zul je leren hoe je Subgraphs bouwt en implementeer om de Arweave blockchain te indexeren.

## Wat is Arweave?

Het Arweave protocol stelt ontwikkelaars in staat om gegevens permanent op te slaan, dat is het voornaamste verschil tussen Arweave en IPFS, waar IPFS deze functie mist, en bestanden die op Arweave zijn opgeslagen, kunnen niet worden gewijzigd of verwijderd.

Arweave heeft al talloze bibliotheken gebouwd voor het integreren van het protocol in verschillende programmeertalen. Voor meer informatie kun je kijken op:

- [Arwiki](https://arwiki.wiki/#/en/main)
- [Arweave Bronnen](https://www.arweave.org/build)

## Wat zijn Arweave Subgraphs?

The Graph stelt je in staat om aangepaste open API's genaamd "Subgraphs" te bouwen. Subgraphs worden gebruikt om indexers (serveroperators) te vertellen welke gegevens ze moeten indexeren op een blockchain en op hun servers moeten opslaan, zodat je deze op elk gewenst moment kunt opvragen met behulp van [GraphQL](https://graphql.org/).

[Graph Node](https://github.com/graphprotocol/graph-node) kan nu gegevens indexeren op het Arweave protocol. De huidige integratie indexeert alleen Arweave als een blockchain (blokken en transacties), het indexeert nog niet de opgeslagen bestanden.

## Bouwen van een Arweave Subgraph

Voor het kunnen bouwen en implementeren van Arweave Subgraphs, heb je twee paketten nodig:

1. `@graphprotocol/graph-cli` hierboven versie 0.30.2 - dit is een command-line tool voor het bouwen en implementeren van Subgraphs. [Klik hier](https://www.npmjs.com/package/@graphprotocol/graph-cli) voor het downloaden door middel van `npm`.
2. `@graphprotovol/graph-ts` hierboven versie 0.27.0 - Dit is een bibliotheek van subgeraph-specifieke types. [Klik hier](https://www.npmjs.com/package/@graphprotocol/graph-ts) voor het downloaden door middel van `npm`.

## Subgraph's componenten

Er zijn drie componenten van een subgraph:

### 1. Manifest - `subgraph.yaml`

Definieert gegevensbronnen die van belang zijn en hoe deze verwerkt moeten worden. Arweave is een nieuw type gegevensbron.

### 2. Schema - `schema.graphql`

Hier definieer je welke gegevens je wilt kunnen opvragen na het indexeren van je subgraph door het gebruik van GraphQL. Dit lijkt eigenlijk op een model voor een API, waarbij het model de structuur van een verzoek definieert.

De benodigdheden voor Arweave subgraphs zijn gedekt door de [bestaande documentatie](/developing/creating-a-subgraph/#the-graphql-schema).

### 3. AssemblyScript Toewijzingen - `mapping.ts`

Dit is de logica die definieert hoe data zou moeten worden opgevraagd en opgeslagen wanneer iemand met de gegevens communiceert waarnaar jij aan het luisteren bent. De gegevens worden vertaald en is opgeslagen gebaseerd op het schema die je genoteerd hebt.

Tijdens subgraph ontwikkeling zijn er twee belangrijke commando's:

```
$ graph codegen # genereert types van het schema bestand die geÃ¯dentificeerd is in het manifest
$ graph build # genereert Web Assembly vanuit de AssemblyScript-bestanden, en bereidt alle Subgraph-bestanden voor in een /build map
```

## Subgraph Manifest Definitie

De subgraph manifest `subgraph.yaml` identificeert de gegevens bronnen voor de subgraph, de trekkers van interesse, en de functies die moeten worden uitgevoerd als antwoord op die trekkers. Zie hieronder voor een voorbeeld subgraph manifest voor een Arweave Subgraph:

```yaml
specVersie: 0.0.5
omschrijving: Arweave Blocks Indexing
schema:
  bestand: ./schema.graphql # link to the schema file
dataSources:
  - type: arweave
    naam: arweave-blocks
    netwerk: arweave-mainnet # The Graph only supports Arweave Mainnet
    bron:
      eigenaar: 'ID-OF-AN-OWNER' # The public key of an Arweave wallet
      startBlock: 0 # set this to 0 to start indexing from chain genesis
    toewijzing:
      apiVersie: 0.0.5
      taal: wasm/assemblyscript
      bestand: ./src/blocks.ts # link to the file with the Assemblyscript mappings
      entiteit:
        - Block
        - Transaction
      blockAfhandelaar:
        - afhandelaar: handleBlock # the function name in the mapping file
      transactieAfhandelaar:
        - afhandelaar: handleTx # the function name in the mapping file
```

- Arweave subgraphs introduceert een nieuw type data bron (`arweave`)
- The network should correspond to a network on the hosting Graph Node. In Subgraph Studio, Arweave's mainnet is `arweave-mainnet`
- Arweave data bronnen introduceert een optionele bron.eigenaar veld, dat de openbare sleutel is van een Arweave wallet

Arweave data bronnen ondersteunt twee typen verwerkers:

- `blockHandlers` - Draait op elk nieuw Arweave block. Geen enkele bron.eigenaar is vereist.
- `transactieVerwerker` - Draait op elke transactie waarbij de data brons `bron.eigenaar` de eigenaar is. Momenteel is een eigenaar vereist voor `transactieVerwerker`, als gebruikers alle transacties willen verwerken moeten zij aanbieden als de `bron.eigenaar`

> The source.owner can be the owner's address, or their Public Key.

> Transactions are the building blocks of the Arweave permaweb and they are objects created by end-users.

> Note: [Irys (previously Bundlr)](https://irys.xyz/) transactions are not supported yet.

## Schema Definition

Schema definition describes the structure of the resulting subgraph database and the relationships between entities. This is agnostic of the original data source. There are more details on the subgraph schema definition [here](/developing/creating-a-subgraph/#the-graphql-schema).

## AssemblyScript Mappings

The handlers for processing events are written in [AssemblyScript](https://www.assemblyscript.org/).

Arweave indexing introduces Arweave-specific data types to the [AssemblyScript API](/developing/assemblyscript-api/).

```tsx
class Block {
  timestamp: u64
  lastRetarget: u64
  height: u64
  indepHash: Bytes
  nonce: Bytes
  previousBlock: Bytes
  diff: Bytes
  hash: Bytes
  txRoot: Bytes
  txs: Bytes[]
  walletList: Bytes
  rewardAddr: Bytes
  tags: Tag[]
  rewardPool: Bytes
  weaveSize: Bytes
  blockSize: Bytes
  cumulativeDiff: Bytes
  hashListMerkle: Bytes
  poa: ProofOfAccess
}

class Transaction {
  format: u32
  id: Bytes
  lastTx: Bytes
  owner: Bytes
  tags: Tag[]
  target: Bytes
  quantity: Bytes
  data: Bytes
  dataSize: Bytes
  dataRoot: Bytes
  signature: Bytes
  reward: Bytes
}
```

Block handlers receive a `Block`, while transactions receive a `Transaction`.

Writing the mappings of an Arweave Subgraph is very similar to writing the mappings of an Ethereum Subgraph. For more information, click [here](/developing/creating-a-subgraph/#writing-mappings).

## Deploying an Arweave Subgraph in Subgraph Studio

Once your subgraph has been created on your Subgraph Studio dashboard, you can deploy by using the `graph deploy` CLI command.

```bash
graph deploy --studio --access-token <your-access-token>
```

## Querying an Arweave Subgraph

The GraphQL endpoint for Arweave subgraphs is determined by the schema definition, with the existing API interface. Please visit the [GraphQL API documentation](/querying/graphql-api/) for more information.

## Example Subgraphs

Here is an example subgraph for reference:

- [Example subgraph for Arweave](https://github.com/graphprotocol/graph-tooling/tree/main/examples/arweave-blocks-transactions)

## FAQ

### Can a subgraph index Arweave and other chains?

No, a subgraph can only support data sources from one chain/network.

### Can I index the stored files on Arweave?

Currently, The Graph is only indexing Arweave as a blockchain (its blocks and transactions).

### Can I identify Bundlr bundles in my subgraph?

This is not currently supported.

### How can I filter transactions to a specific account?

The source.owner can be the user's public key or account address.

### What is the current encryption format?

Data is generally passed into the mappings as Bytes, which if stored directly is returned in the subgraph in a `hex` format (ex. block and transaction hashes). You may want to convert to a `base64` or `base64 URL`-safe format in your mappings, in order to match what is displayed in block explorers like [Arweave Explorer](https://viewblock.io/arweave/).

The following `bytesToBase64(bytes: Uint8Array, urlSafe: boolean): string` helper function can be used, and will be added to `graph-ts`:

```
const base64Alphabet = [
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
    "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
    "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64UrlAlphabet = [
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
    "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
    "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
];

function bytesToBase64(bytes: Uint8Array, urlSafe: boolean): string {
    let alphabet = urlSafe? base64UrlAlphabet : base64Alphabet;

    let result = '', i: i32, l = bytes.length;
    for (i = 2; i < l; i += 3) {
        result += alphabet[bytes[i - 2] >> 2];
        result += alphabet[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
        result += alphabet[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
        result += alphabet[bytes[i] & 0x3F];
    }
    if (i === l + 1) { // 1 octet yet to write
        result += alphabet[bytes[i - 2] >> 2];
        result += alphabet[(bytes[i - 2] & 0x03) << 4];
        if (!urlSafe) {
            result += "==";
        }
    }
    if (!urlSafe && i === l) { // 2 octets yet to write
        result += alphabet[bytes[i - 2] >> 2];
        result += alphabet[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
        result += alphabet[(bytes[i - 1] & 0x0F) << 2];
        if (!urlSafe) {
            result += "=";
        }
    }
    return result;
}
```
