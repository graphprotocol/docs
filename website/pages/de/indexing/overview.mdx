---
title: Indizierung Überblick
---

Indexer sind Knotenbetreiber im Graph Network, die Graph Tokens (GRT) einsetzen, um Indizierungs- und Abfrageverarbeitungsdienste anzubieten. Indexer verdienen Abfragegebühren und Indexing Rewards für ihre Dienste. Sie verdienen auch Abfragegebühren, die gemäß einer exponentiellen Rabattfunktion zurückerstattet werden.

GRT that is staked in the protocol is subject to a thawing period and can be slashed if Indexers are malicious and serve incorrect data to applications or if they index incorrectly. Indexers also earn rewards for delegated stake from Delegators, to contribute to the network.

Indexers select subgraphs to index based on the subgraph’s curation signal, where Curators stake GRT in order to indicate which subgraphs are high-quality and should be prioritized. Consumers (eg. applications) can also set parameters for which Indexers process queries for their subgraphs and set preferences for query fee pricing.

<Difficulty level="ADVANCED" />

## FAQ

### What is the minimum stake required to be an Indexer on the network?

The minimum stake for an Indexer is currently set to 100K GRT.

### What are the revenue streams for an Indexer?

**Abfragegebühren-Rabatte** - Zahlungen für die Bedienung von Abfragen im Netz. Diese Zahlungen werden über Statuskanäle zwischen einem Indexer und einem Gateway vermittelt. Jede Abfrageanfrage eines Gateways enthält eine Zahlung und die entsprechende Antwort einen Nachweis für die Gültigkeit des Abfrageergebnisses.

**Rewards für die Indizierung** - Die Rewards für die Indizierung werden über eine jährliche protokollweite Inflation von 3% an Indexer verteilt, die Subgraphen für das Netzwerk indizieren.

### How are indexing rewards distributed?

Die Rewards für die Indizierung stammen aus der Protokollinflation, die auf 3 % pro Jahr festgelegt ist. Sie werden auf Subgraphen verteilt, basierend auf dem Anteil aller Kurationssignale auf jedem Subgraphen, und dann anteilig an Indexer verteilt, basierend auf ihrem zugewiesenen Anteil auf diesem Subgraphen. **Eine Zuteilung muss mit einem gültigen Indizierungsnachweis (proof of indexing - POI) abgeschlossen werden, der die in der Schlichtungscharta festgelegten Standards erfüllt, um für Rewards in Frage zu kommen.**

Numerous tools have been created by the community for calculating rewards; you'll find a collection of them organized in the [Community Guides collection](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). You can also find an up to date list of tools in the #Delegators and #Indexers channels on the [Discord server](https://discord.gg/graphprotocol). Here we link a [recommended allocation optimiser](https://github.com/graphprotocol/allocation-optimizer) integrated with the indexer software stack.

### What is a proof of indexing (POI)?

POIs are used in the network to verify that an Indexer is indexing the subgraphs they have allocated on. A POI for the first block of the current epoch must be submitted when closing an allocation for that allocation to be eligible for indexing rewards. A POI for a block is a digest for all entity store transactions for a specific subgraph deployment up to and including that block.

### When are indexing rewards distributed?

Allocations are continuously accruing rewards while they're active and allocated within 28 epochs. Rewards are collected by the Indexers, and distributed whenever their allocations are closed. That happens either manually, whenever the Indexer wants to force close them, or after 28 epochs a Delegator can close the allocation for the Indexer, but this results in no rewards. 28 epochs is the max allocation lifetime (right now, one epoch lasts for ~24h).

### Can pending indexing rewards be monitored?

Der RewardsManager-Vertrag verfügt über eine schreibgeschützte Funktion [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316), mit der die ausstehenden Rewards für eine bestimmte Zuweisung überprüft werden können.

Many of the community-made dashboards include pending rewards values and they can be easily checked manually by following these steps:

1. Fragen Sie den [Mainnet-Subgraphen](https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one) ab, um die IDs für alle aktiven Zuweisungen zu erhalten:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Verwenden Sie Etherscan, um `getRewards()` aufzurufen:

- Navigieren Sie zu [Etherscan-Schnittstelle zu Rewards-Vertrag](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)

<!---->

- Um `getRewards()` aufzurufen:
  - Erweitern Sie das Dropdown-Menü **9. getRewards**.
  - Geben Sie die **allocationID** in die Eingabe ein.
  - Klicken Sie auf die Schaltfläche **Abfrage**.

### Was sind Streitigkeiten und wo kann ich sie einsehen?

Indexer's queries and allocations can both be disputed on The Graph during the dispute period. The dispute period varies, depending on the type of dispute. Queries/attestations have 7 epochs dispute window, whereas allocations have 56 epochs. After these periods pass, disputes cannot be opened against either of allocations or queries. When a dispute is opened, a deposit of a minimum of 10,000 GRT is required by the Fishermen, which will be locked until the dispute is finalized and a resolution has been given. Fisherman are any network participants that open disputes.

Bei Streitigkeiten gibt es **drei** mögliche Ergebnisse, so auch bei der Kaution der Fischer.

- If the dispute is rejected, the GRT deposited by the Fishermen will be burned, and the disputed Indexer will not be slashed.
- If the dispute is settled as a draw, the Fishermen's deposit will be returned, and the disputed Indexer will not be slashed.
- If the dispute is accepted, the GRT deposited by the Fishermen will be returned, the disputed Indexer will be slashed and the Fishermen will earn 50% of the slashed GRT.

Disputes can be viewed in the UI in an Indexer's profile page under the `Disputes` tab.

### What are query fee rebates and when are they distributed?

Die Abfragegebühren werden vom Gateway eingezogen und gemäß der exponentiellen Rabattfunktion an die Indexer verteilt (siehe GIP [hier](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). Die exponentielle Rabattfunktion wird vorgeschlagen, um sicherzustellen, dass Indexer das beste Ergebnis erzielen, indem sie Abfragen treu bedienen. Sie schafft Anreize für Indexer, einen hohen Einsatz (der bei Fehlern bei der Bedienung einer Anfrage gekürzt werden kann) im Verhältnis zur Höhe der Abfragegebühren, die sie einnehmen können, bereitzustellen.

Sobald eine Zuteilung abgeschlossen ist, können die Rabatte vom Indexer beansprucht werden. Nach der Beantragung werden die Abfragegebührenrabatte auf der Grundlage der Abfragegebührenkürzung und der exponentiellen Rabattfunktion an den Indexer und seine Delegatoren verteilt.

### What is query fee cut and indexing reward cut?

Die Werte `queryFeeCut` und `indexingRewardCut` sind Delegationsparameter, die der Indexer zusammen mit cooldownBlocks setzen kann, um die Verteilung von GRT zwischen dem Indexer und seinen Delegatoren zu kontrollieren. Siehe die letzten Schritte in [Staking im Protokoll](/indexing/overview/#stake-in-the-protocol) für Anweisungen zur Einstellung der Delegationsparameter.

- **queryFeeCut** - der Prozentsatz der Rückerstattungen von Abfragegebühren, der an den Indexer verteilt wird. Wenn dieser Wert auf 95 % gesetzt ist, erhält der Indexer 95 % der Abfragegebühren, die beim Abschluss einer Zuteilung anfallen, während die restlichen 5 % an die Delegatoren gehen.

- **indexingRewardCut** - der Prozentsatz der Indizierung Rewards, der an den Indexer verteilt wird. Wenn dieser Wert auf 95 % gesetzt ist, erhält der Indexer 95 % der Rewards für die Indizierung, wenn eine Zuweisung abgeschlossen wird, und die Delegatoren teilen sich die restlichen 5 %.

### How do Indexers know which subgraphs to index?

Indexers may differentiate themselves by applying advanced techniques for making subgraph indexing decisions but to give a general idea we'll discuss several key metrics used to evaluate subgraphs in the network:

- **Kurationssignal** - Der Anteil des Netzwerkkurationssignals, der auf einen bestimmten Subgraphen angewandt wird, ist ein guter Indikator für das Interesse an diesem Subgraphen, insbesondere während der Bootstrap-Phase, wenn das Abfragevolumen ansteigt.

- **Eingezogene Abfragegebühren** - Die historischen Daten zum Volumen der eingezogenen Abfragegebühren für einen bestimmten Subgraphen sind ein guter Indikator für die künftige Nachfrage.

- **Einsatzhöhe** - Die Beobachtung des Verhaltens anderer Indexer oder die Betrachtung des Anteils am Gesamteinsatz, der bestimmten Subgraphen zugewiesen wird, kann es einem Indexer ermöglichen, die Angebotsseite für Subgraphenabfragen zu überwachen, um Subgraphen zu identifizieren, in die das Netzwerk Vertrauen zeigt, oder Subgraphen, die möglicherweise einen Bedarf an mehr Angebot aufweisen.

- **Subgraphen ohne Indexer Rewards** - Einige Subgraphen erzeugen keine Indexer Rewards, hauptsächlich weil sie nicht unterstützte Funktionen wie IPFS verwenden oder weil sie ein anderes Netzwerk außerhalb des Hauptnetzes abfragen. Wenn ein Subgraph keine Indexing Rewards generiert, wird eine entsprechende Meldung angezeigt.

### What are the hardware requirements?

- **Small** - Ausreichend, um mit der Indizierung mehrerer Subgraphen zu beginnen, wird wahrscheinlich erweitert werden müssen.
- **Standard** - Standardeinstellung, die in den Datenbeispielen für die k8s/terraform-Bereitstellungsmanifeste verwendet wird.
- **Medium** - Produktions-Indexer, der 100 Subgraphen und 200-500 Anfragen pro Sekunde unterstützt.
- **Large** - Vorbereitet, um alle derzeit verwendeten Subgraphen zu indizieren und Anfragen für den entsprechenden Verkehr zu bedienen.

| Konfiguration | Postgres<br />(CPUs) | Postgres<br />(Speicher in GB) | Postgres<br />(Festplatte in TB) | VMs<br />(CPUs) | VMs<br />(Speicher in GB) |
| ------------- | :------------------: | :----------------------------: | :------------------------------: | :-------------: | :-----------------------: |
| Small         |           4          |                8               |                 1                |        4        |             16            |
| Standard      |           8          |               30               |                 1                |        12       |             48            |
| Medium        |          16          |               64               |                 2                |        32       |             64            |
| Large         |          72          |               468              |                3.5               |        48       |            184            |

### What are some basic security precautions an Indexer should take?

- **Operator Wallet** - Die Einrichtung einer Operator Wallet ist eine wichtige Vorsichtsmaßnahme, da sie es einem Indexer ermöglicht, eine Trennung zwischen seinen Schlüsseln, die den Einsatz kontrollieren, und den Schlüsseln, die für den täglichen Betrieb zuständig sind, aufrechtzuerhalten. Siehe [Stake im Protocol](/indexing/overview/#stake-in-the-protocol) für Anweisungen.

- **Firewall** - Nur der Indexer-Dienst muss öffentlich zugänglich gemacht werden, und es sollte besonders darauf geachtet werden, die Admin-Ports und den Datenbankzugriff zu sperren: The Graph Node JSON-RPC-Endpunkt (Standard-Port: 8030), der Indexer-Management-API-Endpunkt (Standard-Port: 18000) und der Postgres-Datenbank-Endpunkt (Standard-Port: 5432) sollten nicht öffentlich zugänglich sein.

## Infrastruktur

Im Zentrum der Infrastruktur eines Indexers steht der Graph Node, der die indizierten Netzwerke überwacht, Daten gemäß einer Subgraph-Definition extrahiert und lädt und sie als [GraphQL API](/about/#how-the-graph-works) bereitstellt. Der Graph Node muss mit einem Endpunkt verbunden sein, der Daten aus jedem indizierten Netzwerk ausgibt; einem IPFS-Knoten für die Datenbeschaffung; einer PostgreSQL-Datenbank für ihre Speicherung; und Indexer-Komponenten, die seine Interaktionen mit dem Netzwerk erleichtern.

- **PostgreSQL-Datenbank** - Der Hauptspeicher für den Graph Node, in dem die Subgraph-Daten gespeichert werden. Der Indexer-Dienst und der Agent nutzen die Datenbank auch zum Speichern von Statuskanaldaten, Kostenmodellen, Indizierungsregeln und Zuordnungsaktionen.

- **Datenendpunkt** - Bei EVM-kompatiblen Netzwerken muss der Graph Node mit einem Endpunkt verbunden sein, der eine EVM-kompatible JSON-RPC-API bereitstellt. Dabei kann es sich um einen einzelnen Client handeln oder um ein komplexeres Setup, das die Last auf mehrere Clients verteilt. Es ist wichtig, sich darüber im Klaren zu sein, dass bestimmte Subgraphen bestimmte Client-Funktionen erfordern, wie z. B. den Archivmodus und/oder die Paritätsverfolgungs-API.

- **IPFS-Knoten (Version kleiner als 5)** - Die Metadaten für die Bereitstellung von Subgraphen werden im IPFS-Netzwerk gespeichert. Der Graph Node greift während der Subgraph-Bereitstellung hauptsächlich auf den IPFS-Knoten zu, um das Subgraph-Manifest und alle verknüpften Dateien zu holen. Netzwerk-Indexer brauchen keinen eigenen IPFS-Knoten zu hosten, ein IPFS-Knoten für das Netzwerk wird unter https://ipfs.network.thegraph.com gehostet.

- **Indexer-Dienst** - Erledigt alle erforderlichen externen Kommunikationen mit dem Netz. Teilt Kostenmodelle und Indizierungsstatus, leitet Abfrageanfragen von Gateways an einen Graph Node weiter und verwaltet die Abfragezahlungen über Statuskanäle mit dem Gateway.

- **Indexer-Agent** - Erleichtert die Interaktionen des Indexers in der Kette, einschließlich der Registrierung im Netzwerk, der Verwaltung von Subgraph-Bereitstellungen an seine(n) Graph-Knoten und der Verwaltung von Zuweisungen.

- **Prometheus Metrics Server** - Die Komponenten Graph Node und Indexer protokollieren ihre Metriken auf dem Metrics Server.

Hinweis: Um eine agile Skalierung zu unterstützen, wird empfohlen, Abfrage- und Indizierungsbelange zwischen verschiedenen Gruppen von Knoten zu trennen: Abfrageknoten und Indexknoten.

### Ports overview

> **Wichtig**: Seien Sie vorsichtig damit, Ports öffentlich zugänglich zu machen - **Verwaltungsports** sollten unter Verschluss gehalten werden. Dies gilt auch für den Graph Node JSON-RPC und die Indexer-Verwaltungsendpunkte, die im Folgenden beschrieben werden.

#### Graph Node

| Port | Verwendungszweck                                | Routen                                         | CLI-Argument       | Umgebungsvariable |
| ---- | ----------------------------------------------- | ---------------------------------------------- | ------------------ | ----------------- |
| 8000 | GraphQL HTTP-Server<br />(für Subgraf-Abfragen) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port       | -                 |
| 8001 | GraphQL WS<br />(für Subgraf-Abonnements)       | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port         | -                 |
| 8020 | JSON-RPC<br />(zum Verwalten von Deployments)   | /                                              | \--admin-port      | -                 |
| 8030 | Subgraf-Indizierungsstatus-API                  | /graphql                                       | \--index-node-port | -                 |
| 8040 | Prometheus-Metriken                             | /metrics                                       | \--metrics-port    | -                 |

#### Indexer Service

| Port | Verwendungszweck                                                 | Routen                                                      | CLI-Argument    | Umgebungsvariable      |
| ---- | ---------------------------------------------------------------- | ----------------------------------------------------------- | --------------- | ---------------------- |
| 7600 | GraphQL-HTTP-Server<br />(für kostenpflichtige Subgraf-Abfragen) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port         | `INDEXER_SERVICE_PORT` |
| 7300 | Prometheus-Metriken                                              | /metrics                                                    | \--metrics-port | -                      |

#### Indexer Agent

| Port | Verwendungszweck                | Routen | CLI Argument               | Umgebungsvariable                       |
| ---- | ------------------------------- | ------ | -------------------------- | --------------------------------------- |
| 8000 | Indexer-Verwaltungs-API         | /      | \--indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Setup server infrastructure using Terraform on Google Cloud

> Note: Indexers can alternatively use AWS, Microsoft Azure, or Alibaba.

#### Install prerequisites

- Google Cloud SDK
- Kubectl command line tool
- Terraform

#### Create a Google Cloud Project

- Klonen oder navigieren Sie zum [Indexer-Repository] (https://github.com/graphprotocol/indexer).

- Navigieren Sie zum Verzeichnis `./terraform`, in dem alle Befehle ausgeführt werden sollen.

```sh
cd terraform
```

- Authenticate with Google Cloud and create a new project.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Use the Google Cloud Console's billing page to enable billing for the new project.

- Create a Google Cloud configuration.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Enable required Google Cloud APIs.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Create a service account.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Enable peering between database and Kubernetes cluster that will be created in the next step.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer Networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Create minimal terraform configuration file (update as needed).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database password>"
EOF
```

#### Use Terraform to create infrastructure

Bevor Sie irgendwelche Befehle ausführen, lesen Sie [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) und erstellen Sie eine Datei `terraform.tfvars` in diesem Verzeichnis (oder ändern Sie die im letzten Schritt erstellte Datei). Für jede Variable, bei der Sie die Standardeinstellung überschreiben oder einen Wert festlegen möchten, geben Sie eine Einstellung in `terraform.tfvars` ein.

- Run the following commands to create the infrastructure.

```sh
# Install required plugins
terraform init

# View plan for resources to be created
terraform plan

# Create the resources (expect it to take up to 30 minutes)
terraform apply
```

Laden Sie die Anmeldedaten für den neuen Cluster in `~/.kube/config` herunter und setzen Sie ihn als Standardkontext.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Creating the Kubernetes components for the Indexer

- Kopieren Sie das Verzeichnis `k8s/overlays` in ein neues Verzeichnis `$dir,` und passen Sie den Eintrag `bases` in `$dir/kustomization.yaml` so an, dass er auf das Verzeichnis `k8s/base` zeigt.

- Lesen Sie alle Dateien in `$dir` durch und passen Sie alle Werte wie in den Kommentaren angegeben an.

Stellen Sie alle Ressourcen mit `kubectl apply -k $dir` bereit.

### Graph Node

[Graph Node] (https://github.com/graphprotocol/graph-node) ist eine quelloffene Rust-Implementierung, die die Ethereum-Blockchain mit Ereignisquellen versorgt, um einen Datenspeicher deterministisch zu aktualisieren, der über den GraphQL-Endpunkt abgefragt werden kann. Entwickler verwenden Subgraphen, um ihr Schema zu definieren, sowie eine Reihe von Mappings zur Umwandlung der von der Blockchain bezogenen Daten. Der Graph Node übernimmt die Synchronisierung der gesamten Kette, die Überwachung auf neue Blöcke und die Bereitstellung über einen GraphQL-Endpunkt.

#### Einstieg in den Sourcecode

#### Install prerequisites

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Zusätzliche Anforderungen für Ubuntu-Benutzer** - Um einen Graph Node unter Ubuntu zu betreiben, sind möglicherweise einige zusätzliche Pakete erforderlich.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Konfiguration

1. Starten Sie einen PostgreSQL-Datenbankserver

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Klonen Sie das [Graph Node](https://github.com/graphprotocol/graph-node)-Repository und erstellen Sie den Quellcode, indem Sie `cargo build` ausführen

3. Now that all the dependencies are setup, start the Graph Node:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Erste Schritte mit Docker

#### Vorbedingungen

- **Ethereum node** - By default, the docker compose setup will use mainnet: [http://host.docker.internal:8545](http://host.docker.internal:8545) to connect to the Ethereum node on your host machine. You can replace this network name and url by updating `docker-compose.yaml`.

#### Konfiguration

1. Klonen Sie den Graph-Knoten und navigieren Sie zum Docker-Verzeichnis:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. For linux users only - Use the host IP address instead of `host.docker.internal` in the `docker-compose.yaml `using the included script:

```sh
./setup.sh
```

3. Starten Sie einen lokalen Graph-Knoten, der sich mit Ihrem Ethereum-Endpunkt verbindet:

```sh
docker-compose up
```

### Indexer-Komponenten

To successfully participate in the network requires almost constant monitoring and interaction, so we've built a suite of Typescript applications for facilitating an Indexers network participation. There are three Indexer components:

- **Indexer-Agent** - Der Agent überwacht das Netzwerk und die eigene Infrastruktur des Indexers und verwaltet, welche Subgraph-Einsätze indiziert und der Onchain zugewiesen werden und wie viel davon jeweils zugewiesen wird.

- **Indexer-Dienst** - Die einzige Komponente, die nach außen hin offengelegt werden muss. Der Dienst leitet Subgraph-Abfragen an den Graph-Knoten weiter, verwaltet Statuskanäle für Abfragezahlungen und gibt wichtige Entscheidungsinformationen an Clients wie die Gateways weiter.

- **Indexer CLI** - Die Befehlszeilenschnittstelle zur Verwaltung des Indexer-Agenten. Sie ermöglicht Indexern die Verwaltung von Kostenmodellen, manuellen Zuweisungen, Aktionswarteschlangen und Indizierungsregeln.

#### Getting started

Der Indexer-Agent und der Indexer-Service sollten sich in Ihrer Graph Node-Infrastruktur befinden. Es gibt viele Möglichkeiten, virtuelle Ausführungsumgebungen für Ihre Indexer-Komponenten einzurichten; hier erklären wir, wie Sie sie auf Baremetal mit NPM-Paketen oder Source oder über Kubernetes und Docker auf der Google Cloud Kubernetes Engine ausführen. Wenn sich diese Datenbeispiele nicht gut auf Ihre Infrastruktur übertragen lassen, wird es wahrscheinlich einen Community-Leitfaden geben, auf den Sie sich beziehen können. Kommen Sie auf [Discord] (https://discord.gg/graphprotocol) vorbei! Vergessen Sie nicht, [stake in the protocol](/indexing/overview/#stake-in-the-protocol), bevor Sie Ihre Indexer-Komponenten starten!

#### From NPM packages

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### From source

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Using docker

- Pull images from the registry

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Or build images locally from source

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Run the components

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**HINWEIS**: Nach dem Start der Container sollte der Indexer-Dienst unter [http://localhost:7600](http://localhost:7600) erreichbar sein und der Indexer-Agent sollte die Indexer-Verwaltungs-API unter [http://localhost:18000/](http://localhost:18000/) zur Verfügung stellen.

#### Using K8s and Terraform

Sehen Sie den Abschnitt [Einrichten der Serverinfrastruktur mit Terraform in Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Verwendung

> HINWEIS: Alle Laufzeit-Konfigurationsvariablen können entweder als Parameter auf den Befehl beim Start oder mithilfe von Umgebungsvariablen im Format `COMPONENT_NAME_VARIABLE_NAME`(z. B. `INDEXER_AGENT_ETHEREUM`) angewandt werden.

#### Indexer-Agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer-Service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexer-CLI

Das Indexer CLI ist ein Plugin für [`@graphprotocol/graph-cli`] (https://www.npmjs.com/package/@graphprotocol/graph-cli), das im Terminal unter `graph indexer` erreichbar ist.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Indexer management using Indexer CLI

Das vorgeschlagene Tool für die Interaktion mit der **Indexer-Verwaltungs-API** ist die **Indexer CLI**, eine Erweiterung der **Graph CLI**. Der Indexer-Agent benötigt Eingaben von einem Indexer, um im Namen des Indexers autonom mit dem Netzwerk zu interagieren. Die Mechanismen zur Definition des Verhaltens des Indexer-Agenten sind der **Zuweisungsmanagement**-Modus und die **Indizierungsregeln**. Im Auto-Modus kann ein Indexer **Indizierungsregeln** verwenden, um seine spezifische Strategie für die Auswahl von Subgraphen anzuwenden, die er indizieren und für die er Abfragen liefern soll. Die Regeln werden über eine GraphQL-API verwaltet, die vom Agenten bereitgestellt wird und als IIndexer-Verwaltungs-API bekannt ist. Im manuellen Modus kann ein Indexer Zuordnungsaktionen über die **Aktionswarteschlange** erstellen und sie explizit genehmigen, bevor sie ausgeführt werden. Im Überwachungsmodus werden **Indizierungsregeln** verwendet, um die **Aktionswarteschlange** zu füllen, und erfordern ebenfalls eine ausdrückliche Genehmigung für die Ausführung.

#### Verwendung

Die **Indexer CLI** verbindet sich mit dem Indexer-Agenten, in der Regel über Port-Forwarding, so dass die CLI nicht auf demselben Server oder Cluster laufen muss. Um Ihnen den Einstieg zu erleichtern und etwas Kontext zu liefern, wird die CLI hier kurz beschrieben.

- `graph indexer connect <url>` - Verbindet mit der Indexer-Verwaltungs-API. Typischerweise wird die Verbindung zum Server über Port-Forwarding geöffnet, so dass die CLI einfach aus der Ferne bedient werden kann. (Datenbeispiel: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Holt eine oder mehrere Indizierungsregeln unter Verwendung von `all` als `<deployment-id>`, um alle Regeln zu erhalten, oder `global`, um die globalen Standardwerte zu erhalten. Ein zusätzliches Argument `--merged` kann verwendet werden, um anzugeben, dass einsatzspezifische Regeln mit der globalen Regel zusammengeführt werden. Auf diese Weise werden sie im Indexer-Agent angewendet.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Eine oder mehrere Indizierungsregeln setzen.

- `graph indexer rules start [options] <deployment-id>` - Startet die Indizierung eines Subgraph-Einsatzes, wenn dieser verfügbar ist, und setzt seine `decisionBasis` auf `always`, so dass der Indexer-Agent sich immer für die Indizierung entscheidet. Wenn die globale Regel auf „always“ gesetzt ist, werden alle verfügbaren Subgraphen im Netzwerk indiziert.

- `graph indexer rules stop [options] <deployment-id>` - Stop indexing a deployment and set its `decisionBasis` to never, so it will skip this deployment when deciding on deployments to index.

- `graph indexer rules maybe [options] <deployment-id>` — Set the `decisionBasis` for a deployment to `rules`, so that the Indexer agent will use indexing rules to decide whether to index this deployment.

- `graph indexer actions get [options] <action-id>` - Fetch one or more actions using `all` or leave `action-id` empty to get all actions. An additional argument `--status` can be used to print out all actions of a certain status.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Queue allocation action

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Queue reallocate action

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Queue unallocate action

- `graph indexer actions cancel [<action-id> ...]` - Cancel all action in the queue if id is unspecified, otherwise cancel array of id with space as separator

- `graph indexer actions approve [<action-id> ...]` - Approve multiple actions for execution

- `graph indexer actions execute approve` - Force the worker to execute approved actions immediately

All commands which display rules in the output can choose between the supported output formats (`table`, `yaml`, and `json`) using the `-output` argument.

#### Indexing rules

Indexing rules can either be applied as global defaults or for specific subgraph deployments using their IDs. The `deployment` and `decisionBasis` fields are mandatory, while all other fields are optional. When an indexing rule has `rules` as the `decisionBasis`, then the Indexer agent will compare non-null threshold values on that rule with values fetched from the network for the corresponding deployment. If the subgraph deployment has values above (or below) any of the thresholds it will be chosen for indexing.

For example, if the global rule has a `minStake` of **5** (GRT), any subgraph deployment which has more than 5 (GRT) of stake allocated to it will be indexed. Threshold rules include `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, and `minAverageQueryFees`.

Data model:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Example usage of indexing rule:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Actions queue CLI

The indexer-cli provides an `actions` module for manually working with the action queue. It uses the **Graphql API** hosted by the indexer management server to interact with the actions queue.

The action execution worker will only grab items from the queue to execute if they have `ActionStatus = approved`. In the recommended path actions are added to the queue with ActionStatus = queued, so they must then be approved in order to be executed onchain. The general flow will look like:

- Action added to the queue by the 3rd party optimizer tool or indexer-cli user
- Indexer can use the `indexer-cli` to view all queued actions
- Indexer (or other software) can approve or cancel actions in the queue using the `indexer-cli`. The approve and cancel commands take an array of action ids as input.
- The execution worker regularly polls the queue for approved actions. It will grab the `approved` actions from the queue, attempt to execute them, and update the values in the db depending on the status of execution to `success` or `failed`.
- If an action is successful the worker will ensure that there is an indexing rule present that tells the agent how to manage the allocation moving forward, useful when taking manual actions while the agent is in `auto` or `oversight` mode.
- The indexer can monitor the action queue to see a history of action execution and if needed re-approve and update action items if they failed execution. The action queue provides a history of all actions queued and taken.

Data model:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Example usage from source:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Note that supported action types for allocation management have different input requirements:

- `Allocate` - allocate stake to a specific subgraph deployment

  - required action params:
    - deploymentID
    - amount

- `Unallocate` - close allocation, freeing up the stake to reallocate elsewhere

  - required action params:
    - allocationID
    - deploymentID
  - optional action params:
    - poi
    - force (forces using the provided POI even if it doesn’t match what the graph-node provides)

- `Reallocate` - atomically close allocation and open a fresh allocation for the same subgraph deployment

  - required action params:
    - allocationID
    - deploymentID
    - amount
  - optional action params:
    - poi
    - force (forces using the provided POI even if it doesn’t match what the graph-node provides)

#### Kostenmodelle

Cost models provide dynamic pricing for queries based on market and query attributes. The Indexer Service shares a cost model with the gateways for each subgraph for which they intend to respond to queries. The gateways, in turn, use the cost model to make Indexer selection decisions per query and to negotiate payment with chosen Indexers.

#### Agora

The Agora language provides a flexible format for declaring cost models for queries. An Agora price model is a sequence of statements that execute in order for each top-level query in a GraphQL query. For each top-level query, the first statement which matches it determines the price for that query.

A statement is comprised of a predicate, which is used for matching GraphQL queries, and a cost expression which when evaluated outputs a cost in decimal GRT. Values in the named argument position of a query may be captured in the predicate and used in the expression. Globals may also be set and substituted in for placeholders in an expression.

Example cost model:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Example query costing using the above model:

| Query                                                                        | Price   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### Anwendung des Kostenmodells

Cost models are applied via the Indexer CLI, which passes them to the Indexer Management API of the Indexer agent for storing in the database. The Indexer Service will then pick them up and serve the cost models to gateways whenever they ask for them.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interaktion mit dem Netzwerk

### Stake in the protocol

The first steps to participating in the network as an Indexer are to approve the protocol, stake funds, and (optionally) set up an operator address for day-to-day protocol interactions.

> Note: For the purposes of these instructions Remix will be used for contract interaction, but feel free to use your tool of choice ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), and [MyCrypto](https://www.mycrypto.com/account) are a few other known tools).

Once an Indexer has staked GRT in the protocol, the [Indexer components](/indexing/overview/#indexer-components) can be started up and begin their interactions with the network.

#### Approve tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **GraphToken.abi** with the [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. With `GraphToken.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the GraphToken contract address - Paste the GraphToken contract address (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) next to `At Address` and click the `At address` button to apply.

6. Call the `approve(spender, amount)` function to approve the Staking contract. Fill in `spender` with the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) and `amount` with the tokens to stake (in wei).

#### Stake tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **Staking.abi** with the staking ABI.

3. With `Staking.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the Staking contract address - Paste the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) next to `At Address` and click the `At address` button to apply.

6. Call `stake()` to stake GRT in the protocol.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their indexingRewardCut (parts per million), queryFeeCut (parts per million), and cooldownBlocks (number of blocks). To do so call `setDelegationParameters()`. The following example sets the queryFeeCut to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the indexingRewardCutto distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set `thecooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### Setting delegation parameters

The `setDelegationParameters()` function in the [staking contract](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) is essential for Indexers, allowing them to set parameters that define their interactions with Delegators, influencing their reward sharing and delegation capacity.

### How to set delegation parameters

To set the delegation parameters using Graph Explorer interface, follow these steps:

1. Navigate to [Graph Explorer](https://thegraph.com/explorer/).
2. Connect your wallet. Choose multisig (such as Gnosis Safe) and then select mainnet. Note: You will need to repeat this process for Arbitrum One.
3. Connect the wallet you have as a signer.
4. Navigate to the 'Settings' section and select 'Delegation Parameters'. These parameters should be configured to achieve an effective cut within the desired range. Upon entering values in the provided input fields, the interface will automatically calculate the effective cut. Adjust these values as necessary to attain the desired effective cut percentage.
5. Submit the transaction to the network.

> Note: This transaction will need to be confirmed by the multisig wallet signers.

### The life of an allocation

After being created by an Indexer a healthy allocation goes through two states.

- **Active** - Once an allocation is created onchain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a subgraph deployment, which allows them to claim indexing rewards and serve queries for that subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - An Indexer is free to close an allocation once 1 epoch has passed ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) or their Indexer agent will automatically close the allocation after the **maxAllocationEpochs** (currently 28 days). When an allocation is closed with a valid proof of indexing (POI) their indexing rewards are distributed to the Indexer and its Delegators ([learn more](/indexing/overview/#how-are-indexing-rewards-distributed)).

Indexers are recommended to utilize offchain syncing functionality to sync subgraph deployments to chainhead before creating the allocation onchain. This feature is especially useful for subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
