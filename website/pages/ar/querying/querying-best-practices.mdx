---
title: أفضل الممارسات للاستعلام
---

يوفر The Graph طريقة لامركزية للاستعلام عن البيانات من سلاسل الكتل.

يتم عرض بيانات شبكة Graph من خلال GraphQL API ، مما يسهل الاستعلام عن البيانات باستخدام لغة GraphQL.

ستوجهك هذه الصفحة خلال القواعد الأساسية للغة GraphQL وأفضل ممارسات استعلامات GraphQL.

---

## الاستعلام عن واجهة برمجة تطبيقات GraphQL

### بنية استعلام GraphQL

على عكس REST API ، فإن GraphQL API مبنية على مخطط يحدد الاستعلامات التي يمكن تنفيذها.

على سبيل المثال ، طلب الاستعلام للحصول على توكن باستخدام استعلام ` token ` سيبدو كما يلي:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

والتي ستعرض استجابة JSON التالية التي يمكن التنبؤ بها (_ عند تمرير القيمة المتغيرة `$id` المناسبة _):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

تستخدم استعلامات GraphQL لغة GraphQL ، التي تم تحديدها في [المواصفات](https://spec.graphql.org/).

يتكون استعلام ` GetToken ` أعلاه من أجزاء متعددة للغة (تم استبدالها أدناه بـ placeholders ` [...] `):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

على الرغم من أن قائمة القواعد التي يجب اتباعها طويلة، إلا أن هناك قواعد أساسية يجب أخذها في الاعتبار عند كتابة استعلامات GraphQL:

- يجب استخدام كل ` queryName ` مرة واحدة فقط لكل عملية.
- يجب استخدام كل ` field ` مرة واحدة فقط في التحديد (لا يمكننا الاستعلام عن ` id ` مرتين ضمن ` token `)
- بعض ` field ` أو الاستعلامات (مثل `tokens`) ترجع أنواعًا معقدة تتطلب تحديدًا للحقول الفرعية. عدم تقديم تحديد عندما يكون متوقعًا (أو تقديم تحديد عندما لا يكون متوقعًا - على سبيل المثال ، الـ ` id `) سيؤدي إلى ظهور خطأ. لمعرفة نوع الحقل ، يرجى الرجوع إلى [ The Graph Explorer ](/network/explorer).
- يجب أن يكون أي متغير تم تعيينه لوسيط متطابقًا مع نوعه.
- في قائمة المتغيرات المعطاة ، يجب أن يكون كل واحد منها فريدًا.
- يجب استخدام جميع المتغيرات المحددة.

إذا لم تتبع القواعد المذكورة أعلاه ، فستحدث خطأ من Graph API.

للحصول على قائمة كاملة بالقواعد مع أمثلة التعليمات البرمجية ، يرجى إلقاء نظرة على دليل التحقق من GraphQL.

<br />

### إرسال استعلام إلى GraphQL API

GraphQL هي لغة بمجموعة من التوجيهات التي تنقل عبر شبكة HTTP.

وهذا يعني أنه يمكنك استعلام GraphQL API باستخدام ` fetch` القياسي (بشكل أصلي أو بإستخدام ` @ whatwg-node / fetch ` أو ` isomorphic-fetch `).

ومع ذلك ، كما هو مذكور في [ "الاستعلام من أحد التطبيقات" ](/querying/querying-from-an-application) ، نوصيك باستخدام ` برنامج graph-client `الذي يدعم ميزات فريدة مثل:

- التعامل مع ال subgraph عبر السلاسل: الاستعلام من عدة subgraphs عبر استعلام واحد
- [تتبع الكتلة التلقائي](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [ترقيم الصفحات التلقائي](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- نتيجة مكتوبة بالكامل

<br />

فيما يلي كيفية الاستعلام عن The Graph باستخدام `graph-client `:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

يتم تناول المزيد لعميل GraphQL في [ "الاستعلام من تطبيق" ](/querying/querying-from-an-application).

<br />

الآن وقد غطينا القواعد الأساسية لبناء جملة استعلامات GraphQL ، فلنلقِ نظرة الآن على أفضل ممارسات كتابة استعلام GraphQL.

---

## كتابة استعلامات GraphQL

### اكتب دائمًا استعلامات ثابتة

من الممارسات الشائعة (السيئة) إنشاء سلاسل الاستعلام بشكل ديناميكي على النحو التالي:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

على الرغم من أن المقتطف أعلاه ينتج استعلامًا صالحًا لـ GraphQL، **إلا أنه يعاني من العديد من العيوب**:

- يجعل من الصعب ** فهم ** الإستعلام ككل
- developers are **responsible for safely sanitizing the string interpolation**
- عدم إرسال قيم المتغيرات كجزء من معاملات الطلب ** يمنع التخزين المؤقت المحتمل على جانب الخادم **
- ** يمنع هذا الأمر أدوات التحليل الثابت للإستعلام**(على سبيل المثال: أدوات التدقيق اللغوي أو أدوات إنشاء الأنواع Linter)

لهذا السبب ، يوصى دائمًا بكتابة الاستعلامات كسلاسل ثابتة:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

يؤدي القيام بذلك إلى جلب ** العديد من المزايا **:

- ** إستعلامات سهلة القراءة والصيانة **
- يقوم خادم GraphQL ** بتصحيح المتغيرات **
- ** يمكن تخزين المتغيرات مؤقتًا ** على مستوى الخادم
- ** يمكن تحليل طلبات البحث بشكل ثابت بواسطة الأدوات ** (المزيد حول هذا الموضوع في الأقسام التالية)

**ملاحظة: كيفية تضمين الحقول بشكل مشروط في الاستعلامات الثابتة**

قد نرغب في تضمين حقل ` owner ` في حالة معينة فقط.

لهذا ، يمكننا الاستفادة من التوجيه `include (if:...) ` على النحو التالي:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

ملاحظة: التوجيه المعاكس هو `skip (if: ...) `.

<br />

### نصائح حول الأداء

**"أسأل عن ما تريد"**

أصبحت GraphQL مشهورة بشعارها "اسأل عما تريد".

لهذا السبب ، لا توجد طريقة ، في GraphQL ، للحصول على جميع الحقول المتاحة دون الحاجة إلى سردها بشكل فردي.

عند الاستعلام عن GraphQL APIs ، فكر دائمًا في الاستعلام فقط عن الحقول التي سيتم استخدامها بالفعل.

سبب شائع للحصول على مزيد من البيانات مما هو مطلوب هو مجموعات الكيانات. بشكل افتراضي ستسترد الاستعلامات 100 كيان في المجموعة ، وهو عادة أكثر بكثير مما سيتم استخدامه فعليا ، على سبيل المثال ، لعرضه للمستخدم. يجب دائمًا تعيين الاستعلامات أولاً بشكل صريح ، والتأكد من أنها تجلب فقط العديد من الكيانات التي تحتاجها بالفعل.لا ينطبق هذا فقط على مجموعات المستوى الأعلى في الاستعلام ، بل ينطبق أيضًا على مجموعات الكيانات المتداخلة.

على سبيل المثال ، في الاستعلام التالي:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

الاستجابة يمكن أن تحتوي على 100 عملية لكل 100 توكن.

إذا كان التطبيق يحتاج فقط إلى 10 عمليات ، يجب أن يحدد الاستعلام بشكل صريح ` first: 10 ` على حقل العمليات.

**الجمع بين عدة استفسارات**

قد يتطلب تطبيقك الاستعلام عن أنواع متعددة من البيانات على النحو التالي:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

في حين أن هذا التنفيذ صالح تمامًا ، فإنه سيتطلب رحلتين ذهابًا وإيابًا باستخدام GraphQL API.

لحسن الحظ ، يمكن أيضًا إرسال استعلامات متعددة في نفس طلب GraphQL على النحو التالي:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

ستعمل هذه الطريقة ** على تحسين الأداء العام ** عن طريق تقليل الوقت الذي تقضيه على الشبكة (يوفر لك رحلة ذهابًا وإيابًا إلى واجهة برمجة التطبيقات) وسيوفر ** تنفيذ أكثر إختصار **.

<br />

### الاستفادة من أجزاء GraphQL

إحدى الميزات المفيدة لكتابة استعلامات GraphQL هي GraphQL Fragment.

عند النظر إلى الاستعلام التالي ، ستلاحظ وجود تكرار لبعض الحقول تتكرر عبر مجموعات الاختيار المتعددة(`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

مثل هذه الحقول المتكررة (` id ` ، ` active ` ، ` status `) تجلب العديد من المشكلات:

- harder to read for more extensive queries
- عند استخدام الأدوات التي تنشئ أنواع TypeScript بناءً على الاستعلامات (_المزيد عن ذلك في القسم الأخير_)، و ` newDelate ` و ` oldDelegate ` سينتج عنهما واجهتين مضمنتان متمايزتين.

ستكون النسخة المعاد بناؤها من الاستعلام كما يلي:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

استخدام ` fragment ` في GraphQL ستتحسن قابلية القراءة (خاصة على نطاق واسع) ولكنه سيؤدي أيضًا إلى إنشاء أفضل لأنواع TypeScript.

عند استخدام أداة إنشاء الأنواع ، ستقوم الاستعلامات المذكورة أعلاه بتوليد نوعًا مناسبًا من ` DelegateItemFragment ` (_ راجع قسم "الأدوات" في الاسفل_).

<br />

### ما يجب فعله وما لا يجب فعله في GraphQL Fragment

**يجب ان يكون الأساس الذي تستند إليه ال Fragment نوعا**

لا يمكن أن يستند ال Fragment إلى نوع غير قابل للتطبيق ، باختصار ، **على النوع الذي لا يحتوي على حقول **:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

` BigInt`هو ** عددية ** (نوع "عادي" أصلي) لا يمكن استخدامه كأساس ل fragment.

**كيفية نشر الFragment**

يتم تعريف الFragment بناء على أنواع محدده ويجب استخدامها وفقًا لذلك في الاستعلامات.

مثال:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` و `oldDelegate` هي من نوع `Transcoder`.

لا يمكن نشر ال fragment من نوع ` Vote ` هنا.

**يمكن نعريف ال Fragment على انه وحدة عمل ذاتية ذات صلة بالبيانات**

يجب تحديد GraphQL Fragment بناءً على استخدامها.

بالنسبة لمعظم حالات الاستخدام ، يكون تحديد fragment واحد لكل نوع (في حالة استخدام الحقول المتكررة أو إنشاء النوع) كافياً.

فيما يلي قاعدة أساسية لاستخدام Fragment:

- عند تكرار الحقول من نفس النوع في استعلام ، قم بتجميعها في Fragment
- عند تكرار الحقول متشابهه ولكن غير متطابقة ، قم بإنشاء fragments متعددة ، على سبيل المثال:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## الأدوات الأساسية

### GraphQL web-based explorers

قد يكون تكرار الاستعلامات عن طريق تشغيلها في تطبيقك أمرًا مرهقًا. لهذا السبب ، لا تتردد في استخدام [The Graph Explorer ](https://thegraph.com/explorer) لاختبار استعلاماتك قبل إضافتها إلى تطبيقك. سيوفر لك مستكشف جراف GraphQL playground معدة مسبقا لاختبار الاستعلامات الخاص بك.

إذا كنت تبحث عن طريقة أكثر مرونة لتصحيح الاخطاء / واختبار استعلاماتك ،فهناك أدوات مشابهة عبر الويب متاحة مثل [ Altair ](https://altair.sirmuel.design/) و [ GraphiQL](https://graphiql-online.com/graphiql).

<br />

### GraphQL Linting

In order to keep up with the mentioned above best practices and syntactic rules, it is highly recommended to use the following workflow and IDE tools.

**GraphQL ESLint**

ستساعدك [ GraphQL ESLint ](https://github.com/dotansimha/graphql-eslint) في متابعة أفضل ممارسات GraphQL بدون مجهود.

[ إعداد تهيئة "العمليات الموصى بها" ](https://github.com/dotansimha/graphql-eslint#available-configs) الذي سيفرض قواعد أساسية مثل:

- ` @ graphql-eslint / field-on-right-type `: هل يتم استخدام الحقل على النوع المناسب؟
- ` @ graphql-eslint / no-unused variables `: هل يجب أن يبقى المتغير المعطى غير مستخدم؟
- و اكثر!

سيتيح لك ذلك **اكتشاف الأخطاء حتى دون اختبار الاستعلامات ** على playground أو تشغيلها في الإنتاج!

<br />

### IDE plugins

**VSCode و GraphQL**

يعد [ امتداد GraphQL VSCode ](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) إضافة ممتازة لسير عمل التطوير لديك للحصول على:

- syntax highlighting
- اقتراحات الإكمال التلقائي
- validation against schema
- snippets
- انتقل إلى تعريف ال fragment وأنواع الإدخال

إذا كنت تستخدم ` graphql-eslint ` ، فإنه يجب أن يكون لديك [ESLint VSCode extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) لتصور الأخطاء والتحذيرات المضمنة في الاكواد البرمجية الخاصة بك بشكل صحيح.

**WebStorm/Intellij و GraphQL**

سيحسن [ المكون الإضافي JS GraphQL ](https://plugins.jetbrains.com/plugin/8097-graphql/) تجربتك بشكل كبير أثناء العمل مع GraphQL من خلال توفير:

- syntax highlighting
- اقتراحات الإكمال التلقائي
- validation against schema
- snippets

مزيد من المعلومات حول [ مقالة WebStorm ](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) التي تعرض جميع الميزات الرئيسية للمكون الإضافي.
