---
title: API för AssemblyScript
---

> Obs: om du skapade en subgraf före `graph-cli`/`graph-ts` version `0.22.0`, använder du en äldre version av AssemblyScript, vi rekommenderar att du tar en titt på [`Migreringsguiden`](/release-notes/assemblyscript-migration-guide)

Denna sida dokumenterar vilka inbyggda API: er som kan användas när man skriver mappningar av undergrafer. Två typer av API: er är tillgängliga från start:

- [Graf TypeScript-biblioteket](https://github.com/graphprotocol/graph-ts) (`graph-ts`) och
- kod som genereras från subgraffiler av `graph codegen`.

Det är också möjligt att lägga till andra bibliotek som beroenden, så länge de är kompatibla med [AssemblyScript](https://github.com/AssemblyScript/assemblyscript). Eftersom detta är språkmappningarna är skrivna i, är [AssemblyScript-wikin](https://github.com/AssemblyScript/assemblyscript/wiki) en bra källa för språk- och standardbiblioteksfunktioner.

## Installation

Subgrafer skapade med [`graph init`](/developing/creating-a-subgraph) kommer med förkonfigurerade beroenden. Allt som krävs för att installera dessa beroenden är att köra ett av följande kommandon:

```sh
yarn install # Yarn
npm install  # NPM
```

Om undergrafen skapades från grunden kommer ett av följande två kommandon att installera Graph TypeScript biblioteket som ett beroende:

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## API-referens

Biblioteket `@graphprotocol/graph-ts` tillhandahåller följande API: er:

- Ett `ethereum` API för att arbeta med smarta kontrakt, händelser, block, transaktioner och Ethereum-värden i Ethereum.
- Ett `store` API för att ladda och spara enheter från och till Graph Node lagret.
- Ett `log` API för att logga meddelanden till Graph Node utdata och Graf Explorer.
- Ett `ipfs` API för att ladda filer från IPFS.
- Ett `json` API för att analysera JSON-data.
- Ett `crypto` API för att använda kryptografiska funktioner.
- Primitiver på låg nivå för att översätta mellan olika typsystem som Ethereum, JSON, GraphQL och AssemblyScript.

### Versioner

`apiVersion` i undergraf manifestet anger den API version för mappning som körs av Graf Nod för en viss undergraf.

| Version | Versionsanteckningar                                                                                                                                                                                                                                   |
|:-------:| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|  0.0.7  | Lade till klasserna `TransactionReceipt` och `Log` till Ethereum-typerna<br />Lagde till fältet `receipt` till Ethereum Event objektet                                                                                                           |
|  0.0.6  | Lade till `nonce`-fältet till Ethereum-transaktions objektet<br />Lagde till `baseFeePerGas` till Ethereum Block objektet                                                                                                                        |
|  0.0.5  | AssemblyScript uppgraderat till version 0.19.10 (detta inkluderar brytande ändringar, se [`Migrerings guide`](/release-notes/assemblyscript-migration-guide))<br />`ethereum.transaction.gasUsed` bytt namn till `ethereum.transaction.gasLimit` |
|  0.0.4  | Lade till fältet `functionSignature` till objektet Ethereum SmartContractCall                                                                                                                                                                          |
|  0.0.3  | Lade till `från`-fältet till Ethereum Call-objektet<br />`etherem.call.address` som bytt namn till `ethereum.call.to`                                                                                                                            |
|  0.0.2  | Lade till fältet `input` till Ethereum-transaktionsobjektet                                                                                                                                                                                            |

### Inbyggda typer

Dokumentation om de inbyggda bastyperna i AssemblyScript finns i [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types).

Följande ytterligare typer tillhandahålls av `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` representerar en array av `u8`.

_Byggnation_

- `fromI32(x: i32): ByteArray` - sönderdelas `x` till bytes.
- `fromHexString(hex: string): ByteArray` - Ingångslängden måste vara jämn. Prefix med `0x` är valfritt.

_Typ konverteringar_

- `toHexString(): string` - Konverteras till en hex sträng med prefixet `0x`.
- `toString(): string` - Tolkar byten som en UTF-8-sträng.
- `toBase58(): string` - Kodar bytena till en base58 sträng.
- `toU32(): u32` - Tolkar bytena som en little-endian `u32`. Kastar vid överflöd.
- `toI32(): i32` - Tolkar byte-arrayen som en little-endian `i32`. Kastar vid överflöd.

_Operatörer_

- `equals(y: ByteArray): bool` – kan skrivas som `x == y`.
- `concat(other: ByteArray) : ByteArray` - returnera en ny `ByteArray` bestående av `this` direkt följt av `other`
- `concatI32(other: i32) : ByteArray` - returnera en ny `ByteArray` bestående av `detta` direkt följt av byte-representationen av `other`

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal` används för att representera decimaler med godtycklig precision.

> Obs: [Internt](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal` lagras i [IEEE-754 decimal128 flyttalformat](https://en.wikipedia.org/wiki/Decimal128_floating-point_format), som stöder 34 decimalsiffror av signifikans. Detta gör `BigDecimal` olämpliga för att representera fixpunktstyper som kan sträcka sig över mer än 34 siffror, till exempel en Solidity [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) eller motsvarande.

_Byggnation_

- `constructor(bigInt: BigInt)` – skapar en `BigDecimal` från en `BigInt`.
- `static fromString(s: string): BigDecimal` – analyserar från en decimalsträng.

_Typ konverteringar_

- `toString(): string` - skriver ut till en decimalsträng.

_Math_

- `plus(y: BigDecimal): BigDecimal` – kan skrivas som `x + y`.
- `minus(y: BigDecimal): BigDecimal` – kan skrivas som `x - y`.
- `times(y: BigDecimal): BigDecimal` – kan skrivas som `x * y`.
- `div(y: BigDecimal): BigDecimal` – kan skrivas som `x / y`.
- `equals(y: BigDecimal): bool` – kan skrivas som `x == y`.
- `notEqual(y: BigDecimal): bool` – kan skrivas som `x != y`.
- `lt(y: BigDecimal): bool` – kan skrivas som `x < y`.
- `le(y: BigDecimal): bool` – kan skrivas som `x <= y`.
- `gt(y: BigDecimal): bool` – kan skrivas som `x > y`.
- `ge(y: BigDecimal): bool` – kan skrivas som `x >= y`.
- `neg(): BigDecimal` - kan skrivas som `-x`.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` används för att representera stora heltal. Detta inkluderar Ethereum-värden av typen `uint32` till `uint256` och `int64` till `int256`. Allt under `uint32`, som `int32`, `uint24` eller `int8` representeras som `i32`.

Klassen `BigInt` har följande API:

_Byggnation_

- `BigInt.fromI32(x: i32): BigInt` – skapar en `BigInt` från en `i32`.
- `BigInt.fromString(s: string): BigInt`– Analyserar en `BigInt` från en sträng.
- `BigInt.fromUnsignedBytes(x: Bytes): BigInt` – Tolkar `bytes` som ett osignerat, litet endian heltal. Om din inmatning är big-endian, ring `.reverse()` först.
- `BigInt.fromSignedBytes(x: Bytes): BigInt` – Tolkar `bytes` som ett tecken med litet-endian heltal. Om din inmatning är big-endian, ring `.reverse()` först.

  _Typ konverteringar_

- `x.toHex(): sträng` – förvandlar `BigInt` till en sträng med hexadecimala tecken.
- `x.toString(): string` – förvandlar `BigInt` till en decimaltalsträng.
- `x.toI32(): i32` – returnerar `BigInt` som en `i32`; misslyckas om värdet inte passar in i `i32`. Det är en bra idé att först kontrollera `x.isI32()`.
- `x.toBigDecimal(): BigDecimal` - konverteras till en decimal utan bråkdel.

_Math_

- `x.plus(y: BigInt): BigInt` – kan skrivas som `x + y`.
- `x.minus(y: BigInt): BigInt` – kan skrivas som `x - y`.
- `x.times(y: BigInt): BigInt` – kan skrivas som `x * y`.
- `x.div(y: BigInt): BigInt` – kan skrivas som `x / y`.
- `x.mod(y: BigInt): BigInt` – kan skrivas som `x % y`.
- `x.equals(y: BigInt): bool` – kan skrivas som `x == y`.
- `x.notEqual(y: BigInt): bool` – kan skrivas som `x != y`.
- `x.lt(y: BigInt): bool` – kan skrivas som `x < y`.
- `x.le(y: BigInt): bool` – kan skrivas som `x <= y`.
- `x.gt(y: BigInt): bool` – kan skrivas som `x > y`.
- `x.ge(y: BigInt): bool` – kan skrivas som `x >= y`.
- `x.neg(): BigInt` – kan skrivas som `-x`.
- `x.divDecimal(y: BigDecimal): BigDecimal` – dividerar med en decimal, vilket ger ett decimalresultat.
- `x.isZero(): bool` – Bekvämlighet för att kontrollera om talet är noll.
- `x.isI32(): bool` – Kontrollera om talet ryms i en `i32`.
- `x.abs(): BigInt` – Absolut värde.
- `x.pow(exp: u8): BigInt` – Exponentiering.
- `bitOr(x: BigInt, y: BigInt): BigInt` – kan skrivas som `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – kan skrivas som `x & y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – kan skrivas som `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – kan skrivas som `x >> y`.

#### TypedMap

```typescript
import { TypedMap } from "@graphprotocol/graph-ts";
```

`TypedMap` kan användas för att lagra nyckel-värde-par. Se [detta exempel](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

Klassen `TypedMap` har följande API:

- `new TypedMap<K, V>()` – skapar en tom karta med nycklar av typ `K` och värden av typ `V`
- `map.set(key: K, value: V): void` – sätter värdet för `nyckel` till `värde`
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – returnerar nyckel-värde-paret för en `nyckel` eller `null` om `nyckeln` inte finns i kartan
- `map.get(key: K): V | null` – returnerar värdet för en `nyckel` eller `null` om `nyckeln` inte finns i kartan
- `map.isSet(key: K): bool` – returnerar `true` om `nyckeln` finns i kartan och `false` om den inte gör det

#### Bytes

```typescript
import { Bytes } from "@graphprotocol/graph-ts";
```

`Bytes` används för att representera byte-arrayer med godtycklig längd. Detta inkluderar Ethereum-värden av typen `bytes`, `bytes32`, osv.

Klassen `Bytes` utökar AssemblyScripts [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) och stöder alla `Uint8Array`-funktioner, plus följande nya metoder:

_Skapande_

- `fromHexString(hex: string) : Bytes` - Konverterar strängen `hex`, som måste bestå av ett jämnt antal hexadecimala siffror, till en `ByteArray`. Strängen `hex` kan valfritt börja med `0x`.
- `fromI32(i: i32) : Bytes` - Konverterar `i` till en array av byte.

_Typomvandlingar_

- `b.toHex()` – returnerar en hexadecimal sträng som representerar byten i arrayen.
- `b.toString()` – konverterar byten i arrayen till en sträng av unicode-tecken.
- `b.toBase58()` – omvandlar ett Ethereum Bytes-värde till bas58-kodning (används för IPFS-hashar).

_Operatorer_

- `b.concat(other: Bytes) : Bytes` - returnerar en ny `Bytes` som består av `this` direkt följt av `other`
- `b.concatI32(other: i32) : ByteArray` - returnerar en ny `Bytes` som består av `this` direkt följt av byte-representationen av `other`

#### Address

```typescript
import { Address } from "@graphprotocol/graph-ts";
```

`Address` utökar `Bytes` för att representera Ethereum `address`-värden.

Den lägger till följande metod ovanpå `Bytes` API:

- `Address.fromString(s: string): Address` – skapar en `Address` från en hexadecimal sträng.
- `Address.fromBytes(b: Bytes): Address` – skapar en `Address` från `b`, som måste vara exakt 20 byte lång. Om du skickar in ett värde med färre eller fler byte kommer det att resultera i ett fel.

### Store API

```typescript
import { store } from "@graphprotocol/graph-ts";
```

`store` API:en tillåter att ladda, spara och ta bort entiteter till och från Graph Node-lagret.

Entiteter som skrivs till lagret mappar en-till-en till `@entity`-typerna som är definierade i subgraphens GraphQL-schema. För att göra arbetet med dessa entiteter bekvämt, genererar kommandot `graph codegen` som tillhandahålls av [Graph CLI](https://github.com/graphprotocol/graph-cli) entitetsklasser. Dessa är subklasser av den inbyggda `Entity`-typen med egenskapsgetters och setters för fälten i schemat, samt metoder för att ladda och spara dessa entiteter.

#### Skapa entiteter

Följande är ett vanligt mönster för att skapa entiteter från Ethereum-händelser.

```typescript
// Importera händelseklassen Transfer som genererats från ERC20 ABI
import { Transfer as TransferEvent } from "../generated/ERC20/ERC20";

// Importera entitetstypen Transfer som genererats från GraphQL-schemat
import { Transfer } from "../generated/schema";

// Händelsehanterare för överföring
export function handleTransfer(event: TransferEvent): void {
  // Skapa en Transfer-entitet, med transaktionshash som enhets-ID
  let id = event.transaction.hash;
  let transfer = new Transfer(id);

  // Ange egenskaper för entiteten med hjälp av händelseparametrarna
  transfer.from = event.params.from;
  transfer.to = event.params.to;
  transfer.amount = event.params.amount;

  // Spara entiteten till lagret
  transfer.save();
}
```

När en `Transfer`-händelse stöts på under bearbetningen av kedjan skickas den till `handleTransfer`-händelsehanteraren med hjälp av den genererade `Transfer`-typen (här aliasad till `TransferEvent` för att undvika en namnkonflikt med entitetstypen). Denna typ gör det möjligt att få åtkomst till data som händelsens överordnade transaktion och dess parametrar.

Varje entitet måste ha en unik ID för att undvika kollisioner med andra entiteter. Det är ganska vanligt att händelsens parametrar inkluderar en unik identifierare som kan användas. Observera: Att använda transaktionshashen som ID förutsätter att inga andra händelser i samma transaktion skapar entiteter med denna hash som ID.

#### Ladda entiteter från lagret

Om en entitet redan finns kan den laddas från lagret med följande:

```typescript
let id = event.transaction.hash; // eller hur ID konstrueras
let transfer = Transfer.load(id);
if (transfer == null) {
  transfer = new Transfer(id);
}

// Använd överföringsenheten som tidigare
```

Eftersom entiteten kanske ännu inte finns i lagret, returnerar `load`-metoden en värde av typen `Transfer | null`. Det kan därför vara nödvändigt att kontrollera fallet med `null` innan värdet används.

> **Observera:** Att ladda entiteter är endast nödvändigt om ändringarna som görs i mappningen beror på den tidigare datan i en entitet. Se nästa avsnitt för de två sätten att uppdatera befintliga entiteter.

#### Sökning av entiteter skapade inom ett block

Från och med `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 och `@graphprotocol/graph-cli` v0.49.0 finns `loadInBlock`-metoden tillgänglig för alla entitetstyper.

API:et för lagret underlättar hämtningen av entiteter som skapades eller uppdaterades i det aktuella blocket. En vanlig situation för detta är att en hanterare skapar en transaktion från någon händelse på kedjan, och en senare hanterare vill komma åt denna transaktion om den finns. I det fall då transaktionen inte finns, måste subgraphen gå till databasen bara för att ta reda på att entiteten inte finns; om subgraphförfattaren redan vet att entiteten måste ha skapats i samma block, undviker man detta databasbesök genom att använda `loadInBlock`. För vissa subgrapher kan dessa missade sökningar bidra avsevärt till indexeringstiden.

```typescript
let id = event.transaction.hash; // eller hur ID konstrueras
let transfer = Transfer.loadInBlock(id);
if (transfer == null) {
  transfer = new Transfer(id);
}

// Använd överföringsenheten som tidigare
```

> Observera: Om det inte finns någon entitet som skapats i det angivna blocket kommer `loadInBlock` att returnera `null`, även om det finns en entitet med den angivna ID:n i lagret.

#### Sökning av härledda entiteter

Från och med `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.31.0 och `@graphprotocol/graph-cli` v0.51.0 finns `loadRelated`-metoden tillgänglig.

Detta möjliggör laddning av härledda entitetsfält från inom en händelsehanterare. Till exempel, med följande schema:

```graphql
type Token @entity {
  id: ID!
  holder: Holder!
  color: String
}

type Holder @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "holder")
}
```

Följande kod kommer att ladda `Token`-entiteten som `Holder`-entiteten härleddes från:

```typescript
let holder = Holder.load("test-id");
// Ladda Token-entiteten som innehavarentiteten härleddes från
let token = holder.tokens.load();
```

#### Uppdatering av befintliga entiteter

Det finns två sätt att uppdatera en befintlig entitet:

1. Ladda entiteten med t.ex. `Transfer.load(id)`, sätt egenskaper på entiteten och använd sedan `.save()` för att spara till lagret.
2. Skapa helt enkelt entiteten med t.ex. `new Transfer(id)`, sätt egenskaper på entiteten och använd sedan `.save()` för att spara den i lagret. Om entiteten redan finns, slås ändringarna samman med den.

Att ändra egenskaper är rakt fram i de flesta fall, tack vare de genererade egenskapsinställarna:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

Det är också möjligt att avaktivera egenskaper med en av följande två instruktioner:

```typescript
transfer.from.unset();
transfer.from = null
```

Detta fungerar endast med valfria egenskaper, dvs. egenskaper som deklareras utan `!` i GraphQL. Två exempel skulle vara `owner: Bytes` eller `amount: BigInt`.

Uppdatering av array-egenskaper är lite mer komplicerat, eftersom hämtning av en array från en entitet skapar en kopia av den arrayen. Detta innebär att array-egenskaper måste ställas in igen explicit efter att arrayen har ändrats. Följande förutsätter att `entity` har en `numbers: [BigInt!]!` fält.

```typescript
// Detta kommer inte att fungera
entity.numbers.push(BigInt.fromI32(1));
entity.save();

// Detta kommer att fungera
let numbers = entity.numbers;
numbers.push(BigInt.fromI32(1));
entity.numbers = numbers;
entity.save();
```

#### Ta bort entiteter från lagret

För närvarande finns det ingen metod att ta bort en entitet via de genererade typerna. Istället kräver borttagning av en entitet att namnet på entitetstypen och entitetens ID skickas till `store.remove`:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API ger tillgång till smarta kontrakt, offentliga tillståndsvariabler, kontrakt funktioner, händelser, transaktioner, block och kodning/avkodning av Ethereum data.

#### Stöd för Ethereum-typer

Precis som med entiteter genererar `graph codegen` klasser för alla smarta kontrakt och händelser som används i en subgraph. För detta måste kontrakts ABIs vara en del av datakällan i subgraf manifestet. Vanligtvis lagras ABI-filerna i en `abis/`-mapp.

Med de genererade klasserna sker konverteringar mellan Ethereum-typer och [inbyggda typer](#built-in-types) automatiskt, så att subgraf-författare inte behöver oroa sig för dem.

Följande exempel illustrerar detta. Med en subgraph-schema som

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

och en `Transfer(address,address,uint256)` händelsesignatur på Ethereum, konverteras `from`, `to` och `amount` värden av typ `address`, `address` och `uint256` till `Address` och `BigInt`, vilket gör det möjligt att skicka dem till `Bytes!` och `BigInt!` egenskaper av `Transfer` entiteten:

```typescript
let id = event.transaction.hash;
let transfer = new Transfer(id);
transfer.from = event.params.from;
transfer.to = event.params.to;
transfer.amount = event.params.amount;
transfer.save();
```

#### Händelser och Block/Transaktionsdata

Ethereum-händelser som skickas till händelsehanterare, såsom `Transfer`-händelsen i de tidigare exemplen, ger inte bara åtkomst till händelsens parametrar utan även till deras överordnade transaktion och det block de är en del av. Följande data kan erhållas från `event`-instanser (dessa klasser är en del av modulen `ethereum` i `graph-ts`):

```typescript
class Event {
  address: Address;
  logIndex: BigInt;
  transactionLogIndex: BigInt;
  logType: string | null;
  block: Block;
  transaction: Transaction;
  parameters: Array<EventParam>;
  receipt: TransactionReceipt | null;
}

class Block {
  hash: Bytes;
  parentHash: Bytes;
  unclesHash: Bytes;
  author: Address;
  stateRoot: Bytes;
  transactionsRoot: Bytes;
  receiptsRoot: Bytes;
  number: BigInt;
  gasUsed: BigInt;
  gasLimit: BigInt;
  timestamp: BigInt;
  difficulty: BigInt;
  totalDifficulty: BigInt;
  size: BigInt | null;
  baseFeePerGas: BigInt | null;
}

class Transaction {
  hash: Bytes;
  index: BigInt;
  from: Address;
  to: Address | null;
  value: BigInt;
  gasLimit: BigInt;
  gasPrice: BigInt;
  input: Bytes;
  nonce: BigInt;
}

class TransactionReceipt {
  transactionHash: Bytes;
  transactionIndex: BigInt;
  blockHash: Bytes;
  blockNumber: BigInt;
  cumulativeGasUsed: BigInt;
  gasUsed: BigInt;
  contractAddress: Address;
  logs: Array<Log>;
  status: BigInt;
  root: Bytes;
  logsBloom: Bytes;
}

class Log {
  address: Address;
  topics: Array<Bytes>;
  data: Bytes;
  blockHash: Bytes;
  blockNumber: Bytes;
  transactionHash: Bytes;
  transactionIndex: BigInt;
  logIndex: BigInt;
  transactionLogIndex: BigInt;
  logType: string;
  removed: bool | null;
}
```

#### Åtkomst till Smart Contract-tillstånd

Koden som genereras av `graph codegen` inkluderar också klasser för de smarta kontrakt som används i subgraphen. Dessa kan användas för att komma åt offentliga tillståndsvariabler och anropa funktioner i kontraktet vid det aktuella blocket.

En vanlig mönster är att komma åt kontraktet från vilket en händelse härstammar. Detta uppnås med följande kod:

```typescript
// Importera den genererade kontraktsklassen och den genererade klassen för överföringshändelser
import {
  ERC20Contract,
  Transfer as TransferEvent,
} from "../generated/ERC20Contract/ERC20Contract";
// Importera den genererade entitetsklassen
import { Transfer } from "../generated/schema";

export function handleTransfer(event: TransferEvent) {
  // Bind kontraktet till den adress som skickade händelsen
  let contract = ERC20Contract.bind(event.address);

  // Åtkomst till tillståndsvariabler och funktioner genom att anropa dem
  let erc20Symbol = contract.symbol();
}
```

`Transfer` är aliasat till `TransferEvent` här för att undvika en namnkonflikt med entitetstypen

Så länge `ERC20Contract` på Ethereum har en offentlig skrivskyddad funktion som heter `symbol`, kan den anropas med `.symbol()`. För offentliga tillståndsvariabler skapas en metod med samma namn automatiskt.

Andra kontrakt som är en del av subgraphen kan importeras från den genererade koden och bindas till en giltig adress.

#### Hantering av återkallade anrop

Om de skrivskyddade metoderna i ditt kontrakt kan återkallas bör du hantera det genom att anropa den genererade kontrakt metoden med prefixet `try_`. Till exempel exponerar Gravity kontraktet metoden `gravatarToOwner`. Denna kod skulle kunna hantera ett återkall i den metoden:

```typescript
let gravitera = gravitera.bind(event.address);
let callResult = gravitera_gravatarToOwner(gravatar);
if (callResult.reverted) {
  log.info("getGravatar reverted", []);
} else {
  let owner = callResult.value;
}
```

Observera att en Graf-nod ansluten till en Geth eller Infura klient kanske inte upptäcker alla återkallade anrop. Om du förlitar dig på detta rekommenderar vi att du använder en Graph nod som är ansluten till en Parity klient.

#### Kodning/Dekodning av ABI

Data kan kodas och avkodas enligt Ethereums ABI-kodningsformat med hjälp av funktionerna `encode` och `decode` i modulen `ethereum`.

```typescript
import { Address, BigInt, ethereum } from "@graphprotocol/graph-ts";

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(
    Address.fromString("0x0000000000000000000000000000000000000420")
  ),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
];

let tuple = tupleArray as ethereum.Tuple;

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!;

let decoded = ethereum.decode("(address,uint256)", encoded)
```

För ytterligare information:

- [ABI Specifikation](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Kodning/avkodning [Rust library/CLI](https://github.com/rust-ethereum/ethabi)
- Mer [komplext exempel](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### API för loggning

```typescript
import { log } from "@graphprotocol/graph-ts";
```

API: en`log` gör det möjligt för subgrafer att logga information till standardutmatningen från Graph Node samt till Graph Explorer. Meddelanden kan loggas med olika loggnivåer. En grundläggande formatsträngssyntax tillhandahålls för att komponera loggmeddelanden från argument.

`log` API: en inkluderar följande funktioner:

- `log.debug(fmt: string, args: Array<string>): void` - loggar ett felsökningsmeddelande.
- `log.info(fmt: string, args: Array<string>): void` - loggar ett informationsmeddelande.
- `log.warning(fmt: string, args: Array<string>): void` - loggar en varning.
- `log.error(fmt: string, args: Array<string>): void` - loggar ett felmeddelande.
- `log.critical(fmt: string, args: Array<string>): void` – loggar ett kritiskt meddelande _och_ avslutar subgrafer.

`log` API:en tar en formatsträng och en array med strängvärden. Den ersätter sedan platshållare med strängvärden från arrayen. Den första `{}` platshållaren ersätts med det första värdet i arrayen, den andra `{}` platshållaren ersätts med det andra värdet och så vidare.

```typescript
log.info("Message to be displayed: {}, {}, {}", [
  value.toString(),
  anotherValue.toString(),
  "already a string",
]);
```

#### Loggning av ett eller flera värden

##### Logga ett enskilt värde

I exemplet nedan skickas strängvärdet "A" till en array för att bli `['A']` innan det loggas:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Logga en enskild post från en befintlig array

I exemplet nedan loggas endast det första värdet i argument arrayen, trots att arrayen innehåller tre värden.

```typescript
let myArray = ["A", "B", "C"];

export function handleSomeEvent(event: SomeEvent): void {
  // Visar : "Mitt värde är: A" (Även om tre värden skickas till `log.info`)
  log.info("Mitt värde är: {}", myArray);
}
```

#### Logga flera poster från en befintlig array

Varje post i argument arrayn kräver sin egen platsmarkör `{}` i loggmeddelandesträngen. I nedanstående exempel finns det tre platsmarkörer `{}` i loggmeddelandet. På grund av detta loggas alla tre värden i `myArray`.

```typescript
let myArray = ["A", "B", "C"];

export function handleSomeEvent(event: SomeEvent): void {
  // Visar: "Mitt första värde är: A, andra värdet är: B, tredje värdet är: C"
  log.info(
    "My first value is: {}, second value is: {}, third value is: {}",
    myArray
  );
}
```

##### Logga en specifik post från en befintlig array

För att visa ett specifikt värde i arrayen måste det indexeras och tillhandahållas.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Visar : "Mitt tredje värde är C"
  log.info("My third value is: {}", [myArray[2]]);
}
```

##### Loggning av händelseinformation

I exemplet nedan loggas blocknummer, blockhash och transaktionshash från en händelse:

```typescript
import { log } from "@graphprotocol/graph-ts";

export function handleSomeEvent(event: SomeEvent): void {
  log.debug("Block number: {}, block hash: {}, transaction hash: {}", [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ]);
}
```

### IPFS API

```typescript
import { ipfs } from "@graphprotocol/graph-ts"
```

Smarta kontrakt förankrar ibland IPFS-filer på kedjan. Detta gör det möjligt för avbildningar att hämta IPFS-hashar från kontraktet och läsa motsvarande filer från IPFS. Fildata returneras som `Bytes`, vilket vanligtvis kräver ytterligare bearbetning, t.ex. med hjälp av `json` API som dokumenteras senare på denna sida.

För att läsa en fil från IPFS med en given IPFS-hash eller sökväg görs följande:

```typescript
// Placera detta i en händelsehanterare i mappningen
let hash = "QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D";
let data = ipfs.cat(hash);

// Sökvägar som `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// som inkluderar filer i kataloger stöds också
let path = "QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile";
let data = ipfs.cat(path);
```

**Observera:** `ipfs.cat` är för närvarande inte deterministiskt. Om filen inte kan hämtas över IPFS-nätverket innan begäran upphör, kommer den att returnera `null`. På grund av detta är det alltid värt att kontrollera resultatet för `null`.

Det är också möjligt att behandla större filer i en strömmande stil med `ipfs.map`. Funktionen förväntar sig hashen eller sökvägen för en IPFS-fil, namnet på en återuppringning, och flaggor för att ändra dess beteende:

```typescript
import { JSONValue, Value } from "@graphprotocol/graph-ts";

export function processItem(value: JSONValue, userData: Value): void {
  // Se JSONValue-dokumentationen för mer information om hur man hanterar
  // med JSON-värden
  let obj = value.toObject();
  let id = obj.get("id");
  let title = obj.get("title");

  if (!id || !title) {
    return;
  }

  // Callbacks kan också skapa enheter
  let newItem = new Item(id);
  newItem.title = title.toString();
  newitem.parent = userData.toString(); // Ange parent till "parentId"
  newitem.save();
}

// Placera detta i en händelsehanterare i mappningen
ipfs.map("Qm...", "processItem", Value.fromString("parentId"), ["json"]);

// Alternativt kan du använda `ipfs.mapJSON`.
ipfs.mapJSON("Qm...", "processItem", Value.fromString("parentId"));
```

Det enda flagg som för närvarande stöds är `json`, som måste skickas till `ipfs.map`. Med flaggan `json` måste IPFS-filen bestå av en serie JSON-värden, ett värde per rad. Anropet till `ipfs.map` kommer att läsa varje rad i filen, deserialisera den till en `JSONValue` och anropa återuppringningen för var och en av dem. Återuppringningen kan sedan använda entitetsoperationer för att lagra data från `JSONValue`. Entitetsändringar lagras endast när den handler som kallade `ipfs.map` avslutas framgångsrikt; under tiden behålls de i minnet, och storleken på filen som `ipfs.map` kan bearbeta är därför begränsad.

Vid framgång returnerar `ipfs.map` `void`. Om något anrop till återuppringningen orsakar ett fel avbryts den handler som kallade `ipfs.map`, och subgraphen markeras som misslyckad.

### Crypto API

```typescript
import { crypto } from "@graphprotocol/graph-ts";
```

API: et `crypto` gör kryptografiska funktioner tillgängliga för användning i mappningar. Just nu finns det bara en:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from "@graphprotocol/graph-ts"
```

JSON-data kan tolkas med hjälp av `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – tolkar JSON-data från en `Bytes`-sekvens som tolkas som en giltig UTF-8-sekvens
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – säker version av `json.fromBytes`, den returnerar en felvariant om tolkningen misslyckades
- `json.fromString(data: string): JSONValue` – tolkar JSON-data från en giltig UTF-8 `String`
- `json.try_fromString(data: string): Result<JSONValue, boolean>` – säker version av `json.fromString`, den returnerar en felvariant om tolkningen misslyckades

Klassen `JSONValue` erbjuder ett sätt att hämta värden ur ett godtyckligt JSON-dokument. Eftersom JSON-värden kan vara booleans, nummer, arrays och mer, har `JSONValue` en `kind`-egenskap för att kontrollera typen av ett värde:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

Utöver detta finns en metod för att kontrollera om värdet är `null`:

- `value.isNull(): boolean`

När typen på ett värde är säker, kan det konverteras till en [inbyggd typ](#built-in-types) med någon av följande metoder:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (och sedan konvertera `JSONValue` med någon av de 5 metoderna ovan)

### Typkonverteringsreferens

| Källa/-er            | Mål                  | Konverteringsfunktion           |
| -------------------- | -------------------- | ------------------------------- |
| Address              | Bytes                | ingen                           |
| Address              | Sträng               | s.toHexString()                 |
| BigDecimal           | Sträng               | s.toString()                    |
| BigInt               | BigDecimal           | s.toBigDecimal()                |
| BigInt               | Sträng (hexadecimal) | s.toHexString() eller s.toHex() |
| BigInt               | Sträng (unicode)     | s.toString()                    |
| BigInt               | i32                  | s.toI32()                       |
| Boolean              | Boolean              | ingen                           |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)       |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)     |
| Bytes                | Sträng (hexadecimal) | s.toHexString() eller s.toHex() |
| Bytes                | Sträng (unicode)     | s.toString()                    |
| Bytes                | Sträng (base58)      | s.toBase58()                    |
| Bytes                | i32                  | s.toI32()                       |
| Bytes                | u32                  | s.toU32()                       |
| Bytes                | JSON                 | json.fromBytes(s)               |
| int8                 | i32                  | ingen                           |
| int32                | i32                  | ingen                           |
| int32                | BigInt               | BigInt.fromI32(s)               |
| uint24               | i32                  | ingen                           |
| int64 - int256       | BigInt               | ingen                           |
| uint32 - uint256     | BigInt               | ingen                           |
| JSON                 | boolean              | s.toBool()                      |
| JSON                 | i64                  | s.toI64()                       |
| JSON                 | u64                  | s.toU64()                       |
| JSON                 | f64                  | s.toF64()                       |
| JSON                 | BigInt               | s.toBigInt()                    |
| JSON                 | sträng               | s.toString()                    |
| JSON                 | Array                | s.toArray()                     |
| JSON                 | Objekt               | s.toObject()                    |
| Sträng               | Address              | Address.fromString(s)           |
| Bytes                | Address              | Address.fromBytes(s)            |
| Sträng               | BigInt               | BigInt.fromString(s)            |
| Sträng               | BigDecimal           | BigDecimal.fromString(s)        |
| Sträng (hexadecimal) | Bytes                | ByteArray.fromHexString(s)      |
| Sträng (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)           |

### Metadata för datakälla

Du kan inspektera kontrakt adressen, nätverket och kontexten för datakällan som anropade hanteraren genom namespace `dataSource`:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entitet och DataSourceContext

Basklassen `Entity` och underklassen `DataSourceContext` har hjälpfunktioner för att dynamiskt ställa in och hämta fält:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### Vanliga problem med AssemblyScript

Det finns vissa [AssemblyScript](https://github.com/AssemblyScript/assemblyscript)-problem som är vanliga att stöta på under subgraph-utveckling. De varierar i svårighetsgrad att felsöka, men att vara medveten om dem kan vara till hjälp. Följande är en icke-uttömmande lista över dessa problem:

- `Privata` klassvariabler genomförs inte i [AssemblyScript](https://www.assemblyscript.org/status.html#language-features). Det finns ingen möjlighet att skydda klassvariabler från att direkt ändras från klassobjektet.
- Omfattning ärvs inte till [avslutande funktioner](https://www.assemblyscript.org/status.html#on-closures), dvs variabler deklarerade utanför avslutande funktioner kan inte användas. Förklaring i [Developer Highlights #3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s).
