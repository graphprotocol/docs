---
title: Enhetsprovningsramverk
---

Matchstick √§r ett enhetsprovningsramverk utvecklat av [LimeChain](https://limechain.tech/) som m√∂jligg√∂r f√∂r subgraph-utvecklare att testa sin kartl√§ggningslogik i en avsk√§rmad milj√∂ och distribuera sina subgrapher med f√∂rtroende!

## Komma ig√•ng

### Installera beroenden

F√∂r att anv√§nda testhj√§lpmedlen och k√∂ra testerna m√•ste du installera f√∂ljande beroenden:

```sh
yarn add --dev matchstick-as
```

‚ùó graph-node √§r beroende av PostgreSQL, s√• om du inte redan har det m√•ste du installera det. Vi rekommenderar starkt att du anv√§nder f√∂ljande kommandon eftersom att l√§gga till det p√• n√•got annat s√§tt kan orsaka ov√§ntade fel!

#### MacOS

Kommando f√∂r installation av Postgres:

```sh
brew install postgresql
```

Skapa en symbolisk l√§nk till den senaste libpq.5.lib._ Du kanske beh√∂ver skapa den h√§r mappen f√∂rst: _`/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Linux

Kommando f√∂r Postgres installation (beroende p√• din distribution):

```sh
sudo apt install postgresql
```

### WSL (Windows Subsystem for Linux)

Du kan anv√§nda Matchstick i WSL b√•de med Docker-metoden och bin√§rmetoden. Eftersom WSL kan vara lite knepigt, h√§r √§r n√•gra tips om du st√∂ter p√• problem som

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

eller

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Se till att du anv√§nder en nyare version av Node.js eftersom graph-cli inte l√§ngre st√∂der **v10.19.0**, och det √§r fortfarande standardversionen f√∂r nya Ubuntu-bilder p√• WSL. Till exempel √§r Matchstick bekr√§ftat fungerande p√• WSL med **v18.1.0**. Du kan byta till den antingen via** nvm ** eller genom att uppdatera din globala Node.js. Gl√∂m inte att ta bort `node_modules` och k√∂ra ` npm install `igen efter att du har uppdaterat Node.js! Sedan, se till att du har **libpq** installerat, du kan g√∂ra det genom att k√∂ra

```
sudo apt-get install libpq-dev
```

Och till sist, anv√§nd inte `graph test` (som anv√§nder din globala installation av graph-cli och av n√•gon anledning ser ut som om det √§r trasig p√• WSL f√∂r n√§rvarande), ist√§llet anv√§nd `yarn test` eller `npm run test` (det kommer att anv√§nda den lokala projektbaserade instansen av graph-cli, som fungerar utm√§rkt). F√∂r detta beh√∂ver du sj√§lvklart ha ett `"test"`-skript i din `package.json`-fil, vilket kan vara n√•got s√• enkelt som

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### Anv√§ndning

F√∂r att anv√§nda **Matchstick** i ditt subgrafprojekt √∂ppnar du bara en terminal, navigerar till rotmappen f√∂r ditt projekt och k√∂r helt enkelt `graftest [options] <datasource> ` - den laddar ner den senaste **Matchstick**-bin√§ren och k√∂r det angivna testet eller alla tester i en testmapp (eller alla befintliga tester om ingen datak√§llasflagga √§r angiven).

### CLI alternativ

Detta kommer att k√∂ra alla tester i testmappen:

```sh
graph test
```

Detta kommer att k√∂ra en test med namnet gravity.test.ts och/eller alla tester inuti en mapp med namnet gravity:

```sh
graph test gravity
```

D√• k√∂rs endast den specifika testfilen:

```sh
graph test path/to/file.test.ts
```

**Alternativ:**

```sh
-c, --coverage                K√∂r testerna i t√§ckningsl√§ge
-d, --docker                  K√∂r testerna i en docker-container (Observera: K√∂r fr√•n rotmappen f√∂r subgraph)
-f, --force                   Bin√§r: H√§mtar om bin√§ren. Docker: H√§mtar om Dockerfilen och bygger om dockerbilden.
-h, --help                    Visar anv√§ndningsinformation
-l, --logs                    Loggar till konsolen information om OS, CPU-modell och nedladdnings-URL (f√∂r fels√∂kningssyften)
-r, --recompile               Tvingar testerna att kompileras om
-v, --version <tag>           V√§lj versionen av den rust bin√§ra som du vill att den ska h√§mtas/anv√§ndas
```

### Docker

Fr√•n `graph-cli 0.25.2` st√∂der kommandot `graph test` att k√∂ra `matchstick` i en Docker-beh√•llare med flaggan `-d`. Docker-implementeringen anv√§nder [bind mount](https://docs.docker.com/storage/bind-mounts/) s√• att den inte beh√∂ver bygga om dockerbilden varje g√•ng kommandot `graph test -d` k√∂rs. Alternativt kan du f√∂lja instruktionerna fr√•n [matchstick](https://github.com/LimeChain/matchstick#docker-) repository f√∂r att k√∂ra Docker manuellt.

‚ùó `graph test -d` forces `docker run` to run with flag `-t`. This must be removed to run inside non-interactive environments (like GitHub CI).

‚ùó Om du tidigare har k√∂rt `graph test` kan du st√∂ta p√• f√∂ljande fel under docker build:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

I det h√§r fallet skapar du en `.dockerignore` i rotmappen och l√§gger till `node_modules/binary-install-raw/bin`.

### Konfiguration

Matchstick kan konfigureras att anv√§nda en anpassad s√∂kv√§g f√∂r tester, libs och manifest via konfigurationsfilen `matchstick.yaml`:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Demo undergraf

Du kan prova och leka med exemplen fr√•n den h√§r guiden genom att klona [Demo Subgraph-repot](https://github.com/LimeChain/demo-subgraph)

### Handledning f√∂r video

Du kan ocks√• kolla p√• videoserien om ["Hur man anv√§nder Matchstick f√∂r att skriva enhetstester f√∂r dina subgraph"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Tests structure

_**IMPORTANT: The test structure described below depens on `matchstick-as` version >=0.5.0**_

### describe()

`describe(name: String , () => {})` - Definierar en testgrupp.

**_Noteringar:_**

- _Describes √§r inte obligatoriska. Du kan fortfarande anv√§nda test() p√• det gamla s√§ttet, utanf√∂r describe() blocken_

Exempel:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

N√§stat `describe()` exempel:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Definierar ett testfall. Du kan anv√§nda test() inuti describe()-block eller frist√•ende.

Exempel:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

eller

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

K√∂r en kodblock f√∂re n√•got av testen i filen. Om `beforeAll` deklareras inuti en `describe`-block k√∂rs den i b√∂rjan av det `describe`-blocket.

Exempel:

Kod inuti `beforeAll` kommer att utf√∂ras en g√•ng f√∂re _alla_ tester i filen.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("N√§r enheten inte existerar", () => {
  test("det b√∂r skapa en ny Gravatar med id 0x1", () => {
    ...
  })
})

describe("N√§r enheten redan existerar", () => {
  test("det b√∂r uppdatera Gravatar med id 0x0", () => {
    ...
  })
})
```

Kod inuti `beforeAll` kommer att exekveras en g√•ng f√∂re alla tester i det f√∂rsta beskrivningsblocket

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
    gravatar.save()
    ...
  })

  test("uppdaterar Gravatar med id 0x0", () => {
    ...
  })

  test("skapar ny Gravatar med id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

K√∂r en kodblock efter alla test i filen. Om `afterAll` deklareras inuti en `describe`-block k√∂rs den i slutet av det `describe`-blocket.

Exempel:

Kod inuti `afterAll` kommer att utf√∂ras en g√•ng efter _alla_ tester i filen.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("skapar Gravatar med id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("uppdaterar Gravatar med id 0x0", () => {
    ...
  })
})
```

Kod inuti `afterAll` kommer att exekveras en g√•ng efter alla tester i det f√∂rsta beskrivna blocket

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
    afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
    })

  test("Det skapar en ny enhet med id 0x0", () => {
    ...
  })

  test("Det skapar en ny enhet med id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("uppdaterar Gravatar med id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

K√∂r en kodblock f√∂re varje test. Om `beforeEach` deklareras inuti en `describe`-block k√∂rs den f√∂re varje test i det `describe`-blocket.

Exempel: Koden inuti `beforeEach` kommer att utf√∂ras f√∂re varje test.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- rensa butiken f√∂re varje test i filen
})

describe("handleNewGravatars, () => {
  test("Ett test som kr√§ver en ren butik", () => {
    ...
  })

  test("Andra som kr√§ver en ren butik", () => {
    ...
  })
})

 ...
```

Kod inuti `beforeEach` kommer att exekveras endast f√∂re varje test i den som beskriver

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'F√∂rsta Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Upates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // kod som ska uppdatera displayName till 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // kod som ska √§ndra imageUrl till https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

K√∂r en kodblock efter varje test. Om `afterEach` deklareras inuti en `describe`-block k√∂rs den efter varje test i det `describe`-blocket.

Exempel:

Kod inuti `afterEach` kommer att utf√∂ras efter varje test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // kod som ska uppdatera displayName till 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // kod som ska √§ndra imageUrl till https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Kod i `afterEach` kommer att exekveras efter varje test i den beskrivningen

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Upates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // kod som ska uppdatera displayName till 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // kod som ska √§ndra imageUrl till https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Asserts

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

As of version 0.6.0, asserts support custom error messages as well

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id should be 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value should equal 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar should not be in store')
assert.addressEquals(Address.zero(), Address.zero(), 'Address should be zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes should be equal')
assert.i32Equals(2, 2, 'I32 should equal 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt should equal 1')
assert.booleanEquals(true, true, 'Boolean should be true')
assert.stringEquals('1', '1', 'String should equal 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arrays should be equal')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuples should be equal',
)
assert.assertTrue(true, 'Should be true')
assert.assertNull(null, 'Should be null')
assert.assertNotNull('not null', 'Should be not null')
assert.entityCount('Gravatar', 1, 'There should be 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet template should have one data source')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet should have a data source for zero address',
)
```

## Skriv en enhetstest

L√•t oss se hur ett enkelt enhetstest skulle se ut med hj√§lp av Gravatar-exemplen i [Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

Antag att vi har f√∂ljande hanteringsfunktion (tillsammans med tv√• hj√§lpfunktioner f√∂r att g√∂ra v√•rt liv enklare):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Vi m√•ste f√∂rst skapa en testfil i v√•rt projekt. Det h√§r √§r ett exempel p√• hur det kan se ut:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Skapa en testenhet och spara den i arkivet som initialtillst√•nd (valfritt)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Skapa l√•tsash√§ndelser
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Anropa mappningsfunktioner som skickar h√§ndelserna vi just skapade
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Bekr√§fta butikens tillst√•nd
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Rensa lagret f√∂r att starta n√§sta test med en ny start
  clearStore()
})

test('Next test', () => {
  //...
})
```

Det √§r mycket att ta in! F√∂rst och fr√§mst √§r det viktigt att notera att vi importerar saker fr√•n `matchstick-as`, v√•r AssemblyScript hj√§lpbibliotek (distribuerat som ett npm-paket). Du kan hitta lagringsplatsen [h√§r](https://github.com/LimeChain/matchstick-as). `matchstick-as` f√∂rser oss med anv√§ndbara testmetoder och definierar ocks√• funktionen `test()` som vi kommer att anv√§nda f√∂r att bygga v√•ra testblock. Resten √§r ganska sj√§lvf√∂rklarande - h√§r √§r vad som h√§nder:

- Vi st√§ller in v√•r inledande status och l√§gger till en anpassad Gravatar-entitet;
- Vi definierar tv√• `NewGravatar` h√§ndelseobjekt tillsammans med deras data, med hj√§lp av funktionen `createNewGravatarEvent()`.
- Vi kallar p√• v√•ra hanteringsmetoder f√∂r dessa h√§ndelser - `handleNewGravatars()` och skickar in listan med v√•ra anpassade h√§ndelser;
- Vi f√∂rs√§krar oss om statusen f√∂r lagringen. Hur fungerar det? - Vi skickar en unik kombination av entitetstyp och id. Sedan kontrollerar vi ett specifikt f√§lt p√• den entiteten och f√∂rs√§krar oss om att det har det v√§rde vi f√∂rv√§ntar oss. Vi g√∂r detta b√•de f√∂r den ursprungliga Gravatar-entiteten vi lade till i lagringen och de tv√• Gravatar-entiteterna som l√§ggs till n√§r hanteringsfunktionen anropas;
- Och sist men inte minst - vi rensar lagringen med hj√§lp av `clearStore()` s√• att v√•rt n√§sta test kan b√∂rja med en fr√§sch och tom lagringsobjekt. Vi kan definiera s√• m√•nga testblock som vi vill.

S√• d√§r har vi skapat v√•rt f√∂rsta test! üëè

F√∂r att k√∂ra v√•ra tester beh√∂ver du helt enkelt k√∂ra f√∂ljande i din subgrafs rotmapp:

`graph test Gravity`

Och om allt g√•r bra b√∂r du h√§lsas av f√∂ljande:

![Matchstick s√§ger Alla tester har passerat](/img/matchstick-tests-passed.png)

## Vanliga testscenarier

### Fylla p√• lagringen med en viss status

Anv√§ndare kan fylla p√• lagringen med en k√§nd upps√§ttning entiteter. H√§r √§r ett exempel p√• att initialisera lagringen med en Gravatar-entitet:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Anropa en mappnings funktion med en h√§ndelse

En anv√§ndare kan skapa en anpassad h√§ndelse och skicka den till en mappningsfunktion som √§r bunden till butiken:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Anropar alla mappningar med h√§ndelsefixturer

Anv√§ndare kan kalla mappningarna med testfixturer.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Mocka kontraktsanrop

Anv√§ndare kan simulera kontraktssamtal:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

F√∂r att kunna simulera ett kontraktsanrop och ett hardcore returv√§rde m√•ste anv√§ndaren tillhandah√•lla en kontraktsadress, funktionsnamn, funktionssignatur, en upps√§ttning argument och naturligtvis - returv√§rdet.

Anv√§ndare kan ocks√• simulera funktions√•terg√•ngar:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Simulering av IPFS-filer (fr√•n matchstick 0.4.1)

Anv√§ndare kan simulera IPFS-filer genom att anv√§nda funktionen `mockIpfsFile(hash, filePath)`. Funktionen accepterar tv√• argument, det f√∂rsta √§r IPFS-filens hash/s√∂kv√§g och det andra √§r s√∂kv√§gen till en lokal fil.

OBS: N√§r du testar `ipfs.map/ipfs.mapJSON` m√•ste callback-funktionen exporteras fr√•n testfilen f√∂r att matchstck ska uppt√§cka den, liknande `processGravatar()`-funktionen i testexemplet nedan:

`.test.ts` fil:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Exportera ipfs.map() callback s√• att matchstck kan uppt√§cka den
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` fil:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// ipfs.map callback
export function processGravatar(value: JSONValue, userData: Value): void {
  // Se JSONValue-dokumentationen f√∂r mer information om hur man hanterar
  // med JSON-v√§rden
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Callbacks kan ocks√• skapa enheter
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// funktion som anropar ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Kontrollera tillst√•ndet f√∂r lagret

Anv√§ndare kan kontrollera det slutgiltiga (eller delvisa) tillst√•ndet f√∂r lagret genom att verifiera enheter. F√∂r att g√∂ra detta m√•ste anv√§ndaren ange en enhetstyp, den specifika ID: n f√∂r en enhet, namnet p√• ett f√§lt p√• den enheten och det f√∂rv√§ntade v√§rdet p√• f√§ltet. H√§r √§r ett snabbt exempel:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

K√∂rning av funktionen assert.fieldEquals() kommer att kontrollera om det angivna f√§ltet √§r lika med det f√∂rv√§ntade v√§rdet. Testet kommer att misslyckas och ett felmeddelande kommer att visas om v√§rdena **INTE** √§r lika. Annars kommer testet att passera framg√•ngsrikt.

### Interagera med h√§ndelsemetadata

Anv√§ndare kan anv√§nda standardtransaktionsmetadata, som kan returneras som en ethereum.Event genom att anv√§nda funktionen `newMockEvent()`. F√∂ljande exempel visar hur du kan l√§sa/skriva till de f√§lten p√• Event-objektet:

```typescript
// L√§s
let logType = newGravatarEvent.logType

// Skriv
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### P√•st√•ende om variabelns likhet

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### P√•st√• att en entitet **inte** finns i butiken

Anv√§ndare kan h√§vda att en entitet inte finns i butiken. Funktionen tar en entitetstyp och ett id. Om entiteten faktiskt finns i butiken kommer testet att misslyckas med ett relevant felmeddelande. H√§r √§r ett snabbt exempel p√• hur du anv√§nder den h√§r funktionen:

```typescript
assert.notInStore('Gravatar', '23')
```

### Printing the whole store, or single entities from it (for debug purposes)

Du kan skriva ut hela lagret till konsolen med hj√§lp av denna hj√§lpfunktion:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

As of version 0.6.0, `logStore` no longer prints derived fields, instead users can use the new `logEntity` function. Of course `logEntity` can be used to print any entity, not just ones that have derived fields. `logEntity` takes the entity type, entity id and a `showRelated` flag to indicate if users want to print the related derived entities.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### F√∂rv√§ntat misslyckande

Anv√§ndare kan ha f√∂rv√§ntade testfel genom att anv√§nda flaggan shouldFail p√• test()-funktionerna:

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Om testet √§r markerat med shouldFail = true men INTE misslyckas, kommer det att visas som ett fel i loggarna och testblocket kommer att misslyckas. Om testet √§r markerat med shouldFail = false (standardtillst√•ndet) kommer testk√∂raren dessutom att krascha.

### Loggning

Att ha anpassade loggar i enhetstesterna √§r exakt samma sak som att logga i mappningarna. Skillnaden √§r att loggobjektet m√•ste importeras fr√•n matchstick-as snarare √§n graph-ts. H√§r √§r ett enkelt exempel med alla icke-kritiska loggtyper:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Anv√§ndare kan ocks√• simulera ett kritiskt fel, t.ex:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Loggning av kritiska fel kommer att stoppa utf√∂randet av testerna och orsaka total krasch. Trots allt vill vi s√§kerst√§lla att din kod inte har kritiska loggar i produktion, och du b√∂r m√§rka det omedelbart om det skulle intr√§ffa.

### Testning av h√§rledda f√§lt

Testing derived fields is a feature which allows users to set a field on a certain entity and have another entity be updated automatically if it derives one of its fields from the first entity.

Before version `0.6.0` it was possible to get the derived entities by accessing them as entity fields/properties, like so:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

As of version `0.6.0`, this is done by using the `loadRelated` function of graph-node, the derived entities can be accessed the same way as in the handlers.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Testing `loadInBlock`

As of version `0.6.0`, users can test `loadInBlock` by using the `mockInBlockStore`, it allows mocking entities in the block cache.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Can use entity.loadInBlock() to retrieve entity from cache store in the current block', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Returns null when calling entity.loadInBlock() if an entity doesn't exist in the current block", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Testning av dynamiska datak√§llor

Testning av dynamiska datak√§llor kan g√∂ras genom att moka returv√§rdena f√∂r funktionerna `context()`, `address()` och `network()` i dataSource-namespace. Dessa funktioner returnerar f√∂r n√§rvarande f√∂ljande: `context()` - returnerar en tom entitet (DataSourceContext), `address()` - returnerar `0x0000000000000000000000000000000000000000`, `network()` - returnerar `mainnet`. Funktionerna `create(...)` och `createWithContext(...)` mokas f√∂r att inte g√∂ra n√•got, s√• de beh√∂ver inte anropas i testerna alls. √Ñndringar av returv√§rden kan g√∂ras genom funktionerna i namespace `dataSourceMock` i `matchstick-as` (version 0.3.0+).

Exempel nedan:

F√∂rst har vi f√∂ljande h√§ndelsehanterare (som medvetet har √§ndrats f√∂r att visa datasourcemockning):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

Och sedan har vi testet som anv√§nder en av metoderna i namespace dataSourceMock f√∂r att st√§lla in ett nytt returv√§rde f√∂r alla dataSource-funktioner:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Observera att dataSourceMock.resetValues() anropas i slutet. Det beror p√• att v√§rdena kom ih√•g n√§r de √§ndrades och beh√∂ver √•terst√§llas om du vill √•terg√• till standardv√§rdena.

### Testing dynamic data source creation

As of version `0.6.0`, it is possible to test if a new data source has been created from a template. This feature supports both ethereum/contract and file/ipfs templates. There are four functions for this:

- `assert.dataSourceCount(templateName, expectedCount)` can be used to assert the expected count of data sources from the specified template
- `assert.dataSourceExists(templateName, address/ipfsHash)` asserts that a data source with the specified identifier (could be a contract address or IPFS file hash) from a specified template was created
- `logDataSources(templateName)` prints all data sources from the specified template to the console for debugging purposes
- `readFile(path)` reads a JSON file that represents an IPFS file and returns the content as Bytes

#### Testing `ethereum/contract` templates

```typescript
test('ethereum/contract dataSource creation example', () => {
  // Assert there are no dataSources created from GraphTokenLockWallet template
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // Create a new GraphTokenLockWallet datasource with address 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Add a second dataSource with context
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert there are now 2 dataSources
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // Assert that a dataSource with address "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" was created
  // Keep in mind that `Address` type is transformed to lower case when decoded, so you have to pass the address as all lower case when asserting if it exists
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### Example `logDataSource` output

```bash
üõ†  {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
}
```

#### Testing `file/ipfs` templates

Similarly to contract dynamic data sources, users can test test file datas sources and their handlers

##### Example `subgraph.yaml`

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### Example `schema.graphql`

```graphql
"""
Token Lock Wallets which hold locked GRT
"""
type TokenLockMetadata @entity {
  "The address of the token lock wallet"
  id: ID!
  "Start time of the release schedule"
  startTime: BigInt!
  "End time of the release schedule"
  endTime: BigInt!
  "Number of periods between start time and end time"
  periods: BigInt!
  "Time when the releases start"
  releaseStartTime: BigInt!
}
```

##### Example `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Example handler

```typescript
export function handleMetadata(content: Bytes): void {
  // dataSource.stringParams() returns the File DataSource CID
  // stringParam() will be mocked in the handler test
  // for more info https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Example test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () => {
  // Generate the dataSource CID from the ipfsHash + ipfs path file
  // For example QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // Create a new dataSource using the generated CID
  GraphTokenLockMetadata.create(CID)

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Now we have to mock the dataSource metadata and specifically dataSource.stringParam()
  // dataSource.stringParams actually uses the value of dataSource.address(), so we will mock the address using dataSourceMock from  matchstick-as
  // First we will reset the values and then use dataSourceMock.setAddress() to set the CID
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)

  // Now we need to generate the Bytes to pass to the dataSource handler
  // For this case we introduced a new function readFile, that reads a local json and returns the content as Bytes
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Now we will test if a TokenLockMetadata was created
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Testt√§ckning

Med **Matchstick** kan subgraph-utvecklare k√∂ra ett skript som ber√§knar t√§ckningen av de skrivna enhetstesterna.

Verktyget f√∂r testt√§ckning tar de kompilerade test `wasm` bin√§rerna och omvandlar dem till `wat`filer, som sedan enkelt kan inspekteras f√∂r att se om hanterarna som √§r definierade i `subgraph.yaml` har blivit kallade eller inte. Eftersom kodt√§ckning (och tester som helhet) √§r i mycket tidiga stadier i AssemblyScript och WebAssembly kan **Matchstick** inte kontrollera grent√§ckning. Ist√§llet f√∂rlitar vi oss p√• p√•st√•endet att om en given hanterare har blivit kallad, har h√§ndelsen/funktionen f√∂r den hanteraren blivit korrekt mockad.

### F√∂ruts√§ttningar

F√∂r att k√∂ra testt√§ckningsfunktionaliteten som tillhandah√•lls i **Matchstick** m√•ste du f√∂rbereda n√•gra saker i f√∂rv√§g:

#### Exportera dina hanterare

F√∂r att **Matchstick** ska kunna kontrollera vilka hanterare som k√∂rs m√•ste dessa hanterare exporteras fr√•n **testfilen**. Till exempel i v√•rt exempel, i v√•r fil gravity.test.ts, har vi f√∂ljande hanterare som importeras:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

F√∂r att denna funktion skall vara synlig (f√∂r att den skall ing√• i `wat`-filen **med namn**) m√•ste vi ocks√• exportera den, s√• h√§r:

```typescript
export { handleNewGravatar }
```

### Anv√§ndning

N√§r allt √§r klart k√∂r du bara testt√§ckningsverktyget:

```sh
graph test -- -c
```

Du kan ocks√• l√§gga till ett anpassat `coverage`-kommando i din `package.json`-fil, s√• h√§r:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Det kommer att k√∂ra t√§ckningsverktyget och du b√∂r se n√•got liknande i terminalen:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 Ô∏è
Reading generated test modules... üîéÔ∏è

Generating coverage report üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Testk√∂rningens varaktighet i loggutmatningen

Loggutmatningen inneh√•ller testk√∂rningens varaktighet. H√§r √§r ett exempel:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Vanliga kompilatorfel

> Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined

Det betyder att du har anv√§nt `console.log` i din kod, som inte st√∂ds av AssemblyScript. √ñverv√§g att anv√§nda [Logging API](/developing/assemblyscript-api/#logging-api)

> ERROR TS2554: Expected ? arguments, but got ?.
> 
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
> 
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
> 
> ERROR TS2554: Expected ? arguments, but got ?.
> 
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
> 
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

Mots√§gelsen i argumenten beror p√• en mots√§gelse i `graph-ts` och `matchstick-as`. Det b√§sta s√§ttet att √•tg√§rda problem som detta √§r att uppdatera allt till den senaste utgivna versionen.

## Respons

Om du har n√•gra fr√•gor, feedback, funktionsf√∂rfr√•gningar eller bara vill n√• ut, √§r det b√§sta st√§llet The Graph Discord d√§r vi har en dedikerad kanal f√∂r Matchstick, kallad üî•| unit-testing.
