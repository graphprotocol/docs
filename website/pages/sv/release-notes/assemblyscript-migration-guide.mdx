---
title: AssemblyScript Migrationsguide
---

Hittills har undergrafar anv√§nt en av de [f√∂rsta versionerna av AssemblyScript](https://github.com/AssemblyScript/assemblyscript/tree/v0.6) (v0.6). √Ñntligen har vi lagt till st√∂d f√∂r den [nyaste tillg√§ngliga versionen](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10)! üéâ

Det kommer att m√∂jligg√∂ra f√∂r undergrafutvecklare att anv√§nda nyare funktioner i AS-spr√•ket och standardbiblioteket.

Denna guide √§r till√§mplig f√∂r alla som anv√§nder `graph-cli`/`graph-ts` version `0.22.0` eller l√§gre. Om du redan √§r p√• en h√∂gre version √§n (eller lika med) det, har du redan anv√§nt version `0.19.10` av AssemblyScript üôÇ

> Observera: Fr√•n och med `0.24.0` kan `graph-node` st√∂dja b√•da versionerna, beroende p√• `apiVersion` som anges i undergrafens manifest.

## Funktioner

### Ny funktionalitet

- `TypedArray`s kan nu skapas fr√•n `ArrayBuffer`s med hj√§lp av [det nya `wrap`-statiska metoden](https://www.assemblyscript.org/stdlib/typedarray.html#static-members) ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1))
- Nya standardbiblioteksfunktioner: `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare` och `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Lagt till st√∂d f√∂r x instanceof GenericClass ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Lagt till `StaticArray<T>`, en mer effektiv varian av en array ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- Lagt till `Array<T>#flat` ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Implementerat `radix`-argumentet p√• `Number#toString` ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- Lagt till st√∂d f√∂r avskiljare i flyttal ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7))
- Lagt till st√∂d f√∂r funktioner av f√∂rsta klass ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0))
- L√§gg till inbyggda funktioner: `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- Implementera `Array/TypedArray/String#at` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- Lagt till st√∂d f√∂r mallliteralstr√§ngar ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- L√§gg till `encodeURI(Component)` och `decodeURI(Component)` ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- L√§gg till `toString`, `toDateString` och `toTimeString` f√∂r `Date` ([v0.18.29](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- L√§gg till `toUTCString` f√∂r `Date` ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- L√§gg till inbyggd typ `nonnull/NonNullable` ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### Optimeringar

- `Math`-funktioner som `exp`, `exp2`, `log`, `log2` och `pow` har ersatts med snabbare varianter ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- L√§tt optimering av `Math.mod` ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- Cachea fler f√§lt√•tkomster i std Map och Set ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
- Optimering f√∂r potenser av tv√• i `ipow32/64` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### Annat

- Typen f√∂r en arrayliteral kan nu h√§rledas fr√•n dess inneh√•ll ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Uppdaterad stdlib till Unicode 13.0.0 ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))

## Hur uppgraderar du?

1. √Ñndra dina mappningar `apiVersion` i `subgraph.yaml` till `0.0.6`:

```yaml
...
dataSources:
  ...
    mapping:
      ...
      apiVersion: 0.0.6
      ...
```

2. Uppdatera `graph-cli` som du anv√§nder till den `nyaste` versionen genom att k√∂ra:

```bash
# om du har den globalt installerad
npm install --global @graphprotocol/graph-cli@latest

# eller i din subgraf om du har det som ett utvecklingsberoende
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. G√∂r samma sak f√∂r `graph-ts`, men ist√§llet f√∂r att installera globalt, spara den i dina huvudberoenden:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. F√∂lj resten av guiden f√∂r att √•tg√§rda spr√•kbrytande √§ndringar.
5. K√∂r `codegen` och `deploy` igen.

## Spr√•kbrytande √§ndringar

### Nullbarhet

I den √§ldre versionen av AssemblyScript kunde du skapa kod som detta:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

Men i den nyare versionen, eftersom v√§rdet √§r nullable, m√•ste du kontrollera, s√• h√§r:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` is not null anymore
}
```

Eller g√∂r s√• h√§r:

```typescript
let maybeValue = load()! // bryts i runtime om v√§rdet √§r null

maybeValue.aMethod()
```

Om du √§r os√§ker p√• vilken du ska v√§lja, rekommenderar vi alltid att anv√§nda den s√§kra versionen. Om v√§rdet inte finns kanske du bara vill g√∂ra ett tidigt villkorligt uttalande med en retur i din undergrafshanterare.

### Variabelskuggning

Tidigare kunde du anv√§nda [variabelskuggning](https://en.wikipedia.org/wiki/Variable_shadowing) och kod som detta skulle fungera:

```typescript
let a = 10
let b = 20
let a = a + b
```

Men nu √§r detta inte l√§ngre m√∂jligt, och kompilatorn returnerar detta fel:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

Du m√•ste d√∂pa om dina duplicerade variabler om du hade variabelskuggning.

### J√§mf√∂relser med nollv√§rden

N√§r du g√∂r uppgraderingen av din subgraf kan du ibland f√• fel som dessa:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

F√∂r att l√∂sa problemet kan du helt enkelt √§ndra `if`-satsen till n√•got i den h√§r stilen:

```typescript
  if (!decimals) {

  // or

  if (decimals === null) {
```

Samma g√§ller om du anv√§nder != ist√§llet f√∂r ==.

### Kasting

Det vanliga s√§ttet att g√∂ra kasting tidigare var att bara anv√§nda nyckelordet `as`, som s√• h√§r:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // motsvarande: <Uint8Array>byteArray
```

Detta fungerar dock endast i tv√• scenarier:

- Primitiv kasting (mellan typer som `u8`, `i32`, `bool`; t.ex. `let b: isize = 10; b as usize`);
- Uppkasting vid klassarv (underklass ‚Üí √∂verklass)

Exempel:

```typescript
// primitive casting
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
// upcasting on class inheritance
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // same as: bytes as Uint8Array
```

Det finns tv√• scenarier d√§r du kan vilja casta, men att anv√§nda `as`/`<T>var` **√§r inte s√§kert**:

- Downcasting vid arv av klasser (superklass ‚Üí subklass)
- Mellan tv√• typer som delar en superklass

```typescript
// downcasting om klassarv
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // breaks in runtime :(
```

```typescript
// mellan tv√• typer som delar en superklass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // breaks in runtime :(
```

I dessa fall kan du anv√§nda funktionen `changetype<T>`:

```typescript
// downcasting om klassarv
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // works :)
```

```typescript
// mellan tv√• typer som delar en superklass
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // works :)
```

Om du bara vill ta bort nullability kan du forts√§tta anv√§nda `as`-operatorn (eller `<T>variable`), men se till att du vet att v√§rdet inte kan vara null, annars kommer det att bryta.

```typescript
// ta bort ogiltighet
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // safe remove null
}

let newBalance = new AccountBalance(balanceId)
```

F√∂r nullbarhetsfallet rekommenderar vi att du tittar p√• [nullbarhetskontrollfunktionen](https://www.assemblyscript.org/basics.html#nullability-checks), den kommer att g√∂ra din kod renare üôÇ

Vi har ocks√• lagt till n√•gra fler statiska metoder i vissa typer f√∂r att underl√§tta kastning, de √§r:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### Kontroll av nollst√§llbarhet med tillg√•ng till egendom

F√∂r att anv√§nda [nullability check feature](https://www.assemblyscript.org/basics.html#nullability-checks) kan du anv√§nda antingen `if`-satser eller den tern√§ra operatorn (`?` och `:`) s√• h√§r:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// or

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

Men det fungerar bara n√§r du g√∂r `if` / ternary p√• en variabel, inte p√• en egenskapstillg√•ng, som den h√§r:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // Kompilerar inte
```

Vilket ger detta fel:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

F√∂r att √•tg√§rda problemet kan du skapa en variabel f√∂r den egenskapen s√• att kompilatorn kan utf√∂ra den magiska nollbarhetskontrollen:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // kompilerar helt okej :)
```

### Operat√∂rs√∂verladdning med egenskapsaccess

Om du f√∂rs√∂ker summera (till exempel) en nullable typ (fr√•n en property access) med en non nullable, kommer AssemblyScript-kompilatorn ist√§llet f√∂r att ge en kompileringsfelsvarning om att ett av v√§rdena √§r nullable, bara att kompilera tyst, vilket g√∂r att koden kan g√• s√∂nder vid k√∂rning.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // ge kompileringsfel om ogiltighet

let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // ger inte kompileringsfel som det borde
```

Vi har √∂ppnat en fr√•ga om AssemblyScript-kompilatorn f√∂r detta, men om du g√∂r den h√§r typen av operationer i dina subgraf-mappningar b√∂r du √§ndra dem s√• att de g√∂r en null-kontroll innan den.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // nu √§r `n` garanterat ett BigInt
```

### Initialisering av v√§rde

Om du har n√•gon kod som denna:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

Det kommer att kompilera men brytas vid k√∂rning, det h√§nder eftersom v√§rdet inte har initialiserats, s√• se till att din subgraf har initialiserat sina v√§rden, s√• h√§r:

```typescript
var value = new Type() // initialized
value.x = 10
value.y = 'content'
```

√Ñven om du har nullable properties i en GraphQL-entitet, som denna:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

Och du har en kod som liknar den h√§r:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

Du m√•ste se till att initialisera v√§rdet `total.amount`, f√∂r om du f√∂rs√∂ker komma √•t som i den sista raden f√∂r summan, kommer det att krascha. S√• antingen initialiserar du det f√∂rst:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

Eller s√• kan du bara √§ndra ditt GraphQL-schema f√∂r att inte anv√§nda en nullable-typ f√∂r den h√§r egenskapen, d√• initierar vi den som noll i `codegen` -steget üòâ

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest') // initierar redan icke-nullst√§llbara egenskaper
}

total.amount = total.amount + BigInt.fromI32(1)
```

### Initialisering av klassegenskaper

Om du exporterar n√•gra klasser med egenskaper som √§r andra klasser (deklarerade av dig eller av standardbiblioteket) p√• det h√§r s√§ttet:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

Kompilatorn kommer att g√∂ra fel eftersom du antingen m√•ste l√§gga till en initialiserare f√∂r de egenskaper som √§r klasser, eller l√§gga till operatorn `!`:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// or

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// or

export class Something {
  value!: Thing
}
```

### Initialisering av Array

Klassen `Array` accepterar fortfarande ett tal f√∂r att initiera l√§ngden p√• listan, men du b√∂r vara f√∂rsiktig eftersom operationer som `.push` faktiskt √∂kar storleken ist√§llet f√∂r att l√§gga till i b√∂rjan, till exempel:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // size 6 :(
```

Beroende p√• vilka typer du anv√§nder, t.ex. nullable-typer, och hur du kommer √•t dem, kan du st√∂ta p√• ett runtime-fel som det h√§r:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

F√∂r att faktiskt trycka i b√∂rjan b√∂r du antingen initiera `Array` med storlek noll, s√• h√§r:

```typescript
let arr = new Array<string>(0) // []

arr.push('something') // ["something"]
```

Eller s√• b√∂r du mutera den via index:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'something' // ["something", "", "", "", ""]
```

### GraphQL-schema

Detta √§r inte en direkt AssemblyScript-√§ndring, men du kan beh√∂va uppdatera din `schema.graphql`-fil.

Nu kan du inte l√§ngre definiera f√§lt i dina typer som √§r Non-Nullable Lists. Om du har ett schema som detta:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something]! # no longer valid
}
```

Du m√•ste l√§gga till en `!` till medlemmen i List-typen, s√• h√§r:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # valid
}
```

Detta √§ndrades p√• grund av skillnader i nullbarhet mellan AssemblyScript-versioner, och det √§r relaterat till filen `src/generated/schema.ts` (standardv√§g, du kanske har √§ndrat detta).

### Annat

- J√§mnade `Map#set` och `Set#add` med specifikationen, som returnerar `this` ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Arrayer √§rver inte l√§ngre fr√•n ArrayBufferView, men √§r nu distinkta ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Klasser som initialiseras fr√•n objektlitteraler kan inte l√§ngre definiera en konstruktor ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Resultatet av en bin√§r `**`-operation √§r nu det gemensamma n√§mnaren f√∂r heltal om b√•da operanderna √§r heltal. Tidigare var resultatet ett flyttal som om man anropade `Math/f.pow` ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- Tvinga `NaN` till `false` vid kastning till `bool` ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9))
- N√§r du skiftar en liten heltalsv√§rde av typ `i8`/`u8` eller `i16`/`u16`, p√•verkar endast de 3 respektive 4 minst signifikanta bitarna i RHS-v√§rdet resultatet, analogt med resultatet av en `i32.shl` som endast p√•verkas av de 5 minst signifikanta bitarna i RHS-v√§rdet. Exempel: `someI8 << 8` producerade tidigare v√§rdet `0`, men producerar nu `someI8` p√• grund av maskeringen av RHS som `8 & 7 = 0` (3 bitar) ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0))
- Buggfix f√∂r relationella str√§ngj√§mf√∂relser n√§r storlekarna skiljer sig ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
