---
title: Indexing का अवलोकन
---

Indexers are node operators in The Graph Network that stake Graph Tokens (GRT) in order to provide indexing and query processing services. Indexers earn query fees and indexing rewards for their services. They also earn query fees that are rebated according to an exponential rebate function.

जीआरटी जो प्रोटोकॉल में दांव पर लगा है, विगलन अवधि के अधीन है और यदि अनुक्रमणिका दुर्भावनापूर्ण हैं और अनुप्रयोगों को गलत डेटा प्रदान करते हैं या यदि वे गलत तरीके से अनुक्रमणित करते हैं तो इसे घटाया जा सकता है। इंडेक्सर्स नेटवर्क में योगदान करने के लिए डेलीगेटर्स से प्रत्यायोजित हिस्सेदारी के लिए पुरस्कार भी अर्जित करते हैं।

इंडेक्सर्स सबग्राफ के क्यूरेशन सिग्नल के आधार पर इंडेक्स के लिए सबग्राफ का चयन करते हैं, जहां क्यूरेटर GRT को यह इंगित करने के लिए दांव पर लगाते हैं कि कौन से सबग्राफ उच्च-गुणवत्ता वाले हैं और उन्हें प्राथमिकता दी जानी चाहिए। उपभोक्ता (उदाहरण के लिए अनुप्रयोग) पैरामीटर भी सेट कर सकते हैं जिसके लिए इंडेक्सर्स अपने सबग्राफ के लिए प्रश्नों को प्रोसेस करते हैं और क्वेरी शुल्क मूल्य निर्धारण के लिए वरीयताएँ निर्धारित करते हैं।

<Difficulty level="ADVANCED" />

## FAQ

### नेटवर्क पर इंडेक्सर बनने के लिए आवश्यक न्यूनतम हिस्सेदारी क्या है?

इंडेक्सर के लिए न्यूनतम हिस्सेदारी वर्तमान में 100K GRT पर सेट है।

### एक इंडेक्सर के लिए राजस्व धाराएं क्या हैं?

**क्वेरी शुल्क छूट** - नेटवर्क पर क्वेरी सेवाओं के लिए किए गए भुगतान। ये भुगतान 'state channels' के माध्यम से एक Indexer और एक 'gateway' के बीच नियंत्रित किए जाते हैं। 'gateway' से प्रत्येक क्वेरी अनुरोध में एक भुगतान और संबंधित प्रतिक्रिया में क्वेरी परिणाम की वैधता का प्रमाण शामिल होता है।

indexing रिवॉर्ड्स - 3% वार्षिक प्रोटोकॉल वाइड इन्फ्लेशन के माध्यम से उत्पन्न, indexing रिवॉर्ड्स उन Indexers को वितरित किए जाते हैं जो नेटवर्क के indexing subgraph डिप्लॉयमेंट्स को इंडेक्स कर रहे हैं।

### इंडेक्सिंग पुरस्कार कैसे वितरित किए जाते हैं?

प्रोटोकॉल मुद्रास्फीति से मिलने वाले indexing पुरस्कार 3% वार्षिक निर्गमन पर सेट किए गए हैं। इन्हें प्रत्येक subgraph पर कुल क्यूरेशन सिग्नल के अनुपात के आधार पर वितरित किया जाता है, और फिर Indexers को उनके उस subgraph पर आवंटित हिस्सेदारी के अनुपात में वितरित किया जाता है। पुरस्कार के लिए पात्र होने के लिए, एक आवंटन को 'proof of indexing (POI)' के साथ बंद किया जाना चाहिए जो कि 'arbitration charter' द्वारा निर्धारित मानकों को पूरा करता हो।

समुदाय द्वारा इनामों की गणना के लिए कई उपकरण बनाए गए हैं; आपको इनका संग्रह Community Guides
collection(https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c) में संगठित रूप से मिलेगा। आप इन उपकरणों की एक अद्यतन सूची #Delegators और #Indexers चैनलों में Discord server(https://discord.gg/graphprotocol) पर भी पा सकते हैं। यहाँ हम एक recommended allocation optimiser(https://github.com/graphprotocol/allocation-optimizer) का लिंक देते हैं, जो indexer software stack के साथ एकीकृत है।

### इंडेक्सिंग (पीओआई) का सबूत क्या है?

पीओआई का उपयोग नेटवर्क में यह सत्यापित करने के लिए किया जाता है कि एक इंडेक्सर उनके द्वारा आवंटित उपग्राफों को अनुक्रमित कर रहा है। इंडेक्सिंग पुरस्कारों के लिए पात्र होने के लिए उस आवंटन के आवंटन को बंद करते समय वर्तमान युग के पहले ब्लॉक के लिए एक पीओआई जमा किया जाना चाहिए। एक ब्लॉक के लिए एक पीओआई उस ब्लॉक तक और उस सहित एक विशिष्ट सबग्राफ परिनियोजन के लिए सभी एंटिटी स्टोर लेनदेन के लिए डाइजेस्ट है।

### अनुक्रमण पुरस्कार कब वितरित किए जाते हैं?

आवंटन लगातार पुरस्कार अर्जित कर रहे हैं जबकि वे सक्रिय हैं और 28 युगों के भीतर आवंटित किए गए हैं। इंडेक्सर्स द्वारा पुरस्कार एकत्र किए जाते हैं, और जब भी उनका आवंटन बंद हो जाता है, वितरित किया जाता है। यह या तो मैन्युअल रूप से होता है, जब भी इंडेक्सर उन्हें बंद करना चाहता है, या 28 युगों के बाद एक प्रतिनिधि इंडेक्सर के आवंटन को बंद कर सकता है, लेकिन इसका परिणाम कोई पुरस्कार नहीं होता है। 28 युग अधिकतम आवंटन जीवनकाल है (अभी, एक युग ~ 24h तक रहता है)।

### क्या लंबित अनुक्रमण पुरस्कारों की निगरानी की जा सकती है?

RewardsManager कॉन्ट्रैक्ट में एक read-only getRewards(https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316) फ़ंक्शन है, जिसे किसी विशेष allocation के लिए लंबित rewards की जांच करने के लिए उपयोग किया जा सकता है।

कई समुदाय-निर्मित डैशबोर्ड में लंबित पुरस्कार मान शामिल हैं और इन चरणों का पालन करके उन्हें आसानी से मैन्युअल रूप से चेक किया जा सकता है:

1. [mainnet subgraph](https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one) को क्वेरी करें ताकि सभी 'active allocations' के लिए IDs प्राप्त की जा सकें।

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Etherscan का उपयोग करके getRewards() कॉल करें:

- Etherscan इंटरफेस पर 'Rewards' कॉन्ट्रैक्ट(https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract) को नेविगेट करें

<!---->

- getRewards() को कॉल करने के लिए:
  - **9. getRewards** ड्रॉपडाउन को विस्तार से खोलें।
  - **allocationID** को इनपुट में दर्ज करें।
  - **Query** बटन पर क्लिक करें।

### विवाद क्या हैं और मैं उन्हें कहां देख सकता हूं?

विवाद की अवधि के दौरान इंडेक्सर की पूछताछ और आवंटन दोनों को ग्राफ़ पर विवादित किया जा सकता है। विवाद के प्रकार के आधार पर विवाद की अवधि अलग-अलग होती है। प्रश्न/सत्यापन में 7 युग विवाद विंडो हैं, जबकि आवंटन में 56 युग हैं। इन अवधियों के बीत जाने के बाद, आवंटन या प्रश्नों में से किसी के विरुद्ध विवाद नहीं खोला जा सकता है। जब कोई विवाद खोला जाता है, तो मछुआरों द्वारा न्यूनतम 10,000 जीआरटी की जमा राशि की आवश्यकता होती है, जो विवाद को अंतिम रूप देने और समाधान दिए जाने तक बंद रहेगा। मछुआरे कोई भी नेटवर्क प्रतिभागी हैं जो विवाद खोलते हैं।

विवादों के **तीन** संभावित परिणाम होते हैं, वैसे ही मछुआरों का जमा भी होता है।

- यदि विवाद को खारिज कर दिया जाता है, तो मछुआरों द्वारा जमा किए गए जीआरटी को जला दिया जाएगा और विवादित इंडेक्सर को नहीं काटा जाएगा।
- यदि विवाद ड्रा के रूप में सुलझाया जाता है, तो मछुआरों की जमा राशि वापस कर दी जाएगी, और विवादित इंडेक्सर को नहीं काटा जाएगा।
- यदि विवाद स्वीकार किया जाता है, तो मछुआरों द्वारा जमा किया गया जीआरटी वापस कर दिया जाएगा, विवादित इंडेक्सर को घटा दिया जाएगा और मछुआरे घटे हुए जीआरटी का 50% अर्जित करेंगे।

विवादों को UI में एक Indexer के प्रोफ़ाइल पृष्ठ पर Disputes टैब के तहत देखा जा सकता है।

### प्रश्न शुल्क छूट क्या हैं और वे कब वितरित की जाती हैं?

क्वेरी शुल्क गेटवे द्वारा एकत्र किए जाते हैं और Indexer को प्रक्षिप्त छूट फ़ंक्शन के अनुसार वितरित किए जाते हैं (यहां GIP देखें here(https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162))। प्रक्षिप्त छूट फ़ंक्शन को Indexer को सबसे अच्छा परिणाम प्राप्त करने के लिए प्रोत्साहित करने का एक तरीका प्रस्तावित किया गया है, ताकि वे queries की सेवा faithfully करें। यह Indexer को एक बड़ी मात्रा में स्टेक आवंटित करने के लिए प्रोत्साहित करता है (जो एक क्वेरी की सेवा करते समय गलती करने पर स्लैश किया जा सकता है), जो कि वे जो क्वेरी शुल्क एकत्र कर सकते हैं, उसके मुकाबले अधिक है।

Once an allocation has been closed the rebates are available to be claimed by the Indexer. Upon claiming, the query fee rebates are distributed to the Indexer and their Delegators based on the query fee cut and the exponential rebate function.

### क्वेरी फी कट और इंडेक्सिंग रिवॉर्ड कट क्या है?

The 'queryFeeCut' और 'indexingRewardCut' मान delegation पैरामीटर हैं जिन्हें Indexer अपने Delegators के बीच GRT के वितरण को नियंत्रित करने के लिए cooldownBlocks के साथ सेट कर सकता है। delegation पैरामीटर सेट करने के लिए Staking in the Protocol(/indexing/overview/#stake-in-the-protocol) में अंतिम कदम देखें।

- queryFeeCut - वह % जो query fee rebates का वितरण Indexer को किया जाएगा। अगर इसे 95% पर सेट किया जाता है, तो Indexer को वह query fees का 95% मिलेगा जो allocation बंद होने पर अर्जित होती है, जबकि बाकी का 5% Delegators को मिलेगा।

- **indexingRewardCut** - वह प्रतिशत जो indexing पुरस्कारों का होगा जिसे Indexer को वितरित किया जाएगा। यदि इसे 95% पर सेट किया गया है, तो Indexer को जब एक आवंटन बंद होगा, तो वह 95% indexing पुरस्कार प्राप्त करेगा और बाकी 5% को Delegators आपस में बांट लेंगे।

### इंडेक्सर्स कैसे जानते हैं कि इंडेक्स करने के लिए कौन से सबग्राफ हैं?

इंडेक्सर्स सबग्राफ इंडेक्सिंग निर्णय लेने के लिए उन्नत तकनीकों को लागू करके खुद को अलग कर सकते हैं लेकिन एक सामान्य विचार देने के लिए हम नेटवर्क में सबग्राफ का मूल्यांकन करने के लिए उपयोग की जाने वाली कई प्रमुख मीट्रिक पर चर्चा करेंगे:

- **Curation signal** - किसी विशेष subgraph पर लागू नेटवर्क क्यूरेशन सिग्नल का अनुपात उस subgraph में रुचि का अच्छा संकेतक होता है, खासकर बूटस्ट्रैप चरण के दौरान जब क्वेरी वॉल्यूम बढ़ रहा होता है।

- **क्वेरी शुल्क एकत्रित किए गए** - एक विशिष्ट Subgraph के लिए एकत्रित किए गए क्वेरी शुल्क के वॉल्यूम का ऐतिहासिक डेटा भविष्य की मांग का एक अच्छा संकेतक होता है।

- **Amount staked** - अन्य Indexers के व्यवहार की निगरानी करना या विशिष्ट subgraphs के लिए कुल स्टेक में आवंटित अनुपात को देखना एक Indexer को subgraph क्वेरीज़ के लिए आपूर्ति पक्ष की निगरानी करने की अनुमति दे सकता है, ताकि वे subgraphs की पहचान कर सकें जिनमें नेटवर्क विश्वास दिखा रहा है या ऐसे subgraphs जिन्हें अधिक आपूर्ति की आवश्यकता हो सकती है।

- **Subgraphs with no indexing rewards** - कुछ subgraphs में indexing rewards नहीं होते, मुख्य रूप से क्योंकि वे ऐसे unsupported features का उपयोग कर रहे होते हैं जैसे IPFS या क्योंकि वे mainnet के बाहर किसी अन्य नेटवर्क से query कर रहे होते हैं। यदि कोई subgraph indexing rewards नहीं जनरेट कर रहा है, तो आपको उस पर एक संदेश दिखाई देगा।

### हार्डवेयर आवश्यकताएँ क्या हैं?

- **छोटा** - शुरू करने के लिए पर्याप्त है, कुछ subgraphs को इंडेक्स करने के लिए, संभवतः इसे बढ़ाने की आवश्यकता होगी।
- **मानक** - डिफ़ॉल्ट सेटअप, यही है जो उदाहरण k8s/terraform डिप्लॉयमेंट मैनिफेस्ट्स में उपयोग किया जाता है।
- मध्यम - प्रोडक्शन Indexer जो 100 subgraphs और 200-500 रिक्वेस्ट प्रति सेकंड का समर्थन करता है।
- **बड़ा**- सभी वर्तमान में उपयोग किए जा रहे सबग्राफ़ को अनुक्रमित करने और संबंधित ट्रैफ़िक के लिए अनुरोधों को सेवा देने के लिए तैयार।

| Setup    | Postgres<br />(CPUs) | Postgres<br />(memory in GBs) | Postgres<br />(disk in TBs) | VMs<br />(CPUs) | VMs<br />(memory in GBs) |
| -------- | :------------------: | :---------------------------: | :-------------------------: | :-------------: | :----------------------: |
| Small    |           4          |               8               |              1              |        4        |            16            |
| Standard |           8          |               30              |              1              |        12       |            48            |
| Medium   |          16          |               64              |              2              |        32       |            64            |
| Large    |          72          |              468              |             3.5             |        48       |            184           |

### एक इंडेक्सर को कौन सी बुनियादी सुरक्षा सावधानियां बरतनी चाहिए?

- ऑपरेटर वॉलेट - एक ऑपरेटर वॉलेट सेट करना एक महत्वपूर्ण सुरक्षा उपाय है क्योंकि इससे एक Indexer को अपने स्टेक को नियंत्रित करने वाली कुंजियों और दिन-प्रतिदिन के संचालन को नियंत्रित करने वाली कुंजियों के बीच अलगाव बनाए रखने में मदद मिलती है। निर्देशों के लिए Stake in Protocol(/indexing/overview/#stake-in-the-protocol) for instructions. देखें।

- **फायरवॉल** - केवल Indexer सेवा को सार्वजनिक रूप से एक्सपोज़ किया जाना चाहिए और विशेष ध्यान प्रशासनिक पोर्ट्स और डेटाबेस एक्सेस को लॉक करने पर दिया जाना चाहिए: Graph Node JSON-RPC एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 8030), Indexer प्रबंधन API एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 18000), और Postgres डेटाबेस एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 5432) को एक्सपोज़ नहीं किया जाना चाहिए।

## आधारभूत संरचना

An Indexer की इंफ्रास्ट्रक्चर के केंद्र में the Graph Node होता है जो इंडेक्स किए गए नेटवर्क्स की निगरानी करता है, एक subgraph परिभाषा के अनुसार डेटा निकालता और लोड करता है और इसे एक GraphQL API(/about/#how-the-graph-works) के रूप में प्रदान करता है। The Graph Node को प्रत्येक इंडेक्स किए गए नेटवर्क से डेटा को एक्सपोज़ करने वाले एक endpoint से जोड़ा जाना चाहिए; डेटा स्रोत के लिए एक IPFS node; इसके स्टोर के लिए एक PostgreSQL डेटाबेस; और Indexer घटक जो इसके नेटवर्क के साथ इंटरएक्शन को सुविधाजनक बनाते हैं।

- PostgreSQL डेटाबेस - यह Graph Node के लिए मुख्य स्टोर है, जहां subgraph डेटा संग्रहीत किया जाता है। Indexer सेवा और एजेंट भी डेटाबेस का उपयोग state channel डेटा, लागत मॉडल, indexing नियम, और आवंटन क्रियाओं को संग्रहीत करने के लिए करते हैं।

- डेटा एंडपॉइंट -EVM-संगत नेटवर्क्स के लिए, Graph Node को एक ऐसे एन्डपॉइंट से कनेक्ट होना चाहिए जो EVM-संगत JSON-RPC API प्रदान करता हो। यह एक सिंगल क्लाइंट के रूप में हो सकता है या एक अधिक जटिल सेटअप हो सकता है जो कई क्लाइंट्स के बीच लोड को बैलेंस करता है। यह जानना महत्वपूर्ण है कि कुछ subgraphs को विशेष क्लाइंट क्षमताओं की आवश्यकता हो सकती है, जैसे कि आर्काइव मोड और/या parity tracing API।

- IPFS नोड (संस्करण 5 से कम) - सबग्राफ डिप्लॉयमेंट मेटाडेटा IPFS नेटवर्क पर संग्रहीत होता है। The Graph Node मुख्य रूप से सबग्राफ डिप्लॉयमेंट के दौरान IPFS नोड का उपयोग करता है ताकि सबग्राफ मैनिफेस्ट और सभी लिंक की गई फाइल्स को प्राप्त किया जा सके। नेटवर्क Indexers को अपना स्वयं का IPFS नोड होस्ट करने की आवश्यकता नहीं होती है, नेटवर्क के लिए एक IPFS नोड https://ipfs.network.thegraph.com पर होस्ट किया गया है।

- **Indexer सेवा** - नेटवर्क के साथ आवश्यक सभी बाहरी संचार को संभालती है। लागत मॉडलों और indexing स्थितियों को साझा करती है, गेटवे से आने वाले क्वेरी अनुरोधों को Graph Node तक पहुंचाती है, और गेटवे के साथ राज्य चैनलों के माध्यम से क्वेरी भुगतानों का प्रबंधन करती है।

- **Indexer एजेंट** - ऑनचेन पर Indexers की इंटरैक्शन को सुविधाजनक बनाता है, जिसमें नेटवर्क पर रजिस्ट्रेशन करना, अपने ग्राफ नोड/स पर Subgraph डिप्लॉयमेंट्स को मैनेज करना और आवंटनों (allocations) को प्रबंधित करना शामिल है।

- **प्रोमेथियस मेट्रिक्स सर्वर** - The Graph Node और Indexer कंपोनेंट्स अपने मेट्रिक्स को मेट्रिक्स सर्वर पर लॉग करते हैं।

नोट: फुर्तीली स्केलिंग का समर्थन करने के लिए, यह अनुशंसा की जाती है कि क्वेरी और इंडेक्सिंग चिंताओं को नोड्स के विभिन्न सेटों के बीच अलग किया जाए: क्वेरी नोड्स और इंडेक्स नोड्स।

### Ports overview

> **महत्वपूर्ण** पोर्ट्स को सार्वजनिक रूप से एक्सपोज़ करने में सतर्क रहें - **प्रशासनिक पोर्ट्स** को सुरक्षित रखना चाहिए। इसमें नीचे बताए गए Graph Node JSON-RPC और Indexer प्रबंधन एंडपॉइंट्स शामिल हैं।

#### ग्राफ-नोड

| Port | Purpose                                            | Routes                                         | CLI Argument       | Environment Variable |
| ---- | -------------------------------------------------- | ---------------------------------------------- | ------------------ | -------------------- |
| 8000 | GraphQL HTTP server<br />(सबग्राफ प्रश्नों के लिए) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port       | -                    |
| 8001 | GraphQL WS<br />(सबग्राफ सब्सक्रिप्शन के लिए)      | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port         | -                    |
| 8020 | JSON-RPC<br />(तैनाती के प्रबंधन के लिए)           | /                                              | \--admin-port      | -                    |
| 8030 | Subgraph indexing status API                       | /graphql                                       | \--index-node-port | -                    |
| 8040 | Prometheus metrics                                 | /metrics                                       | \--metrics-port    | -                    |

#### Indexer Service

| Port | Purpose                                            | Routes                                                      | CLI Argument    | Environment Variable   |
| ---- | -------------------------------------------------- | ----------------------------------------------------------- | --------------- | ---------------------- |
| 7600 | GraphQL HTTP server<br />(सबग्राफ प्रश्नों के लिए) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port         | `INDEXER_SERVICE_PORT` |
| 7300 | Prometheus metrics                                 | /metrics                                                    | \--metrics-port | -                      |

#### Indexer Agent

| Port | उद्देश्य                | Routes | CLI आर्ग्युमेंट              | एनवायरनमेंट वेरिएबल                     |
| ---- | ----------------------- | ------ | ---------------------------- | --------------------------------------- |
| 8000 | Indexer management API  | /      | \--indexer-management-port   | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Google क्लाउड पर टेराफॉर्म का उपयोग करके सर्वर इंफ्रास्ट्रक्चर सेटअप करें

> नोट: इंडेक्सर वैकल्पिक रूप से AWS, Microsoft Azure, या अलीबाबा का उपयोग कर सकते हैं।

#### Install prerequisites

- Google Cloud SDK
- Kubectl command line tool
- Terraform

#### एक Google क्लाउड प्रोजेक्ट बनाएं

- [Indexer repository](https://github.com/graphprotocol/indexer). को क्लोन करें या नेविगेट करें।

- `./terraform` निर्देशिका पर जाएं, यहीं पर सभी कमांड्स को निष्पादित किया जाना चाहिए।

```sh
cd terraform
```

- Google क्लाउड से प्रमाणित करें और एक नया प्रोजेक्ट बनाएं।

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- नए प्रोजेक्ट के लिए बिलिंग सक्षम करने के लिए Google क्लाउड कंसोल के बिलिंग पृष्ठ का उपयोग करें।

- Create a Google Cloud configuration.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- आवश्यक Google क्लाउड एपीआई सक्षम करें।

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- एक सेवा खाता बनाएँ।

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Terraform के लिए सेवा खाता" \
  --display-name="$svc_name"
gcloud iam service-accounts list
#सूची से सेवा खाते का ईमेल प्राप्त करें
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- डेटाबेस और Kubernetes क्लस्टर के बीच पियरिंग सक्षम करें जो अगले चरण में बनाया जाएगा।

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- न्यूनतम टेराफ़ॉर्म कॉन्फ़िगरेशन फ़ाइल बनाएँ (आवश्यकतानुसार अद्यतन करें)।

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database password>"
EOF
```

#### इंफ्रास्ट्रक्चर बनाने के लिए टेराफॉर्म का इस्तेमाल करें

किसी भी कमांड को चलाने से पहले, [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) को पढ़ें और इस डायरेक्टरी में एक फाइल terraform.tfvars बनाएं (या उस फाइल को संशोधित करें जो हमने पिछले चरण में बनाई थी)। प्रत्येक वेरिएबल के लिए, जहाँ आप डिफ़ॉल्ट को ओवरराइड करना चाहते हैं, या जहाँ आपको एक मान सेट करना है, terraform.tfvars में एक सेटिंग दर्ज करें।

- इन्फ्रास्ट्रक्चर बनाने के लिए निम्नलिखित कमांड चलाएँ।

```sh
# Install required plugins
terraform init

# View plan for resources to be created
terraform plan

# Create the resources (expect it to take up to 30 minutes)
terraform apply
```

नए क्लस्टर के लिए क्रेडेंशियल्स को `~/.kube/config` में डाउनलोड करें और इसे अपना डिफ़ॉल्ट कॉन्टेक्स्ट सेट करें।

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### इंडेक्सर के लिए कुबेरनेट्स घटक बनाना

- `k8s/overlays` डायरेक्टरी को एक नई डायरेक्टरी `$dir` में कॉपी करें, और `$dir/kustomization.yaml` में `bases` एंट्री को इस तरह से एडजस्ट करें कि वह `k8s/base` डायरेक्टरी की ओर पॉइंट करे।

- `$dir` में सभी फाइलों को पढ़ें और किसी भी मान को उन टिप्पणियों में दिए गए निर्देशों के अनुसार समायोजित करें।

सभी संसाधनों को $dir के साथ kubectl apply -k का उपयोग करके डिप्लॉय करें।

### ग्राफ-नोड

[Graph Node](https://github.com/graphprotocol/graph-node) एक ओपन-सोर्स रस्ट इंप्लीमेंटेशन है जो Ethereum ब्लॉकचेन को इवेंट सोर्सिंग करता है ताकि एक डेटा स्टोर को डिटर्मिनिस्टिक तरीके से अपडेट किया जा सके, जिसे GraphQL endpoint के माध्यम से क्वेरी किया जा सकता है। डेवलपर्स सबग्राफ का उपयोग करके अपनी स्कीमा को परिभाषित करते हैं और ब्लॉकचेन से प्राप्त डेटा को ट्रांसफॉर्म करने के लिए एक सेट ऑफ मैपिंग्स बनाते हैं। Graph Node संपूर्ण चेन को सिंक करता है, नए ब्लॉक्स की मॉनिटरिंग करता है और इसे GraphQL endpoint के माध्यम से सर्व करता है।

#### स्रोत से प्रारंभ करना

#### Install prerequisites

- **Rust**

- **PostgreSQL**

- **IPFS**

- **उबंटू उपयोगकर्ताओं के लिए अतिरिक्त आवश्यकताएँ** - उबंटू पर ग्राफ़ नोड चलाने के लिए कुछ अतिरिक्त पैकेजों की आवश्यकता हो सकती है।

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Setup

1. एक PostgreSQL डेटाबेस सर्वर प्रारंभ करें

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. [Graph Node](https://github.com/graphprotocol/graph-node) रिपोज़िटरी को क्लोन करें और स्रोत को बिल्ड करने के लिए `cargo build` कमांड चलाएं।

3. अब जब सभी निर्भरताएँ स्थापित हो गई हैं, तो ग्राफ़ नोड प्रारंभ करें:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### डॉकर का उपयोग शुरू करना

#### आवश्यक शर्तें

- **Ethereum नोड**-डिफ़ॉल्ट रूप से, डॉकर-कंपोज़ सेटअप मुख्यनेट का उपयोग करेगा: [http://host.docker.internal:8545] 
  (http://host.docker.internal:8545)आपके होस्ट मशीन पर Ethereum नोड से कनेक्ट होने के लिए। आप `docker-compose.yaml` को अपडेट करके इस नेटवर्क नाम और URL को बदल सकते हैं।

#### Setup

1. क्लोन ग्राफ़ नोड और डॉकर निर्देशिका पर नेविगेट करें:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. केवल Linux उपयोगकर्ताओं के लिए - `docker-compose.yaml` में `host.docker.internal` की बजाय होस्ट IP एड्रेस का उपयोग करें, दिए गए स्क्रिप्ट का उपयोग करते हुए।

```sh
./setup.sh
```

3. एक स्थानीय ग्राफ़ नोड प्रारंभ करें जो आपके एथेरियम समापन बिंदु से जुड़ जाएगा:

```sh
docker-compose up
```

### Indexer components

नेटवर्क में सफलतापूर्वक भाग लेने के लिए लगभग निरंतर निगरानी और सहभागिता की आवश्यकता होती है, इसलिए हमने इंडेक्सर्स नेटवर्क भागीदारी को सुविधाजनक बनाने के लिए टाइपस्क्रिप्ट एप्लिकेशन का एक सूट बनाया है। तीन इंडेक्सर घटक हैं:

- **Indexer एजेंट** - यह एजेंट नेटवर्क और इंडेक्सर के अपने इंफ्रास्ट्रक्चर की निगरानी करता है और यह प्रबंधित करता है कि कौन से subgraph deployments को ऑनचेन इंडेक्स और अलोकेट किया जाए और प्रत्येक पर कितना अलोकेशन किया जाए।

- **Indexer सेवा** - केवल एकमात्र घटक जिसे बाहरी रूप से एक्सपोज़ किया जाना आवश्यक है, यह सेवा Subgraph queries को ग्राफ नोड पर भेजती है, क्वेरी भुगतान के लिए स्टेट चैनल्स को प्रबंधित करती है, और क्लाइंट्स जैसे गेटवे को महत्वपूर्ण निर्णय लेने की जानकारी साझा करती है।

- **Indexer CLI** - Indexer एजेंट को प्रबंधित करने के लिए कमांड लाइन इंटरफ़ेस। यह इंडेक्सर्स को लागत मॉडल्स, मैनुअल आवंटन, कार्यों की कतार, और इंडेक्सिंग नियमों को प्रबंधित करने की अनुमति देता है।

#### शुरू करना

आपके Graph Node इंफ्रास्ट्रक्चर के साथ Indexer एजेंट और Indexer सेवा को सह-स्थित किया जाना चाहिए। Indexer कंपोनेंट्स के लिए वर्चुअल निष्पादन वातावरण सेटअप करने के कई तरीके हैं; यहां हम समझाएंगे कि उन्हें baremetal  पर NPM पैकेज या स्रोत का उपयोग करके कैसे चलाया जाए, या Google Cloud Kubernetes Engine पर Kubernetes और Docker के माध्यम से। यदि ये सेटअप उदाहरण आपकी इंफ्रास्ट्रक्चर पर लागू नहीं होते हैं, तो शायद एक समुदाय गाइड उपलब्ध होगा, [Discord](https://discord.gg/graphprotocol) पर आकर हमें हैलो कहें! अपने Indexer कंपोनेंट्स शुरू करने से पहले [stake in the protocol](/indexing/overview/#stake-in-the-protocol) करना न भूलें!

#### From NPM packages

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### From source

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Using docker

- रजिस्ट्री से चित्र खींचे

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

या स्रोत से स्थानीय रूप से छवियां बनाएं

```sh
#इंडेक्सर सेवा
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
इंडेक्सर एजेंट
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- घटकों को चलाएँ

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**नोट**: कंटेनरों को शुरू करने के बाद, Indexer सेवा [http://localhost:7600](http://localhost:7600) पर उपलब्ध होगी और Indexer एजेंट [http://localhost:18000/](http://localhost:18000/) पर Indexer प्रबंधन API को एक्सपोज़ करेगा।

#### K8s और टेराफॉर्म का उपयोग करना

[Setup Server Infrastructure Using Terraform on Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud) अनुभाग देखें।

#### Usage

> **नोट**: सभी रनटाइम कॉन्फ़िगरेशन वेरिएबल्स को या तो स्टार्टअप पर कमांड के पैरामीटर के रूप में लागू किया जा सकता है या `COMPONENT_NAME_VARIABLE_NAME `(जैसे, `INDEXER_AGENT_ETHEREUM`) प्रारूप के पर्यावरण वेरिएबल्स का उपयोग करके।

#### इंडेक्सर एजेंट

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer Service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexer CLI

Indexer CLI [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli)  का एक प्लगइन है जो टर्मिनल में `graph indexer` के रूप में एक्सेस किया जा सकता है।

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### इंडेक्सर सीएलआई का उपयोग कर इंडेक्सर प्रबंधन

**Indexer Management API** के साथ इंटरैक्ट करने के लिए सुझाया गया टूल **Indexer CLI** है, जो कि **Graph CLI** का एक विस्तार है। Indexer agent को नेटवर्क के साथ स्वतःसंपर्क स्थापित करने के लिए एक Indexer से इनपुट की आवश्यकता होती है। Indexer agent के व्यवहार को परिभाषित करने के लिए मुख्य तंत्र **allocation management** मोड और **indexing rules** हैं।ऑटो मोड में, एक Indexer अपने विशिष्ट रणनीति का उपयोग करके उन सबग्राफ को चुनने और क्वेरी सर्व करने के लिए **indexing rules** का उपयोग कर सकता है। इन नियमों को एक GraphQL API के माध्यम से प्रबंधित किया जाता है जिसे एजेंट द्वारा सर्व किया जाता है और जिसे Indexer Management API के रूप में जाना जाता है।मैनुअल मोड में, एक Indexer **actions queue** का उपयोग करके allocation actions बना सकता है और उनके निष्पादन से पहले उन्हें स्पष्ट रूप से स्वीकृत कर सकता है।ऑवरसाइट मोड में, **indexing rules** का उपयोग **actions queue** को भरने के लिए किया जाता है और उनके निष्पादन के लिए भी स्पष्ट स्वीकृति की आवश्यकता होती है।

#### Usage

**Indexer CLI** Indexer agent से जुड़ता है, आमतौर पर पोर्ट-फॉरवर्डिंग के माध्यम से, इसलिए CLI को उसी सर्वर या क्लस्टर पर चलाने की आवश्यकता नहीं होती। आपको आरंभ करने में सहायता करने और कुछ संदर्भ प्रदान करने के लिए, CLI का संक्षिप्त विवरण यहां दिया जाएगा।

- `graph indexer connect <url>` - Indexer प्रबंधन API से कनेक्ट करें। आमतौर पर, सर्वर से कनेक्शन पोर्ट फॉरवर्डिंग के माध्यम से खोला जाता है, जिससे CLI को आसानी से रिमोटली ऑपरेट किया जा सके। (उदाहरण: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - एक या एक से अधिक indexing rules प्राप्त करें, `<deployment-id>` के रूप में all का उपयोग करके सभी rules प्राप्त करें, या `global` का उपयोग करके global defaults प्राप्त करें। एक अतिरिक्त argument --`merged` का उपयोग किया जा सकता है यह निर्दिष्ट करने के लिए कि deployment-specific rules को global rule के साथ merge किया गया है। इसी तरह से इन्हें Indexer agent में लागू किया जाता है।

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - एक या अधिक indexing नियम सेट करें।

- `graph indexer rules start [options] <deployment-id>` - यदि उपलब्ध हो, तो किसी subgraph deployment को इंडेक्सिंग करना शुरू करें और इसका `decisionBasis` `always` पर सेट करें, ताकि Indexer agent हमेशा इसे इंडेक्स करने का चयन करे। यदि ग्लोबल नियम always पर सेट है, तो नेटवर्क पर सभी उपलब्ध सबग्राफ को इंडेक्स किया जाएगा।

- `graph indexer rules stop [options] <deployment-id>` - किसी परिनियोजन की indexing रोकें और इसके `decisionBasis` को कभी नहीं पर सेट करें, ताकि यह deployment को index करने के निर्णय लेते समय इसे छोड़ दे।

- `graph indexer rules maybe [options] <deployment-id>` — किसी डिप्लॉयमेंट के लिए `decisionBasis` को rules पर सेट करें, ताकि Indexer agent इस डिप्लॉयमेंट को इंडेक्स करने का निर्णय लेने के लिए indexing rules का उपयोग कर सके।

- `graph indexer actions get [options] <action-id>` - `all` का उपयोग करके एक या अधिक कार्यवाही को प्राप्त करें या सभी कार्यवाही प्राप्त करने के लिए `action-id` खाली छोड़ दें। एक अतिरिक्त argument --`status` का उपयोग किसी विशेष स्थिति के सभी कार्यवाही को प्रिंट करने के लिए किया जा सकता है।

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - आवंटन क्रिया को कतार में डालें

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - पुनः आवंटन क्रिया को कतार में जोड़ें

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - अनवेलोकेट कार्रवाई को कतार में लगाएं

- `graph indexer actions cancel [<action-id> ...]` - यदि आईडी निर्दिष्ट नहीं है, तो कतार में सभी कार्रवाई रद्द करें, अन्यथा आईडी की सूची को स्पेस द्वारा अलग करके रद्द करें।

- `graph indexer actions approve [<action-id> ...]` - एक से अधिक क्रियाओं को निष्पादन के लिए अनुमोदित करें

- `graph indexer actions execute approve` - वर्कर को स्वीकृत क्रियाओं को तुरंत निष्पादित करने के लिए मजबूर करें।

सभी आदेश जो आउटपुट में नियम प्रदर्शित करते हैं, वे -`output` तर्क का उपयोग करके समर्थित आउटपुट प्रारूपों (`table`, `yaml`, और `json`) में से किसी एक का चयन कर सकते हैं।

#### Indexing rules

Indexing नियम या तो वैश्विक डिफ़ॉल्ट के रूप में लागू किए जा सकते हैं या विशिष्ट subgraph डिप्लॉयमेंट्स के लिए उनके ID का उपयोग करके। `deployment` और `decisionBasis` फ़ील्ड्स अनिवार्य हैं, जबकि अन्य सभी फ़ील्ड्स वैकल्पिक हैं। जब एक इंडेक्सिंग नियम में rules को `decisionBasis` के रूप में सेट किया जाता है, तो Indexer एजेंट उस नियम पर गैर-नल थ्रेशहोल्ड मानों की तुलना करेगा, जो नेटवर्क से संबंधित डिप्लॉयमेंट के लिए प्राप्त मानों से की जाएगी। यदि subgraph डिप्लॉयमेंट के मान किसी भी थ्रेशहोल्ड से ऊपर (या नीचे) होते हैं, तो उसे indexing के लिए चुना जाएगा।

उदाहरण के लिए, यदि वैश्विक नियम का `minStake` **5** (GRT) है, तो कोई भी subgraph डिप्लॉयमेंट जिसमें 5 (GRT) से अधिक staking आवंटित किया गया हो, उसे इंडेक्स किया जाएगा। थ्रेशोल्ड नियमों में 
`maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, और `minAverageQueryFees` शामिल हैं।

डेटा मॉडल:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

अनुक्रमण नियम का उदाहरण उपयोग:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Actions queue CLI

indexer-cli एक `actions` मॉड्यूल प्रदान करता है जो एक्शन क्यू के साथ मैन्युअल रूप से काम करने के लिए उपयोग किया जाता है। यह **Graphql API** का उपयोग करता है जो एक्शन क्यू के साथ इंटरैक्ट करने के लिए indexer प्रबंधन सर्वर द्वारा होस्ट किया जाता है।

यह क्रिया निष्पादन कार्यकर्ता केवल उन आइटमों को कतार से निष्पादित करेगा जिनका `ActionStatus = approved` है। अनुशंसित मार्ग में क्रियाएँ कतार में ActionStatus = queued के साथ जोड़ी जाती हैं, इसलिए उन्हें फिर से स्वीकृत करना होता है ताकि उन्हें ऑनचेन पर निष्पादित किया जा सके। सामान्य प्रवाह इस प्रकार होगा:

- तृतीय पक्ष ऑप्टिमाइज़र टूल या इंडेक्सर-क्ली उपयोगकर्ता द्वारा कतार में जोड़ी गई कार्रवाई
- Indexer `indexer-cli` का उपयोग करके सभी कतारबद्ध क्रियाएं देख सकता है।
- Indexer (या अन्य सॉफ़्टवेयर) `indexer-cli` का उपयोग करके क्यू में क्रियाओं को स्वीकृत या रद्द कर सकता है। स्वीकृत और रद्द करने के आदेश एक्शन आईडी की एक सूची को इनपुट के रूप में लेते हैं।
- निष्पादन कार्यकर्ता नियमित रूप से स्वीकृत क्रियाओं के लिए कतार को पोल करता है। यह कतार से `approved` क्रियाओं को उठाएगा, उन्हें निष्पादित करने का प्रयास करेगा, और निष्पादन की स्थिति के आधार पर db में मानों को `success` या `failed` के रूप में अपडेट करेगा।
- अगर कोई क्रिया सफल होती है, तो कार्यकर्ता यह सुनिश्चित करेगा कि एक indexing नियम मौजूद हो जो एजेंट को आगे बढ़ने के लिए आवंटन को कैसे प्रबंधित करना है, यह तब उपयोगी होता है जब एजेंट `auto` या `oversight` मोड में होते हुए मैन्युअल क्रियाएँ करता है।
- अनुक्रमणक क्रिया निष्पादन के इतिहास को देखने के लिए क्रिया कतार की निगरानी कर सकता है और यदि आवश्यक हो तो निष्पादन विफल होने पर क्रिया आइटम को पुन: अनुमोदित और अद्यतन कर सकता है। क्रिया कतार पंक्तिबद्ध और की गई सभी कार्रवाइयों का इतिहास प्रदान करती है।

डेटा मॉडल:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

स्रोत से उदाहरण उपयोग:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

ध्यान दें कि आवंटन प्रबंधन के लिए समर्थित क्रिया प्रकारों की अलग-अलग इनपुट आवश्यकताएं होती हैं:

- `Allocate` - विशिष्ट subgraph deployment को staking आवंटित करें

  - आवश्यक क्रिया पैरामीटर:
    - deploymentID
    - amount

- `Unallocate` - आवंटन बंद करना, फिर से कहीं और पुनः आवंटित करने के लिए दांव को मुक्त करना

  - आवश्यक क्रिया पैरामीटर:
    - allocationID
    - deploymentID
  - वैकल्पिक क्रिया पैरामीटर:
    - poi
    - बल (प्रदान किए गए POI का उपयोग करने पर बल देता है, भले ही वह ग्राफ़-नोड द्वारा प्रदान किए गए मेल से मेल न खाता हो)

- `Reallocate` - परमाणु रूप से आवंटन को बंद करें और उसी subgraph परिनियोजन के लिए एक नया आवंटन खोलें।

  - आवश्यक क्रिया पैरामीटर:
    - allocationID
    - deploymentID
    - amount
  - वैकल्पिक क्रिया पैरामीटर:
    - poi
    - बल (प्रदान किए गए POI का उपयोग करने पर बल देता है, भले ही वह ग्राफ़-नोड द्वारा प्रदान किए गए मेल से मेल न खाता हो)

#### Cost models

लागत मॉडल बाजार और क्वेरी विशेषताओं के आधार पर प्रश्नों के लिए गतिशील मूल्य निर्धारण प्रदान करते हैं। अनुक्रमणिका सेवा प्रत्येक सबग्राफ के लिए गेटवे के साथ एक लागत मॉडल साझा करती है जिसके लिए वे प्रश्नों का उत्तर देना चाहते हैं। गेटवे, बदले में, प्रति प्रश्न अनुक्रमणिका चयन निर्णय लेने और चुने गए अनुक्रमणकों के साथ भुगतान पर बातचीत करने के लिए लागत मॉडल का उपयोग करते हैं।

#### Agora

अगोरा भाषा प्रश्नों के लिए लागत मॉडल घोषित करने के लिए एक लचीला प्रारूप प्रदान करती है। एक एगोरा मूल्य मॉडल बयानों का एक क्रम है जो एक ग्राफक्यूएल क्वेरी में प्रत्येक शीर्ष-स्तरीय क्वेरी के क्रम में निष्पादित होता है। प्रत्येक शीर्ष-स्तरीय क्वेरी के लिए, पहला कथन जो उससे मेल खाता है, उस क्वेरी के लिए मूल्य निर्धारित करता है।

एक कथन में एक विधेय शामिल होता है, जिसका उपयोग ग्राफक्यूएल प्रश्नों के मिलान के लिए किया जाता है, और एक लागत अभिव्यक्ति होती है, जिसका मूल्यांकन दशमलव GRT में लागत को आउटपुट करता है। क्वेरी के नामित तर्क स्थिति में मान विधेय में कैप्चर किए जा सकते हैं और अभिव्यक्ति में उपयोग किए जा सकते हैं। एक अभिव्यक्ति में प्लेसहोल्डर्स के लिए ग्लोबल्स भी सेट और प्रतिस्थापित किए जा सकते हैं।

उदाहरण लागत मॉडल:

```
#यह कथन skip मान को कैप्चर करता है,
#एक बूलियन अभिव्यक्ति का उपयोग करते हुए प्रीडिकेट में उन विशिष्ट क्वेरीज़ को मिलाने के लिए जो skip का उपयोग करती हैं,
और skip मान और SYSTEM_LOAD ग्लोबल के आधार पर लागत की गणना के लिए एक लागत अभिव्यक्ति का उपयोग करती है।
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

#यह डिफ़ॉल्ट किसी भी GraphQL अभिव्यक्ति से मेल खाएगा।
#यह लागत की गणना के लिए एक ग्लोबल का उपयोग करता है जिसे अभिव्यक्ति में प्रतिस्थापित किया गया है।
default => 0.1 * $SYSTEM_LOAD;
```

उपरोक्त मॉडल का उपयोग करके उदाहरण क्वेरी लागत:

| Query                                                                        | Price   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; टोकन &#123; symbol &#125; &#125;                                      | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### लागत मॉडल लागू करना

लागत मॉडल इंडेक्सर सीएलआई के माध्यम से लागू किए जाते हैं, जो उन्हें डेटाबेस में स्टोर करने के लिए इंडेक्सर एजेंट के इंडेक्सर मैनेजमेंट एपीआई को भेजता है। इंडेक्सर सर्विस तब उन्हें उठाएगी और जब भी वे उनके लिए मांगेंगे, गेटवे को लागत मॉडल की सेवा देगी।

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## नेटवर्क के साथ बातचीत करना

### प्रोटोकॉल में हिस्सेदारी

The first steps to participating in the network as an Indexer are to approve the protocol, stake funds, and (optionally) set up an operator address for day-to-day protocol interactions.

> नोट: इन निर्देशों के लिए Remix का उपयोग कॉन्ट्रैक्ट इंटरैक्शन के लिए किया जाएगा, लेकिन आप अपनी पसंद के टूल का उपयोग करने के लिए स्वतंत्र हैं ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), और [MyCrypto](https://www.mycrypto.com/account) कुछ अन्य ज्ञात टूल्स हैं)।

एक बार जब Indexer ने प्रोटोकॉल में GRT को staked कर दिया है, तो [Indexer components](/indexing/overview/#indexer-components) को शुरू किया जा सकता है और वे नेटवर्क के साथ अपनी बातचीत शुरू कर सकते हैं।

#### टोकन स्वीकृत करें

1. [Remix app](https://remix.ethereum.org/) को ब्राउज़र में खोलें।

2. `File Explorer` में एक फाइल बनाएँ जिसका नाम **GraphToken.abi** हो, और उसमें [टोकनABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json) का उपयोग करें।

3. `GraphToken.abi` को चुनें और इसे संपादक में खोलें, फिर Remix इंटरफ़ेस के `Deploy and run transaction` सेक्शन पर स्विच करें।

4. पर्यावरण के अंतर्गत `Injected Web3` चुनें और `Account` के अंतर्गत अपना Indexer पता चुनें।

5. GraphToken contract address सेट करें - GraphToken contract address (0xc944E90C64B2c07662A292be6244BDf05Cda44a7) को `At Address` के पास पेस्ट करें और इसे लागू करने के लिए `At address` बटन पर क्लिक करें।

6. `approve(spender, amount)` फ़ंक्शन को कॉल करें ताकि Staking contract को अप्रूव किया जा सके। `spender` में Staking contract address (0xF55041E37E12cD407ad00CE2910B8269B01263b9) भरें और `amount` में staking करने वाले टोकन की मात्रा (wei में) भरें।

#### स्टेक टोकन

1. [Remix app](https://remix.ethereum.org/) को ब्राउज़र में खोलें।

2. `File Explorer` में एक फाइल बनाएं जिसका नाम **Staking.abi** हो और इसमें staking ABI हो।

3. `Staking.abi` को चुनकर और एडिटर में खोलने के बाद, Remix इंटरफेस में `Deploy and run transaction` सेक्शन पर स्विच करें।

4. पर्यावरण के तहत `Injected Web3` का चयन करें और `Account` के तहत अपने Indexer पते का चयन करें।

5. Staking contract address सेट करें - Staking contract address (0xF55041E37E12cD407ad00CE2910B8269B01263b9) को `At Address` के पास पेस्ट करें और `At address` बटन पर क्लिक करें ताकि इसे लागू किया जा सके।

6. `stake()` को कॉल करें ताकि प्रोटोकॉल में GRT staking किया जा सके।

7. (ऐच्छिक) Indexer अपने Indexer इंफ्रास्ट्रक्चर के लिए किसी अन्य पते को ऑपरेटर के रूप में अनुमोदित कर सकते हैं, ताकि वे फंड्स को नियंत्रित करने वाली चाबियों को उन चाबियों से अलग कर सकें जो रोज़मर्रा के कार्यों को अंजाम देती हैं जैसे कि सबग्राफ पर आवंटन और (भुगतान) queries सर्व करना। ऑपरेटर सेट करने के लिए `setOperator()` को ऑपरेटर पते के साथ कॉल करें।

8. (वैकल्पिक) इनामों के वितरण को नियंत्रित करने और रणनीतिक रूप से Delegators को आकर्षित करने के लिए Indexers अपनी delegation parameters को अपडेट कर सकते हैं, जैसे कि indexingRewardCut (भाग प्रति मिलियन), queryFeeCut (भाग प्रति मिलियन), और cooldownBlocks (ब्लॉकों की संख्या)। ऐसा करने के लिए `setDelegationParameters()` को कॉल करें। निम्नलिखित उदाहरण में queryFeeCut को सेट किया गया है ताकि query rebates का 95% Indexer को और 5% Delegators को वितरित किया जाए, indexingRewardCut को सेट किया गया है ताकि indexing rewards का 60% Indexer को और 40% Delegators को वितरित किया जाए, और `thecooldownBlocks` अवधि को 500 ब्लॉकों पर सेट किया गया है।

```
setDelegationParameters(950000, 600000, 500)
```

### Setting delegation parameters

`setDelegationParameters()` फ़ंक्शन [staking contract](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) में Indexers के लिए महत्वपूर्ण है, क्योंकि यह उन्हें ऐसे पैरामीटर सेट करने की अनुमति देता है जो उनके Delegators के साथ इंटरएक्शन को परिभाषित करते हैं, जिससे उनके पुरस्कार वितरण और डेलीगेशन क्षमता पर प्रभाव पड़ता है।

### How to set delegation parameters

To set the delegation parameters using Graph Explorer interface, follow these steps:

1. [Graph Explorer](https://thegraph.com/explorer/) पर जाएं।
2. Connect your wallet. Choose multisig (such as Gnosis Safe) and then select mainnet. Note: You will need to repeat this process for Arbitrum One.
3. Connect the wallet you have as a signer.
4. Navigate to the 'Settings' section and select 'Delegation Parameters'. These parameters should be configured to achieve an effective cut within the desired range. Upon entering values in the provided input fields, the interface will automatically calculate the effective cut. Adjust these values as necessary to attain the desired effective cut percentage.
5. Submit the transaction to the network.

> Note: This transaction will need to be confirmed by the multisig wallet signers.

### आवंटन का जीवन

एक Indexer द्वारा बनाए जाने के बाद, एक स्वस्थ आवंटन दो स्थितियों से गुजरता है।

- **सक्रिय** - जब एक आवंटन ऑनचेन [(allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)) बनाया जाता है, तो इसे **सक्रिय** माना जाता है। Indexer की अपनी और/या प्रत्यायोजित स्टेक का एक हिस्सा एक subgraph डिप्लॉयमेंट के लिए आवंटित किया जाता है, जिससे उन्हें उस subgraph डिप्लॉयमेंट के लिए indexing पुरस्कार प्राप्त करने और प्रश्नों की सेवा करने की अनुमति मिलती है। Indexer एजेंट Indexer नियमों के आधार पर आवंटन बनाने का प्रबंधन करता है।

- **Closed** - एक Indexer 1 अवधियों को के बाद एक allocation को बंद करने के लिए स्वतंत्र है (closeAllocation()(https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) या उनका Indexer एजेंट स्वतः **maxAllocationEpochs** (वर्तमान में 28 दिन) के बाद allocation को बंद कर देगा। जब एक allocation को एक वैध proof of indexing (POI) के साथ बंद किया जाता है, तो उनके indexing पुरस्कार Indexer और उसके Delegators को वितरित किए जाते हैं [(learn more)](/indexing/overview/#how-are-indexing-rewards-distributed))।

Indexer को अनुशंसा की जाती है कि वे ऑनचेन पर आवंटन बनाने से पहले चेनहेड तक Subgraph डिप्लॉयमेंट को सिंक करने के लिए ऑफचेन सिंकिंग फ़ंक्शनलिटी का उपयोग करें। यह विशेषता उन सबग्राफ़्स के लिए विशेष रूप से उपयोगी है जिन्हें सिंक होने में 28 अवधियों को अधिक समय लग सकता है या जिनमें अव्यक्त रूप से विफल होने की संभावना हो सकती है।
