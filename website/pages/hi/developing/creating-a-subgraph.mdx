---
title: सबग्राफ बनाना
---

This detailed guide provides instructions to successfully create a subgraph.

A subgraph extracts data from a blockchain, processes it, and stores it for efficient querying via GraphQL.

![एक सबग्राफ को परिभाषित करना](/img/defining-a-subgraph.png)

> अपने subgraph को The Graph के विकेन्द्रीकृत नेटवर्क पर उपयोग करने के लिए, आपको [एक API कुंजी बनानी होगी](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key) [Subgraph Studio](https://thegraph.com/studio/apikeys/) में। यह सिफारिश की जाती है कि आप अपने subgraph में कम से कम 3,000 GRT का सिग्नल जोड़ें ताकि 2-3 Indexers को आकर्षित किया जा सके।

## शुरू करना

### . ग्राफ़ सीएलआई इनस्टॉल करें

एक subgraph बनाने और तैनात करने के लिए, आपको [Graph CLI](https://github.com/graphprotocol/graph-tooling/tree/main/packages/cli) की आवश्यकता होगी।

The Graph CLI , TypeScript में लिखा गया है, और इसका उपयोग करने के लिए आपके पास node और या तो npm या yarn इंस्टॉल होना चाहिए। [सबसे हालिया](https://github.com/graphprotocol/graph-tooling/releases?q=%40graphprotocol%2Fgraph-cli&expanded=true) CLI संस्करण के लिए जांचें।

अपनी स्थानीय मशीन पर, निम्न आदेशों में से कोई एक चलाएँ:

#### npm का उपयोग करते हुए [npm](https://www.npmjs.com/)

```bash
npm install -g @graphprotocol/graph-cli@latest
```

#### [yarn](https://yarnpkg.com/) का उपयोग करके

```bash
yarn global add @graphprotocol/graph-cli
```

- `graph init` कमांड का उपयोग एक नए subgraph प्रोजेक्ट को सेट अप करने के लिए किया जा सकता है, चाहे वह एक मौजूदा कॉन्ट्रैक्ट से हो या एक उदाहरण subgraph से।

- यह `graph init` कमांड `--product subgraph-studio` पास करके Subgraph Studio में एक subgraph भी बना सकता है।

- यदि आपके पास पहले से ही आपके पसंदीदा नेटवर्क पर एक स्मार्ट कॉन्ट्रैक्ट तैनात है, तो आप उस कॉन्ट्रैक्ट से एक नया subgraph बनाने के लिए शुरुआत कर सकते हैं।

## एक subgraph बनाएं

### एक मौजूदा कॉन्ट्रैक्ट से

यह कमांड एक subgraph बनाता है जो एक मौजूदा कॉन्ट्रैक्ट के सभी इवेंट्स को इंडेक्स करता है:

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

- कमांड Etherscan से कॉन्ट्रैक्ट ABI को पुनः प्राप्त करने की कोशिश करता है।

  - The Graph CLI एक सार्वजनिक RPC एंडपॉइंट पर निर्भर करता है। जबकि कुछ असफलताएँ अपेक्षित हैं, पुनः प्रयास आमतौर पर इस समस्या को हल कर देते हैं। यदि असफलताएँ बनी रहती हैं, तो एक स्थानीय ABI का उपयोग करने पर विचार करें।

- यदि कोई वैकल्पिक तर्क गायब है, तो यह आपको एक इंटरैक्टिव फॉर्म के माध्यम से मार्गदर्शन करता है।

- The `<SUBGRAPH_SLUG>`आपके subgraph की ID है [Subgraph Studio](https://thegraph.com/studio/) में। इसे आपके subgraph विवरण पृष्ठ पर पाया जा सकता है।

### एक उदाहरण subgraph सेएक उदाहरण subgraph से

निम्नलिखित कमांड एक उदाहरण subgraph से एक नया प्रोजेक्ट प्रारंभ करता है:

```sh
graph init --studio <SUBGRAPH_SLUG> --from-example=example-subgraph
```

- [example subgraph](https://github.com/graphprotocol/example-subgraph) डैनी ग्रांट द्वारा बनाए गए Gravity कॉन्ट्रैक्ट पर आधारित है, जो उपयोगकर्ता अवतारों का प्रबंधन करता है और जब भी अवतार बनाए या अपडेट किए जाते हैं, तो `NewGravatar` या `UpdateGravatar` घटनाओं को उत्पन्न करता है।

- Subgraph इन इवेंट्स को हैंडल करता है द्वारा `Gravatar` एंटिटीज़ को Graph Node स्टोर में लिखकर और यह सुनिश्चित करता है कि ये इवेंट्स के अनुसार अपडेट होते रहें।

## मौजूदा subgraph में नए `dataSources` जोड़ें

संस्करण `v0.31.0` से, The Graph CLI एक मौजूदा subgraph में नए `dataSources` जोड़ने का समर्थन करता है `graph add` कमांड के माध्यम से:

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Options:

      --abi <path>              Path to the contract ABI (default: download from Etherscan)
      --contract-name           Name of the contract (default: Contract)
      --merge-entities          Whether to merge entities with the same name (default: false)
      --network-file <path>     Networks config file path (default: "./networks.json")
```

### Specifics

`graph add` कमांड Etherscan से ABI को प्राप्त करेगा (जब तक कि `--abi` विकल्प के साथ कोई ABI पथ निर्दिष्ट न किया गया हो) और एक नया `dataSource` बनाएगा, ठीक वैसे ही जैसे `graph init` कमांड `dataSource` `--from-contract` बनाता है। यह स्कीमा और मैपिंग्स को उसी अनुसार अपडेट करता है। यह आपको उनके प्रॉक्सी कॉन्ट्रैक्ट्स से इम्प्लिमेंटेशन कॉन्ट्रैक्ट्स को इंडेक्स करने की अनुमति देता है।

- `--merge-entities` विकल्प यह बताता है कि डेवलपर `entity` और `event` नाम के विरोधों को कैसे हैंडल करना चाहता है:

  - अगर `सही`: नए `dataSource` को मौजूदा `eventHandlers` & `इकाइयां`।

  - यदि ``false`\` हो: एक नया ``entity` & `event`\` हैंडलर बनाया जाना चाहिए जिसका नाम ``${dataSourceName}{EventName}`\` होगा।

- संबंधित नेटवर्क के लिए `networks.json` को अनुबंध `पता` लिखा जाएगा।

> ध्यान दें: जब आप इंटरएक्टिव CLI का उपयोग कर रहे होते हैं, तो `graph init` को सफलतापूर्वक चलाने के बाद, आपको एक नया `dataSource` जोड़ने के लिए प्रेरित किया जाएगा।

## subgraph  के घटक

### द सबग्राफ मेनिफेस्ट

The subgraph manifest, `subgraph.yaml`, उन स्मार्ट कॉन्ट्रैक्ट्स & नेटवर्क को परिभाषित करता है जिन्हें आपका subgraph इंडेक्स करेगा, इन कॉन्ट्रैक्ट्स से ध्यान देने योग्य इवेंट्स को, और कैसे इवेंट डेटा को उन एंटिटीज़ में मैप करना है जिन्हें Graph Node स्टोर करता है और क्वेरी करने की अनुमति देता है।

थी **subgraph definition** निम्नलिखित फ़ाइलों से बनी होती है:

- `subgraph.yaml`: इसमें सबग्राफ मैनिफेस्ट होता है

- `schema.graphql`: एक GraphQL स्कीमा जो आपके subgraph के लिए संग्रहीत डेटा को परिभाषित करता है और इसे GraphQL के माध्यम से कैसे क्वेरी किया जाए।

- `mapping.ts`: [AssemblyScript Mappings](https://github.com/AssemblyScript/assemblyscript) कोड जो इवेंट डेटा को आपकी स्कीमा में परिभाषित इकाइयों में अनुवाद करता है (उदाहरण के लिए, इस गाइड में `mapping.ts`)

एक सिंगल subgraph कर सकता है:

- कई स्मार्ट कॉन्ट्रैक्ट्स से डेटा को इंडेक्स करें (लेकिन कई नेटवर्क नहीं)।

- IPFS फ़ाइलों से डेटा को डेटा स्रोत फ़ाइलें  का उपयोग करके अनुक्रमित करें।

- प्रत्येक contract के लिए, जिसे indexing की आवश्यकता है, एक एंट्री `dataSources` array में जोड़ें।

Subgraph मैनिफेस्ट के लिए पूरी विशिष्टता [यहां](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md) मिल सकती है।

उदाहरण Subgraph के लिए, `subgraph.yaml` है:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
indexerHints:
  prune: auto
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
      endBlock: 7175245
    context:
      foo:
        type: Bool
        data: true
      bar:
        type: String
        data: 'bar'
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

मेनिफेस्ट के लिए अद्यतन करने के लिए महत्वपूर्ण प्रविष्टियां हैं:

- `specVersion`: एक सेमवर संस्करण जो उपग्राफ के लिए समर्थित मैनिफेस्ट संरचना और कार्यक्षमता को पहचानता है। नवीनतम संस्करण `1.2.0` है। अधिक विवरण के लिए [specVersion रिलीज़](#specversion-releases) अनुभाग देखें, जिसमें फीचर्स & रिलीज़ शामिल हैं।

- `description`: एक मानव-पठनीय विवरण है कि subgraph क्या है। यह विवरण Graph Explorer में प्रदर्शित किया जाता है जब subgraph को Subgraph Studio में डिप्लॉय किया जाता है।

- `repository`: वह URL जहाँ subgraph मैनिफेस्ट पाया जा सकता है। यह Graph Explorer में भी प्रदर्शित होता है।

- `विशेषताएं`: सभी प्रयुक्त [विशेषता](#experimental-features) नामों की सूची।

- `indexerHints.prune`: एक उपग्राफ के लिए ऐतिहासिक ब्लॉक डेटा की रिटेंशन को परिभाषित करता है। [prune](#prune) को [indexerHints](#indexer-hints) सेक्शन में देखें।

- `dataSources.source`: स्मार्ट अनुबंध का पता सबग्राफ स्रोत, और उपयोग करने के लिए स्मार्ट अनुबंध का ABI। पता वैकल्पिक है; इसे छोड़ने से सभी अनुबंधों से मिलान करने वाले ईवेंट को अनुक्रमित करने की अनुमति मिलती है।

- `dataSources.source.startBlock`: उस ब्लॉक की वैकल्पिक संख्या जिससे डेटा स्रोत इंडेक्स करना शुरू करता है। ज्यादातर मामलों में, हम उस ब्लॉक का उपयोग करने का सुझाव देते हैं जिसमें अनुबंध बनाया गया था।

- `dataSources.source.endBlock`: वह वैकल्पिक संख्या जो उस ब्लॉक को शामिल करते हुए डेटा स्रोत की इंडेक्सिंग को रोकता है। आवश्यक न्यूनतम विशिष्टता संस्करण: `0.0.9`.

- `dataSources.context`: कुंजी-मूल्य जोड़े जो उपग्राफ मैपिंग में उपयोग किए जा सकते हैं। विभिन्न डेटा प्रकारों का समर्थन करता है जैसे `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, और `BigInt`। प्रत्येक वेरिएबल को अपना `type` और `data` निर्दिष्ट करना आवश्यक है। ये संदर्भ वेरिएबल फिर मैपिंग फ़ाइलों में पहुँच योग्य होते हैं, जो उपग्राफ विकास के लिए अधिक कॉन्फ़िगर करने योग्य विकल्प प्रदान करते हैं।

- `dataSources.mapping.entities`: वे निकाय जो डेटा स्रोत स्टोर को लिखते हैं। प्रत्येक इकाई के लिए स्कीमा को schema.graphql फ़ाइल में परिभाषित किया गया है।

- `dataSources.mapping.abis`: स्रोत अनुबंध के साथ-साथ मैपिंग के भीतर से आपके द्वारा इंटरैक्ट किए जाने वाले किसी भी अन्य स्मार्ट अनुबंध के लिए एक या अधिक नामित एबीआई फाइलें।

- `dataSources.mapping.eventHandlers`: उन स्मार्ट कॉन्ट्रैक्ट इवेंट्स को सूचीबद्ध करता है जिन पर यह सबग्राफ प्रतिक्रिया करता है और मैपिंग में हैंडलर—./src/mapping.ts उदाहरण में — जो इन इवेंट्स को स्टोर में संस्थाओं में बदल देता है।

- `dataSources.mapping.callHandlers`: उन स्मार्ट कॉन्ट्रैक्ट फ़ंक्शंस को सूचीबद्ध करता है जो इस सबग्राफ पर प्रतिक्रिया करता है और मैपिंग में हैंडलर जो इनपुट और आउटपुट को स्टोर में संस्थाओं में फ़ंक्शन कॉल में बदल देता है।

- `dataSources.mapping.blockHandlers`: उन ब्लॉक्स को सूचीबद्ध करता है जिन पर यह सबग्राफ प्रतिक्रिया करता है और मैपिंग में हैंडलर्स को तब चलाया जाता है जब ब्लॉक को चेन से जोड़ा जाता है। फ़िल्टर के बिना, प्रत्येक ब्लॉक में ब्लॉक हैंडलर चलाया जाएगा। हैंडलर में `kind: call` के साथ एक `फ़िल्टर` फ़ील्ड जोड़कर एक वैकल्पिक कॉल-फ़िल्टर प्रदान किया जा सकता है। यह केवल हैंडलर चलाएगा यदि ब्लॉक में डेटा स्रोत अनुबंध के लिए कम से कम एक कॉल हो।

एक सबग्राफ कई स्मार्ट कॉन्ट्रैक्ट्स से डेटा को इंडेक्स कर सकता है। प्रत्येक अनुबंध के लिए एक प्रविष्टि जोड़ें जिससे डेटा को `dataSources` सरणी में अनुक्रमित करने की आवश्यकता है।

### ट्रिगरिंग हैंडलर्स का क्रम

निम्नलिखित प्रक्रिया का उपयोग करके एक ब्लॉक के भीतर डेटा स्रोत के लिए ट्रिगर्स का आदेश दिया गया है:

1.  ईवेंट और कॉल ट्रिगर्स को पहले ब्लॉक के भीतर ट्रांजैक्शन इंडेक्स द्वारा ऑर्डर किया जाता है।
2.  एक ही लेन-देन के भीतर ईवेंट और कॉल ट्रिगर्स को एक कन्वेंशन का उपयोग करके ऑर्डर किया जाता है: ईवेंट पहले ट्रिगर करता है फिर ट्रिगर्स को कॉल करता है, प्रत्येक प्रकार के ऑर्डर का सम्मान करते हुए उन्हें मेनिफेस्ट में परिभाषित किया जाता है।
3.  ब्लॉक ट्रिगर इवेंट और कॉल ट्रिगर के बाद चलाए जाते हैं, जिस क्रम में उन्हें मेनिफेस्ट में परिभाषित किया गया है।

ये आदेश नियम परिवर्तन के अधीन हैं।

> **Note:** जब नए [dynamic data source](#data-source-templates-for-dynamically-created-contracts) बनाए जाते हैं, तो dynamic data sources के लिए निर्धारित हैंडलर्स तब तक प्रोसेसिंग शुरू नहीं करेंगे जब तक सभी मौजूदा data source हैंडलर्स को प्रोसेस नहीं किया जाता, और जब भी ट्रिगर किया जाता है, यह उसी क्रम में दोहराएगा।

### सूचीकृत तर्क फ़िल्टर / विषय फ़िल्टर

> **आवश्यकता**: [SpecVersion](#specversion-releases) >= `1.2.0`

विषय फ़िल्टर, जिन्हें इंडेक्स किए गए तर्क फ़िल्टर भी कहा जाता है, एक शक्तिशाली विशेषता है जो उपयोगकर्ताओं को उनके इंडेक्स किए गए तर्कों के मानों के आधार पर ब्लॉकचेन घटनाओं को सटीक रूप से फ़िल्टर करने की अनुमति देती है।

- ये फ़िल्टर ब्लॉकचेन पर घटनाओं की विशाल धारा से रुचि की विशिष्ट घटनाओं को अलग करने में मदद करते हैं, जिससे सबग्राफ़ केवल प्रासंगिक डेटा पर ध्यान केंद्रित करके अधिक कुशलता से कार्य कर सके।

- यह व्यक्तिगत subgraphs बनाने के लिए उपयोगी है जो विशेष पते और विभिन्न स्मार्ट कॉन्ट्रैक्ट्स के साथ उनके इंटरैक्शन को ट्रैक करते हैं ब्लॉकचेन पर।

#### शीर्षक फ़िल्टर कैसे काम करते हैं

जब एक स्मार्ट कॉन्ट्रैक्ट एक इवेंट को उत्पन्न करता है, तो कोई भी तर्क जो 'indexed' के रूप में चिह्नित किया गया है, एक 'subgraph' की मैनिफेस्ट में फ़िल्टर के रूप में उपयोग किया जा सकता है। यह 'subgraph' को इन 'indexed' तर्कों से मेल खाने वाले इवेंट्स के लिए चयनात्मक रूप से सुनने की अनुमति देता है।

- इस घटना का पहला अनुक्रमित तर्क `topic1` के अनुरूप है, दूसरा `topic2` के लिए है, और इसी तरह, तीसरे तक `topic3` तक, क्योंकि एथेरियम वर्चुअल मशीन (EVM) प्रति घटना तीन तक अनुक्रमित तर्कों की अनुमति देती है।

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    // ईवेंट की घोषणा जिसमें पते के लिए इंडेक्स्ड पैरामीटर हैं
    event Transfer(address indexed from, address indexed to, uint256 value);

    // टोकन ट्रांसफर करने की क्रिया को सिमुलेट करने के लिए फ़ंक्शन
    function transfer(address to, uint256 value) public {
        // from, to, और value के साथ Transfer ईवेंट को उत्सर्जित करना
        emit Transfer(msg.sender, to, value);
    }
}
```

इस उदाहरण में:

- `Transfer` इवेंट का उपयोग पते के बीच टोकन लेनदेन को लॉग करने के लिए किया जाता है।
- `from` और `to` पैरामीटर इंडेक्स किए गए हैं, जिससे इवेंट लिसनर्स को विशिष्ट पतों से संबंधित ट्रांसफर को फ़िल्टर और मॉनिटर करने की अनुमति मिलती है।
- `transfer` फ़ंक्शन टोकन ट्रांसफर क्रिया का एक सरल प्रतिनिधित्व है, जब भी इसे कॉल किया जाता है तब यह Transfer इवेंट को उत्सर्जित करता है।

#### सबस्पष्ट में कॉन्फ़िगरेशन

Topic filters are defined directly within the event handler configuration in the subgraph manifest. Here is how they are configured:

```yaml
eventHandlers:
  - event: SomeEvent(indexed uint256, indexed address, indexed uint256)
    handler: handleSomeEvent
    topic1: ['0xValue1', '0xValue2']
    topic2: ['0xAddress1', '0xAddress2']
    topic3: ['0xValue3']
```

इस सेटअप में:

- `topic1` पहले इंडेक्स किए गए तर्क से मेल खाता है, `topic2` दूसरे से, और `topic3` तीसरे से।
- प्रत्येक विषय में एक या अधिक मान हो सकते हैं, और एक घटना केवल तभी प्रोसेस की जाती है जब वह प्रत्येक निर्दिष्ट विषय में से किसी एक मान से मेल खाती है।

##### फ़िल्टर लॉजिक

- एकल विषय के भीतर: लॉजिक एक OR स्थिति के रूप में कार्य करता है। यदि यह किसी दिए गए विषय में सूचीबद्ध मूल्यों में से किसी एक के साथ मेल खाता है, तो इवेंट को प्रोसेस किया जाएगा।
- विभिन्न विषयों के बीच: लॉजिक एक AND स्थिति के रूप में कार्य करता है। एक घटना को संबंधित हैंडलर को ट्रिगर करने के लिए विभिन्न विषयों में सभी निर्दिष्ट शर्तों को संतोषजनक रूप से पूरा करना चाहिए।

#### उदाहरण 1: 'पता A' से 'पता B' के लिए प्रत्यक्ष स्थानांतरण का ट्रैकिंग

```yaml
eventHandlers:
  - event: Transfer(indexed address,indexed address,uint256)
    handler: handleDirectedTransfer
    topic1: ['0xAddressA'] # Sender Address
    topic2: ['0xAddressB'] # Receiver Address
```

इस कॉन्फ़िगरेशन में:

- `topic1` को `Transfer` घटनाओं को फ़िल्टर करने के लिए कॉन्फ़िगर किया गया है जहां `0xAddressA` प्रेषक है।
- `topic2` को `Transfer` इवेंट को फ़िल्टर करने के लिए कॉन्फ़िगर किया गया है जहाँ `0xAddressB` रिसीवर है।
- The subgraph will only index transactions that occur directly from `0xAddressA` to `0xAddressB`.

#### उदाहरण 2: दो या अधिक 'पते' के बीच किसी भी दिशा में लेन-देन को ट्रैक करना

```yaml
eventHandlers:
  - event: Transfer(indexed address,indexed address,uint256)
    handler: handleTransferToOrFrom
    topic1: ['0xAddressA', '0xAddressB', '0xAddressC'] # प्रेषक पता
    topic2: ['0xAddressB', '0xAddressC'] # प्राप्तकर्ता पता
```

इस कॉन्फ़िगरेशन में:

- `topic1` को `Transfer` इवेंट को फ़िल्टर करने के लिए कॉन्फ़िगर किया गया है जहाँ `0xAddressA`, `0xAddressB`, `0xAddressC` भेजने वाला है।
- `topic2` को `Transfer` इवेंट्स को फ़िल्टर करने के लिए कॉन्फ़िगर किया गया है जहाँ `0xAddressB` और `0xAddressC` रिसीवर हैं।
- Subgraph उन कई पतों के बीच होने वाले लेनदेन को दोनों दिशाओं में सूचीबद्ध करेगा, जिससे सभी पतों के बीच इंटरैक्शन की व्यापक निगरानी संभव हो सकेगी।

### Declared eth_call

> Note: This is an experimental feature that is not currently available in a stable Graph Node release yet. You can only use it in Subgraph Studio or your self-hosted node.

डिक्लेरेटिव `eth_calls` एक मूल्यवान subgraph विशेषता है जो `eth_calls` को पहले से निष्पादित करने की अनुमति देती है, जिससे `graph-node` उन्हें समानांतर में निष्पादित कर सकता है।

यह फ़ीचर निम्नलिखित कार्य करता है:

- इथेरियम ब्लॉकचेन से डेटा प्राप्त करने के प्रदर्शन में महत्वपूर्ण सुधार करता है, जिससे कई कॉल के लिए कुल समय कम होता है और सबग्राफ की समग्र दक्षता का अनुकूलन होता है।
- यह तेजी से डेटा फ़ेचिंग की अनुमति देता है, जिससे तेजी से क्वेरी प्रतिक्रियाएँ और बेहतर उपयोगकर्ता अनुभव मिलता है।
- कई Ethereum कॉल्स से डेटा को एकत्रित करने की आवश्यकता वाली अनुप्रयोगों के लिए प्रतीक्षा समय को कम करता है, जिससे डेटा पुनर्प्राप्ति प्रक्रिया अधिक प्रभावी हो जाती है।

#### Key Concepts

- डिक्लेरेटिव `eth_calls`: एथेरियम कॉल जो क्रमिक रूप से निष्पादित होने के बजाय समानांतर में निष्पादित किए जाने के लिए परिभाषित किए गए हैं।
- समानांतर निष्पादन: एक कॉल समाप्त होने की प्रतीक्षा करने के बजाय, कई कॉल एक साथ आरंभ किए जा सकते हैं।
- समय दक्षता: सभी कॉल के लिए कुल समय व्यक्तिगत कॉल के समय के योग (अनुक्रमिक) से बदलकर सबसे लंबे कॉल के द्वारा लिए गए समय (समानांतर) में बदल जाता है।

#### Scenario without Declarative `eth_calls`

आपके पास एक subgraph है जिसे एक उपयोगकर्ता के लेनदेन, बैलेंस और टोकन होल्डिंग्स के बारे में डेटा प्राप्त करने के लिए तीन Ethereum कॉल करने की आवश्यकता है।

परंपरागत रूप से, ये कॉल क्रमिक रूप से की जा सकती हैं:

1.  कॉल 1 (लेनदेन): 3 सेकंड लेता है
2.  कॉल 2 (शेष): 2 सेकंड लेता है
3.  कॉल 3 (टोकन होल्डिंग्स): लेता है 4 सेकंड

कुल समय लिया गया = 3 + 2 + 4 = 9 सेकंड

#### Scenario with Declarative `eth_calls`

इस फीचर के साथ, आप इन कॉल्स को समानांतर में निष्पादित करने के लिए घोषित कर सकते हैं:

1.  कॉल 1 (लेनदेन): 3 सेकंड लेता है
2.  कॉल 2 (शेष): 2 सेकंड लेता है
3.  कॉल 3 (टोकन होल्डिंग्स): लेता है 4 सेकंड

चूंकि ये कॉल समानांतर में निष्पादित होते हैं, कुल समय लिया गया सबसे लंबे कॉल के समय के बराबर होता है।

कुल समय = max (3, 2, 4) = 4 सेकंड

#### How it Works

1.  In the subgraph manifest, आप Ethereum कॉल्स को इस तरह घोषित करते हैं कि ये समानांतर में निष्पादित किए जा सकें।
2.  पैरलेल निष्पादन इंजन: The Graph Node का निष्पादन इंजन इन घोषणाओं को पहचानता है और कॉल को समानांतर में चलाता है।
3.  परिणाम संग्रहण: जब सभी कॉल समाप्त हो जाते हैं, तो परिणामों को एकत्रित किया जाता है और आगे की प्रक्रिया के लिए उपयोग किया जाता है।

#### Example Configuration in Subgraph Manifest

घोषित `eth_calls` को अंतर्निहित घटना के `event.address` और सभी `event.params` तक पहुंच प्राप्त होगी।

`Subgraph.yaml` का उपयोग करते हुए `event.address`:

```yaml
eventHandlers:
event: Swap(indexed address,indexed address,int256,int256,uint160,uint128,int24)
handler: handleSwap
calls:
  global0X128: Pool[event.address].feeGrowthGlobal0X128()
  global1X128: Pool[event.address].feeGrowthGlobal1X128()
```

उदाहरण उपरोक्त के लिए विवरण:

- `global0X128` घोषित `eth_call` है।
- यह पाठ (`global0X128`) इस `eth_call` का लेबल है जिसका उपयोग त्रुटियों को लॉग करने के लिए किया जाता है।
- The text (`Pool[event.address].feeGrowthGlobal0X128()`) is the actual `eth_call` that will be executed, which is in the form of `Contract[address].function(arguments)`
- यहां `address` और `arguments` को उन वेरिएबल्स से बदला जा सकता है जो हैंडलर के निष्पादन के समय उपलब्ध होंगे।

`Subgraph.yaml` का उपयोग करते हुए `event.params`

```yaml
calls:
  - ERC20DecimalsToken0: ERC20[event.params.token0].decimals()
```

### SpecVersion Releases

| संस्करण | रिलीज नोट्स                                                                                                                                                              |
|:-------:| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|  1.2.0  | `eth_call` [Indexed Argument Filtering](/#indexed-argument-filters--topic-filters) & के लिए समर्थन जोड़ा गया                                                             |
|  1.1.0  | समर्थित हैं [Timeseries & Aggregations](#timeseries-and-aggregations)। `id` के लिए `Int8` प्रकार के लिए समर्थन जोड़ा गया है।                                             |
|  1.0.0  | समर्थन करता है [`indexerHints`](/developing/creating-a-subgraph/#indexer-hints) फ़ीचर जो उपग्राफ को प्रून करने में मदद करता है                                           |
|  0.0.9  | `endBlock` फीचर का समर्थन करता है                                                                                                                                        |
|  0.0.8  | Added support for polling [Block Handlers](/developing/creating-a-subgraph/#polling-filter) and [Initialisation Handlers](/developing/creating-a-subgraph/#once-filter). |
|  0.0.7  | Added support for [File Data Sources](/developing/creating-a-subgraph/#file-data-sources).                                                                               |
|  0.0.6  | तेज [Proof of Indexing](/network/indexing/#what-is-a-proof-of-indexing-poi) गणना वेरिएंट का समर्थन करता है।                                                              |
|  0.0.5  | घटना हैंडलरों को लेनदेन रसीदों तक पहुंच प्रदान करने के लिए समर्थन जोड़ा गया है।                                                                                          |
|  0.0.4  | घटना हैंडलरों को लेनदेन रसीदों तक पहुंच प्रदान करने के लिए समर्थन जोड़ा गया है।                                                                                          |

### Getting The ABIs

एबीआई फाइल(फाइलों) को आपके अनुबंध(ओं) से मेल खाना चाहिए। ABI फ़ाइलें प्राप्त करने के कुछ तरीके हैं:

- यदि आप अपना खुद का प्रोजेक्ट बना रहे हैं, तो आपके पास अपने सबसे मौजूदा एबीआई तक पहुंच होने की संभावना है।
- If you are building a subgraph for a public project, you can download that project to your computer and get the ABI by using [`npx hardhat compile`](https://hardhat.org/hardhat-runner/docs/guides/compile-contracts#compiling-your-contracts) or using `solc` to compile.
- आप ABI को [Etherscan](https://etherscan.io/) पर भी ढूंढ सकते हैं, लेकिन यह हमेशा विश्वसनीय नहीं होता, क्योंकि वहां अपलोड किया गया ABI पुराना हो सकता है। सुनिश्चित करें कि आपके पास सही ABI है, अन्यथा आपका सबग्राफ चलाना विफल हो जाएगा।

### The GraphQL Schema

The schema for your subgraph is in the file `schema.graphql`. GraphQL schemas are defined using the GraphQL interface definition language. If you've never written a GraphQL schema, it is recommended that you check out this primer on the GraphQL type system. Reference documentation for GraphQL schemas can be found in the [GraphQL API](/querying/graphql-api/) section.

### Defining Entities

Before defining entities, it is important to take a step back and think about how your data is structured and linked.

- All queries will be made against the data model defined in the subgraph schema and the entities indexed by the subgraph. As a result, it is good to define the subgraph schema in a way that matches the needs of your dapp.
- It may be useful to imagine entities as "objects containing data", rather than as events or functions.
- You define entity types in `schema.graphql`, and Graph Node will generate top-level fields for querying single instances and collections of that entity type.
- Each type that should be an entity is required to be annotated with an `@entity` directive.
- By default, entities are mutable, meaning that mappings can load existing entities, modify them and store a new version of that entity.
  - Mutability comes at a price, so for entity types that will never be modified, such as those containing data extracted verbatim from the chain, it is recommended to mark them as immutable with `@entity(immutable: true)`.
  - If changes happen in the same block in which the entity was created, then mappings can make changes to immutable entities. Immutable entities are much faster to write and to query so they should be used whenever possible.

#### अच्छा उदाहरण

The following `Gravatar` entity is structured around a Gravatar object and is a good example of how an entity could be defined.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

#### खराब उदाहरण

The following example `GravatarAccepted` and `GravatarDeclined` entities are based around events. It is not recommended to map events or function calls to entities 1:1.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

#### वैकल्पिक और आवश्यक फ़ील्ड

इकाई क्षेत्रों को आवश्यक या वैकल्पिक के रूप में परिभाषित किया जा सकता है। स्कीमा में आवश्यक फ़ील्ड `!` द्वारा दर्शाए गए हैं। यदि मैपिंग में कोई आवश्यक फ़ील्ड सेट नहीं है, तो फ़ील्ड की क्वेरी करते समय आपको यह त्रुटि प्राप्त होगी:

```
गैर-शून्य फ़ील्ड 'नाम' के लिए हल किया गया शून्य मान
```

प्रत्येक इकाई में एक `आईडी` फ़ील्ड होना चाहिए, जो कि `बाइट्स!` या `स्ट्रिंग!` प्रकार का होना चाहिए। आमतौर पर `बाइट्स!` का उपयोग करने की सिफारिश की जाती है, जब तक कि `आईडी` में मानव-पठनीय पाठ न हो, चूंकि `बाइट्स!` आईडी वाली इकाइयां लिखने में तेज़ होंगी और `स्ट्रिंग!` `id` वाले प्रश्नों के रूप में। `id` फ़ील्ड प्राथमिक कुंजी के रूप में कार्य करता है, और एक ही प्रकार की सभी संस्थाओं के बीच अद्वितीय होना चाहिए। ऐतिहासिक कारणों से, प्रकार `ID!` को भी स्वीकार किया जाता है और यह `स्ट्रिंग!` का पर्यायवाची है।

कुछ इकाई प्रकारों के लिए `id` का निर्माण दो अन्य संस्थाओं की आईडी से किया जाता है; यह `concat` का उपयोग करके संभव है, उदाहरण के लिए, `let id = left.id.concat(right.id)` `left` की आईडी से आईडी बनाने के लिए और `दाएं`। इसी तरह, एक मौजूदा इकाई की आईडी से एक आईडी बनाने के लिए और एक काउंटर `गिनती`, `let id = left.id.concatI32(count)` का उपयोग किया जा सकता है। जब तक `बाएं` की लंबाई ऐसी सभी संस्थाओं के लिए समान है, उदाहरण के लिए, क्योंकि `left.id` एक `पता है, तब तक विशिष्ट आईडी बनाने के लिए संयोजन की गारंटी दी जाती है`।

### बिल्ट-इन स्केलर प्रकार

#### ग्राफक्यूएल समर्थित स्केलर्स

The following scalars are supported in the GraphQL API:

| प्रकार        | विवरण                                                                                                                                                                                                                                                         |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Bytes`       | बाइट सरणी, एक हेक्साडेसिमल स्ट्रिंग के रूप में दर्शाया गया है। आमतौर पर एथेरियम हैश और पतों के लिए उपयोग किया जाता है।                                                                                                                                        |
| `String`      | `स्ट्रिंग` मानों के लिए स्केलर। अशक्त वर्ण समर्थित नहीं हैं और स्वचालित रूप से हटा दिए जाते हैं।                                                                                                                                                              |
| `Boolean`     | `boolean` मानों के लिए स्केलर।                                                                                                                                                                                                                                |
| `Int`         | GraphQL स्पेक `Int` को एक साइन किया हुआ 32-बिट पूर्णांक के रूप में परिभाषित करता है।                                                                                                                                                                          |
| `Int8`        | एक 8-बाइट साइन किया गया पूर्णांक, जिसे 64-बिट साइन किया गया पूर्णांक भी कहा जाता है, -9,223,372,036,854,775,808 से 9,223,372,036,854,775,807 के बीच के मानों को संग्रहीत कर सकता है। ethereum से `i64` का प्रतिनिधित्व करने के लिए इसका उपयोग करना पसंद करें। |
| `BigInt`      | बड़े पूर्णांक। एथेरियम के `uint32`, `int64`, `uint64`, ..., `uint256` प्रकारों के लिए उपयोग किया जाता है। नोट: `uint32` के नीचे सब कुछ, जैसे `int32`, `uint24` या `int8` को `i32` के रूप में दर्शाया गया है।                                                  |
| `BigDecimal`  | `BigDecimal` उच्च परिशुद्धता दशमलव एक महत्व और एक प्रतिपादक के रूप में दर्शाया गया है। एक्सपोनेंट रेंज -6143 से +6144 तक है। 34 महत्वपूर्ण अंकों तक गोल।                                                                                                      |
| `टाइमस्टैम्प` | यह एक `i64` मान है जो माइक्रोसेकंड में है। आमतौर पर `timestamp` फ़ील्ड के लिए समय श्रृंखला और समेकनों के लिए उपयोग किया जाता है।                                                                                                                              |

#### Enums

आप स्कीमा के भीतर एनम भी बना सकते हैं। Enums में निम्न सिंटैक्स होता है:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

स्कीमा में एक बार एनम परिभाषित हो जाने के बाद, आप किसी इकाई पर एनम फ़ील्ड सेट करने के लिए एनम मान के स्ट्रिंग प्रतिनिधित्व का उपयोग कर सकते हैं। उदाहरण के लिए, आप पहले अपनी इकाई को परिभाषित करके और बाद में `entity.tokenStatus = "SecondOwner"` के साथ फ़ील्ड सेट करके `tokenStatus` को `SecondOwner` पर सेट कर सकते हैं। नीचे दिया गया उदाहरण दर्शाता है कि एनम फील्ड के साथ टोकन इकाई कैसी दिखेगी:

एनम लिखने के बारे में अधिक विवरण [GraphQL प्रलेखन](https://graphql.org/learn/schema/) में पाया जा सकता है।

#### निकाय संबंध

एक इकाई का आपकी स्कीमा में एक या अधिक अन्य संस्थाओं से संबंध हो सकता है। आपके प्रश्नों में इन संबंधों का पता लगाया जा सकता है। ग्राफ़ में रिश्ते यूनिडायरेक्शनल हैं। रिश्ते के किसी भी "अंत" पर एक यूनिडायरेक्शनल रिश्ते को परिभाषित करके द्विपक्षीय संबंधों को अनुकरण करना संभव है।

संस्थाओं पर संबंधों को किसी अन्य क्षेत्र की तरह ही परिभाषित किया जाता है सिवाय इसके कि निर्दिष्ट प्रकार किसी अन्य इकाई का है।

#### एक-से-एक संबंध

`TransactionReceipt` इकाई प्रकार के साथ एक वैकल्पिक एक-से-एक संबंध के साथ एक `लेन-देन` इकाई प्रकार परिभाषित करें:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### एक से कई रिश्ते

टोकन निकाय प्रकार के साथ आवश्यक वन-टू-मैनी संबंध के साथ `TokenBalance` निकाय प्रकार परिभाषित करें:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### रिवर्स लुकअप

उल्टे लुकअप को किसी इकाई पर `@derivedFrom` फ़ील्ड के माध्यम से परिभाषित किया जा सकता है। यह इकाई पर एक आभासी क्षेत्र बनाता है जिसे क्वेरी किया जा सकता है लेकिन मैपिंग एपीआई के माध्यम से मैन्युअल रूप से सेट नहीं किया जा सकता है। बल्कि, यह दूसरे निकाय पर परिभाषित संबंध से प्राप्त होता है। इस तरह के रिश्तों के लिए, रिश्ते के दोनों पक्षों को स्टोर करने के लिए यह शायद ही कभी समझ में आता है, और इंडेक्सिंग और क्वेरी प्रदर्शन दोनों बेहतर होंगे जब केवल एक पक्ष संग्रहीत किया जाता है और दूसरा व्युत्पन्न होता है।

एक-से-अनेक संबंधों के लिए, संबंध को हमेशा 'एक' पक्ष में संग्रहीत किया जाना चाहिए, और 'अनेक' पक्ष हमेशा निकाला जाना चाहिए। संबंधों को इस तरह से संग्रहीत करने के बजाय, 'अनेक' पक्ष पर संस्थाओं की एक सरणी संग्रहीत करने के परिणामस्वरूप, सबग्राफ को अनुक्रमित करने और क्वेरी करने दोनों के लिए नाटकीय रूप से बेहतर प्रदर्शन होगा। सामान्य तौर पर, संस्थाओं की सरणियों को संग्रहीत करने से जितना संभव हो उतना बचा जाना चाहिए।

#### उदाहरण

`tokenBalances` फ़ील्ड प्राप्त करके हम टोकन से टोकन के लिए शेष राशि को सुलभ बना सकते हैं:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### अनेक-से-अनेक संबंध

मैनी-टू-मैनी संबंधों के लिए, जैसे कि प्रत्येक उपयोगकर्ता किसी भी संख्या में संगठनों से संबंधित हो सकता है, सबसे सरल, लेकिन आम तौर पर सबसे अधिक प्रदर्शनकारी नहीं, संबंध को मॉडल करने का तरीका शामिल दो संस्थाओं में से प्रत्येक में एक सरणी के रूप में है। यदि संबंध सममित है, तो संबंध के केवल एक पक्ष को संग्रहित करने की आवश्यकता है और दूसरे पक्ष को व्युत्पन्न किया जा सकता है।

#### उदाहरण

एक `User` entity प्रकार से `Organization` entity प्रकार के लिए एक रिवर्स लुकअप परिभाषित करें। नीचे दिए गए उदाहरण में, यह `Organization` entity के भीतर `members` विशेषता को देखकर प्राप्त किया जाता है। क्वेरी में, `User` पर `organizations` फ़ील्ड को उपयोगकर्ता के आईडी वाले सभी `Organization` entities को खोजकर हल किया जाएगा।

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

इस संबंध को संग्रहीत करने का एक अधिक प्रभावशाली तरीका एक मैपिंग टेबल के माध्यम से है जिसमें प्रत्येक `उपयोगकर्ता` / `संगठन` जोड़ी के लिए स्कीमा के साथ एक प्रविष्टि है

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

इस दृष्टिकोण के लिए आवश्यक है कि प्रश्नों को पुनः प्राप्त करने के लिए एक अतिरिक्त स्तर में उतरना पड़े, उदाहरण के लिए, उपयोगकर्ताओं के लिए संगठन:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

मैनी-टू-मैनी संबंधों को संग्रहीत करने के इस अधिक विस्तृत तरीके के परिणामस्वरूप सबग्राफ के लिए कम डेटा संग्रहीत होगा, और इसलिए एक सबग्राफ के लिए जो अक्सर इंडेक्स और क्वेरी के लिए नाटकीय रूप से तेज़ होता है।

#### स्कीमा में टिप्पणियां जोड़ना

GraphQL स्पेक के अनुसार, टिप्पणियाँ स्कीमा एंटिटी विशेषताओं के ऊपर हैश चिन्ह `#` का उपयोग करके जोड़ी जा सकती हैं। नीचे उदाहरण में इसे दर्शाया गया है:

```graphql
type MyFirstEntity @entity {
  # unique identifier and primary key of the entity
  id: Bytes!
  address: Bytes!
}
```

## फुलटेक्स्ट सर्च फील्ड्स को परिभाषित करना

पूर्ण पाठ खोज क्वेरी फ़िल्टर करती है और पाठ खोज इनपुट के आधार पर संस्थाओं को रैंक करती है। अनुक्रमित टेक्स्ट डेटा से तुलना करने से पहले क्वेरी टेक्स्ट इनपुट को तने में संसाधित करके पूर्ण टेक्स्ट क्वेरी समान शब्दों के लिए मैच वापस करने में सक्षम हैं।

एक पूर्ण पाठ क्वेरी परिभाषा में क्वेरी का नाम, पाठ फ़ील्ड को संसाधित करने के लिए उपयोग किया जाने वाला भाषा शब्दकोश, परिणामों को क्रमबद्ध करने के लिए उपयोग किया जाने वाला रैंकिंग एल्गोरिदम और खोज में शामिल फ़ील्ड शामिल हैं। प्रत्येक पूर्ण-पाठ क्वेरी में कई फ़ील्ड शामिल हो सकते हैं, लेकिन सभी शामिल फ़ील्ड एक इकाई प्रकार से होने चाहिए।

फुलटेक्स्ट क्वेरी जोड़ने के लिए, ग्राफक्यूएल स्कीमा में एक `_Schema_` टाइप को फुलटेक्स्ट डायरेक्टिव के साथ शामिल करें।

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

`नाम`, `विवरण</0 में टेक्स्ट दस्तावेज़ों के आधार पर <code>बैंड` इकाइयों को फ़िल्टर करने के लिए उदाहरण `बैंडसर्च` फ़ील्ड का उपयोग प्रश्नों में किया जा सकता है >, और `जैव` फ़ील्ड। पूर्ण पाठ खोज API और अधिक उदाहरण उपयोग के विवरण के लिए [GraphQL API - क्वेरीज़](/querying/graphql-api#queries) पर जायें।

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[सुविधा प्रबंधन](#experimental-features):** `specVersion` `0.0.4</code से > और आगे, <code>fullTextSearch` को सबग्राफ मेनिफेस्ट में `फीचर्स` सेक्शन के तहत घोषित किया जाना चाहिए।

### भाषाओं का समर्थन किया

एक अलग भाषा का चयन एक निश्चित, हालांकि कभी-कभी सूक्ष्म, पूर्ण पाठ खोज एपीआई पर प्रभाव डालेगा। पूर्ण-पाठ क्वेरी फ़ील्ड द्वारा कवर किए गए फ़ील्ड को चुनी हुई भाषा के संदर्भ में जांचा जाता है, इसलिए विश्लेषण और खोज क्वेरी द्वारा उत्पन्न शब्दांश भाषा से भाषा में भिन्न होते हैं। उदाहरण के लिए: समर्थित तुर्की शब्दकोश "टोकन" का उपयोग करते समय "टोकन" के लिए स्टेम किया जाता है, जबकि निश्चित रूप से, अंग्रेजी शब्दकोश इसे "टोकन" के लिए स्टेम करेगा।

समर्थित भाषा शब्दकोश:

| कोड    | शब्दकोष    |
| ------ | ---------- |
| simple | आम         |
| da     | डेनिश      |
| nl     | डच         |
| en     | अंग्रेज़ी  |
| fi     | फिनिश      |
| fr     | फ्रेंच     |
| de     | जर्मन      |
| hu     | हंगेरी     |
| it     | इतालवी     |
| no     | नार्वेजियन |
| pt     | पुर्तगाली  |
| ro     | रोमानियाई  |
| ru     | रूसी       |
| es     | स्पैनिश    |
| sv     | स्वीडिश    |
| tr     | तुर्की     |

### रैंकिंग एल्गोरिदम

परिणाम ऑर्डर करने के लिए समर्थित एल्गोरिदम:

| एल्गोरिदम     | विवरण                                                                                     |
| ------------- | ----------------------------------------------------------------------------------------- |
| rank          | परिणामों को व्यवस्थित करने के लिए पूर्ण पाठ क्वेरी की मिलान गुणवत्ता (0-1) का उपयोग करें। |
| proximityRank | रैंक के समान लेकिन इसमें मैचों की निकटता भी शामिल है।                                     |

## मैपिंग लिखना

मैपिंग एक विशेष स्रोत से डेटा लेती है और इसे उन संस्थाओं में बदल देती है जो आपके स्कीमा के भीतर परिभाषित हैं। मैपिंग को [टाइपस्क्रिप्ट](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) के उपसमुच्चय में लिखा जाता है जिसे [असेंबलीस्क्रिप्ट](https://github.com/AssemblyScript/assemblyscript/wiki) कहा जाता है जिसे WASM ([WebAssembly](https://webassembly.org/)) में संकलित किया जा सकता है। असेंबलीस्क्रिप्ट सामान्य टाइपस्क्रिप्ट की तुलना में सख्त है, फिर भी एक परिचित सिंटैक्स प्रदान करता है।

प्रत्येक ईवेंट हैंडलर के लिए जो `subgraph.yaml` `mapping.eventHandlers` के अंतर्गत परिभाषित है, उसी नाम का एक निर्यातित फ़ंक्शन बनाएं। प्रत्येक हैंडलर को `event` नामक एकल पैरामीटर को उस ईवेंट के नाम के अनुरूप एक प्रकार के साथ स्वीकार करना होगा जिसे संभाला जा रहा है।

उदाहरण के सबग्राफ में, `src/mapping.ts` में `NewGravatar` और `UpdatedGravatar` ईवेंट के लिए हैंडलर शामिल हैं:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

पहला हैंडलर `NewGravatar` ईवेंट लेता है और `new Gravatar(event.params.id.toHex())` के साथ एक नया `Gravatar` इकाई बनाता है, जो पॉप्युलेट करता है संबंधित ईवेंट पैरामीटर का उपयोग करके निकाय फ़ील्ड. इस इकाई उदाहरण को `event.params.id.toHex()` के आईडी मान के साथ वेरिएबल `gravatar` द्वारा दर्शाया गया है।

दूसरा हैंडलर ग्राफ़ नोड स्टोर से मौजूदा `Gravatar` को लोड करने का प्रयास करता है। यदि यह अभी तक मौजूद नहीं है, तो इसे ऑन-डिमांड बनाया गया है। इसके बाद इकाई को `gravatar.save()` का उपयोग करके स्टोर में वापस सहेजे जाने से पहले नए ईवेंट पैरामीटर से मेल खाने के लिए अपडेट किया जाता है।

### नई संस्थाओं को बनाने के लिए अनुशंसित आईडी

यह अत्यधिक अनुशंसा की जाती है कि `Bytes` को `id` फ़ील्ड के प्रकार के रूप में उपयोग किया जाए, और केवल `String` का उपयोग उन गुणों के लिए करें जो वास्तव में मानव-पठनीय पाठ होते हैं, जैसे किसी टोकन का नाम। नए संस्थाओं को बनाने के समय विचार करने के लिए कुछ अनुशंसित `id` मान नीचे दिए गए हैं।

- `transfer.id = event.transaction.hash`

- `let id = event.transaction.hash.concatI32(event.logIndex.toI32())`

- संवेदनाओं के लिए जो संचित डेटा स्टोर करते हैं, जैसे कि दैनिक व्यापार वॉल्यूम, `id` आमतौर पर दिन का नंबर शामिल होता है। यहाँ, `Bytes` को `id` के रूप में उपयोग करना फायदेमंद है। `id` निर्धारित करने की प्रक्रिया इस प्रकार होगी:

```typescript
let dayID = event.block.timestamp.toI32() / 86400
let id = Bytes.fromI32(dayID)
```

- स्थायी पते को `Bytes` में परिवर्तित करें।

`const id = Bytes.fromHexString('0xdead...beef')`

एक [Graph Typescript Library](https://github.com/graphprotocol/graph-tooling/tree/main/packages/ts) है जिसमें Graph Node स्टोर के साथ इंटरैक्ट करने के लिए उपयोगिताएँ और स्मार्ट कॉन्ट्रैक्ट डेटा और संस्थाओं को संभालने के लिए सुविधाएँ शामिल हैं। इसे `mapping.ts` में `@graphprotocol/graph-ts` से आयात किया जा सकता है।

### एक समान आईडी वाले एंटिटीज़ का प्रबंधन

जब एक नई इकाई बनाते और सहेजते हैं, यदि एक ही ID वाली इकाई पहले से मौजूद है, तो मर्ज प्रक्रिया के दौरान नई इकाई के गुणों को हमेशा प्राथमिकता दी जाती है। इसका मतलब है कि मौजूदा इकाई को नई इकाई के मानों के साथ अपडेट किया जाएगा।

यदि एक नया एन्टिटी जिसमें समान ID है, के लिए किसी फील्ड के लिए जानबूझकर एक null मान सेट किया जाता है, तो मौजूदा एन्टिटी को null मान के साथ अपडेट किया जाएगा।

यदि समान ID वाली नई entity में किसी field के लिए कोई मान set नहीं किया गया है, तो field का result भी null हो जाएगा।

## कोड जनरेशन

स्मार्ट कॉन्ट्रैक्ट्स, इवेंट्स और एंटिटीज के साथ काम करना आसान और टाइप-सेफ बनाने के लिए, ग्राफ सीएलआई सबग्राफ के ग्राफक्यूएल स्कीमा और डेटा स्रोतों में शामिल कॉन्ट्रैक्ट एबीआई से असेंबलीस्क्रिप्ट प्रकार उत्पन्न कर सकता है।

इसके साथ किया जाता है

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

लेकिन ज्यादातर मामलों में, सबग्राफ पहले से ही `package.json` के माध्यम से पूर्व-कॉन्फ़िगर किए जाते हैं ताकि आप इसे प्राप्त करने के लिए निम्न में से किसी एक को चला सकें:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

यह `subgraph.yaml` में वर्णित एबीआई फाइलों में प्रत्येक स्मार्ट अनुबंध के लिए एक असेंबलीस्क्रिप्ट क्लास उत्पन्न करेगा, जिससे आप इन अनुबंधों को मैपिंग में विशिष्ट पतों से बाँध सकते हैं और ब्लॉक होने के खिलाफ केवल-पढ़ने वाली अनुबंध विधियों को कॉल कर सकते हैं। संसाधित। यह प्रत्येक अनुबंध घटना के लिए एक वर्ग भी उत्पन्न करेगा, जो घटना के मापदंडों तक आसान पहुँच प्रदान करेगा, साथ ही ब्लॉक और लेन-देन की घटना से उत्पन्न हुआ। ये सभी प्रकार `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts` को लिखे जाते हैं। उदाहरण के सबग्राफ में, यह `उत्पन्न/ग्रेविटी/ग्रेविटी.टीएस` होगा, जिससे मैपिंग को इन प्रकारों को आयात करने की अनुमति मिलेगी।

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

इसके अलावा, सबग्राफ के ग्राफक्यूएल स्कीमा में प्रत्येक इकाई प्रकार के लिए एक वर्ग उत्पन्न होता है। ये क्लासेस टाइप-सेफ एंटिटी लोडिंग, एंटिटी फील्ड्स तक रीड और राइट एक्सेस के साथ-साथ स्टोर करने के लिए एंटिटीज लिखने के लिए `save()` मेथड मुहैया कराती हैं। सभी निकाय वर्ग `<OUTPUT_DIR>/schema.ts` पर लिखे गए हैं, जिससे मैपिंग उन्हें आयात करने की अनुमति देती है

```javascript
import { Gravatar } from '../generated/schema'
```

> **ध्यान दें:** मेनिफेस्ट में शामिल ग्राफ़क्यूएल स्कीमा या एबीआई में हर बदलाव के बाद कोड जेनरेशन फिर से किया जाना चाहिए। सबग्राफ बनाने या तैनात करने से पहले इसे कम से कम एक बार अवश्य किया जाना चाहिए।

कोड जनरेशन `src/mapping.ts` में आपके मैपिंग कोड की जांच नहीं करता है। यदि आप Graph Explorer पर अपने subgraph को डिप्लॉय करने से पहले इसकी जांच करना चाहते हैं, तो आप `yarn build` चला सकते हैं और TypeScript कंपाइलर द्वारा पाए गए किसी भी सिंटैक्स एरर को ठीक कर सकते हैं।

## डेटा स्रोत टेम्पलेट्स

ईवीएम-संगत स्मार्ट अनुबंधों में एक सामान्य पैटर्न रजिस्ट्री या फ़ैक्टरी अनुबंधों का उपयोग होता है, जहां एक अनुबंध अन्य अनुबंधों की मनमानी संख्या का निर्माण, प्रबंधन या संदर्भ करता है, जिनमें से प्रत्येक का अपना राज्य और ईवेंट होता है।

इन उप-अनुबंधों के पते पहले से ज्ञात हो सकते हैं या नहीं भी हो सकते हैं और इनमें से कई अनुबंध समय के साथ बनाए और/या जोड़े जा सकते हैं। यही कारण है कि, ऐसे मामलों में, एक डेटा स्रोत या डेटा स्रोतों की एक निश्चित संख्या को परिभाषित करना असंभव है और अधिक गतिशील दृष्टिकोण की आवश्यकता है: _डेटा स्रोत टेम्पलेट्स_।

### मुख्य अनुबंध के लिए डेटा स्रोत

सबसे पहले, आप मुख्य अनुबंध के लिए एक नियमित डेटा स्रोत परिभाषित करते हैं। नीचे दिया गया स्निपेट [Uniswap](https://uniswap.org) एक्सचेंज फैक्ट्री अनुबंध के लिए एक सरलीकृत उदाहरण डेटा स्रोत दिखाता है। `NewExchange(address,address)` ईवेंट हैंडलर पर ध्यान दें। यह तब उत्सर्जित होता है जब फ़ैक्टरी अनुबंध द्वारा एक नया एक्सचेंज अनुबंध ऑन-चेन बनाया जाता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### गतिशील रूप से बनाए गए अनुबंधों के लिए डेटा स्रोत टेम्प्लेट

फिर, आप _data source templates_ को मैनिफेस्ट में जोड़ते हैं। ये सामान्य डेटा स्रोतों के समान होते हैं, सिवाय इसके कि इनमें `source` के तहत एक पूर्व-परिभाषित कॉन्ट्रैक्ट पता नहीं होता है। आमतौर पर, आप प्रत्येक प्रकार के उप-कॉन्ट्रैक्ट के लिए एक टेम्पलेट परिभाषित करेंगे जिसे पैरेंट कॉन्ट्रैक्ट द्वारा प्रबंधित या संदर्भित किया जाता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### डेटा स्रोत टेम्प्लेट को इंस्टेंट करना

अंतिम चरण में, आप किसी एक टेम्प्लेट से डायनेमिक डेटा स्रोत इंस्टेंस बनाने के लिए अपनी मुख्य अनुबंध मैपिंग को अपडेट करते हैं। इस उदाहरण में, आप `Exchange` टेम्पलेट को इम्पोर्ट करने के लिए मुख्य कॉन्ट्रैक्ट मैपिंग को बदलेंगे और नए एक्सचेंज कॉन्ट्रैक्ट को इंडेक्स करना शुरू करने के लिए उस पर `Exchange.create(address)` मेथड को कॉल करेंगे।

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **ध्यान दें:** एक नया डेटा स्रोत केवल उस ब्लॉक के लिए कॉल और ईवेंट को प्रोसेस करेगा जिसमें इसे बनाया गया था और सभी बाद के ब्लॉक, लेकिन ऐतिहासिक डेटा, यानी डेटा को प्रोसेस नहीं करेगा जो पिछले ब्लॉकों में निहित है।
> 
> यदि पिछले ब्लॉक में नए डेटा स्रोत के लिए प्रासंगिक डेटा है, तो उस डेटा को अनुबंध की वर्तमान स्थिति को पढ़कर और नए डेटा स्रोत के निर्माण के समय उस स्थिति का प्रतिनिधित्व करने वाली संस्थाओं का निर्माण करना सबसे अच्छा है।

### डेटा स्रोत प्रसंग

डेटा स्रोत संदर्भ किसी टेम्प्लेट को इंस्टेंट करते समय अतिरिक्त कॉन्फ़िगरेशन पास करने की अनुमति देते हैं। हमारे उदाहरण में, मान लें कि एक्सचेंज एक विशेष ट्रेडिंग जोड़ी से जुड़े हैं, जो `NewExchange` इवेंट में शामिल है। उस जानकारी को तात्कालिक डेटा स्रोत में पास किया जा सकता है, जैसे:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

`Exchange` टेम्प्लेट की मैपिंग के अंदर, संदर्भ तक पहुँचा जा सकता है:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

सभी प्रकार के मूल्य के लिए `setString` और `getString` जैसे सेटर्स और गेटर्स हैं।

## Start Blocks

`StartBlock` एक वैकल्पिक सेटिंग है जो आपको यह परिभाषित करने की अनुमति देती है कि श्रृंखला में किस ब्लॉक से डेटा स्रोत अनुक्रमण शुरू करेगा। स्टार्ट ब्लॉक सेट करने से डेटा स्रोत संभावित रूप से अप्रासंगिक लाखों ब्लॉक को छोड़ देता है। आमतौर पर, एक सबग्राफ डेवलपर `स्टार्टब्लॉक` को उस ब्लॉक पर सेट करेगा जिसमें डेटा स्रोत का स्मार्ट अनुबंध बनाया गया था।

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **ध्यान दें:** इथरस्कैन पर अनुबंध निर्माण ब्लॉक को जल्दी से देखा जा सकता है:
> 
> 1. खोज बार में उसका पता दर्ज करके अनुबंध की खोज करें।
> 2. `अनुबंध निर्माता` अनुभाग में निर्माण लेनदेन हैश पर क्लिक करें।
> 3. लेन-देन विवरण पृष्ठ लोड करें जहां आपको उस अनुबंध के लिए प्रारंभ ब्लॉक मिलेगा।

## Indexer संकेत

The `indexerHints` सेटिंग एक subgraph के मैनिफेस्ट में indexers को एक subgraph को प्रोसेस और मैनेज करने के लिए निर्देश प्रदान करती है। यह डेटा हैंडलिंग, इंडेक्सिंग स्ट्रैटेजीज़, और ऑप्टिमाइजेशन से जुड़ी संचालनात्मक निर्णयों को प्रभावित करती है। वर्तमान में, यह ऐतिहासिक डेटा रिटेंशन या pruning को मैनेज करने के लिए `prune` विकल्प को दर्शाती है।

> यह फीचर `specVersion: 1.0.0` से उपलब्ध है

### Prune

`indexerHints.prune`: एक उपग्राफ के लिए ऐतिहासिक ब्लॉक डेटा को संरक्षित करने की परिभाषा। विकल्पों में शामिल हैं:

1.  `"never"`: कोई ऐतिहासिक डेटा को हटाने का काम नहीं होता है; पूरी इतिहास को बनाए रखता है।
2.  `"auto"`: न्यूनतम आवश्यक इतिहास को बनाए रखता है जैसा कि इंडेक्सर द्वारा निर्धारित किया गया है, जिससे क्वेरी प्रदर्शन को अनुकूलित किया जाता है।
3.  एक विशेष संख्या: ऐतिहासिक ब्लॉकों की एक कस्टम सीमा निर्धारित करता है जिन्हें बनाए रखा जाना है।

```
 indexerHints:
  prune: auto
```

> इस संदर्भ में "history" का अर्थ उन आंकड़ों को संग्रहीत करने से है जो 'mutable' संस्थाओं की पुरानी स्थितियों को दर्शाते हैं।

दिए गए ब्लॉक के रूप में इतिहास की आवश्यकता है:

- [टाइम ट्रैवल क्वेरीज़](/querying/graphql-api/#time-travel-queries), जो आपको इन इकाइयों के पिछले अवस्थाओं को विशेष 'blocks' पर 'subgraph' के इतिहास में क्वेरी करने की अनुमति देती हैं
- दूसरे subgraph में [graft base](/developing/creating-a-subgraph/#grafting-onto-existing-subgraphs) के रूप में उपयोग करना, उस ब्लॉक में
- उस ब्लॉक पर 'subgraph' को वापस लाना

यदि ब्लॉक के रूप में ऐतिहासिक डेटा को प्रून किया गया है, तो उपरोक्त क्षमताएँ उपलब्ध नहीं होंगी।

> `auto` का उपयोग सामान्यतः अनुशंसित है क्योंकि यह क्वेरी प्रदर्शन को अधिकतम करता है और उन अधिकांश उपयोगकर्ताओं के लिए पर्याप्त है जिन्हें व्यापक ऐतिहासिक डेटा की आवश्यकता नहीं होती है।

'टाइम ट्रैवल क्वेरियों' के लिए [time travel queries](/querying/graphql-api/#time-travel-queries) का उपयोग करते समय, ऐतिहासिक डेटा रखरखाव के लिए एक निश्चित संख्या में ब्लॉकों को सेट करना या `prune: never` का उपयोग करना उचित है ताकि सभी ऐतिहासिक एंटिटी राज्यों को रखा जा सके। आपके subgraph की सेटिंग्स में दोनों विकल्पों को कॉन्फ़िगर करने के उदाहरण नीचे दिए गए हैं:

विशिष्ट मात्रा में ऐतिहासिक डेटा बनाए रखने के लिए:

```
 indexerHints:
  prune: 1000 # इच्छित ब्लॉकों की संख्या को बनाए रखने के लिए 1000 को बदलें
```

पूरे 'entity' राज्यों का इतिहास बनाए रखने के लिए:

```
indexerHints:
  prune: never
```

## आयोजन Handlers

Event handlers एक subgraph में स्मार्ट कॉन्ट्रैक्ट्स द्वारा ब्लॉकचेन पर उत्पन्न होने वाले विशिष्ट घटनाओं पर प्रतिक्रिया करते हैं और subgraph के मैनिफेस्ट में परिभाषित हैंडलर्स को ट्रिगर करते हैं। इससे subgraphs को परिभाषित लॉजिक के अनुसार घटना डेटा को प्रोसेस और स्टोर करने की अनुमति मिलती है।

### इवेंट हैंडलर को परिभाषित करना

एक event handler को डेटा स्रोत के भीतर subgraph के YAML configuration में घोषित किया जाता है। यह निर्दिष्ट करता है कि कौन से events पर ध्यान देना है और उन events का पता चलने पर कार्यान्वित करने के लिए संबंधित function क्या है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: Approval(address,address,uint256)
          handler: handleApproval
        - event: Transfer(address,address,uint256)
          handler: handleTransfer
          topic1: ['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', '0xc8dA6BF26964aF9D7eEd9e03E53415D37aA96325'] # Optional topic filter which filters only events with the specified topic.
```

## कॉल हैंडलर्स

जबकि घटनाएँ एक अनुबंध की स्थिति में प्रासंगिक परिवर्तन एकत्र करने का एक प्रभावी तरीका प्रदान करती हैं, कई अनुबंध गैस लागतों को अनुकूलित करने के लिए लॉग उत्पन्न करने से बचते हैं। इन मामलों में, एक सबग्राफ डेटा स्रोत अनुबंध में किए गए कॉलों की सदस्यता ले सकता है। यह फ़ंक्शन सिग्नेचर और मैपिंग हैंडलर को संदर्भित करने वाले कॉल हैंडलर को परिभाषित करके प्राप्त किया जाता है जो इस फ़ंक्शन को कॉल संसाधित करेगा। इन कॉल्स को प्रोसेस करने के लिए, मैपिंग हैंडलर को `ethereum.Call` एक आर्गुमेंट के रूप में प्राप्त होगा, जिसमें टाइप किए गए इनपुट और कॉल के आउटपुट होंगे। लेन-देन की कॉल श्रृंखला में किसी भी गहराई पर किए गए कॉल मैपिंग को ट्रिगर करेंगे, जिससे प्रॉक्सी अनुबंधों के माध्यम से डेटा स्रोत अनुबंध के साथ गतिविधि को कैप्चर किया जा सकेगा।

कॉल हैंडलर केवल दो मामलों में से एक में ट्रिगर होंगे: जब निर्दिष्ट फ़ंक्शन को अनुबंध के अलावा किसी अन्य खाते द्वारा कॉल किया जाता है या जब इसे सॉलिडिटी में बाहरी के रूप में चिह्नित किया जाता है और उसी अनुबंध में किसी अन्य फ़ंक्शन के भाग के रूप में कॉल किया जाता है।

> **ध्यान दें:** कॉल हैंडलर वर्तमान में समता अनुरेखण API पर निर्भर करते हैं। बीएनबी चेन और आर्बिट्रम जैसे कुछ नेटवर्क इस एपीआई का समर्थन नहीं करते हैं। यदि इन नेटवर्कों में से किसी एक सबग्राफ इंडेक्सिंग में एक या अधिक कॉल हैंडलर हैं, तो यह सिंक करना शुरू नहीं करेगा। सबग्राफ डेवलपर्स को इसके बजाय इवेंट हैंडलर्स का उपयोग करना चाहिए। ये कॉल हैंडलर्स की तुलना में कहीं अधिक प्रदर्शनकारी हैं, और प्रत्येक ईवीएम नेटवर्क पर समर्थित हैं।

### कॉल हैंडलर को परिभाषित करना

अपने मेनिफेस्ट में कॉल हैंडलर को परिभाषित करने के लिए, आप जिस डेटा स्रोत की सदस्यता लेना चाहते हैं, उसके तहत बस एक `callHandlers` सरणी जोड़ें।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`फ़ंक्शन` कॉल को फ़िल्टर करने के लिए सामान्यीकृत फ़ंक्शन सिग्नेचर है। `हैंडलर` गुण आपकी मैपिंग में उस फ़ंक्शन का नाम है जिसे आप तब निष्पादित करना चाहेंगे जब डेटा स्रोत अनुबंध में लक्ष्य फ़ंक्शन को कॉल किया जाता है।

### मानचित्रण समारोह

प्रत्येक कॉल हैंडलर एक पैरामीटर लेता है जिसमें कॉल किए गए फ़ंक्शन के नाम से संबंधित प्रकार होता है। उपरोक्त उदाहरण सबग्राफ में, मैपिंग में एक हैंडलर होता है जब `createGravatar` फ़ंक्शन को कॉल किया जाता है और `CreateGravatarCall` पैरामीटर को तर्क के रूप में प्राप्त होता है:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

The `handleCreateGravatar` function takes a new `CreateGravatarCall` which is a subclass of `ethereum.Call`, provided by `@graphprotocol/graph-ts`, that includes the typed inputs and outputs of the call. The `CreateGravatarCall` type is generated for you when you run `graph codegen`.

## ब्लॉक हैंडलर

Contract events या function calls की सदस्यता लेने के अलावा, एक subgraph अपने data को update करना चाह सकता है क्योंकि chain में नए blocks जोड़े जाते हैं। इसे प्राप्त करने के लिए एक subgraph every block के बाद या pre-defined filter से match होन वाले block के बाद एक function चला सकता है।

### समर्थित फ़िल्टर

#### कॉल फ़िल्टर

```yaml
filter:
  kind: call
```

_परिभाषित हैंडलर को प्रत्येक ब्लॉक के लिए एक बार कॉल किया जाएगा जिसमें अनुबंध (डेटा स्रोत) के लिए कॉल शामिल है जिसे हैंडलर के तहत परिभाषित किया गया है।_

> **ध्यान दें:** `कॉल` फ़िल्टर फ़िलहाल पैरिटी ट्रेसिंग API पर निर्भर करता है। बीएनबी चेन और आर्बिट्रम जैसे कुछ नेटवर्क इस एपीआई का समर्थन नहीं करते हैं। अगर इन नेटवर्कों में से किसी एक सबग्राफ इंडेक्सिंग में `कॉल` फिल्टर के साथ एक या अधिक ब्लॉक हैंडलर हैं, तो यह सिंक करना शुरू नहीं करेगा।

ब्लॉक हैंडलर के लिए फ़िल्टर की अनुपस्थिति सुनिश्चित करेगी कि हैंडलर को प्रत्येक ब्लॉक कहा जाता है। डेटा स्रोत में प्रत्येक फ़िल्टर प्रकार के लिए केवल एक ब्लॉक हैंडलर हो सकता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

#### मतदान फ़िल्टर

> **की आवश्यकता है `specVersion` >= 0.0.8**

> **Note:** Polling फ़िल्टर केवल `kind: ethereum` के dataSources पर उपलब्ध हैं।

```yaml
blockHandlers:
  - handler: handleBlock
    filter:
      kind: polling
      every: 10
```

परिभाषित handler हर `n` ब्लॉकों के लिए एक बार कॉल किया जाएगा, जहाँ `n` वह मान है जो `every` फ़ील्ड में प्रदान किया गया है। यह कॉन्फ़िगरेशन Subgraph को नियमित ब्लॉक अंतराल पर विशिष्ट संचालन करने की अनुमति देता है।

#### Once फ़िल्टर

> **की आवश्यकता है `specVersion` >= 0.0.8**

> **Note:** एक बार जब फ़िल्टर केवल `kind: ethereum` के डेटा स्रोतों पर उपलब्ध होते हैं।

```yaml
blockHandlers:
  - handler: handleOnce
    filter:
      kind: once
```

'once' फ़िल्टर के साथ परिभाषित हैंडलर केवल एक बार सभी अन्य हैंडलर्स चलने से पहले कॉल किया जाएगा। यह कॉन्फ़िगरेशन 'subgraph' को प्रारंभिक हैंडलर के रूप में उपयोग करने की अनुमति देता है, जिससे 'indexing' के शुरू होने पर विशिष्ट कार्य किए जा सकते हैं।

```ts
export function handleOnce(block: ethereum.Block): void {
  let data = new InitialData(Bytes.fromUTF8('initial'))
  data.data = 'Setup data here'
  data.save()
}
```

### मानचित्रण समारोह

'mapping' फ़ंक्शन एक `ethereum.Block` को केवल अपने एकमात्र तर्क के रूप में प्राप्त करेगा। घटनाओं के लिए 'mapping' फ़ंक्शनों की तरह, यह फ़ंक्शन स्टोर में मौजूदा Subgraph संस्थाओं तक पहुंच सकता है, स्मार्ट contract को कॉल कर सकता है और संस्थाओं को बना या अपडेट कर सकता है।

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## अनाम घटनाएँ

यदि आपको अनाम घटनाओं को सॉलिडिटी में संसाधित करने की आवश्यकता है, तो इसे घटना के विषय 0 प्रदान करके प्राप्त किया जा सकता है, जैसा कि उदाहरण में है:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

एक घटना तभी शुरू होगी जब दोनों हस्ताक्षर और विषय 0 मेल खाते हों। डिफ़ॉल्ट रूप से, `topic0` इवेंट सिग्नेचर के हैश के बराबर है।

## इवेंट हैंडलर में लेनदेन रसीदें

`specVersion` `0.0.5` और `apiVersion` `0.0.7` से शुरू होकर, ईवेंट हैंडलर्स के पास रसीद तक ​​पहुंच हो सकती है लेनदेन जो उन्हें उत्सर्जित करता है।

ऐसा करने के लिए, इवेंट हैंडलर को सबग्राफ मेनिफेस्ट में नई `receipt: true` कुंजी के साथ घोषित किया जाना चाहिए, जो वैकल्पिक है और डिफ़ॉल्ट रूप से गलत है।

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

हैंडलर फ़ंक्शन के अंदर, रसीद को `Event.receipt` फ़ील्ड में एक्सेस किया जा सकता है। जब `receipt` कुंजी को `गलत` पर सेट किया जाता है या मेनिफ़ेस्ट में छोड़ दिया जाता है, तो इसके बजाय एक `शून्य` मान लौटाया जाएगा।

## प्रायोगिक विशेषताएं

`specVersion` `0.0.4` से शुरू होकर, सबग्राफ सुविधाओं को `सुविधाओं` अनुभाग में मेनिफेस्ट फ़ाइल के शीर्ष स्तर पर उनके का उपयोग करके स्पष्ट रूप से घोषित किया जाना चाहिए `camelCase` नाम, जैसा कि नीचे दी गई तालिका में सूचीबद्ध है:

| विशेषता                                            | नाम              |
| -------------------------------------------------- | ---------------- |
| [गैर-घातक त्रुटियाँ](#non-fatal-errors)            | `nonFatalErrors` |
| [पूरा पाठ खोजें](#defining-fulltext-search-fields) | `fullTextSearch` |
| [ग्राफ्टिंग](#grafting-onto-existing-subgraphs)    | `grafting`       |

उदाहरण के लिए, यदि कोई सबग्राफ **पूर्ण-पाठ खोज** और **गैर-घातक त्रुटियां** सुविधाओं का उपयोग करता है, तो मेनिफेस्ट में `सुविधाएं` फ़ील्ड होना चाहिए:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

ध्यान दें कि किसी सुविधा को घोषित किए बिना उसका उपयोग करने से सबग्राफ परिनियोजन के दौरान **सत्यापन त्रुटि** उत्पन्न होगी, लेकिन यदि सुविधा घोषित की जाती है लेकिन उसका उपयोग नहीं किया जाता है, तो कोई त्रुटि उत्पन्न नहीं होगी.

### Timeseries और Aggregations

Timeseries और aggregations आपके subgraph को दैनिक औसत मूल्य, घंटेवारी कुल स्थानांतरण आदि जैसे आंकड़े ट्रैक करने में सक्षम बनाते हैं।

यह विशेषता दो नए प्रकार की 'subgraph' इकाई पेश करती है। 'Timeseries' इकाइयाँ डेटा बिंदुओं को समय की छाप के साथ रिकॉर्ड करती हैं। 'Aggregation' इकाइयाँ 'Timeseries' डेटा बिंदुओं पर पूर्व-घोषित गणनाएँ करती हैं, जो प्रति घंटे या प्रति दिन होती हैं, फिर परिणामों को GraphQL के माध्यम से आसान पहुँच के लिए संग्रहीत करती हैं।

#### उदाहरण स्कीमा

```graphql
type Data @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  price: BigDecimal!
}

type Stats @aggregation(intervals: ["hour", "day"], source: "Data") {
  id: Int8!
  timestamp: Timestamp!
  sum: BigDecimal! @aggregate(fn: "sum", arg: "price")
}
```

### टाइमसीरीज और एग्रीगेशन्स को परिभाषित करना

Timeseries entities को schema.graphql में `@entity(timeseries: true)` के साथ परिभाषित किया गया है। प्रत्येक timeseries entity के पास int8 प्रकार की एक अद्वितीय ID होनी चाहिए, एक Timestamp प्रकार का timestamp होना चाहिए, और डेटा शामिल करना चाहिए जिसका उपयोग aggregation entities द्वारा गणना के लिए किया जाएगा। ये Timeseries entities सामान्य ट्रिगर हैंडलर्स में सहेजे जा सकते हैं, और Aggregation entities के लिए “raw data” के रूप में कार्य करते हैं।

Aggregation entities को `@aggregation` का उपयोग करके schema.graphql में परिभाषित किया गया है। प्रत्येक aggregation entity स्रोत को परिभाषित करती है जिससे यह डेटा एकत्र करेगा (जो कि एक Timeseries entity होना चाहिए), इंटरवल सेट करती है (जैसे, घंटा, दिन), और वह aggregation फ़ंक्शन निर्दिष्ट करती है जिसका यह उपयोग करेगी (जैसे, sum, count, min, max, first, last)। Aggregation entities को निर्दिष्ट स्रोत के आधार पर आवश्यक इंटरवल के अंत में स्वचालित रूप से गणना की जाती है।

#### उपलब्ध Aggregation अंतराल

- `hour`: हर घंटे, पूरी घंटे पर टाइमसीरीज अवधि सेट करता है।
- `day`: हर दिन का समय श्रृंखला अवधि सेट करता है, 00:00 पर शुरू और समाप्त होता है।

#### उपलब्ध Aggregation फ़ंक्शन

- `sum`: सभी मानों का कुल।
- `count`: मानों की संख्या।
- `min`: न्यूनतम मान।
- `max`: अधिकतम मान।
- `first`: इस अवधि में पहला मान।
- `last`: अवधि में अंतिम मान।

#### उदाहरण Aggregations queries

```graphql
{
  stats(interval: "hour", where: { timestamp_gt: 1704085200 }) {
    id
    timestamp
    sum
  }
}
```

नोट:

Timeseries और Aggregations का उपयोग करने के लिए, एक subgraph का spec version ≥1.1.0 होना चाहिए। ध्यान दें कि यह सुविधा महत्वपूर्ण परिवर्तनों का सामना कर सकती है जो पीछे की संगतता को प्रभावित कर सकती है।

[Read more](https://github.com/graphprotocol/graph-node/blob/master/docs/aggregations.md) Timeseries और Aggregations के बारे में.

### गैर-घातक त्रुटियाँ

पहले से सिंक किए गए सबग्राफ पर इंडेक्सिंग त्रुटियां, डिफ़ॉल्ट रूप से, सबग्राफ को विफल कर देंगी और सिंक करना बंद कर देंगी। सबग्राफ को वैकल्पिक रूप से त्रुटियों की उपस्थिति में समन्वयन जारी रखने के लिए कॉन्फ़िगर किया जा सकता है, हैंडलर द्वारा किए गए परिवर्तनों को अनदेखा करके त्रुटि उत्पन्न हुई। यह सबग्राफ लेखकों को अपने सबग्राफ को ठीक करने का समय देता है, जबकि नवीनतम ब्लॉक के विरुद्ध प्रश्नों को जारी रखा जाता है, हालांकि त्रुटि के कारण बग के कारण परिणाम असंगत हो सकते हैं। ध्यान दें कि कुछ त्रुटियाँ अभी भी हमेशा घातक होती हैं। गैर-घातक होने के लिए, त्रुटि नियतात्मक होने के लिए जानी जानी चाहिए।

> **नोट:** ग्राफ़ नेटवर्क अभी तक गैर-घातक त्रुटियों का समर्थन नहीं करता है, और डेवलपर्स को स्टूडियो के माध्यम से नेटवर्क पर उस कार्यक्षमता का उपयोग करके सबग्राफ तैनात नहीं करना चाहिए।

गैर-घातक त्रुटियों को सक्षम करने के लिए सबग्राफ मेनिफ़ेस्ट पर निम्न फ़ीचर फ़्लैग सेट करने की आवश्यकता होती है:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

क्वेरी को `subgraphError` तर्क के माध्यम से संभावित विसंगतियों वाले डेटा को क्वेरी करने के लिए भी ऑप्ट-इन करना चाहिए। यह जाँचने के लिए `_meta` को क्वेरी करने की भी सिफारिश की जाती है कि क्या सबग्राफ ने त्रुटियों को छोड़ दिया है, जैसा कि उदाहरण में दिया गया है:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

यदि सबग्राफ में कोई त्रुटि आती है, तो वह क्वेरी `"indexing_error"` संदेश के साथ डेटा और ग्राफ़कल त्रुटि दोनों वापस कर देगी, जैसा कि इस उदाहरण प्रतिक्रिया में है:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### मौजूदा सबग्राफ पर ग्राफ्टिंग

> **Note:** यह अनुशंसा नहीं की जाती है कि प्रारंभिक रूप से The Graph Network में अपग्रेड करते समय ग्राफ्टिंग का उपयोग करें। अधिक जानें [here](/cookbook/grafting/#important-note-on-grafting-when-upgrading-to-the-network)।

जब एक subgraph पहली बार तैनात किया जाता है, तो यह संबंधित श्रृंखला के उत्पत्ति ब्लॉक से घटनाओं को अनुक्रमित करना शुरू करता है (या उस `startBlock` पर जो प्रत्येक डेटा स्रोत के साथ परिभाषित किया गया है) कुछ परिस्थितियों में; एक मौजूदा subgraph के डेटा का पुनः उपयोग करना और एक बहुत बाद के ब्लॉक से अनुक्रमण शुरू करना फायदेमंद होता है। इस अनुक्रमण मोड को _Grafting_ कहा जाता है। Grafting, उदाहरण के लिए, विकास के दौरान सरल त्रुटियों को जल्दी से पार पाने या अस्थायी रूप से एक मौजूदा subgraph को फिर से कार्यरत करने के लिए उपयोगी है जब यह विफल हो गया हो।

जब `subgraph.yaml` में सबग्राफ मेनिफेस्ट में `graft` ब्लॉक होता है तो एक सबग्राफ को बेस सबग्राफ पर ग्राफ्ट किया जाता है:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

जब एक सबग्राफ जिसके मेनिफ़ेस्ट में `graft` ब्लॉक होता है, तैनात किया जाता है, तो ग्राफ़ नोड दिए गए `ब्लॉक` सहित `base` सबग्राफ़ के डेटा को कॉपी करेगा और उसके बाद उस ब्लॉक से नए सबग्राफ को अनुक्रमणित करना जारी रखें। बेस सबग्राफ लक्ष्य ग्राफ़ नोड उदाहरण पर मौजूद होना चाहिए और कम से कम दिए गए ब्लॉक तक अनुक्रमित होना चाहिए। इस प्रतिबंध के कारण, ग्राफ्टिंग का उपयोग केवल विकास के दौरान या किसी आपात स्थिति के दौरान समकक्ष गैर-ग्राफ्टेड सबग्राफ के उत्पादन में तेजी लाने के लिए किया जाना चाहिए।

क्योंकि आधार डेटा को अनुक्रमित करने के बजाय प्रतियों को ग्राफ्ट करना, स्क्रैच से अनुक्रमणित करने की तुलना में सबग्राफ को वांछित ब्लॉक में प्राप्त करना बहुत तेज है, हालांकि बहुत बड़े सबग्राफ के लिए प्रारंभिक डेटा कॉपी में अभी भी कई घंटे लग सकते हैं। जबकि ग्राफ्टेड सबग्राफ को इनिशियलाइज़ किया जा रहा है, ग्राफ़ नोड उन एंटिटी प्रकारों के बारे में जानकारी लॉग करेगा जो पहले ही कॉपी किए जा चुके हैं।

ग्राफ्टेड सबग्राफ एक ग्राफक्यूएल स्कीमा का उपयोग कर सकता है जो बेस सबग्राफ के समान नहीं है, लेकिन इसके साथ केवल संगत है। यह अपने आप में एक मान्य सबग्राफ स्कीमा होना चाहिए, लेकिन निम्नलिखित तरीकों से बेस सबग्राफ के स्कीमा से विचलित हो सकता है:

- यह इकाई प्रकार जोड़ता या हटाता है
- यह इकाई प्रकारों से विशेषताएँ निकालता है
- यह प्रभावहीन गुणों को इकाई प्रकारों में जोड़ता है|
- यह प्रभाव वाले गुणों को प्रभावहीन गुणों में बदल देता है|
- यह इनम्स में महत्व देता है|
- यह इंटरफेस जोड़ता या हटाता है|
- यह कि, किन इकाई प्रकारों के लिए इंटरफ़ेस लागू होगा, इसे बदल देता है|

> **[सुविधा प्रबंधन](#experimental-features):** `ग्राफ्टिंग` को `विशेषताओं` के अंतर्गत घोषित किया जाना चाहिए कोड सबग्राफ मेनिफेस्ट में।

## IPFS/Arweave फ़ाइल डेटा स्रोत

फाइल डेटा स्रोत एक नई subgraph कार्यक्षमता है जो indexing के दौरान ऑफ-चेन डेटा तक एक मजबूत, विस्तारित तरीके से पहुँच प्रदान करती है। फाइल डेटा स्रोत IPFS और Arweave से फ़ाइलें फ़ेच करने का समर्थन करते हैं।

> यह ऑफ-चेन डेटा के नियतात्मक अनुक्रमण के साथ-साथ स्वैच्छिक HTTP-स्रोत डेटा के संभावित परिचय के लिए आधार भी देता है।

### अवलोकन

"लाइन" में हैंडलर कार्यान्वयन के दौरान फ़ाइलों को लाने के बजाय, यह टेम्पलेट्स को पेश करता है जिन्हें एक दिए गए फ़ाइल पहचानकर्ता के लिए नए डेटा स्रोतों के रूप में उत्पन्न किया जा सकता है। ये नए डेटा स्रोत फ़ाइलों को लाते हैं, यदि वे असफल होते हैं तो पुनः प्रयास करते हैं, और जब फ़ाइल मिलती है तो एक समर्पित हैंडलर चलाते हैं।

यह [existing data source templates](/developing/creating-a-subgraph/#data-source-templates) के समान है, जिसका उपयोग नए श्रृंखला-आधारित डेटा स्रोतों को गतिशील रूप से बनाने के लिए किया जाता है।

> यह मौजूदा `ipfs.cat` API को प्रतिस्थापित करता है

### अपग्रेड गाइड

#### `ग्राफ़-टीएस` और `ग्राफ़-क्ली` अपडेट करें

फ़ाइल डेटा स्रोतों के लिए ग्राफ़-टीएस >=0.29.0 और ग्राफ़-क्ली >=0.33.1 की आवश्यकता होती है

#### एक नया इकाई प्रकार जोड़ें जो फ़ाइलें मिलने पर अपडेट किया जाएगा

फ़ाइल डेटा स्रोत श्रृंखला-आधारित संस्थाओं तक पहुँच या अद्यतन नहीं कर सकते हैं, लेकिन फ़ाइल विशिष्ट संस्थाओं को अद्यतन करना चाहिए।

इसका मतलब हो सकता है कि फ़ील्ड को मौजूदा इकाइयों से अलग-अलग इकाइयों में विभाजित करना, एक साथ जुड़े हुए।

मूल संयुक्त इकाई:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

नई, विभाजित इकाई:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

यदि पैरेंट इकाई और परिणामी फ़ाइल डेटा स्रोत इकाई के बीच संबंध 1:1 है, तो सबसे सरल पैटर्न मूल इकाई को लुकअप के रूप में IPFS CID का उपयोग करके परिणामी फ़ाइल इकाई से लिंक करना है। यदि आपको अपनी नई फ़ाइल-आधारित संस्थाओं को मॉडलिंग करने में कठिनाई हो रही है, तो डिस्कॉर्ड पर संपर्क करें!

> आप इन [nested filters](/querying/graphql-api/#example-for-nested-entity-filtering) का उपयोग करके इन nested entities के आधार पर माता-पिता की संस्थाओं को फ़िल्टर कर सकते हैं।

#### नया टेम्पलेटेड डेटा स्रोत जोड़ें जिसमें `kind: file/ipfs` या `kind: file/arweave` हो।

यह वह डेटा स्रोत है जो ब्याज की फ़ाइल की पहचान होने पर उत्पन्न होगा।

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> वर्तमान में `abis` की आवश्यकता है, हालांकि फ़ाइल डेटा स्रोतों के भीतर से अनुबंधों को कॉल करना संभव नहीं है

फाइल डेटा स्रोत को विशेष रूप से उन सभी एंटिटी प्रकारों का उल्लेख करना चाहिए जिनके साथ यह `entities` के तहत इंटरैक्ट करेगा। अधिक विवरण के लिए [limitations](#limitations) देखें।

#### फ़ाइलों को संसाधित करने के लिए एक नया हैंडलर बनाएँ

यह हैंडलर एक `Bytes` पैरामीटर स्वीकार करेगा, जो फ़ाइल की सामग्री होगी, जब यह पाई जाएगी, जिसे फिर संसाधित किया जा सकता है। यह अक्सर एक JSON फ़ाइल होगी, जिसे `graph-ts` हेल्पर्स के साथ संसाधित किया जा सकता है ([documentation](/developing/graph-ts/api/#json-api))।

पढ़ने योग्य स्ट्रिंग के रूप में फ़ाइल की CID को `dataSource` के माध्यम से निम्नानुसार एक्सेस किया जा सकता है:

```typescript
const cid = dataSource.stringParam()
```

उदाहरण हैंडलर:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### आवश्यक होने पर फ़ाइल डेटा स्रोत स्पॉन करें

अब आप चेन-आधारित हैंडलर के निष्पादन के दौरान फ़ाइल डेटा स्रोत बना सकते हैं:

- ऑटो-जेनरेट किए गए `टेम्पलेट्स` से टेम्प्लेट आयात करें
- एक मैपिंग के भीतर `TemplateName.create(cid: string)` को कॉल करें, जहाँ cid एक मान्य कंटेंट पहचानकर्ता है IPFS या Arweave के लिए।

IPFS के लिए, Graph Node [v0 और v1 सामग्री पहचानकर्ता](https://docs.ipfs.tech/concepts/content-addressing/) का समर्थन करता है, और सामग्री पहचानकर्ता जो निर्देशिकाओं के साथ होते हैं (जैसे `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`)।

Arweave के लिए, संस्करण 0.33.0 के अनुसार, Graph Node Arweave गेटवे से उनकी [transaction ID](https://docs.arweave.org/developers/arweave-node-server/http-api#transactions) के आधार पर संग्रहीत फ़ाइलें प्राप्त कर सकता है ([example file](https://bdxujjl5ev5eerd5ouhhs6o4kjrs4g6hqstzlci5pf6vhxezkgaa.arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA)). Arweave उन लेनदेन का समर्थन करता है जो Irys (पूर्व में Bundlr) के माध्यम से अपलोड किए गए हैं, और Graph Node भी [Irys manifests](https://docs.irys.xyz/overview/gateways#indexing) के आधार पर फ़ाइलें प्राप्त कर सकता है।

उदाहरण:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//This example code is for a Crypto coven subgraph. The above ipfs hash is a directory with token metadata for all crypto coven NFTs.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //This creates a path to the metadata for a single Crypto coven NFT. It concats the directory with "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

यह एक नया file data source बनाएगा, जो Graph Node के configured किए गए IPFS या Arweave endpoint का सर्वेक्षण करेगा, यदि यह नहीं मिलता है तो पुनः प्रयास करेगा। जब file मिल जाती है, तो file data source handler execute किया जाएगा।

यह उदाहरण CID का उपयोग पैरेंट `Token` इकाई और परिणामी `TokenMetadata` इकाई के बीच लुकअप के रूप में कर रहा है।

> पहले, यह वह बिंदु है जिस पर एक सबग्राफ डेवलपर फ़ाइल लाने के लिए `ipfs.cat(CID)` को कॉल करता था

बधाई हो, आप फ़ाइल डेटा स्रोतों का उपयोग कर रहे हैं!

#### अपने उप-अनुच्छेदों को तैनात करना

अब आप अपने सबग्राफ को किसी भी ग्राफ़ नोड >=v0.30.0-rc.0 पर `बना` और `तैनाती` कर सकते हैं।

#### परिसीमन

फ़ाइल डेटा स्रोत हैंडलर और संस्थाएँ अन्य सबग्राफ संस्थाओं से अलग हैं, यह सुनिश्चित करते हुए कि वे निष्पादित होने पर नियतात्मक हैं, और श्रृंखला-आधारित डेटा स्रोतों का कोई संदूषण सुनिश्चित नहीं करते हैं। विस्तार से:

- फ़ाइल डेटा स्रोतों द्वारा बनाई गई इकाइयाँ अपरिवर्तनीय हैं, और इन्हें अद्यतन नहीं किया जा सकता है
- फ़ाइल डेटा स्रोत हैंडलर अन्य फ़ाइल डेटा स्रोतों से संस्थाओं तक नहीं पहुँच सकते
- फ़ाइल डेटा स्रोतों से जुड़ी संस्थाओं को चेन-आधारित हैंडलर द्वारा एक्सेस नहीं किया जा सकता है

> हालांकि यह बाधा अधिकांश उपयोग-मामलों के लिए समस्याग्रस्त नहीं होनी चाहिए, यह कुछ के लिए जटिलता का परिचय दे सकती है। यदि आपको अपने फ़ाइल-आधारित डेटा को सबग्राफ में मॉडलिंग करने में समस्या आ रही है, तो कृपया डिस्कॉर्ड के माध्यम से संपर्क करें!

इसके अतिरिक्त, फ़ाइल डेटा स्रोत से डेटा स्रोत बनाना संभव नहीं है, चाहे वह ऑनचेन डेटा स्रोत हो या अन्य फ़ाइल डेटा स्रोत। भविष्य में यह प्रतिबंध हटाया जा सकता है।

#### सर्वोत्तम प्रथाएं

यदि आप NFT मेटाडेटा को संबंधित टोकन से लिंक कर रहे हैं, तो टोकन इकाई से मेटाडेटा इकाई को संदर्भित करने के लिए मेटाडेटा के IPFS हैश का उपयोग करें। एक आईडी के रूप में IPFS हैश का उपयोग करके मेटाडेटा इकाई को सहेजें।

आप [DataSource context](/developing/graph-ts/api/#entity-and-datasourcecontext) का उपयोग करते समय फ़ाइल डेटा स्रोत बनाने के लिए अतिरिक्त जानकारी पास कर सकते हैं जो फ़ाइल डेटा स्रोत हैंडलर के लिए उपलब्ध होगी।

यदि आपके पास ऐसे निकाय हैं जो कई बार रीफ़्रेश किए गए हैं, तो IPFS हैश & amp का उपयोग करके अद्वितीय फ़ाइल-आधारित निकाय बनाएँ; इकाई आईडी, और श्रृंखला-आधारित इकाई में एक व्युत्पन्न क्षेत्र का उपयोग करके उनका संदर्भ लें।

> हम ऊपर दिए गए सुझाव को बेहतर बनाने के लिए काम कर रहे हैं, इसलिए क्वेरी केवल "नवीनतम" संस्करण लौटाती हैं

#### ज्ञात समस्याएँ

फ़ाइल डेटा स्रोतों को वर्तमान में ABI की आवश्यकता है, भले ही ABI का उपयोग नहीं किया जाता है ([issue](https://github.com/graphprotocol/graph-cli/issues/961))। वर्कअराउंड किसी भी एबीआई को जोड़ना है।

फ़ाइल डेटा स्रोतों के हैंडलर उन फ़ाइलों में नहीं हो सकते हैं जो `eth_call` अनुबंध बाइंडिंग को आयात करती हैं, "unknown import: `ethereum::ethereum.call` has not been defined" के साथ विफल हो रहा है ([issue](https://github.com/graphprotocol/graph-node/issues/4309))। काम का चार्ट एक समर्पित फ़ाइल में फ़ाइल डेटा स्रोत हैंडलर बनाने के लिए है।

#### उदाहरण

[क्रिप्टो कॉवेन सबग्राफ माइग्रेशन](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### संदर्भ

[GIP फ़ाइल डेटा स्रोत](https://forum.thegraph.com/t/gip-file-data-sources/2721)
