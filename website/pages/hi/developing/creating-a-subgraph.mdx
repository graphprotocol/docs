---
title: सबग्राफ बनाना
---

एक सबग्राफ एक ब्लॉकचेन से डेटा निकालता है, इसे प्रोसेस करता है और इसे स्टोर करता है ताकि इसे ग्राफक्यूएल के माध्यम से आसानी से क्वेरी किया जा सके।

![एक सबग्राफ को परिभाषित करना](/img/defining-a-subgraph.png)

सबग्राफ की परिभाषा में कुछ फाइलें होती हैं:

- `subgraph.yaml`: एक YAML फ़ाइल जिसमें सबग्राफ मेनिफ़ेस्ट होता है

- `schema.graphql`: एक ग्राफक्यूएल स्कीमा जो परिभाषित करता है कि आपके सबग्राफ के लिए कौन सा डेटा संग्रहीत है, और इसे ग्राफक्यूएल के माध्यम से कैसे क्वेरी करें

- `AssemblyScript मैपिंग`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) कोड जो इवेंट डेटा से आपके स्कीमा में परिभाषित इकाइयों में अनुवाद करता है (उदाहरण के लिए `mapping.ts` इस ट्यूटोरियल में)

> ग्राफ़ के विकेन्द्रीकृत नेटवर्क पर अपने सबग्राफ का उपयोग करने के लिए, आपको [एक बनाना होगा एपीआई कुंजी](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key)। यह अनुशंसा की जाती है कि आप कम से कम [10,000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network) के साथ [सिग्नल जोड़ें](/network/curating/#how-to-signal)

मेनिफ़ेस्ट फ़ाइल की सामग्री के बारे में विस्तार से जाने से पहले, आपको [ग्राफ़ CLI](https://github.com/graphprotocol/graph-cli) इंस्टॉल करना होगा जिसे आपको बनाना होगा और एक सबग्राफ तैनात करें।

## . ग्राफ़ सीएलआई इनस्टॉल करें

ग्राफ़ सीएलआई जावास्क्रिप्ट में लिखा गया है, और इसका उपयोग करने के लिए आपको या तो `yarn` या `npm` स्थापित करना होगा; यह माना जाता है कि आपके पास निम्नलिखित में yarn है।

एक बार जब आपके पास `yarn` हो जाए, तो चलाकर ग्राफ़ सीएलआई स्थापित करें

**Yarn के साथ स्थापित करें:**

```bash
yarn global add @graphprotocol/graph-cli
```

**एनपीएम के साथ स्थापित करें:**

```bash
npm install -g @graphprotocol/graph-cli
```

एक बार इंस्टॉल हो जाने पर, `ग्राफ़ इनिट` कमांड का उपयोग मौजूदा अनुबंध से या किसी उदाहरण सबग्राफ से एक नया सबग्राफ प्रोजेक्ट सेट करने के लिए किया जा सकता है। `ग्राफ़ इनिट --प्रोडक्ट सबग्राफ़-स्टूडियो` पास करके सबग्राफ़ स्टूडियो पर सबग्राफ़ बनाने के लिए इस कमांड का इस्तेमाल किया जा सकता है। यदि आपके पास पहले से ही आपके पसंदीदा नेटवर्क पर एक स्मार्ट अनुबंध तैनात है, तो उस अनुबंध से एक नया सबग्राफ बूटस्ट्रैप करना आरंभ करने का एक अच्छा तरीका हो सकता है।

## एक मौजूदा कॉन्ट्रैक्ट से

निम्न आदेश एक सबग्राफ बनाता है जो मौजूदा अनुबंध की सभी घटनाओं को अनुक्रमित करता है। यह एथरस्कैन से अनुबंध एबीआई लाने का प्रयास करता है और स्थानीय फ़ाइल पथ का अनुरोध करने के लिए वापस आ जाता है। यदि कोई वैकल्पिक तर्क गायब है, तो यह आपको एक संवादात्मक रूप में ले जाता है।

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>` सबग्राफ स्टूडियो में आपके सबग्राफ की आईडी है, यह आपके सबग्राफ विवरण पृष्ठ पर पाया जा सकता है।

## एक उदाहरण सबग्राफ से

दूसरा मोड `graph init` सपोर्ट करता है, एक उदाहरण सबग्राफ से एक नया प्रोजेक्ट बना रहा है। निम्न आदेश यह करता है:

```sh
graph init --studio <SUBGRAPH_SLUG>
```

उदाहरण सबग्राफ दानी ग्रांट के ग्रेविटी अनुबंध पर आधारित है जो उपयोगकर्ता के अवतारों का प्रबंधन करता है और जब भी अवतार बनाए या अपडेट किए जाते हैं तो `NewGravatar` या `UpdateGravatar` ईवेंट उत्सर्जित करता है। सबग्राफ इन घटनाओं को ग्राफ़ नोड स्टोर में `Gravatar` संस्थाओं को लिखकर और सुनिश्चित करता है कि इन्हें घटनाओं के अनुसार अपडेट किया जाता है। निम्नलिखित खंड उन फाइलों पर जाएंगे जो इस उदाहरण के लिए सबग्राफ मेनिफेस्ट बनाते हैं।

## मौजूदा सबग्राफ में नए डेटा स्रोत जोड़ें

चूँकि `v0.31.0` `graph-cli` `graph add` कमांड के माध्यम से मौजूदा सबग्राफ में नए डेटा स्रोतों को जोड़ने का समर्थन करता है।

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Options:

      --abi <path>              Path to the contract ABI (default: download from Etherscan)
      --contract-name           Name of the contract (default: Contract)
      --merge-entities          Whether to merge entities with the same name (default: false)
      --network-file <path>     Networks config file path (default: "./networks.json")
```

<कोड>ऐड</कोड> कमांड एबीआई को एथरस्कैन से प्राप्त करेगा (जब तक `--abi` विकल्प के साथ एबीआई पथ निर्दिष्ट नहीं किया जाता है), और एक नया <कोड>डेटा स्रोत</कोड बनाएगा। > ठीक उसी तरह `graph init` कमांड एक `dataSource` `--from-contract` बनाता है, स्कीमा और मैपिंग को तदनुसार अपडेट करता है।

`--merge-entities` विकल्प यह बताता है कि डेवलपर `entity` और `event` नाम के विरोधों को कैसे हैंडल करना चाहता है:

- अगर `सही`: नए `dataSource` को मौजूदा `eventHandlers` & `इकाइयां`।
- अगर `गलत`: एक नई इकाई & ईवेंट हैंडलर को `${dataSourceName}{EventName}` के साथ बनाया जाना चाहिए।

संबंधित नेटवर्क के लिए `networks.json` को अनुबंध `पता` लिखा जाएगा।

> **ध्यान दें:** इंटरैक्टिव क्ली का उपयोग करते समय, `ग्राफ़ इनिट` को सफलतापूर्वक चलाने के बाद, आपको एक नया `डेटा स्रोत` जोड़ने के लिए कहा जाएगा ।

## द सबग्राफ मेनिफेस्ट

सबग्राफ मेनिफेस्ट `subgraph.yaml` आपके सबग्राफ इंडेक्स के स्मार्ट कॉन्ट्रैक्ट्स को परिभाषित करता है, इन कॉन्ट्रैक्ट्स से किन इवेंट्स पर ध्यान देना है, और इवेंट डेटा को उन संस्थाओं से कैसे मैप करना है जो ग्राफ़ नोड स्टोर करता है और क्वेरी करने की अनुमति देता है। सबग्राफ मेनिफ़ेस्ट के लिए पूर्ण विशिष्टता [यहां](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md) पाई जा सकती है।

उदाहरण के सबग्राफ के लिए `subgraph.yaml` है:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

मेनिफेस्ट के लिए अद्यतन करने के लिए महत्वपूर्ण प्रविष्टियां हैं:

- `विवरण`: सबग्राफ क्या है, इसका मानव-पठनीय विवरण। यह विवरण ग्राफ़ एक्सप्लोरर द्वारा प्रदर्शित किया जाता है जब सबग्राफ को होस्ट की गई सेवा में तैनात किया जाता है।

- `रिपॉजिटरी`: रिपॉजिटरी का URL जहां सबग्राफ मेनिफेस्ट पाया जा सकता है। यह द ग्राफ एक्सप्लोरर द्वारा भी प्रदर्शित किया गया है।

- `विशेषताएं`: सभी प्रयुक्त [विशेषता](#experimental-features) नामों की सूची।

- `dataSources.source`: स्मार्ट अनुबंध का पता सबग्राफ स्रोत, और उपयोग करने के लिए स्मार्ट अनुबंध का ABI। पता वैकल्पिक है; इसे छोड़ने से सभी अनुबंधों से मिलान करने वाले ईवेंट को अनुक्रमित करने की अनुमति मिलती है।

- `dataSources.source.startBlock`: उस ब्लॉक की वैकल्पिक संख्या जिससे डेटा स्रोत इंडेक्स करना शुरू करता है। ज्यादातर मामलों में, हम उस ब्लॉक का उपयोग करने का सुझाव देते हैं जिसमें अनुबंध बनाया गया था।

- `dataSources.mapping.entities`: वे निकाय जो डेटा स्रोत स्टोर को लिखते हैं। प्रत्येक इकाई के लिए स्कीमा को schema.graphql फ़ाइल में परिभाषित किया गया है।

- `dataSources.mapping.abis`: स्रोत अनुबंध के साथ-साथ मैपिंग के भीतर से आपके द्वारा इंटरैक्ट किए जाने वाले किसी भी अन्य स्मार्ट अनुबंध के लिए एक या अधिक नामित एबीआई फाइलें।

- `dataSources.mapping.eventHandlers`: उन स्मार्ट कॉन्ट्रैक्ट इवेंट्स को सूचीबद्ध करता है जिन पर यह सबग्राफ प्रतिक्रिया करता है और मैपिंग में हैंडलर—./src/mapping.ts उदाहरण में — जो इन इवेंट्स को स्टोर में संस्थाओं में बदल देता है।

- `dataSources.mapping.callHandlers`: उन स्मार्ट कॉन्ट्रैक्ट फ़ंक्शंस को सूचीबद्ध करता है जो इस सबग्राफ पर प्रतिक्रिया करता है और मैपिंग में हैंडलर जो इनपुट और आउटपुट को स्टोर में संस्थाओं में फ़ंक्शन कॉल में बदल देता है।

- `dataSources.mapping.blockHandlers`: उन ब्लॉक्स को सूचीबद्ध करता है जिन पर यह सबग्राफ प्रतिक्रिया करता है और मैपिंग में हैंडलर्स को तब चलाया जाता है जब ब्लॉक को चेन से जोड़ा जाता है। फ़िल्टर के बिना, प्रत्येक ब्लॉक में ब्लॉक हैंडलर चलाया जाएगा। हैंडलर में `kind: call` के साथ एक `फ़िल्टर` फ़ील्ड जोड़कर एक वैकल्पिक कॉल-फ़िल्टर प्रदान किया जा सकता है। यह केवल हैंडलर चलाएगा यदि ब्लॉक में डेटा स्रोत अनुबंध के लिए कम से कम एक कॉल हो।

एक सबग्राफ कई स्मार्ट कॉन्ट्रैक्ट्स से डेटा को इंडेक्स कर सकता है। प्रत्येक अनुबंध के लिए एक प्रविष्टि जोड़ें जिससे डेटा को `dataSources` सरणी में अनुक्रमित करने की आवश्यकता है।

निम्नलिखित प्रक्रिया का उपयोग करके एक ब्लॉक के भीतर डेटा स्रोत के लिए ट्रिगर्स का आदेश दिया गया है:

1. ईवेंट और कॉल ट्रिगर्स को पहले ब्लॉक के भीतर ट्रांजैक्शन इंडेक्स द्वारा ऑर्डर किया जाता है।
2. एक ही लेन-देन के भीतर ईवेंट और कॉल ट्रिगर्स को एक कन्वेंशन का उपयोग करके ऑर्डर किया जाता है: ईवेंट पहले ट्रिगर करता है फिर ट्रिगर्स को कॉल करता है, प्रत्येक प्रकार के ऑर्डर का सम्मान करते हुए उन्हें मेनिफेस्ट में परिभाषित किया जाता है।
3. ब्लॉक ट्रिगर इवेंट और कॉल ट्रिगर के बाद चलाए जाते हैं, जिस क्रम में उन्हें मेनिफेस्ट में परिभाषित किया गया है।

ये आदेश नियम परिवर्तन के अधीन हैं।

### एबीआई प्राप्त करना

एबीआई फाइल(फाइलों) को आपके अनुबंध(ओं) से मेल खाना चाहिए। ABI फ़ाइलें प्राप्त करने के कुछ तरीके हैं:

- यदि आप अपना खुद का प्रोजेक्ट बना रहे हैं, तो आपके पास अपने सबसे मौजूदा एबीआई तक पहुंच होने की संभावना है।
- यदि आप किसी सार्वजनिक परियोजना के लिए सबग्राफ बना रहे हैं, तो आप उस परियोजना को अपने कंप्यूटर पर डाउनलोड कर सकते हैं और [`truffle संकलन का उपयोग करके ABI प्राप्त कर सकते हैं `](https://truffleframework.com/docs/truffle/overview) या संकलित करने के लिए solc का उपयोग करना।
- आप ABI को [Etherscan](https://etherscan.io/) पर भी ढूंढ सकते हैं, लेकिन यह हमेशा विश्वसनीय नहीं होता, क्योंकि वहां अपलोड किया गया ABI पुराना हो सकता है। सुनिश्चित करें कि आपके पास सही ABI है, अन्यथा आपका सबग्राफ चलाना विफल हो जाएगा।

## ग्राफक्यूएल स्कीमा

आपके सबग्राफ का स्कीमा फ़ाइल `schema.graphql` में है। ग्राफ़िकल स्कीमा को ग्राफ़िकल इंटरफ़ेस परिभाषा भाषा का उपयोग करके परिभाषित किया गया है। यदि आपने कभी भी ग्राफ़क्यूएल स्कीमा नहीं लिखा है, तो यह अनुशंसा की जाती है कि आप इस प्राइमर को ग्राफ़िकल टाइप सिस्टम पर देखें। ग्राफक्यूएल स्कीमा के लिए संदर्भ दस्तावेज [ग्राफक्यूएल एपीआई](/querying/graphql-api) अनुभाग में पाया जा सकता है।

## संस्थाओं को परिभाषित करना

संस्थाओं को परिभाषित करने से पहले, एक कदम पीछे हटना और यह सोचना महत्वपूर्ण है कि आपका डेटा कैसे संरचित और लिंक किया गया है। सबग्राफ स्कीमा में परिभाषित डेटा मॉडल और सबग्राफ द्वारा अनुक्रमित संस्थाओं के खिलाफ सभी प्रश्न किए जाएंगे। इस वजह से, सबग्राफ स्कीमा को इस तरह से परिभाषित करना अच्छा होता है जो आपके डैप की जरूरतों से मेल खाता हो। घटनाओं या कार्यों के बजाय "डेटा वाली वस्तुओं" के रूप में संस्थाओं की कल्पना करना उपयोगी हो सकता है।

द ग्राफ़ के साथ, आप केवल `schema.graphql` में इकाई प्रकारों को परिभाषित करते हैं, और ग्राफ़ नोड उस इकाई प्रकार के एकल उदाहरणों और संग्रहों को क्वेरी करने के लिए शीर्ष स्तर के फ़ील्ड उत्पन्न करेगा। प्रत्येक प्रकार जो एक इकाई होना चाहिए उसे `@entity` निर्देश के साथ एनोटेट किया जाना आवश्यक है। डिफ़ॉल्ट रूप से, संस्थाएँ परिवर्तनशील होती हैं, जिसका अर्थ है कि मैपिंग मौजूदा संस्थाओं को लोड कर सकती है, उन्हें संशोधित कर सकती है और उस इकाई का एक नया संस्करण संग्रहीत कर सकती है। परिवर्तनशीलता एक मूल्य पर आती है, और इकाई प्रकारों के लिए जिनके लिए यह ज्ञात है कि उन्हें कभी भी संशोधित नहीं किया जाएगा, उदाहरण के लिए, क्योंकि उनमें केवल श्रृंखला से शब्दशः निकाले गए डेटा होते हैं, उन्हें `@entity के साथ अपरिवर्तनीय के रूप में चिह्नित करने की अनुशंसा की जाती है (अपरिवर्तनीय: सच)`। मैपिंग अपरिवर्तनीय संस्थाओं में तब तक परिवर्तन कर सकती है जब तक वे परिवर्तन उसी ब्लॉक में होते हैं जिसमें इकाई बनाई गई थी। अपरिवर्तनीय संस्थाएं लिखने और क्वेरी करने के लिए बहुत तेज़ हैं, और इसलिए जब भी संभव हो इसका उपयोग किया जाना चाहिए।

### अच्छा उदाहरण

नीचे दी गई `Gravatar` इकाई को Gravatar ऑब्जेक्ट के चारों ओर संरचित किया गया है और यह इस बात का एक अच्छा उदाहरण है कि किसी इकाई को कैसे परिभाषित किया जा सकता है।

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### खराब उदाहरण

The example `GravatarAccepted` and `GravatarDeclined` entities below are based around events. It is not recommended to map events or function calls to entities 1:1.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### वैकल्पिक और आवश्यक फ़ील्ड

इकाई क्षेत्रों को आवश्यक या वैकल्पिक के रूप में परिभाषित किया जा सकता है। स्कीमा में आवश्यक फ़ील्ड `!` द्वारा दर्शाए गए हैं। यदि मैपिंग में कोई आवश्यक फ़ील्ड सेट नहीं है, तो फ़ील्ड की क्वेरी करते समय आपको यह त्रुटि प्राप्त होगी:

```
गैर-शून्य फ़ील्ड 'नाम' के लिए हल किया गया शून्य मान
```

प्रत्येक इकाई में एक `आईडी` फ़ील्ड होना चाहिए, जो कि `बाइट्स!` या `स्ट्रिंग!` प्रकार का होना चाहिए। आमतौर पर `बाइट्स!` का उपयोग करने की सिफारिश की जाती है, जब तक कि `आईडी` में मानव-पठनीय पाठ न हो, चूंकि `बाइट्स!` आईडी वाली इकाइयां लिखने में तेज़ होंगी और `स्ट्रिंग!` `id` वाले प्रश्नों के रूप में। `id` फ़ील्ड प्राथमिक कुंजी के रूप में कार्य करता है, और एक ही प्रकार की सभी संस्थाओं के बीच अद्वितीय होना चाहिए। ऐतिहासिक कारणों से, प्रकार `ID!` को भी स्वीकार किया जाता है और यह `स्ट्रिंग!` का पर्यायवाची है।

कुछ इकाई प्रकारों के लिए `id` का निर्माण दो अन्य संस्थाओं की आईडी से किया जाता है; यह `concat` का उपयोग करके संभव है, उदाहरण के लिए, `let id = left.id.concat(right.id)` `left` की आईडी से आईडी बनाने के लिए और `दाएं`। इसी तरह, एक मौजूदा इकाई की आईडी से एक आईडी बनाने के लिए और एक काउंटर `गिनती`, `let id = left.id.concatI32(count)` का उपयोग किया जा सकता है। जब तक `बाएं` की लंबाई ऐसी सभी संस्थाओं के लिए समान है, उदाहरण के लिए, क्योंकि `left.id` एक `पता है, तब तक विशिष्ट आईडी बनाने के लिए संयोजन की गारंटी दी जाती है`।

### बिल्ट-इन स्केलर प्रकार

#### ग्राफक्यूएल समर्थित स्केलर्स

हम अपने ग्राफक्यूएल एपीआई में निम्नलिखित स्केलर्स का समर्थन करते हैं:

| प्रकार       | विवरण                                                                                                                                                                                                        |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Bytes`      | बाइट सरणी, एक हेक्साडेसिमल स्ट्रिंग के रूप में दर्शाया गया है। आमतौर पर एथेरियम हैश और पतों के लिए उपयोग किया जाता है।                                                                                       |
| `String`     | `स्ट्रिंग` मानों के लिए स्केलर। अशक्त वर्ण समर्थित नहीं हैं और स्वचालित रूप से हटा दिए जाते हैं।                                                                                                             |
| `Boolean`    | `boolean` मानों के लिए स्केलर।                                                                                                                                                                               |
| `Int`        | ग्राफक्लाइन स्पेक `Int` को 32 बाइट्स के आकार के रूप में परिभाषित करता है।                                                                                                                                    |
| `BigInt`     | बड़े पूर्णांक। एथेरियम के `uint32`, `int64`, `uint64`, ..., `uint256` प्रकारों के लिए उपयोग किया जाता है। नोट: `uint32` के नीचे सब कुछ, जैसे `int32`, `uint24` या `int8` को `i32` के रूप में दर्शाया गया है। |
| `BigDecimal` | `BigDecimal` उच्च परिशुद्धता दशमलव एक महत्व और एक प्रतिपादक के रूप में दर्शाया गया है। एक्सपोनेंट रेंज -6143 से +6144 तक है। 34 महत्वपूर्ण अंकों तक गोल।                                                     |

#### Enums

आप स्कीमा के भीतर एनम भी बना सकते हैं। Enums में निम्न सिंटैक्स होता है:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

स्कीमा में एक बार एनम परिभाषित हो जाने के बाद, आप किसी इकाई पर एनम फ़ील्ड सेट करने के लिए एनम मान के स्ट्रिंग प्रतिनिधित्व का उपयोग कर सकते हैं। उदाहरण के लिए, आप पहले अपनी इकाई को परिभाषित करके और बाद में `entity.tokenStatus = "SecondOwner"` के साथ फ़ील्ड सेट करके `tokenStatus` को `SecondOwner` पर सेट कर सकते हैं। नीचे दिया गया उदाहरण दर्शाता है कि एनम फील्ड के साथ टोकन इकाई कैसी दिखेगी:

एनम लिखने के बारे में अधिक विवरण [GraphQL प्रलेखन](https://graphql.org/learn/schema/) में पाया जा सकता है।

#### निकाय संबंध

एक इकाई का आपकी स्कीमा में एक या अधिक अन्य संस्थाओं से संबंध हो सकता है। आपके प्रश्नों में इन संबंधों का पता लगाया जा सकता है। ग्राफ़ में रिश्ते यूनिडायरेक्शनल हैं। रिश्ते के किसी भी "अंत" पर एक यूनिडायरेक्शनल रिश्ते को परिभाषित करके द्विपक्षीय संबंधों को अनुकरण करना संभव है।

संस्थाओं पर संबंधों को किसी अन्य क्षेत्र की तरह ही परिभाषित किया जाता है सिवाय इसके कि निर्दिष्ट प्रकार किसी अन्य इकाई का है।

#### एक-से-एक संबंध

`TransactionReceipt` इकाई प्रकार के साथ एक वैकल्पिक एक-से-एक संबंध के साथ एक `लेन-देन` इकाई प्रकार परिभाषित करें:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### एक से कई रिश्ते

टोकन निकाय प्रकार के साथ आवश्यक वन-टू-मैनी संबंध के साथ `TokenBalance` निकाय प्रकार परिभाषित करें:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### रिवर्स लुकअप

उल्टे लुकअप को किसी इकाई पर `@derivedFrom` फ़ील्ड के माध्यम से परिभाषित किया जा सकता है। यह इकाई पर एक आभासी क्षेत्र बनाता है जिसे क्वेरी किया जा सकता है लेकिन मैपिंग एपीआई के माध्यम से मैन्युअल रूप से सेट नहीं किया जा सकता है। बल्कि, यह दूसरे निकाय पर परिभाषित संबंध से प्राप्त होता है। इस तरह के रिश्तों के लिए, रिश्ते के दोनों पक्षों को स्टोर करने के लिए यह शायद ही कभी समझ में आता है, और इंडेक्सिंग और क्वेरी प्रदर्शन दोनों बेहतर होंगे जब केवल एक पक्ष संग्रहीत किया जाता है और दूसरा व्युत्पन्न होता है।

एक-से-अनेक संबंधों के लिए, संबंध को हमेशा 'एक' पक्ष में संग्रहीत किया जाना चाहिए, और 'अनेक' पक्ष हमेशा निकाला जाना चाहिए। संबंधों को इस तरह से संग्रहीत करने के बजाय, 'अनेक' पक्ष पर संस्थाओं की एक सरणी संग्रहीत करने के परिणामस्वरूप, सबग्राफ को अनुक्रमित करने और क्वेरी करने दोनों के लिए नाटकीय रूप से बेहतर प्रदर्शन होगा। सामान्य तौर पर, संस्थाओं की सरणियों को संग्रहीत करने से जितना संभव हो उतना बचा जाना चाहिए।

#### उदाहरण

`tokenBalances` फ़ील्ड प्राप्त करके हम टोकन से टोकन के लिए शेष राशि को सुलभ बना सकते हैं:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### अनेक-से-अनेक संबंध

मैनी-टू-मैनी संबंधों के लिए, जैसे कि प्रत्येक उपयोगकर्ता किसी भी संख्या में संगठनों से संबंधित हो सकता है, सबसे सरल, लेकिन आम तौर पर सबसे अधिक प्रदर्शनकारी नहीं, संबंध को मॉडल करने का तरीका शामिल दो संस्थाओं में से प्रत्येक में एक सरणी के रूप में है। यदि संबंध सममित है, तो संबंध के केवल एक पक्ष को संग्रहित करने की आवश्यकता है और दूसरे पक्ष को व्युत्पन्न किया जा सकता है।

#### उदाहरण

<कोड>उपयोगकर्ता</कोड> निकाय प्रकार से <कोड>संगठन</कोड> निकाय प्रकार में रिवर्स लुकअप परिभाषित करें. नीचे दिए गए उदाहरण में, यह `संगठन` इकाई के भीतर `सदस्यों` विशेषता को देखकर प्राप्त किया जाता है। क्वेरीज़ में, `संगठन` फ़ील्ड `उपयोगकर्ता` पर उन सभी `संगठन` संस्थाओं को खोजकर हल किया जाएगा जिनमें उपयोगकर्ता की आईडी शामिल है।

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

इस संबंध को संग्रहीत करने का एक अधिक प्रभावशाली तरीका एक मैपिंग टेबल के माध्यम से है जिसमें प्रत्येक `उपयोगकर्ता` / `संगठन` जोड़ी के लिए स्कीमा के साथ एक प्रविष्टि है

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

इस दृष्टिकोण के लिए आवश्यक है कि प्रश्नों को पुनः प्राप्त करने के लिए एक अतिरिक्त स्तर में उतरना पड़े, उदाहरण के लिए, उपयोगकर्ताओं के लिए संगठन:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

मैनी-टू-मैनी संबंधों को संग्रहीत करने के इस अधिक विस्तृत तरीके के परिणामस्वरूप सबग्राफ के लिए कम डेटा संग्रहीत होगा, और इसलिए एक सबग्राफ के लिए जो अक्सर इंडेक्स और क्वेरी के लिए नाटकीय रूप से तेज़ होता है।

#### स्कीमा में टिप्पणियां जोड़ना

रेखांकन विनिर्देश के अनुसार, डबल कोटेशन `""` का उपयोग करके स्कीमा इकाई विशेषताओं के ऊपर टिप्पणियाँ जोड़ी जा सकती हैं। यह नीचे दिए गए उदाहरण में दिखाया गया है:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## फुलटेक्स्ट सर्च फील्ड्स को परिभाषित करना

पूर्ण पाठ खोज क्वेरी फ़िल्टर करती है और पाठ खोज इनपुट के आधार पर संस्थाओं को रैंक करती है। अनुक्रमित टेक्स्ट डेटा से तुलना करने से पहले क्वेरी टेक्स्ट इनपुट को तने में संसाधित करके पूर्ण टेक्स्ट क्वेरी समान शब्दों के लिए मैच वापस करने में सक्षम हैं।

एक पूर्ण पाठ क्वेरी परिभाषा में क्वेरी का नाम, पाठ फ़ील्ड को संसाधित करने के लिए उपयोग किया जाने वाला भाषा शब्दकोश, परिणामों को क्रमबद्ध करने के लिए उपयोग किया जाने वाला रैंकिंग एल्गोरिदम और खोज में शामिल फ़ील्ड शामिल हैं। प्रत्येक पूर्ण-पाठ क्वेरी में कई फ़ील्ड शामिल हो सकते हैं, लेकिन सभी शामिल फ़ील्ड एक इकाई प्रकार से होने चाहिए।

फुलटेक्स्ट क्वेरी जोड़ने के लिए, ग्राफक्यूएल स्कीमा में एक `_Schema_` टाइप को फुलटेक्स्ट डायरेक्टिव के साथ शामिल करें।

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

`नाम`, `विवरण</0 में टेक्स्ट दस्तावेज़ों के आधार पर <code>बैंड` इकाइयों को फ़िल्टर करने के लिए उदाहरण `बैंडसर्च` फ़ील्ड का उपयोग प्रश्नों में किया जा सकता है >, और `जैव` फ़ील्ड। पूर्ण पाठ खोज API और अधिक उदाहरण उपयोग के विवरण के लिए [GraphQL API - क्वेरीज़](/querying/graphql-api#queries) पर जायें।

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[सुविधा प्रबंधन](#experimental-features):** `specVersion` `0.0.4</code से > और आगे, <code>fullTextSearch` को सबग्राफ मेनिफेस्ट में `फीचर्स` सेक्शन के तहत घोषित किया जाना चाहिए।

### भाषाओं का समर्थन किया

एक अलग भाषा का चयन एक निश्चित, हालांकि कभी-कभी सूक्ष्म, पूर्ण पाठ खोज एपीआई पर प्रभाव डालेगा। पूर्ण-पाठ क्वेरी फ़ील्ड द्वारा कवर किए गए फ़ील्ड को चुनी हुई भाषा के संदर्भ में जांचा जाता है, इसलिए विश्लेषण और खोज क्वेरी द्वारा उत्पन्न शब्दांश भाषा से भाषा में भिन्न होते हैं। उदाहरण के लिए: समर्थित तुर्की शब्दकोश "टोकन" का उपयोग करते समय "टोकन" के लिए स्टेम किया जाता है, जबकि निश्चित रूप से, अंग्रेजी शब्दकोश इसे "टोकन" के लिए स्टेम करेगा।

समर्थित भाषा शब्दकोश:

| कोड    | शब्दकोष    |
| ------ | ---------- |
| simple | आम         |
| da     | डेनिश      |
| nl     | डच         |
| en     | अंग्रेज़ी  |
| fi     | फिनिश      |
| fr     | फ्रेंच     |
| de     | जर्मन      |
| hu     | हंगेरी     |
| it     | इतालवी     |
| no     | नार्वेजियन |
| pt     | पुर्तगाली  |
| ro     | रोमानियाई  |
| ru     | रूसी       |
| es     | स्पैनिश    |
| sv     | स्वीडिश    |
| tr     | तुर्की     |

### रैंकिंग एल्गोरिदम

परिणाम ऑर्डर करने के लिए समर्थित एल्गोरिदम:

| एल्गोरिदम     | विवरण                                                                                     |
| ------------- | ----------------------------------------------------------------------------------------- |
| rank          | परिणामों को व्यवस्थित करने के लिए पूर्ण पाठ क्वेरी की मिलान गुणवत्ता (0-1) का उपयोग करें। |
| proximityRank | रैंक के समान लेकिन इसमें मैचों की निकटता भी शामिल है।                                     |

## मैपिंग लिखना

मैपिंग एक विशेष स्रोत से डेटा लेती है और इसे उन संस्थाओं में बदल देती है जो आपके स्कीमा के भीतर परिभाषित हैं। मैपिंग को [टाइपस्क्रिप्ट](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) के उपसमुच्चय में लिखा जाता है जिसे [असेंबलीस्क्रिप्ट](https://github.com/AssemblyScript/assemblyscript/wiki) कहा जाता है जिसे WASM ([WebAssembly](https://webassembly.org/)) में संकलित किया जा सकता है। असेंबलीस्क्रिप्ट सामान्य टाइपस्क्रिप्ट की तुलना में सख्त है, फिर भी एक परिचित सिंटैक्स प्रदान करता है।

प्रत्येक ईवेंट हैंडलर के लिए जो `subgraph.yaml` `mapping.eventHandlers` के अंतर्गत परिभाषित है, उसी नाम का एक निर्यातित फ़ंक्शन बनाएं। प्रत्येक हैंडलर को `event` नामक एकल पैरामीटर को उस ईवेंट के नाम के अनुरूप एक प्रकार के साथ स्वीकार करना होगा जिसे संभाला जा रहा है।

उदाहरण के सबग्राफ में, `src/mapping.ts` में `NewGravatar` और `UpdatedGravatar` ईवेंट के लिए हैंडलर शामिल हैं:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

पहला हैंडलर `NewGravatar` ईवेंट लेता है और `new Gravatar(event.params.id.toHex())` के साथ एक नया `Gravatar` इकाई बनाता है, जो पॉप्युलेट करता है संबंधित ईवेंट पैरामीटर का उपयोग करके निकाय फ़ील्ड. इस इकाई उदाहरण को `event.params.id.toHex()` के आईडी मान के साथ वेरिएबल `gravatar` द्वारा दर्शाया गया है।

दूसरा हैंडलर ग्राफ़ नोड स्टोर से मौजूदा `Gravatar` को लोड करने का प्रयास करता है। यदि यह अभी तक मौजूद नहीं है, तो इसे ऑन-डिमांड बनाया गया है। इसके बाद इकाई को `gravatar.save()` का उपयोग करके स्टोर में वापस सहेजे जाने से पहले नए ईवेंट पैरामीटर से मेल खाने के लिए अपडेट किया जाता है।

### नई संस्थाओं को बनाने के लिए अनुशंसित आईडी

प्रत्येक इकाई के पास एक `id` होना चाहिए जो एक ही प्रकार की सभी संस्थाओं के बीच अद्वितीय हो। किसी इकाई का `आईडी` मान तब सेट किया जाता है जब इकाई बनाई जाती है। नीचे कुछ सुझाए गए `आईडी` मान दिए गए हैं जिन पर नई इकाइयां बनाते समय विचार किया जाना चाहिए। नोट: `आईडी` का मान एक `स्ट्रिंग` होना चाहिए।

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

हम [ग्राफ़ टाइपस्क्रिप्ट लाइब्रेरी](https://github.com/graphprotocol/graph-ts) प्रदान करते हैं जिसमें ग्राफ़ नोड स्टोर के साथ सहभागिता करने के लिए उपयोगिताएँ और स्मार्ट अनुबंध डेटा और संस्थाओं को संभालने की सुविधा शामिल है। आप `mapping.ts` में `@graphprotocol/graph-ts` आयात करके अपने मैपिंग में इस लाइब्रेरी का उपयोग कर सकते हैं।

## कोड जनरेशन

स्मार्ट कॉन्ट्रैक्ट्स, इवेंट्स और एंटिटीज के साथ काम करना आसान और टाइप-सेफ बनाने के लिए, ग्राफ सीएलआई सबग्राफ के ग्राफक्यूएल स्कीमा और डेटा स्रोतों में शामिल कॉन्ट्रैक्ट एबीआई से असेंबलीस्क्रिप्ट प्रकार उत्पन्न कर सकता है।

इसके साथ किया जाता है

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

लेकिन ज्यादातर मामलों में, सबग्राफ पहले से ही `package.json` के माध्यम से पूर्व-कॉन्फ़िगर किए जाते हैं ताकि आप इसे प्राप्त करने के लिए निम्न में से किसी एक को चला सकें:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

यह `subgraph.yaml` में वर्णित एबीआई फाइलों में प्रत्येक स्मार्ट अनुबंध के लिए एक असेंबलीस्क्रिप्ट क्लास उत्पन्न करेगा, जिससे आप इन अनुबंधों को मैपिंग में विशिष्ट पतों से बाँध सकते हैं और ब्लॉक होने के खिलाफ केवल-पढ़ने वाली अनुबंध विधियों को कॉल कर सकते हैं। संसाधित। यह प्रत्येक अनुबंध घटना के लिए एक वर्ग भी उत्पन्न करेगा, जो घटना के मापदंडों तक आसान पहुँच प्रदान करेगा, साथ ही ब्लॉक और लेन-देन की घटना से उत्पन्न हुआ। ये सभी प्रकार `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts` को लिखे जाते हैं। उदाहरण के सबग्राफ में, यह `उत्पन्न/ग्रेविटी/ग्रेविटी.टीएस` होगा, जिससे मैपिंग को इन प्रकारों को आयात करने की अनुमति मिलेगी।

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

इसके अलावा, सबग्राफ के ग्राफक्यूएल स्कीमा में प्रत्येक इकाई प्रकार के लिए एक वर्ग उत्पन्न होता है। ये क्लासेस टाइप-सेफ एंटिटी लोडिंग, एंटिटी फील्ड्स तक रीड और राइट एक्सेस के साथ-साथ स्टोर करने के लिए एंटिटीज लिखने के लिए `save()` मेथड मुहैया कराती हैं। सभी निकाय वर्ग `<OUTPUT_DIR>/schema.ts` पर लिखे गए हैं, जिससे मैपिंग उन्हें आयात करने की अनुमति देती है

```javascript
import { Gravatar } from '../generated/schema'
```

> **ध्यान दें:** मेनिफेस्ट में शामिल ग्राफ़क्यूएल स्कीमा या एबीआई में हर बदलाव के बाद कोड जेनरेशन फिर से किया जाना चाहिए। सबग्राफ बनाने या तैनात करने से पहले इसे कम से कम एक बार अवश्य किया जाना चाहिए।

कोड जेनरेशन `src/mapping.ts` में आपके मैपिंग कोड की जांच नहीं करता है। यदि आप यह जांचना चाहते हैं कि अपने सबग्राफ को ग्राफ़ एक्सप्लोरर में तैनात करने का प्रयास करने से पहले, आप यार्न बिल्ड चला सकते हैं और किसी भी सिंटैक्स त्रुटियों को ठीक कर सकते हैं जो टाइपस्क्रिप्ट कंपाइलर को मिल सकती है।

## डेटा स्रोत टेम्पलेट्स

ईवीएम-संगत स्मार्ट अनुबंधों में एक सामान्य पैटर्न रजिस्ट्री या फ़ैक्टरी अनुबंधों का उपयोग होता है, जहां एक अनुबंध अन्य अनुबंधों की मनमानी संख्या का निर्माण, प्रबंधन या संदर्भ करता है, जिनमें से प्रत्येक का अपना राज्य और ईवेंट होता है।

इन उप-अनुबंधों के पते पहले से ज्ञात हो सकते हैं या नहीं भी हो सकते हैं और इनमें से कई अनुबंध समय के साथ बनाए और/या जोड़े जा सकते हैं। यही कारण है कि, ऐसे मामलों में, एक डेटा स्रोत या डेटा स्रोतों की एक निश्चित संख्या को परिभाषित करना असंभव है और अधिक गतिशील दृष्टिकोण की आवश्यकता है: _डेटा स्रोत टेम्पलेट्स_।

### मुख्य अनुबंध के लिए डेटा स्रोत

सबसे पहले, आप मुख्य अनुबंध के लिए एक नियमित डेटा स्रोत परिभाषित करते हैं। नीचे दिया गया स्निपेट [Uniswap](https://uniswap.org) एक्सचेंज फैक्ट्री अनुबंध के लिए एक सरलीकृत उदाहरण डेटा स्रोत दिखाता है। `NewExchange(address,address)` ईवेंट हैंडलर पर ध्यान दें। यह तब उत्सर्जित होता है जब फ़ैक्टरी अनुबंध द्वारा एक नया एक्सचेंज अनुबंध ऑन-चेन बनाया जाता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### गतिशील रूप से बनाए गए अनुबंधों के लिए डेटा स्रोत टेम्प्लेट

फिर, आप मेनिफेस्ट में _डेटा स्रोत टेम्प्लेट_ जोड़ते हैं। ये नियमित डेटा स्रोतों के समान हैं, सिवाय इसके कि उनमें <कोड>स्रोत</कोड> के तहत पूर्व-निर्धारित अनुबंध पता नहीं है। आमतौर पर, आप पैरेंट अनुबंध द्वारा प्रबंधित या संदर्भित प्रत्येक प्रकार के उप-अनुबंध के लिए एक टेम्प्लेट परिभाषित करेंगे।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### डेटा स्रोत टेम्प्लेट को इंस्टेंट करना

अंतिम चरण में, आप किसी एक टेम्प्लेट से डायनेमिक डेटा स्रोत इंस्टेंस बनाने के लिए अपनी मुख्य अनुबंध मैपिंग को अपडेट करते हैं। इस उदाहरण में, आप `Exchange` टेम्पलेट को इम्पोर्ट करने के लिए मुख्य कॉन्ट्रैक्ट मैपिंग को बदलेंगे और नए एक्सचेंज कॉन्ट्रैक्ट को इंडेक्स करना शुरू करने के लिए उस पर `Exchange.create(address)` मेथड को कॉल करेंगे।

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **ध्यान दें:** एक नया डेटा स्रोत केवल उस ब्लॉक के लिए कॉल और ईवेंट को प्रोसेस करेगा जिसमें इसे बनाया गया था और सभी बाद के ब्लॉक, लेकिन ऐतिहासिक डेटा, यानी डेटा को प्रोसेस नहीं करेगा जो पिछले ब्लॉकों में निहित है।
> 
> यदि पिछले ब्लॉक में नए डेटा स्रोत के लिए प्रासंगिक डेटा है, तो उस डेटा को अनुबंध की वर्तमान स्थिति को पढ़कर और नए डेटा स्रोत के निर्माण के समय उस स्थिति का प्रतिनिधित्व करने वाली संस्थाओं का निर्माण करना सबसे अच्छा है।

### डेटा स्रोत प्रसंग

डेटा स्रोत संदर्भ किसी टेम्प्लेट को इंस्टेंट करते समय अतिरिक्त कॉन्फ़िगरेशन पास करने की अनुमति देते हैं। हमारे उदाहरण में, मान लें कि एक्सचेंज एक विशेष ट्रेडिंग जोड़ी से जुड़े हैं, जो `NewExchange` इवेंट में शामिल है। उस जानकारी को तात्कालिक डेटा स्रोत में पास किया जा सकता है, जैसे:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

`Exchange` टेम्प्लेट की मैपिंग के अंदर, संदर्भ तक पहुँचा जा सकता है:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

सभी प्रकार के मूल्य के लिए `setString` और `getString` जैसे सेटर्स और गेटर्स हैं।

## Start Blocks

`StartBlock` एक वैकल्पिक सेटिंग है जो आपको यह परिभाषित करने की अनुमति देती है कि श्रृंखला में किस ब्लॉक से डेटा स्रोत अनुक्रमण शुरू करेगा। स्टार्ट ब्लॉक सेट करने से डेटा स्रोत संभावित रूप से अप्रासंगिक लाखों ब्लॉक को छोड़ देता है। आमतौर पर, एक सबग्राफ डेवलपर `स्टार्टब्लॉक` को उस ब्लॉक पर सेट करेगा जिसमें डेटा स्रोत का स्मार्ट अनुबंध बनाया गया था।

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **ध्यान दें:** इथरस्कैन पर अनुबंध निर्माण ब्लॉक को जल्दी से देखा जा सकता है:
> 
> 1. खोज बार में उसका पता दर्ज करके अनुबंध की खोज करें।
> 2. `अनुबंध निर्माता` अनुभाग में निर्माण लेनदेन हैश पर क्लिक करें।
> 3. लेन-देन विवरण पृष्ठ लोड करें जहां आपको उस अनुबंध के लिए प्रारंभ ब्लॉक मिलेगा।

## कॉल हैंडलर्स

जबकि घटनाएँ एक अनुबंध की स्थिति में प्रासंगिक परिवर्तन एकत्र करने का एक प्रभावी तरीका प्रदान करती हैं, कई अनुबंध गैस लागतों को अनुकूलित करने के लिए लॉग उत्पन्न करने से बचते हैं। इन मामलों में, एक सबग्राफ डेटा स्रोत अनुबंध में किए गए कॉलों की सदस्यता ले सकता है। यह फ़ंक्शन सिग्नेचर और मैपिंग हैंडलर को संदर्भित करने वाले कॉल हैंडलर को परिभाषित करके प्राप्त किया जाता है जो इस फ़ंक्शन को कॉल संसाधित करेगा। इन कॉल्स को प्रोसेस करने के लिए, मैपिंग हैंडलर को `ethereum.Call` एक आर्गुमेंट के रूप में प्राप्त होगा, जिसमें टाइप किए गए इनपुट और कॉल के आउटपुट होंगे। लेन-देन की कॉल श्रृंखला में किसी भी गहराई पर किए गए कॉल मैपिंग को ट्रिगर करेंगे, जिससे प्रॉक्सी अनुबंधों के माध्यम से डेटा स्रोत अनुबंध के साथ गतिविधि को कैप्चर किया जा सकेगा।

कॉल हैंडलर केवल दो मामलों में से एक में ट्रिगर होंगे: जब निर्दिष्ट फ़ंक्शन को अनुबंध के अलावा किसी अन्य खाते द्वारा कॉल किया जाता है या जब इसे सॉलिडिटी में बाहरी के रूप में चिह्नित किया जाता है और उसी अनुबंध में किसी अन्य फ़ंक्शन के भाग के रूप में कॉल किया जाता है।

> **ध्यान दें:** कॉल हैंडलर वर्तमान में समता अनुरेखण API पर निर्भर करते हैं। बीएनबी चेन और आर्बिट्रम जैसे कुछ नेटवर्क इस एपीआई का समर्थन नहीं करते हैं। यदि इन नेटवर्कों में से किसी एक सबग्राफ इंडेक्सिंग में एक या अधिक कॉल हैंडलर हैं, तो यह सिंक करना शुरू नहीं करेगा। सबग्राफ डेवलपर्स को इसके बजाय इवेंट हैंडलर्स का उपयोग करना चाहिए। ये कॉल हैंडलर्स की तुलना में कहीं अधिक प्रदर्शनकारी हैं, और प्रत्येक ईवीएम नेटवर्क पर समर्थित हैं।

### कॉल हैंडलर को परिभाषित करना

अपने मेनिफेस्ट में कॉल हैंडलर को परिभाषित करने के लिए, आप जिस डेटा स्रोत की सदस्यता लेना चाहते हैं, उसके तहत बस एक `callHandlers` सरणी जोड़ें।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`फ़ंक्शन` कॉल को फ़िल्टर करने के लिए सामान्यीकृत फ़ंक्शन सिग्नेचर है। `हैंडलर` गुण आपकी मैपिंग में उस फ़ंक्शन का नाम है जिसे आप तब निष्पादित करना चाहेंगे जब डेटा स्रोत अनुबंध में लक्ष्य फ़ंक्शन को कॉल किया जाता है।

### मानचित्रण समारोह

प्रत्येक कॉल हैंडलर एक पैरामीटर लेता है जिसमें कॉल किए गए फ़ंक्शन के नाम से संबंधित प्रकार होता है। उपरोक्त उदाहरण सबग्राफ में, मैपिंग में एक हैंडलर होता है जब `createGravatar` फ़ंक्शन को कॉल किया जाता है और `CreateGravatarCall` पैरामीटर को तर्क के रूप में प्राप्त होता है:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

The `handleCreateGravatar` function takes a new `CreateGravatarCall` which is a subclass of `ethereum.Call`, provided by `@graphprotocol/graph-ts`, that includes the typed inputs and outputs of the call. The `CreateGravatarCall` type is generated for you when you run `graph codegen`.

## ब्लॉक हैंडलर

अनुबंध की घटनाओं या फ़ंक्शन कॉल की सदस्यता लेने के अलावा, एक सबग्राफ अपने डेटा को अपडेट करना चाह सकता है क्योंकि श्रृंखला में नए ब्लॉक जोड़े जाते हैं। इसे प्राप्त करने के लिए एक सबग्राफ प्रत्येक ब्लॉक के बाद या पूर्व-निर्धारित फ़िल्टर से मेल खाने वाले ब्लॉक के बाद एक फ़ंक्शन चला सकता है।

### समर्थित फ़िल्टर

```yaml
filter:
  kind: call
```

_परिभाषित हैंडलर को प्रत्येक ब्लॉक के लिए एक बार कॉल किया जाएगा जिसमें अनुबंध (डेटा स्रोत) के लिए कॉल शामिल है जिसे हैंडलर के तहत परिभाषित किया गया है।_

> **ध्यान दें:** `कॉल` फ़िल्टर फ़िलहाल पैरिटी ट्रेसिंग API पर निर्भर करता है। बीएनबी चेन और आर्बिट्रम जैसे कुछ नेटवर्क इस एपीआई का समर्थन नहीं करते हैं। अगर इन नेटवर्कों में से किसी एक सबग्राफ इंडेक्सिंग में `कॉल` फिल्टर के साथ एक या अधिक ब्लॉक हैंडलर हैं, तो यह सिंक करना शुरू नहीं करेगा।

ब्लॉक हैंडलर के लिए फ़िल्टर की अनुपस्थिति सुनिश्चित करेगी कि हैंडलर को प्रत्येक ब्लॉक कहा जाता है। डेटा स्रोत में प्रत्येक फ़िल्टर प्रकार के लिए केवल एक ब्लॉक हैंडलर हो सकता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### मानचित्रण समारोह

The mapping function will receive an `ethereum.Block` as its only argument. Like mapping functions for events, this function can access existing subgraph entities in the store, call smart contracts and create or update entities.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## अनाम घटनाएँ

यदि आपको अनाम घटनाओं को सॉलिडिटी में संसाधित करने की आवश्यकता है, तो इसे घटना के विषय 0 प्रदान करके प्राप्त किया जा सकता है, जैसा कि उदाहरण में है:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

एक घटना तभी शुरू होगी जब दोनों हस्ताक्षर और विषय 0 मेल खाते हों। डिफ़ॉल्ट रूप से, `topic0` इवेंट सिग्नेचर के हैश के बराबर है।

## इवेंट हैंडलर में लेनदेन रसीदें

`specVersion` `0.0.5` और `apiVersion` `0.0.7` से शुरू होकर, ईवेंट हैंडलर्स के पास रसीद तक ​​पहुंच हो सकती है लेनदेन जो उन्हें उत्सर्जित करता है।

ऐसा करने के लिए, इवेंट हैंडलर को सबग्राफ मेनिफेस्ट में नई `receipt: true` कुंजी के साथ घोषित किया जाना चाहिए, जो वैकल्पिक है और डिफ़ॉल्ट रूप से गलत है।

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

हैंडलर फ़ंक्शन के अंदर, रसीद को `Event.receipt` फ़ील्ड में एक्सेस किया जा सकता है। जब `receipt` कुंजी को `गलत` पर सेट किया जाता है या मेनिफ़ेस्ट में छोड़ दिया जाता है, तो इसके बजाय एक `शून्य` मान लौटाया जाएगा।

## प्रायोगिक विशेषताएं

`specVersion` `0.0.4` से शुरू होकर, सबग्राफ सुविधाओं को `सुविधाओं` अनुभाग में मेनिफेस्ट फ़ाइल के शीर्ष स्तर पर उनके का उपयोग करके स्पष्ट रूप से घोषित किया जाना चाहिए `camelCase` नाम, जैसा कि नीचे दी गई तालिका में सूचीबद्ध है:

| विशेषता                                                      | नाम                                                 |
| ------------------------------------------------------------ | --------------------------------------------------- |
| [गैर-घातक त्रुटियाँ](#non-fatal-errors)                      | `nonFatalErrors`                                    |
| [पूरा पाठ खोजें](#defining-fulltext-search-fields)           | `fullTextSearch`                                    |
| [ग्राफ्टिंग](#grafting-onto-existing-subgraphs)              | `grafting`                                          |
| [इथेरियम कॉन्ट्रैक्ट्स पर IPFS](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` or `nonDeterministicIpfs` |

उदाहरण के लिए, यदि कोई सबग्राफ **पूर्ण-पाठ खोज** और **गैर-घातक त्रुटियां** सुविधाओं का उपयोग करता है, तो मेनिफेस्ट में `सुविधाएं` फ़ील्ड होना चाहिए:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

ध्यान दें कि किसी सुविधा को घोषित किए बिना उसका उपयोग करने से सबग्राफ परिनियोजन के दौरान **सत्यापन त्रुटि** उत्पन्न होगी, लेकिन यदि सुविधा घोषित की जाती है लेकिन उसका उपयोग नहीं किया जाता है, तो कोई त्रुटि उत्पन्न नहीं होगी.

### इथेरियम कॉन्ट्रैक्ट्स पर IPFS

IPFS को एथेरियम के साथ संयोजित करने के लिए एक सामान्य उपयोग का मामला IPFS पर डेटा संग्रहीत करना है जो ऑन-चेन बनाए रखने के लिए बहुत महंगा होगा, और Ethereum अनुबंधों में IPFS हैश का संदर्भ देगा।

ऐसे IPFS हैश को देखते हुए, सबग्राफ `ipfs.cat` और `ipfs.map` का उपयोग करके IPFS से संबंधित फ़ाइलों को पढ़ सकते हैं। इसे मज़बूती से करने के लिए, यह आवश्यक है कि इन फ़ाइलों को उच्च उपलब्धता वाले IPFS नोड पर पिन किया जाए, ताकि [होस्ट की गई सेवा](https://thegraph.com/hosted-service) IPFS नोड अनुक्रमण के दौरान उन्हें ढूंढ सके।

> **ध्यान दें:** ग्राफ़ नेटवर्क अभी तक `ipfs.cat` और `ipfs.map` का समर्थन नहीं करता है, और डेवलपर्स को परिनियोजित नहीं करना चाहिए स्टूडियो के माध्यम से नेटवर्क के लिए उस कार्यक्षमता का उपयोग करने वाले सबग्राफ।

> **[सुविधा प्रबंधन](#experimental-features):** `ipfsOnEthereumContracts` को सबग्राफ मेनिफ़ेस्ट में `सुविधाओं` के अंतर्गत घोषित किया जाना चाहिए। गैर ईवीएम श्रृंखलाओं के लिए, इसी उद्देश्य के लिए `nonDeterministicIpfs` उपनाम का भी उपयोग किया जा सकता है।

स्थानीय ग्राफ़ नोड चलाते समय, `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` पर्यावरण चर सेट किया जाना चाहिए ताकि इस प्रायोगिक कार्यक्षमता का उपयोग करके सबग्राफ को अनुक्रमित किया जा सके।

### गैर-घातक त्रुटियाँ

पहले से सिंक किए गए सबग्राफ पर इंडेक्सिंग त्रुटियां, डिफ़ॉल्ट रूप से, सबग्राफ को विफल कर देंगी और सिंक करना बंद कर देंगी। सबग्राफ को वैकल्पिक रूप से त्रुटियों की उपस्थिति में समन्वयन जारी रखने के लिए कॉन्फ़िगर किया जा सकता है, हैंडलर द्वारा किए गए परिवर्तनों को अनदेखा करके त्रुटि उत्पन्न हुई। यह सबग्राफ लेखकों को अपने सबग्राफ को ठीक करने का समय देता है, जबकि नवीनतम ब्लॉक के विरुद्ध प्रश्नों को जारी रखा जाता है, हालांकि त्रुटि के कारण बग के कारण परिणाम असंगत हो सकते हैं। ध्यान दें कि कुछ त्रुटियाँ अभी भी हमेशा घातक होती हैं। गैर-घातक होने के लिए, त्रुटि नियतात्मक होने के लिए जानी जानी चाहिए।

> **नोट:** ग्राफ़ नेटवर्क अभी तक गैर-घातक त्रुटियों का समर्थन नहीं करता है, और डेवलपर्स को स्टूडियो के माध्यम से नेटवर्क पर उस कार्यक्षमता का उपयोग करके सबग्राफ तैनात नहीं करना चाहिए।

गैर-घातक त्रुटियों को सक्षम करने के लिए सबग्राफ मेनिफ़ेस्ट पर निम्न फ़ीचर फ़्लैग सेट करने की आवश्यकता होती है:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

क्वेरी को `subgraphError` तर्क के माध्यम से संभावित विसंगतियों वाले डेटा को क्वेरी करने के लिए भी ऑप्ट-इन करना चाहिए। यह जाँचने के लिए `_meta` को क्वेरी करने की भी सिफारिश की जाती है कि क्या सबग्राफ ने त्रुटियों को छोड़ दिया है, जैसा कि उदाहरण में दिया गया है:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

यदि सबग्राफ में कोई त्रुटि आती है, तो वह क्वेरी `"indexing_error"` संदेश के साथ डेटा और ग्राफ़कल त्रुटि दोनों वापस कर देगी, जैसा कि इस उदाहरण प्रतिक्रिया में है:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### मौजूदा सबग्राफ पर ग्राफ्टिंग

जब एक सबग्राफ पहली बार तैनात किया जाता है, तो यह कुछ परिस्थितियों में संबंधित श्रृंखला के उत्पत्ति ब्लॉक (या प्रत्येक डेटा स्रोत के साथ परिभाषित <कोड>स्टार्टब्लॉक</कोड>) पर घटनाओं को अनुक्रमित करना शुरू कर देता है; किसी मौजूदा सबग्राफ से डेटा का पुन: उपयोग करना और बहुत बाद के ब्लॉक में अनुक्रमण करना प्रारंभ करना लाभदायक होता है। इंडेक्सिंग के इस तरीके को _ग्राफ्टिंग_ कहा जाता है। ग्राफ्टिंग, उदाहरण के लिए, विकास के दौरान मैपिंग में सरल त्रुटियों को जल्दी से दूर करने या अस्थायी रूप से एक मौजूदा सबग्राफ को विफल होने के बाद फिर से काम करने के लिए उपयोगी है।

जब `subgraph.yaml` में सबग्राफ मेनिफेस्ट में `graft` ब्लॉक होता है तो एक सबग्राफ को बेस सबग्राफ पर ग्राफ्ट किया जाता है:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

जब एक सबग्राफ जिसके मेनिफ़ेस्ट में `graft` ब्लॉक होता है, तैनात किया जाता है, तो ग्राफ़ नोड दिए गए `ब्लॉक` सहित `base` सबग्राफ़ के डेटा को कॉपी करेगा और उसके बाद उस ब्लॉक से नए सबग्राफ को अनुक्रमणित करना जारी रखें। बेस सबग्राफ लक्ष्य ग्राफ़ नोड उदाहरण पर मौजूद होना चाहिए और कम से कम दिए गए ब्लॉक तक अनुक्रमित होना चाहिए। इस प्रतिबंध के कारण, ग्राफ्टिंग का उपयोग केवल विकास के दौरान या किसी आपात स्थिति के दौरान समकक्ष गैर-ग्राफ्टेड सबग्राफ के उत्पादन में तेजी लाने के लिए किया जाना चाहिए।

क्योंकि आधार डेटा को अनुक्रमित करने के बजाय प्रतियों को ग्राफ्ट करना, स्क्रैच से अनुक्रमणित करने की तुलना में सबग्राफ को वांछित ब्लॉक में प्राप्त करना बहुत तेज है, हालांकि बहुत बड़े सबग्राफ के लिए प्रारंभिक डेटा कॉपी में अभी भी कई घंटे लग सकते हैं। जबकि ग्राफ्टेड सबग्राफ को इनिशियलाइज़ किया जा रहा है, ग्राफ़ नोड उन एंटिटी प्रकारों के बारे में जानकारी लॉग करेगा जो पहले ही कॉपी किए जा चुके हैं।

ग्राफ्टेड सबग्राफ एक ग्राफक्यूएल स्कीमा का उपयोग कर सकता है जो बेस सबग्राफ के समान नहीं है, लेकिन इसके साथ केवल संगत है। यह अपने आप में एक मान्य सबग्राफ स्कीमा होना चाहिए, लेकिन निम्नलिखित तरीकों से बेस सबग्राफ के स्कीमा से विचलित हो सकता है:

- यह इकाई प्रकार जोड़ता या हटाता है
- यह इकाई प्रकारों से विशेषताएँ निकालता है
- यह प्रभावहीन गुणों को इकाई प्रकारों में जोड़ता है|
- यह प्रभाव वाले गुणों को प्रभावहीन गुणों में बदल देता है|
- यह इनम्स में महत्व देता है|
- यह इंटरफेस जोड़ता या हटाता है|
- यह कि, किन इकाई प्रकारों के लिए इंटरफ़ेस लागू होगा, इसे बदल देता है|

> **[सुविधा प्रबंधन](#experimental-features):** `ग्राफ्टिंग` को `विशेषताओं` के अंतर्गत घोषित किया जाना चाहिए कोड सबग्राफ मेनिफेस्ट में।

## फ़ाइल डेटा स्रोत

फ़ाइल डेटा स्रोत एक मजबूत, विस्तार योग्य तरीके से इंडेक्सिंग के दौरान ऑफ-चेन डेटा तक पहुँचने के लिए एक नई सबग्राफ कार्यक्षमता है, जो IPFS से शुरू होती है।

> यह ऑफ-चेन डेटा के नियतात्मक अनुक्रमण के साथ-साथ स्वैच्छिक HTTP-स्रोत डेटा के संभावित परिचय के लिए आधार भी देता है।

### अवलोकन

हैंडलर निष्पादन के दौरान "इन लाइन" फ़ाइलों को लाने के बजाय, यह उन टेम्पलेट्स को प्रस्तुत करता है जिन्हें किसी दिए गए फ़ाइल पहचानकर्ता के लिए नए डेटा स्रोतों के रूप में उत्पन्न किया जा सकता है। ये नए डेटा स्रोत फ़ाइलें प्राप्त करते हैं, असफल होने पर पुनः प्रयास करते हैं, फ़ाइल मिलने पर एक समर्पित हैंडलर चलाते हैं।

यह [मौजूदा डेटा स्रोत टेम्प्लेट](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates) के समान है, जिनका उपयोग किया जाता है नए श्रृंखला-आधारित डेटा स्रोतों को गतिशील रूप से बनाने के लिए।

> यह मौजूदा `ipfs.cat` API को प्रतिस्थापित करता है

### प्रवासन गाइड

#### `ग्राफ़-टीएस` और `ग्राफ़-क्ली` अपडेट करें

फ़ाइल डेटा स्रोतों के लिए ग्राफ़-टीएस >=0.29.0 और ग्राफ़-क्ली >=0.33.1 की आवश्यकता होती है

#### एक नया इकाई प्रकार जोड़ें जो फ़ाइलें मिलने पर अपडेट किया जाएगा

फ़ाइल डेटा स्रोत श्रृंखला-आधारित संस्थाओं तक पहुँच या अद्यतन नहीं कर सकते हैं, लेकिन फ़ाइल विशिष्ट संस्थाओं को अद्यतन करना चाहिए।

इसका मतलब हो सकता है कि फ़ील्ड को मौजूदा इकाइयों से अलग-अलग इकाइयों में विभाजित करना, एक साथ जुड़े हुए।

मूल संयुक्त इकाई:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

नई, विभाजित इकाई:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

यदि पैरेंट इकाई और परिणामी फ़ाइल डेटा स्रोत इकाई के बीच संबंध 1:1 है, तो सबसे सरल पैटर्न मूल इकाई को लुकअप के रूप में IPFS CID का उपयोग करके परिणामी फ़ाइल इकाई से लिंक करना है। यदि आपको अपनी नई फ़ाइल-आधारित संस्थाओं को मॉडलिंग करने में कठिनाई हो रही है, तो डिस्कॉर्ड पर संपर्क करें!

> आप इन नेस्टेड इकाइयों के आधार पर पैरेंट इकाइयों को फ़िल्टर करने के लिए [नेस्टेड फ़िल्टर](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) का उपयोग कर सकते हैं।

#### `kind: file/ipfs` के साथ एक नया टेम्पलेटेड डेटा स्रोत जोड़ें

यह वह डेटा स्रोत है जो ब्याज की फ़ाइल की पहचान होने पर उत्पन्न होगा।

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> वर्तमान में `abis` की आवश्यकता है, हालांकि फ़ाइल डेटा स्रोतों के भीतर से अनुबंधों को कॉल करना संभव नहीं है

फ़ाइल डेटा स्रोत को विशेष रूप से उन सभी इकाई प्रकारों का उल्लेख करना चाहिए जिनके साथ यह `इकाइयों` के तहत इंटरैक्ट करेगा। अधिक विवरण के लिए [सीमाएं](#Limitations) देखें।

#### फ़ाइलों को संसाधित करने के लिए एक नया हैंडलर बनाएँ

इस हैंडलर को एक `बाइट्स` पैरामीटर स्वीकार करना चाहिए, जो फ़ाइल के मिलने पर उसकी सामग्री होगी, जिसे बाद में संसाधित किया जा सकता है। यह अक्सर एक JSON फ़ाइल होगी, जिसे `ग्राफ़-टीएस` हेल्पर्स ([दस्तावेज़ीकरण](https://thegraph.com/docs/en/developing/assemblyscript-api/#json) के साथ प्रोसेस किया जा सकता है -api))।

पढ़ने योग्य स्ट्रिंग के रूप में फ़ाइल की CID को `dataSource` के माध्यम से निम्नानुसार एक्सेस किया जा सकता है:

```typescript
const cid = dataSource.stringParam()
```

उदाहरण हैंडलर:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### आवश्यक होने पर फ़ाइल डेटा स्रोत स्पॉन करें

अब आप चेन-आधारित हैंडलर के निष्पादन के दौरान फ़ाइल डेटा स्रोत बना सकते हैं:

- ऑटो-जेनरेट किए गए `टेम्पलेट्स` से टेम्प्लेट आयात करें
- call `TemplateName.create(cid: string)` from within a mapping, where the cid is a valid IPFS content identifier

> वर्तमान में ग्राफ़ नोड [v0 और v1 सामग्री पहचानकर्ताओं](https://docs.ipfs.tech/concepts/content-addressing/) का समर्थन करता है, और निर्देशिकाओं के साथ सामग्री पहचानकर्ता (जैसे `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata).json`)

उदाहरण:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//This example code is for a Crypto coven subgraph. The above ipfs hash is a directory with token metadata for all crypto coven NFTs.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //This creates a path to the metadata for a single Crypto coven NFT. It concats the directory with "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

यह एक नया फ़ाइल डेटा स्रोत बनाएगा, जो ग्राफ़ नोड के कॉन्फ़िगर किए गए IPFS एंडपॉइंट को पोल करेगा, अगर यह नहीं मिला तो पुनः प्रयास करेगा। जब फ़ाइल मिल जाती है, फ़ाइल डेटा स्रोत हैंडलर निष्पादित किया जाएगा।

यह उदाहरण CID का उपयोग पैरेंट `Token` इकाई और परिणामी `TokenMetadata` इकाई के बीच लुकअप के रूप में कर रहा है।

> पहले, यह वह बिंदु है जिस पर एक सबग्राफ डेवलपर फ़ाइल लाने के लिए `ipfs.cat(CID)` को कॉल करता था

बधाई हो, आप फ़ाइल डेटा स्रोतों का उपयोग कर रहे हैं!

#### अपने उप-अनुच्छेदों को तैनात करना

अब आप अपने सबग्राफ को किसी भी ग्राफ़ नोड >=v0.30.0-rc.0 पर `बना` और `तैनाती` कर सकते हैं।

#### परिसीमन

फ़ाइल डेटा स्रोत हैंडलर और संस्थाएँ अन्य सबग्राफ संस्थाओं से अलग हैं, यह सुनिश्चित करते हुए कि वे निष्पादित होने पर नियतात्मक हैं, और श्रृंखला-आधारित डेटा स्रोतों का कोई संदूषण सुनिश्चित नहीं करते हैं। विस्तार से:

- फ़ाइल डेटा स्रोतों द्वारा बनाई गई इकाइयाँ अपरिवर्तनीय हैं, और इन्हें अद्यतन नहीं किया जा सकता है
- फ़ाइल डेटा स्रोत हैंडलर अन्य फ़ाइल डेटा स्रोतों से संस्थाओं तक नहीं पहुँच सकते
- फ़ाइल डेटा स्रोतों से जुड़ी संस्थाओं को चेन-आधारित हैंडलर द्वारा एक्सेस नहीं किया जा सकता है

> हालांकि यह बाधा अधिकांश उपयोग-मामलों के लिए समस्याग्रस्त नहीं होनी चाहिए, यह कुछ के लिए जटिलता का परिचय दे सकती है। यदि आपको अपने फ़ाइल-आधारित डेटा को सबग्राफ में मॉडलिंग करने में समस्या आ रही है, तो कृपया डिस्कॉर्ड के माध्यम से संपर्क करें!

इसके अतिरिक्त, फ़ाइल डेटा स्रोत से डेटा स्रोत बनाना संभव नहीं है, चाहे वह ऑनचेन डेटा स्रोत हो या अन्य फ़ाइल डेटा स्रोत। भविष्य में यह प्रतिबंध हटाया जा सकता है।

#### सर्वोत्तम प्रथाएं

यदि आप NFT मेटाडेटा को संबंधित टोकन से लिंक कर रहे हैं, तो टोकन इकाई से मेटाडेटा इकाई को संदर्भित करने के लिए मेटाडेटा के IPFS हैश का उपयोग करें। एक आईडी के रूप में IPFS हैश का उपयोग करके मेटाडेटा इकाई को सहेजें।

फ़ाइल डेटा स्रोत बनाते समय आप [DataSource प्रसंग](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) का उपयोग कर सकते हैं अतिरिक्त जानकारी पास करें जो फ़ाइल डेटा स्रोत हैंडलर के लिए उपलब्ध होगी।

यदि आपके पास ऐसे निकाय हैं जो कई बार रीफ़्रेश किए गए हैं, तो IPFS हैश & amp का उपयोग करके अद्वितीय फ़ाइल-आधारित निकाय बनाएँ; इकाई आईडी, और श्रृंखला-आधारित इकाई में एक व्युत्पन्न क्षेत्र का उपयोग करके उनका संदर्भ लें।

> हम ऊपर दिए गए सुझाव को बेहतर बनाने के लिए काम कर रहे हैं, इसलिए क्वेरी केवल "नवीनतम" संस्करण लौटाती हैं

#### ज्ञात समस्याएँ

फ़ाइल डेटा स्रोतों को वर्तमान में ABI की आवश्यकता है, भले ही ABI का उपयोग नहीं किया जाता है ([issue](https://github.com/graphprotocol/graph-cli/issues/961))। वर्कअराउंड किसी भी एबीआई को जोड़ना है।

फ़ाइल डेटा स्रोतों के लिए हैंडलर उन फ़ाइलों में नहीं हो सकते हैं जो `eth_call` अनुबंध बाइंडिंग आयात करते हैं, "अज्ञात आयात: `ethereum::ethereum.call` परिभाषित नहीं किया गया है" ([ मुद्दा](https://github.com/graphprotocol/graph-cli/issues/4309))। वर्कअराउंड एक समर्पित फ़ाइल में फ़ाइल डेटा स्रोत हैंडलर बनाना है।

#### उदाहरण

[क्रिप्टो कॉवेन सबग्राफ माइग्रेशन](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### संदर्भ

[GIP फ़ाइल डेटा स्रोत](https://forum.thegraph.com/t/gip-file-data-sources/2721)
