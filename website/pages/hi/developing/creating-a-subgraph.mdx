---
title: सबग्राफ बनाना
---

एक सबग्राफ एक ब्लॉकचेन से डेटा निकालता है, इसे प्रोसेस करता है और इसे स्टोर करता है ताकि इसे ग्राफक्यूएल के माध्यम से आसानी से क्वेरी किया जा सके।

![एक सबग्राफ को परिभाषित करना](/img/defining-a-subgraph.png)

सबग्राफ की परिभाषा में कुछ फाइलें होती हैं:

- `subgraph.yaml`: एक YAML फ़ाइल जिसमें सबग्राफ मेनिफ़ेस्ट होता है

- `schema.graphql`: एक ग्राफक्यूएल स्कीमा जो परिभाषित करता है कि आपके सबग्राफ के लिए कौन सा डेटा संग्रहीत है, और इसे ग्राफक्यूएल के माध्यम से कैसे क्वेरी करें

- `AssemblyScript मैपिंग`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) कोड जो इवेंट डेटा से आपके स्कीमा में परिभाषित इकाइयों में अनुवाद करता है (उदाहरण के लिए `mapping.ts` इस ट्यूटोरियल में)

> ग्राफ़ के विकेन्द्रीकृत नेटवर्क पर अपने सबग्राफ का उपयोग करने के लिए, आपको [एक बनाना होगा एपीआई कुंजी](/deploying/subgraph-studio-faqs/#2-how-do-i-create-an-api-key)। यह अनुशंसा की जाती है कि आप कम से कम [10,000 GRT](/network-transition-faq/#how-can-i-ensure-that-my-subgraph-will-be-picked-up-by-indexer-on-the-graph-network) के साथ [सिग्नल जोड़ें](/network/curating/#how-to-signal)

मेनिफ़ेस्ट फ़ाइल की सामग्री के बारे में विस्तार से जाने से पहले, आपको [ग्राफ़ CLI](https://github.com/graphprotocol/graph-cli) इंस्टॉल करना होगा जिसे आपको बनाना होगा और एक सबग्राफ तैनात करें।

## . ग्राफ़ सीएलआई इनस्टॉल करें

ग्राफ़ सीएलआई जावास्क्रिप्ट में लिखा गया है, और इसका उपयोग करने के लिए आपको या तो `yarn` या `npm` स्थापित करना होगा; यह माना जाता है कि आपके पास निम्नलिखित में yarn है।

एक बार जब आपके पास `yarn` हो जाए, तो चलाकर ग्राफ़ सीएलआई स्थापित करें

**Yarn के साथ स्थापित करें:**

```bash
yarn global add @graphprotocol/graph-cli
```

**एनपीएम के साथ स्थापित करें:**

```bash
npm install -g @graphprotocol/graph-cli
```

एक बार इंस्टॉल हो जाने पर, `ग्राफ़ इनिट` कमांड का उपयोग मौजूदा अनुबंध से या किसी उदाहरण सबग्राफ से एक नया सबग्राफ प्रोजेक्ट सेट करने के लिए किया जा सकता है। `ग्राफ़ इनिट --प्रोडक्ट सबग्राफ़-स्टूडियो` पास करके सबग्राफ़ स्टूडियो पर सबग्राफ़ बनाने के लिए इस कमांड का इस्तेमाल किया जा सकता है। यदि आपके पास पहले से ही आपके पसंदीदा नेटवर्क पर एक स्मार्ट अनुबंध तैनात है, तो उस अनुबंध से एक नया सबग्राफ बूटस्ट्रैप करना आरंभ करने का एक अच्छा तरीका हो सकता है।

## एक मौजूदा कॉन्ट्रैक्ट से

निम्न आदेश एक सबग्राफ बनाता है जो मौजूदा अनुबंध की सभी घटनाओं को अनुक्रमित करता है। यह एथरस्कैन से अनुबंध एबीआई लाने का प्रयास करता है और स्थानीय फ़ाइल पथ का अनुरोध करने के लिए वापस आ जाता है। यदि कोई वैकल्पिक तर्क गायब है, तो यह आपको एक संवादात्मक रूप में ले जाता है।

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>` सबग्राफ स्टूडियो में आपके सबग्राफ की आईडी है, यह आपके सबग्राफ विवरण पृष्ठ पर पाया जा सकता है।

## एक उदाहरण सबग्राफ से

दूसरा मोड `graph init` सपोर्ट करता है, एक उदाहरण सबग्राफ से एक नया प्रोजेक्ट बना रहा है। निम्न आदेश यह करता है:

```sh
graph init --studio <SUBGRAPH_SLUG>
```

उदाहरण सबग्राफ दानी ग्रांट के ग्रेविटी अनुबंध पर आधारित है जो उपयोगकर्ता के अवतारों का प्रबंधन करता है और जब भी अवतार बनाए या अपडेट किए जाते हैं तो `NewGravatar` या `UpdateGravatar` ईवेंट उत्सर्जित करता है। सबग्राफ इन घटनाओं को ग्राफ़ नोड स्टोर में `Gravatar` संस्थाओं को लिखकर और सुनिश्चित करता है कि इन्हें घटनाओं के अनुसार अपडेट किया जाता है। निम्नलिखित खंड उन फाइलों पर जाएंगे जो इस उदाहरण के लिए सबग्राफ मेनिफेस्ट बनाते हैं।

## मौजूदा सबग्राफ में नए डेटा स्रोत जोड़ें

चूँकि `v0.31.0` `graph-cli` `graph add` कमांड के माध्यम से मौजूदा सबग्राफ में नए डेटा स्रोतों को जोड़ने का समर्थन करता है।

```sh
graph add <address> [<subgraph-manifest default: "./subgraph.yaml">]

Options:

      --abi <path>              Path to the contract ABI (default: download from Etherscan)
      --contract-name           Name of the contract (default: Contract)
      --merge-entities          Whether to merge entities with the same name (default: false)
      --network-file <path>     Networks config file path (default: "./networks.json")
```

The `add` command will fetch the ABI from Etherscan (unless an ABI path is specified with the `--abi` option), and will create a new `dataSource` in the same way that `graph init` command creates a `dataSource` `--from-contract`, updating the schema and mappings accordingly.

`--merge-entities` विकल्प यह बताता है कि डेवलपर `entity` और `event` नाम के विरोधों को कैसे हैंडल करना चाहता है:

- अगर `सही`: नए `dataSource` को मौजूदा `eventHandlers` & `इकाइयां`।
- अगर `गलत`: एक नई इकाई & ईवेंट हैंडलर को `${dataSourceName}{EventName}` के साथ बनाया जाना चाहिए।

संबंधित नेटवर्क के लिए `networks.json` को अनुबंध `पता` लिखा जाएगा।

> **ध्यान दें:** इंटरैक्टिव क्ली का उपयोग करते समय, `ग्राफ़ इनिट` को सफलतापूर्वक चलाने के बाद, आपको एक नया `डेटा स्रोत` जोड़ने के लिए कहा जाएगा ।

## द सबग्राफ मेनिफेस्ट

सबग्राफ मेनिफेस्ट `subgraph.yaml` आपके सबग्राफ इंडेक्स के स्मार्ट कॉन्ट्रैक्ट्स को परिभाषित करता है, इन कॉन्ट्रैक्ट्स से किन इवेंट्स पर ध्यान देना है, और इवेंट डेटा को उन संस्थाओं से कैसे मैप करना है जो ग्राफ़ नोड स्टोर करता है और क्वेरी करने की अनुमति देता है। सबग्राफ मेनिफ़ेस्ट के लिए पूर्ण विशिष्टता [यहां](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md) पाई जा सकती है।

उदाहरण के सबग्राफ के लिए `subgraph.yaml` है:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/graph-tooling
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
      endBlock: 7175245
    context:
      foo:
        type: Bool
        data: true
      bar:
        type: String
        data: 'bar'
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

मेनिफेस्ट के लिए अद्यतन करने के लिए महत्वपूर्ण प्रविष्टियां हैं:

- `description`: a human-readable description of what the subgraph is. This description is displayed by the Graph Explorer when the subgraph is deployed to the hosted service.

- `रिपॉजिटरी`: रिपॉजिटरी का URL जहां सबग्राफ मेनिफेस्ट पाया जा सकता है। यह द ग्राफ एक्सप्लोरर द्वारा भी प्रदर्शित किया गया है।

- `विशेषताएं`: सभी प्रयुक्त [विशेषता](#experimental-features) नामों की सूची।

- `dataSources.source`: स्मार्ट अनुबंध का पता सबग्राफ स्रोत, और उपयोग करने के लिए स्मार्ट अनुबंध का ABI। पता वैकल्पिक है; इसे छोड़ने से सभी अनुबंधों से मिलान करने वाले ईवेंट को अनुक्रमित करने की अनुमति मिलती है।

- `dataSources.source.startBlock`: उस ब्लॉक की वैकल्पिक संख्या जिससे डेटा स्रोत इंडेक्स करना शुरू करता है। ज्यादातर मामलों में, हम उस ब्लॉक का उपयोग करने का सुझाव देते हैं जिसमें अनुबंध बनाया गया था।

- `dataSources.source.endBlock`: The optional number of the block that the data source stops indexing at, including that block. Minimum spec version required: `0.0.9`.

- `dataSources.context`: key-value pairs that can be used within subgraph mappings. Supports various data types like `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, and `BigInt`. Each variable needs to specify its `type` and `data`. These context variables are then accessible in the mapping files, offering more configurable options for subgraph development.

- `dataSources.mapping.entities`: वे निकाय जो डेटा स्रोत स्टोर को लिखते हैं। प्रत्येक इकाई के लिए स्कीमा को schema.graphql फ़ाइल में परिभाषित किया गया है।

- `dataSources.mapping.abis`: स्रोत अनुबंध के साथ-साथ मैपिंग के भीतर से आपके द्वारा इंटरैक्ट किए जाने वाले किसी भी अन्य स्मार्ट अनुबंध के लिए एक या अधिक नामित एबीआई फाइलें।

- `dataSources.mapping.eventHandlers`: उन स्मार्ट कॉन्ट्रैक्ट इवेंट्स को सूचीबद्ध करता है जिन पर यह सबग्राफ प्रतिक्रिया करता है और मैपिंग में हैंडलर—./src/mapping.ts उदाहरण में — जो इन इवेंट्स को स्टोर में संस्थाओं में बदल देता है।

- `dataSources.mapping.callHandlers`: उन स्मार्ट कॉन्ट्रैक्ट फ़ंक्शंस को सूचीबद्ध करता है जो इस सबग्राफ पर प्रतिक्रिया करता है और मैपिंग में हैंडलर जो इनपुट और आउटपुट को स्टोर में संस्थाओं में फ़ंक्शन कॉल में बदल देता है।

- `dataSources.mapping.blockHandlers`: उन ब्लॉक्स को सूचीबद्ध करता है जिन पर यह सबग्राफ प्रतिक्रिया करता है और मैपिंग में हैंडलर्स को तब चलाया जाता है जब ब्लॉक को चेन से जोड़ा जाता है। फ़िल्टर के बिना, प्रत्येक ब्लॉक में ब्लॉक हैंडलर चलाया जाएगा। हैंडलर में `kind: call` के साथ एक `फ़िल्टर` फ़ील्ड जोड़कर एक वैकल्पिक कॉल-फ़िल्टर प्रदान किया जा सकता है। यह केवल हैंडलर चलाएगा यदि ब्लॉक में डेटा स्रोत अनुबंध के लिए कम से कम एक कॉल हो।

एक सबग्राफ कई स्मार्ट कॉन्ट्रैक्ट्स से डेटा को इंडेक्स कर सकता है। प्रत्येक अनुबंध के लिए एक प्रविष्टि जोड़ें जिससे डेटा को `dataSources` सरणी में अनुक्रमित करने की आवश्यकता है।

निम्नलिखित प्रक्रिया का उपयोग करके एक ब्लॉक के भीतर डेटा स्रोत के लिए ट्रिगर्स का आदेश दिया गया है:

1. ईवेंट और कॉल ट्रिगर्स को पहले ब्लॉक के भीतर ट्रांजैक्शन इंडेक्स द्वारा ऑर्डर किया जाता है।
2. एक ही लेन-देन के भीतर ईवेंट और कॉल ट्रिगर्स को एक कन्वेंशन का उपयोग करके ऑर्डर किया जाता है: ईवेंट पहले ट्रिगर करता है फिर ट्रिगर्स को कॉल करता है, प्रत्येक प्रकार के ऑर्डर का सम्मान करते हुए उन्हें मेनिफेस्ट में परिभाषित किया जाता है।
3. ब्लॉक ट्रिगर इवेंट और कॉल ट्रिगर के बाद चलाए जाते हैं, जिस क्रम में उन्हें मेनिफेस्ट में परिभाषित किया गया है।

ये आदेश नियम परिवर्तन के अधीन हैं।

### एबीआई प्राप्त करना

एबीआई फाइल(फाइलों) को आपके अनुबंध(ओं) से मेल खाना चाहिए। ABI फ़ाइलें प्राप्त करने के कुछ तरीके हैं:

- यदि आप अपना खुद का प्रोजेक्ट बना रहे हैं, तो आपके पास अपने सबसे मौजूदा एबीआई तक पहुंच होने की संभावना है।
- यदि आप किसी सार्वजनिक परियोजना के लिए सबग्राफ बना रहे हैं, तो आप उस परियोजना को अपने कंप्यूटर पर डाउनलोड कर सकते हैं और [`truffle संकलन का उपयोग करके ABI प्राप्त कर सकते हैं `](https://truffleframework.com/docs/truffle/overview) या संकलित करने के लिए solc का उपयोग करना।
- आप ABI को [Etherscan](https://etherscan.io/) पर भी ढूंढ सकते हैं, लेकिन यह हमेशा विश्वसनीय नहीं होता, क्योंकि वहां अपलोड किया गया ABI पुराना हो सकता है। सुनिश्चित करें कि आपके पास सही ABI है, अन्यथा आपका सबग्राफ चलाना विफल हो जाएगा।

## ग्राफक्यूएल स्कीमा

आपके सबग्राफ का स्कीमा फ़ाइल `schema.graphql` में है। ग्राफ़िकल स्कीमा को ग्राफ़िकल इंटरफ़ेस परिभाषा भाषा का उपयोग करके परिभाषित किया गया है। यदि आपने कभी भी ग्राफ़क्यूएल स्कीमा नहीं लिखा है, तो यह अनुशंसा की जाती है कि आप इस प्राइमर को ग्राफ़िकल टाइप सिस्टम पर देखें। ग्राफक्यूएल स्कीमा के लिए संदर्भ दस्तावेज [ग्राफक्यूएल एपीआई](/querying/graphql-api) अनुभाग में पाया जा सकता है।

## संस्थाओं को परिभाषित करना

संस्थाओं को परिभाषित करने से पहले, एक कदम पीछे हटना और यह सोचना महत्वपूर्ण है कि आपका डेटा कैसे संरचित और लिंक किया गया है। सबग्राफ स्कीमा में परिभाषित डेटा मॉडल और सबग्राफ द्वारा अनुक्रमित संस्थाओं के खिलाफ सभी प्रश्न किए जाएंगे। इस वजह से, सबग्राफ स्कीमा को इस तरह से परिभाषित करना अच्छा होता है जो आपके डैप की जरूरतों से मेल खाता हो। घटनाओं या कार्यों के बजाय "डेटा वाली वस्तुओं" के रूप में संस्थाओं की कल्पना करना उपयोगी हो सकता है।

द ग्राफ़ के साथ, आप केवल `schema.graphql` में इकाई प्रकारों को परिभाषित करते हैं, और ग्राफ़ नोड उस इकाई प्रकार के एकल उदाहरणों और संग्रहों को क्वेरी करने के लिए शीर्ष स्तर के फ़ील्ड उत्पन्न करेगा। प्रत्येक प्रकार जो एक इकाई होना चाहिए उसे `@entity` निर्देश के साथ एनोटेट किया जाना आवश्यक है। डिफ़ॉल्ट रूप से, संस्थाएँ परिवर्तनशील होती हैं, जिसका अर्थ है कि मैपिंग मौजूदा संस्थाओं को लोड कर सकती है, उन्हें संशोधित कर सकती है और उस इकाई का एक नया संस्करण संग्रहीत कर सकती है। परिवर्तनशीलता एक मूल्य पर आती है, और इकाई प्रकारों के लिए जिनके लिए यह ज्ञात है कि उन्हें कभी भी संशोधित नहीं किया जाएगा, उदाहरण के लिए, क्योंकि उनमें केवल श्रृंखला से शब्दशः निकाले गए डेटा होते हैं, उन्हें `@entity के साथ अपरिवर्तनीय के रूप में चिह्नित करने की अनुशंसा की जाती है (अपरिवर्तनीय: सच)`। मैपिंग अपरिवर्तनीय संस्थाओं में तब तक परिवर्तन कर सकती है जब तक वे परिवर्तन उसी ब्लॉक में होते हैं जिसमें इकाई बनाई गई थी। अपरिवर्तनीय संस्थाएं लिखने और क्वेरी करने के लिए बहुत तेज़ हैं, और इसलिए जब भी संभव हो इसका उपयोग किया जाना चाहिए।

### अच्छा उदाहरण

नीचे दी गई `Gravatar` इकाई को Gravatar ऑब्जेक्ट के चारों ओर संरचित किया गया है और यह इस बात का एक अच्छा उदाहरण है कि किसी इकाई को कैसे परिभाषित किया जा सकता है।

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### खराब उदाहरण

The example `GravatarAccepted` and `GravatarDeclined` entities below are based around events. It is not recommended to map events or function calls to entities 1:1.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### वैकल्पिक और आवश्यक फ़ील्ड

इकाई क्षेत्रों को आवश्यक या वैकल्पिक के रूप में परिभाषित किया जा सकता है। स्कीमा में आवश्यक फ़ील्ड `!` द्वारा दर्शाए गए हैं। यदि मैपिंग में कोई आवश्यक फ़ील्ड सेट नहीं है, तो फ़ील्ड की क्वेरी करते समय आपको यह त्रुटि प्राप्त होगी:

```
गैर-शून्य फ़ील्ड 'नाम' के लिए हल किया गया शून्य मान
```

प्रत्येक इकाई में एक `आईडी` फ़ील्ड होना चाहिए, जो कि `बाइट्स!` या `स्ट्रिंग!` प्रकार का होना चाहिए। आमतौर पर `बाइट्स!` का उपयोग करने की सिफारिश की जाती है, जब तक कि `आईडी` में मानव-पठनीय पाठ न हो, चूंकि `बाइट्स!` आईडी वाली इकाइयां लिखने में तेज़ होंगी और `स्ट्रिंग!` `id` वाले प्रश्नों के रूप में। `id` फ़ील्ड प्राथमिक कुंजी के रूप में कार्य करता है, और एक ही प्रकार की सभी संस्थाओं के बीच अद्वितीय होना चाहिए। ऐतिहासिक कारणों से, प्रकार `ID!` को भी स्वीकार किया जाता है और यह `स्ट्रिंग!` का पर्यायवाची है।

कुछ इकाई प्रकारों के लिए `id` का निर्माण दो अन्य संस्थाओं की आईडी से किया जाता है; यह `concat` का उपयोग करके संभव है, उदाहरण के लिए, `let id = left.id.concat(right.id)` `left` की आईडी से आईडी बनाने के लिए और `दाएं`। इसी तरह, एक मौजूदा इकाई की आईडी से एक आईडी बनाने के लिए और एक काउंटर `गिनती`, `let id = left.id.concatI32(count)` का उपयोग किया जा सकता है। जब तक `बाएं` की लंबाई ऐसी सभी संस्थाओं के लिए समान है, उदाहरण के लिए, क्योंकि `left.id` एक `पता है, तब तक विशिष्ट आईडी बनाने के लिए संयोजन की गारंटी दी जाती है`।

### बिल्ट-इन स्केलर प्रकार

#### ग्राफक्यूएल समर्थित स्केलर्स

हम अपने ग्राफक्यूएल एपीआई में निम्नलिखित स्केलर्स का समर्थन करते हैं:

| प्रकार | विवरण |
| --- | --- |
| `Bytes` | बाइट सरणी, एक हेक्साडेसिमल स्ट्रिंग के रूप में दर्शाया गया है। आमतौर पर एथेरियम हैश और पतों के लिए उपयोग किया जाता है। |
| `String` | `स्ट्रिंग` मानों के लिए स्केलर। अशक्त वर्ण समर्थित नहीं हैं और स्वचालित रूप से हटा दिए जाते हैं। |
| `Boolean` | `boolean` मानों के लिए स्केलर। |
| `Int` | ग्राफक्लाइन स्पेक `Int` को 32 बाइट्स के आकार के रूप में परिभाषित करता है। |
| `Int8` | An 8-byte signed integer, also known as a 64-bit signed integer, can store values in the range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. Prefer using this to represent `i64` from ethereum. |
| `BigInt` | बड़े पूर्णांक। एथेरियम के `uint32`, `int64`, `uint64`, ..., `uint256` प्रकारों के लिए उपयोग किया जाता है। नोट: `uint32` के नीचे सब कुछ, जैसे `int32`, `uint24` या `int8` को `i32` के रूप में दर्शाया गया है। |
| `BigDecimal` | `BigDecimal` उच्च परिशुद्धता दशमलव एक महत्व और एक प्रतिपादक के रूप में दर्शाया गया है। एक्सपोनेंट रेंज -6143 से +6144 तक है। 34 महत्वपूर्ण अंकों तक गोल। |

#### Enums

आप स्कीमा के भीतर एनम भी बना सकते हैं। Enums में निम्न सिंटैक्स होता है:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

स्कीमा में एक बार एनम परिभाषित हो जाने के बाद, आप किसी इकाई पर एनम फ़ील्ड सेट करने के लिए एनम मान के स्ट्रिंग प्रतिनिधित्व का उपयोग कर सकते हैं। उदाहरण के लिए, आप पहले अपनी इकाई को परिभाषित करके और बाद में `entity.tokenStatus = "SecondOwner"` के साथ फ़ील्ड सेट करके `tokenStatus` को `SecondOwner` पर सेट कर सकते हैं। नीचे दिया गया उदाहरण दर्शाता है कि एनम फील्ड के साथ टोकन इकाई कैसी दिखेगी:

एनम लिखने के बारे में अधिक विवरण [GraphQL प्रलेखन](https://graphql.org/learn/schema/) में पाया जा सकता है।

#### निकाय संबंध

एक इकाई का आपकी स्कीमा में एक या अधिक अन्य संस्थाओं से संबंध हो सकता है। आपके प्रश्नों में इन संबंधों का पता लगाया जा सकता है। ग्राफ़ में रिश्ते यूनिडायरेक्शनल हैं। रिश्ते के किसी भी "अंत" पर एक यूनिडायरेक्शनल रिश्ते को परिभाषित करके द्विपक्षीय संबंधों को अनुकरण करना संभव है।

संस्थाओं पर संबंधों को किसी अन्य क्षेत्र की तरह ही परिभाषित किया जाता है सिवाय इसके कि निर्दिष्ट प्रकार किसी अन्य इकाई का है।

#### एक-से-एक संबंध

`TransactionReceipt` इकाई प्रकार के साथ एक वैकल्पिक एक-से-एक संबंध के साथ एक `लेन-देन` इकाई प्रकार परिभाषित करें:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### एक से कई रिश्ते

टोकन निकाय प्रकार के साथ आवश्यक वन-टू-मैनी संबंध के साथ `TokenBalance` निकाय प्रकार परिभाषित करें:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### रिवर्स लुकअप

उल्टे लुकअप को किसी इकाई पर `@derivedFrom` फ़ील्ड के माध्यम से परिभाषित किया जा सकता है। यह इकाई पर एक आभासी क्षेत्र बनाता है जिसे क्वेरी किया जा सकता है लेकिन मैपिंग एपीआई के माध्यम से मैन्युअल रूप से सेट नहीं किया जा सकता है। बल्कि, यह दूसरे निकाय पर परिभाषित संबंध से प्राप्त होता है। इस तरह के रिश्तों के लिए, रिश्ते के दोनों पक्षों को स्टोर करने के लिए यह शायद ही कभी समझ में आता है, और इंडेक्सिंग और क्वेरी प्रदर्शन दोनों बेहतर होंगे जब केवल एक पक्ष संग्रहीत किया जाता है और दूसरा व्युत्पन्न होता है।

एक-से-अनेक संबंधों के लिए, संबंध को हमेशा 'एक' पक्ष में संग्रहीत किया जाना चाहिए, और 'अनेक' पक्ष हमेशा निकाला जाना चाहिए। संबंधों को इस तरह से संग्रहीत करने के बजाय, 'अनेक' पक्ष पर संस्थाओं की एक सरणी संग्रहीत करने के परिणामस्वरूप, सबग्राफ को अनुक्रमित करने और क्वेरी करने दोनों के लिए नाटकीय रूप से बेहतर प्रदर्शन होगा। सामान्य तौर पर, संस्थाओं की सरणियों को संग्रहीत करने से जितना संभव हो उतना बचा जाना चाहिए।

#### उदाहरण

`tokenBalances` फ़ील्ड प्राप्त करके हम टोकन से टोकन के लिए शेष राशि को सुलभ बना सकते हैं:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

#### अनेक-से-अनेक संबंध

मैनी-टू-मैनी संबंधों के लिए, जैसे कि प्रत्येक उपयोगकर्ता किसी भी संख्या में संगठनों से संबंधित हो सकता है, सबसे सरल, लेकिन आम तौर पर सबसे अधिक प्रदर्शनकारी नहीं, संबंध को मॉडल करने का तरीका शामिल दो संस्थाओं में से प्रत्येक में एक सरणी के रूप में है। यदि संबंध सममित है, तो संबंध के केवल एक पक्ष को संग्रहित करने की आवश्यकता है और दूसरे पक्ष को व्युत्पन्न किया जा सकता है।

#### उदाहरण

Define a reverse lookup from a `User` entity type to an `Organization` entity type. In the example below, this is achieved by looking up the `members` attribute from within the `Organization` entity. In queries, the `organizations` field on `User` will be resolved by finding all `Organization` entities that include the user's ID.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

इस संबंध को संग्रहीत करने का एक अधिक प्रभावशाली तरीका एक मैपिंग टेबल के माध्यम से है जिसमें प्रत्येक `उपयोगकर्ता` / `संगठन` जोड़ी के लिए स्कीमा के साथ एक प्रविष्टि है

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

इस दृष्टिकोण के लिए आवश्यक है कि प्रश्नों को पुनः प्राप्त करने के लिए एक अतिरिक्त स्तर में उतरना पड़े, उदाहरण के लिए, उपयोगकर्ताओं के लिए संगठन:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

मैनी-टू-मैनी संबंधों को संग्रहीत करने के इस अधिक विस्तृत तरीके के परिणामस्वरूप सबग्राफ के लिए कम डेटा संग्रहीत होगा, और इसलिए एक सबग्राफ के लिए जो अक्सर इंडेक्स और क्वेरी के लिए नाटकीय रूप से तेज़ होता है।

#### स्कीमा में टिप्पणियां जोड़ना

रेखांकन विनिर्देश के अनुसार, डबल कोटेशन `""` का उपयोग करके स्कीमा इकाई विशेषताओं के ऊपर टिप्पणियाँ जोड़ी जा सकती हैं। यह नीचे दिए गए उदाहरण में दिखाया गया है:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: Bytes!
  address: Bytes!
}
```

## फुलटेक्स्ट सर्च फील्ड्स को परिभाषित करना

पूर्ण पाठ खोज क्वेरी फ़िल्टर करती है और पाठ खोज इनपुट के आधार पर संस्थाओं को रैंक करती है। अनुक्रमित टेक्स्ट डेटा से तुलना करने से पहले क्वेरी टेक्स्ट इनपुट को तने में संसाधित करके पूर्ण टेक्स्ट क्वेरी समान शब्दों के लिए मैच वापस करने में सक्षम हैं।

एक पूर्ण पाठ क्वेरी परिभाषा में क्वेरी का नाम, पाठ फ़ील्ड को संसाधित करने के लिए उपयोग किया जाने वाला भाषा शब्दकोश, परिणामों को क्रमबद्ध करने के लिए उपयोग किया जाने वाला रैंकिंग एल्गोरिदम और खोज में शामिल फ़ील्ड शामिल हैं। प्रत्येक पूर्ण-पाठ क्वेरी में कई फ़ील्ड शामिल हो सकते हैं, लेकिन सभी शामिल फ़ील्ड एक इकाई प्रकार से होने चाहिए।

फुलटेक्स्ट क्वेरी जोड़ने के लिए, ग्राफक्यूएल स्कीमा में एक `_Schema_` टाइप को फुलटेक्स्ट डायरेक्टिव के साथ शामिल करें।

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

`नाम`, `विवरण</0 में टेक्स्ट दस्तावेज़ों के आधार पर <code>बैंड` इकाइयों को फ़िल्टर करने के लिए उदाहरण `बैंडसर्च` फ़ील्ड का उपयोग प्रश्नों में किया जा सकता है >, और `जैव` फ़ील्ड। पूर्ण पाठ खोज API और अधिक उदाहरण उपयोग के विवरण के लिए [GraphQL API - क्वेरीज़](/querying/graphql-api#queries) पर जायें।

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[सुविधा प्रबंधन](#experimental-features):** `specVersion` `0.0.4</code से > और आगे, <code>fullTextSearch` को सबग्राफ मेनिफेस्ट में `फीचर्स` सेक्शन के तहत घोषित किया जाना चाहिए।

### भाषाओं का समर्थन किया

एक अलग भाषा का चयन एक निश्चित, हालांकि कभी-कभी सूक्ष्म, पूर्ण पाठ खोज एपीआई पर प्रभाव डालेगा। पूर्ण-पाठ क्वेरी फ़ील्ड द्वारा कवर किए गए फ़ील्ड को चुनी हुई भाषा के संदर्भ में जांचा जाता है, इसलिए विश्लेषण और खोज क्वेरी द्वारा उत्पन्न शब्दांश भाषा से भाषा में भिन्न होते हैं। उदाहरण के लिए: समर्थित तुर्की शब्दकोश "टोकन" का उपयोग करते समय "टोकन" के लिए स्टेम किया जाता है, जबकि निश्चित रूप से, अंग्रेजी शब्दकोश इसे "टोकन" के लिए स्टेम करेगा।

समर्थित भाषा शब्दकोश:

| कोड    | शब्दकोष    |
| ------ | ---------- |
| simple | आम         |
| da     | डेनिश      |
| nl     | डच         |
| en     | अंग्रेज़ी  |
| fi     | फिनिश      |
| fr     | फ्रेंच     |
| de     | जर्मन      |
| hu     | हंगेरी     |
| it     | इतालवी     |
| no     | नार्वेजियन |
| pt     | पुर्तगाली  |
| ro     | रोमानियाई  |
| ru     | रूसी       |
| es     | स्पैनिश    |
| sv     | स्वीडिश    |
| tr     | तुर्की     |

### रैंकिंग एल्गोरिदम

परिणाम ऑर्डर करने के लिए समर्थित एल्गोरिदम:

| एल्गोरिदम     | विवरण                                                                                     |
| ------------- | ----------------------------------------------------------------------------------------- |
| rank          | परिणामों को व्यवस्थित करने के लिए पूर्ण पाठ क्वेरी की मिलान गुणवत्ता (0-1) का उपयोग करें। |
| proximityRank | रैंक के समान लेकिन इसमें मैचों की निकटता भी शामिल है।                                     |

## मैपिंग लिखना

मैपिंग एक विशेष स्रोत से डेटा लेती है और इसे उन संस्थाओं में बदल देती है जो आपके स्कीमा के भीतर परिभाषित हैं। मैपिंग को [टाइपस्क्रिप्ट](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) के उपसमुच्चय में लिखा जाता है जिसे [असेंबलीस्क्रिप्ट](https://github.com/AssemblyScript/assemblyscript/wiki) कहा जाता है जिसे WASM ([WebAssembly](https://webassembly.org/)) में संकलित किया जा सकता है। असेंबलीस्क्रिप्ट सामान्य टाइपस्क्रिप्ट की तुलना में सख्त है, फिर भी एक परिचित सिंटैक्स प्रदान करता है।

प्रत्येक ईवेंट हैंडलर के लिए जो `subgraph.yaml` `mapping.eventHandlers` के अंतर्गत परिभाषित है, उसी नाम का एक निर्यातित फ़ंक्शन बनाएं। प्रत्येक हैंडलर को `event` नामक एकल पैरामीटर को उस ईवेंट के नाम के अनुरूप एक प्रकार के साथ स्वीकार करना होगा जिसे संभाला जा रहा है।

उदाहरण के सबग्राफ में, `src/mapping.ts` में `NewGravatar` और `UpdatedGravatar` ईवेंट के लिए हैंडलर शामिल हैं:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id)
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

पहला हैंडलर `NewGravatar` ईवेंट लेता है और `new Gravatar(event.params.id.toHex())` के साथ एक नया `Gravatar` इकाई बनाता है, जो पॉप्युलेट करता है संबंधित ईवेंट पैरामीटर का उपयोग करके निकाय फ़ील्ड. इस इकाई उदाहरण को `event.params.id.toHex()` के आईडी मान के साथ वेरिएबल `gravatar` द्वारा दर्शाया गया है।

दूसरा हैंडलर ग्राफ़ नोड स्टोर से मौजूदा `Gravatar` को लोड करने का प्रयास करता है। यदि यह अभी तक मौजूद नहीं है, तो इसे ऑन-डिमांड बनाया गया है। इसके बाद इकाई को `gravatar.save()` का उपयोग करके स्टोर में वापस सहेजे जाने से पहले नए ईवेंट पैरामीटर से मेल खाने के लिए अपडेट किया जाता है।

### नई संस्थाओं को बनाने के लिए अनुशंसित आईडी

प्रत्येक इकाई के पास एक `id` होना चाहिए जो एक ही प्रकार की सभी संस्थाओं के बीच अद्वितीय हो। किसी इकाई का `आईडी` मान तब सेट किया जाता है जब इकाई बनाई जाती है। नीचे कुछ सुझाए गए `आईडी` मान दिए गए हैं जिन पर नई इकाइयां बनाते समय विचार किया जाना चाहिए। नोट: `आईडी` का मान एक `स्ट्रिंग` होना चाहिए।

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

We provide the [Graph Typescript Library](https://github.com/graphprotocol/graph-ts) which contains utilities for interacting with the Graph Node store and conveniences for handling smart contract data and entities. You can use this library in your mappings by importing `@graphprotocol/graph-ts` in `mapping.ts`.

## कोड जनरेशन

स्मार्ट कॉन्ट्रैक्ट्स, इवेंट्स और एंटिटीज के साथ काम करना आसान और टाइप-सेफ बनाने के लिए, ग्राफ सीएलआई सबग्राफ के ग्राफक्यूएल स्कीमा और डेटा स्रोतों में शामिल कॉन्ट्रैक्ट एबीआई से असेंबलीस्क्रिप्ट प्रकार उत्पन्न कर सकता है।

इसके साथ किया जाता है

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

लेकिन ज्यादातर मामलों में, सबग्राफ पहले से ही `package.json` के माध्यम से पूर्व-कॉन्फ़िगर किए जाते हैं ताकि आप इसे प्राप्त करने के लिए निम्न में से किसी एक को चला सकें:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

यह `subgraph.yaml` में वर्णित एबीआई फाइलों में प्रत्येक स्मार्ट अनुबंध के लिए एक असेंबलीस्क्रिप्ट क्लास उत्पन्न करेगा, जिससे आप इन अनुबंधों को मैपिंग में विशिष्ट पतों से बाँध सकते हैं और ब्लॉक होने के खिलाफ केवल-पढ़ने वाली अनुबंध विधियों को कॉल कर सकते हैं। संसाधित। यह प्रत्येक अनुबंध घटना के लिए एक वर्ग भी उत्पन्न करेगा, जो घटना के मापदंडों तक आसान पहुँच प्रदान करेगा, साथ ही ब्लॉक और लेन-देन की घटना से उत्पन्न हुआ। ये सभी प्रकार `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts` को लिखे जाते हैं। उदाहरण के सबग्राफ में, यह `उत्पन्न/ग्रेविटी/ग्रेविटी.टीएस` होगा, जिससे मैपिंग को इन प्रकारों को आयात करने की अनुमति मिलेगी।

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

इसके अलावा, सबग्राफ के ग्राफक्यूएल स्कीमा में प्रत्येक इकाई प्रकार के लिए एक वर्ग उत्पन्न होता है। ये क्लासेस टाइप-सेफ एंटिटी लोडिंग, एंटिटी फील्ड्स तक रीड और राइट एक्सेस के साथ-साथ स्टोर करने के लिए एंटिटीज लिखने के लिए `save()` मेथड मुहैया कराती हैं। सभी निकाय वर्ग `<OUTPUT_DIR>/schema.ts` पर लिखे गए हैं, जिससे मैपिंग उन्हें आयात करने की अनुमति देती है

```javascript
import { Gravatar } from '../generated/schema'
```

> **ध्यान दें:** मेनिफेस्ट में शामिल ग्राफ़क्यूएल स्कीमा या एबीआई में हर बदलाव के बाद कोड जेनरेशन फिर से किया जाना चाहिए। सबग्राफ बनाने या तैनात करने से पहले इसे कम से कम एक बार अवश्य किया जाना चाहिए।

कोड जेनरेशन `src/mapping.ts` में आपके मैपिंग कोड की जांच नहीं करता है। यदि आप यह जांचना चाहते हैं कि अपने सबग्राफ को ग्राफ़ एक्सप्लोरर में तैनात करने का प्रयास करने से पहले, आप यार्न बिल्ड चला सकते हैं और किसी भी सिंटैक्स त्रुटियों को ठीक कर सकते हैं जो टाइपस्क्रिप्ट कंपाइलर को मिल सकती है।

## डेटा स्रोत टेम्पलेट्स

ईवीएम-संगत स्मार्ट अनुबंधों में एक सामान्य पैटर्न रजिस्ट्री या फ़ैक्टरी अनुबंधों का उपयोग होता है, जहां एक अनुबंध अन्य अनुबंधों की मनमानी संख्या का निर्माण, प्रबंधन या संदर्भ करता है, जिनमें से प्रत्येक का अपना राज्य और ईवेंट होता है।

इन उप-अनुबंधों के पते पहले से ज्ञात हो सकते हैं या नहीं भी हो सकते हैं और इनमें से कई अनुबंध समय के साथ बनाए और/या जोड़े जा सकते हैं। यही कारण है कि, ऐसे मामलों में, एक डेटा स्रोत या डेटा स्रोतों की एक निश्चित संख्या को परिभाषित करना असंभव है और अधिक गतिशील दृष्टिकोण की आवश्यकता है: _डेटा स्रोत टेम्पलेट्स_।

### मुख्य अनुबंध के लिए डेटा स्रोत

सबसे पहले, आप मुख्य अनुबंध के लिए एक नियमित डेटा स्रोत परिभाषित करते हैं। नीचे दिया गया स्निपेट [Uniswap](https://uniswap.org) एक्सचेंज फैक्ट्री अनुबंध के लिए एक सरलीकृत उदाहरण डेटा स्रोत दिखाता है। `NewExchange(address,address)` ईवेंट हैंडलर पर ध्यान दें। यह तब उत्सर्जित होता है जब फ़ैक्टरी अनुबंध द्वारा एक नया एक्सचेंज अनुबंध ऑन-चेन बनाया जाता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### गतिशील रूप से बनाए गए अनुबंधों के लिए डेटा स्रोत टेम्प्लेट

Then, you add _data source templates_ to the manifest. These are identical to regular data sources, except that they lack a pre-defined contract address under `source`. Typically, you would define one template for each type of sub-contract managed or referenced by the parent contract.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### डेटा स्रोत टेम्प्लेट को इंस्टेंट करना

अंतिम चरण में, आप किसी एक टेम्प्लेट से डायनेमिक डेटा स्रोत इंस्टेंस बनाने के लिए अपनी मुख्य अनुबंध मैपिंग को अपडेट करते हैं। इस उदाहरण में, आप `Exchange` टेम्पलेट को इम्पोर्ट करने के लिए मुख्य कॉन्ट्रैक्ट मैपिंग को बदलेंगे और नए एक्सचेंज कॉन्ट्रैक्ट को इंडेक्स करना शुरू करने के लिए उस पर `Exchange.create(address)` मेथड को कॉल करेंगे।

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **ध्यान दें:** एक नया डेटा स्रोत केवल उस ब्लॉक के लिए कॉल और ईवेंट को प्रोसेस करेगा जिसमें इसे बनाया गया था और सभी बाद के ब्लॉक, लेकिन ऐतिहासिक डेटा, यानी डेटा को प्रोसेस नहीं करेगा जो पिछले ब्लॉकों में निहित है।
>
> यदि पिछले ब्लॉक में नए डेटा स्रोत के लिए प्रासंगिक डेटा है, तो उस डेटा को अनुबंध की वर्तमान स्थिति को पढ़कर और नए डेटा स्रोत के निर्माण के समय उस स्थिति का प्रतिनिधित्व करने वाली संस्थाओं का निर्माण करना सबसे अच्छा है।

### डेटा स्रोत प्रसंग

डेटा स्रोत संदर्भ किसी टेम्प्लेट को इंस्टेंट करते समय अतिरिक्त कॉन्फ़िगरेशन पास करने की अनुमति देते हैं। हमारे उदाहरण में, मान लें कि एक्सचेंज एक विशेष ट्रेडिंग जोड़ी से जुड़े हैं, जो `NewExchange` इवेंट में शामिल है। उस जानकारी को तात्कालिक डेटा स्रोत में पास किया जा सकता है, जैसे:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

`Exchange` टेम्प्लेट की मैपिंग के अंदर, संदर्भ तक पहुँचा जा सकता है:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

सभी प्रकार के मूल्य के लिए `setString` और `getString` जैसे सेटर्स और गेटर्स हैं।

## Start Blocks

`StartBlock` एक वैकल्पिक सेटिंग है जो आपको यह परिभाषित करने की अनुमति देती है कि श्रृंखला में किस ब्लॉक से डेटा स्रोत अनुक्रमण शुरू करेगा। स्टार्ट ब्लॉक सेट करने से डेटा स्रोत संभावित रूप से अप्रासंगिक लाखों ब्लॉक को छोड़ देता है। आमतौर पर, एक सबग्राफ डेवलपर `स्टार्टब्लॉक` को उस ब्लॉक पर सेट करेगा जिसमें डेटा स्रोत का स्मार्ट अनुबंध बनाया गया था।

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **ध्यान दें:** इथरस्कैन पर अनुबंध निर्माण ब्लॉक को जल्दी से देखा जा सकता है:
>
> 1. खोज बार में उसका पता दर्ज करके अनुबंध की खोज करें।
> 2. `अनुबंध निर्माता` अनुभाग में निर्माण लेनदेन हैश पर क्लिक करें।
> 3. लेन-देन विवरण पृष्ठ लोड करें जहां आपको उस अनुबंध के लिए प्रारंभ ब्लॉक मिलेगा।

## कॉल हैंडलर्स

जबकि घटनाएँ एक अनुबंध की स्थिति में प्रासंगिक परिवर्तन एकत्र करने का एक प्रभावी तरीका प्रदान करती हैं, कई अनुबंध गैस लागतों को अनुकूलित करने के लिए लॉग उत्पन्न करने से बचते हैं। इन मामलों में, एक सबग्राफ डेटा स्रोत अनुबंध में किए गए कॉलों की सदस्यता ले सकता है। यह फ़ंक्शन सिग्नेचर और मैपिंग हैंडलर को संदर्भित करने वाले कॉल हैंडलर को परिभाषित करके प्राप्त किया जाता है जो इस फ़ंक्शन को कॉल संसाधित करेगा। इन कॉल्स को प्रोसेस करने के लिए, मैपिंग हैंडलर को `ethereum.Call` एक आर्गुमेंट के रूप में प्राप्त होगा, जिसमें टाइप किए गए इनपुट और कॉल के आउटपुट होंगे। लेन-देन की कॉल श्रृंखला में किसी भी गहराई पर किए गए कॉल मैपिंग को ट्रिगर करेंगे, जिससे प्रॉक्सी अनुबंधों के माध्यम से डेटा स्रोत अनुबंध के साथ गतिविधि को कैप्चर किया जा सकेगा।

कॉल हैंडलर केवल दो मामलों में से एक में ट्रिगर होंगे: जब निर्दिष्ट फ़ंक्शन को अनुबंध के अलावा किसी अन्य खाते द्वारा कॉल किया जाता है या जब इसे सॉलिडिटी में बाहरी के रूप में चिह्नित किया जाता है और उसी अनुबंध में किसी अन्य फ़ंक्शन के भाग के रूप में कॉल किया जाता है।

> **ध्यान दें:** कॉल हैंडलर वर्तमान में समता अनुरेखण API पर निर्भर करते हैं। बीएनबी चेन और आर्बिट्रम जैसे कुछ नेटवर्क इस एपीआई का समर्थन नहीं करते हैं। यदि इन नेटवर्कों में से किसी एक सबग्राफ इंडेक्सिंग में एक या अधिक कॉल हैंडलर हैं, तो यह सिंक करना शुरू नहीं करेगा। सबग्राफ डेवलपर्स को इसके बजाय इवेंट हैंडलर्स का उपयोग करना चाहिए। ये कॉल हैंडलर्स की तुलना में कहीं अधिक प्रदर्शनकारी हैं, और प्रत्येक ईवीएम नेटवर्क पर समर्थित हैं।

### कॉल हैंडलर को परिभाषित करना

अपने मेनिफेस्ट में कॉल हैंडलर को परिभाषित करने के लिए, आप जिस डेटा स्रोत की सदस्यता लेना चाहते हैं, उसके तहत बस एक `callHandlers` सरणी जोड़ें।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

`फ़ंक्शन` कॉल को फ़िल्टर करने के लिए सामान्यीकृत फ़ंक्शन सिग्नेचर है। `हैंडलर` गुण आपकी मैपिंग में उस फ़ंक्शन का नाम है जिसे आप तब निष्पादित करना चाहेंगे जब डेटा स्रोत अनुबंध में लक्ष्य फ़ंक्शन को कॉल किया जाता है।

### मानचित्रण समारोह

प्रत्येक कॉल हैंडलर एक पैरामीटर लेता है जिसमें कॉल किए गए फ़ंक्शन के नाम से संबंधित प्रकार होता है। उपरोक्त उदाहरण सबग्राफ में, मैपिंग में एक हैंडलर होता है जब `createGravatar` फ़ंक्शन को कॉल किया जाता है और `CreateGravatarCall` पैरामीटर को तर्क के रूप में प्राप्त होता है:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

The `handleCreateGravatar` function takes a new `CreateGravatarCall` which is a subclass of `ethereum.Call`, provided by `@graphprotocol/graph-ts`, that includes the typed inputs and outputs of the call. The `CreateGravatarCall` type is generated for you when you run `graph codegen`.

## ब्लॉक हैंडलर

Contract events या function calls की सदस्यता लेने के अलावा, एक subgraph अपने data को update करना चाह सकता है क्योंकि chain में नए blocks जोड़े जाते हैं। इसे प्राप्त करने के लिए एक subgraph every block के बाद या pre-defined filter से match होन वाले block के बाद एक function चला सकता है।

### समर्थित फ़िल्टर

#### Call Filter

```yaml
filter:
  kind: call
```

_परिभाषित हैंडलर को प्रत्येक ब्लॉक के लिए एक बार कॉल किया जाएगा जिसमें अनुबंध (डेटा स्रोत) के लिए कॉल शामिल है जिसे हैंडलर के तहत परिभाषित किया गया है।_

> **ध्यान दें:** `कॉल` फ़िल्टर फ़िलहाल पैरिटी ट्रेसिंग API पर निर्भर करता है। बीएनबी चेन और आर्बिट्रम जैसे कुछ नेटवर्क इस एपीआई का समर्थन नहीं करते हैं। अगर इन नेटवर्कों में से किसी एक सबग्राफ इंडेक्सिंग में `कॉल` फिल्टर के साथ एक या अधिक ब्लॉक हैंडलर हैं, तो यह सिंक करना शुरू नहीं करेगा।

ब्लॉक हैंडलर के लिए फ़िल्टर की अनुपस्थिति सुनिश्चित करेगी कि हैंडलर को प्रत्येक ब्लॉक कहा जाता है। डेटा स्रोत में प्रत्येक फ़िल्टर प्रकार के लिए केवल एक ब्लॉक हैंडलर हो सकता है।

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

#### Polling Filter

> **Requires `specVersion` >= 0.0.8**

> **Note:** Polling filters are only available on dataSources of `kind: ethereum`.

```yaml
blockHandlers:
  - handler: handleBlock
    filter:
      kind: polling
      every: 10
```

The defined handler will be called once for every `n` blocks, where `n` is the value provided in the `every` field. This configuration allows the subgraph to perform specific operations at regular block intervals.

#### Once Filter

> **Requires `specVersion` >= 0.0.8**

> **Note:** Once filters are only available on dataSources of `kind: ethereum`.

```yaml
blockHandlers:
  - handler: handleOnce
    filter:
      kind: once
```

The defined handler with the once filter will be called only once before all other handlers run. This configuration allows the subgraph to use the handler as an initialization handler, performing specific tasks at the start of indexing.

```ts
export function handleOnce(block: ethereum.Block): void {
  let data = new InitialData(Bytes.fromUTF8('initial'))
  data.data = 'Setup data here'
  data.save()
}
```

### मानचित्रण समारोह

The mapping function will receive an `ethereum.Block` as its only argument. Like mapping functions for events, this function can access existing subgraph entities in the store, call smart contracts and create or update entities.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## अनाम घटनाएँ

यदि आपको अनाम घटनाओं को सॉलिडिटी में संसाधित करने की आवश्यकता है, तो इसे घटना के विषय 0 प्रदान करके प्राप्त किया जा सकता है, जैसा कि उदाहरण में है:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

एक घटना तभी शुरू होगी जब दोनों हस्ताक्षर और विषय 0 मेल खाते हों। डिफ़ॉल्ट रूप से, `topic0` इवेंट सिग्नेचर के हैश के बराबर है।

## इवेंट हैंडलर में लेनदेन रसीदें

`specVersion` `0.0.5` और `apiVersion` `0.0.7` से शुरू होकर, ईवेंट हैंडलर्स के पास रसीद तक ​​पहुंच हो सकती है लेनदेन जो उन्हें उत्सर्जित करता है।

ऐसा करने के लिए, इवेंट हैंडलर को सबग्राफ मेनिफेस्ट में नई `receipt: true` कुंजी के साथ घोषित किया जाना चाहिए, जो वैकल्पिक है और डिफ़ॉल्ट रूप से गलत है।

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

हैंडलर फ़ंक्शन के अंदर, रसीद को `Event.receipt` फ़ील्ड में एक्सेस किया जा सकता है। जब `receipt` कुंजी को `गलत` पर सेट किया जाता है या मेनिफ़ेस्ट में छोड़ दिया जाता है, तो इसके बजाय एक `शून्य` मान लौटाया जाएगा।

## प्रायोगिक विशेषताएं

`specVersion` `0.0.4` से शुरू होकर, सबग्राफ सुविधाओं को `सुविधाओं` अनुभाग में मेनिफेस्ट फ़ाइल के शीर्ष स्तर पर उनके का उपयोग करके स्पष्ट रूप से घोषित किया जाना चाहिए `camelCase` नाम, जैसा कि नीचे दी गई तालिका में सूचीबद्ध है:

| विशेषता                                                      | नाम                                                 |
| ------------------------------------------------------------ | --------------------------------------------------- |
| [गैर-घातक त्रुटियाँ](#non-fatal-errors)                      | `nonFatalErrors`                                    |
| [पूरा पाठ खोजें](#defining-fulltext-search-fields)           | `fullTextSearch`                                    |
| [ग्राफ्टिंग](#grafting-onto-existing-subgraphs)              | `grafting`                                          |
| [इथेरियम कॉन्ट्रैक्ट्स पर IPFS](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` or `nonDeterministicIpfs` |

उदाहरण के लिए, यदि कोई सबग्राफ **पूर्ण-पाठ खोज** और **गैर-घातक त्रुटियां** सुविधाओं का उपयोग करता है, तो मेनिफेस्ट में `सुविधाएं` फ़ील्ड होना चाहिए:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

ध्यान दें कि किसी सुविधा को घोषित किए बिना उसका उपयोग करने से सबग्राफ परिनियोजन के दौरान **सत्यापन त्रुटि** उत्पन्न होगी, लेकिन यदि सुविधा घोषित की जाती है लेकिन उसका उपयोग नहीं किया जाता है, तो कोई त्रुटि उत्पन्न नहीं होगी.

### इथेरियम कॉन्ट्रैक्ट्स पर IPFS

IPFS को एथेरियम के साथ संयोजित करने के लिए एक सामान्य उपयोग का मामला IPFS पर डेटा संग्रहीत करना है जो ऑन-चेन बनाए रखने के लिए बहुत महंगा होगा, और Ethereum अनुबंधों में IPFS हैश का संदर्भ देगा।

ऐसे IPFS हैश को देखते हुए, सबग्राफ `ipfs.cat` और `ipfs.map` का उपयोग करके IPFS से संबंधित फ़ाइलों को पढ़ सकते हैं। इसे मज़बूती से करने के लिए, यह आवश्यक है कि इन फ़ाइलों को उच्च उपलब्धता वाले IPFS नोड पर पिन किया जाए, ताकि [होस्ट की गई सेवा](https://thegraph.com/hosted-service) IPFS नोड अनुक्रमण के दौरान उन्हें ढूंढ सके।

> **ध्यान दें:** ग्राफ़ नेटवर्क अभी तक `ipfs.cat` और `ipfs.map` का समर्थन नहीं करता है, और डेवलपर्स को परिनियोजित नहीं करना चाहिए स्टूडियो के माध्यम से नेटवर्क के लिए उस कार्यक्षमता का उपयोग करने वाले सबग्राफ।

> **[सुविधा प्रबंधन](#experimental-features):** `ipfsOnEthereumContracts` को सबग्राफ मेनिफ़ेस्ट में `सुविधाओं` के अंतर्गत घोषित किया जाना चाहिए। गैर ईवीएम श्रृंखलाओं के लिए, इसी उद्देश्य के लिए `nonDeterministicIpfs` उपनाम का भी उपयोग किया जा सकता है।

स्थानीय ग्राफ़ नोड चलाते समय, `GRAPH_ALLOW_NON_DETERMINISTIC_IPFS` पर्यावरण चर सेट किया जाना चाहिए ताकि इस प्रायोगिक कार्यक्षमता का उपयोग करके सबग्राफ को अनुक्रमित किया जा सके।

### गैर-घातक त्रुटियाँ

पहले से सिंक किए गए सबग्राफ पर इंडेक्सिंग त्रुटियां, डिफ़ॉल्ट रूप से, सबग्राफ को विफल कर देंगी और सिंक करना बंद कर देंगी। सबग्राफ को वैकल्पिक रूप से त्रुटियों की उपस्थिति में समन्वयन जारी रखने के लिए कॉन्फ़िगर किया जा सकता है, हैंडलर द्वारा किए गए परिवर्तनों को अनदेखा करके त्रुटि उत्पन्न हुई। यह सबग्राफ लेखकों को अपने सबग्राफ को ठीक करने का समय देता है, जबकि नवीनतम ब्लॉक के विरुद्ध प्रश्नों को जारी रखा जाता है, हालांकि त्रुटि के कारण बग के कारण परिणाम असंगत हो सकते हैं। ध्यान दें कि कुछ त्रुटियाँ अभी भी हमेशा घातक होती हैं। गैर-घातक होने के लिए, त्रुटि नियतात्मक होने के लिए जानी जानी चाहिए।

> **नोट:** ग्राफ़ नेटवर्क अभी तक गैर-घातक त्रुटियों का समर्थन नहीं करता है, और डेवलपर्स को स्टूडियो के माध्यम से नेटवर्क पर उस कार्यक्षमता का उपयोग करके सबग्राफ तैनात नहीं करना चाहिए।

गैर-घातक त्रुटियों को सक्षम करने के लिए सबग्राफ मेनिफ़ेस्ट पर निम्न फ़ीचर फ़्लैग सेट करने की आवश्यकता होती है:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - nonFatalErrors
    ...
```

क्वेरी को `subgraphError` तर्क के माध्यम से संभावित विसंगतियों वाले डेटा को क्वेरी करने के लिए भी ऑप्ट-इन करना चाहिए। यह जाँचने के लिए `_meta` को क्वेरी करने की भी सिफारिश की जाती है कि क्या सबग्राफ ने त्रुटियों को छोड़ दिया है, जैसा कि उदाहरण में दिया गया है:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

यदि सबग्राफ में कोई त्रुटि आती है, तो वह क्वेरी `"indexing_error"` संदेश के साथ डेटा और ग्राफ़कल त्रुटि दोनों वापस कर देगी, जैसा कि इस उदाहरण प्रतिक्रिया में है:

```graphql
"data": {
    "foos": [
        {
          "id": "0xdead"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### मौजूदा सबग्राफ पर ग्राफ्टिंग

> **Note:** it is not recommended to use grafting when initially upgrading to The Graph Network. Learn more [here](/cookbook/grafting/#important-note-on-grafting-when-upgrading-to-the-network).

When a subgraph is first deployed, it starts indexing events at the genesis block of the corresponding chain (or at the `startBlock` defined with each data source) In some circumstances; it is beneficial to reuse the data from an existing subgraph and start indexing at a much later block. This mode of indexing is called _Grafting_. Grafting is, for example, useful during development to get past simple errors in the mappings quickly or to temporarily get an existing subgraph working again after it has failed.

जब `subgraph.yaml` में सबग्राफ मेनिफेस्ट में `graft` ब्लॉक होता है तो एक सबग्राफ को बेस सबग्राफ पर ग्राफ्ट किया जाता है:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

जब एक सबग्राफ जिसके मेनिफ़ेस्ट में `graft` ब्लॉक होता है, तैनात किया जाता है, तो ग्राफ़ नोड दिए गए `ब्लॉक` सहित `base` सबग्राफ़ के डेटा को कॉपी करेगा और उसके बाद उस ब्लॉक से नए सबग्राफ को अनुक्रमणित करना जारी रखें। बेस सबग्राफ लक्ष्य ग्राफ़ नोड उदाहरण पर मौजूद होना चाहिए और कम से कम दिए गए ब्लॉक तक अनुक्रमित होना चाहिए। इस प्रतिबंध के कारण, ग्राफ्टिंग का उपयोग केवल विकास के दौरान या किसी आपात स्थिति के दौरान समकक्ष गैर-ग्राफ्टेड सबग्राफ के उत्पादन में तेजी लाने के लिए किया जाना चाहिए।

क्योंकि आधार डेटा को अनुक्रमित करने के बजाय प्रतियों को ग्राफ्ट करना, स्क्रैच से अनुक्रमणित करने की तुलना में सबग्राफ को वांछित ब्लॉक में प्राप्त करना बहुत तेज है, हालांकि बहुत बड़े सबग्राफ के लिए प्रारंभिक डेटा कॉपी में अभी भी कई घंटे लग सकते हैं। जबकि ग्राफ्टेड सबग्राफ को इनिशियलाइज़ किया जा रहा है, ग्राफ़ नोड उन एंटिटी प्रकारों के बारे में जानकारी लॉग करेगा जो पहले ही कॉपी किए जा चुके हैं।

ग्राफ्टेड सबग्राफ एक ग्राफक्यूएल स्कीमा का उपयोग कर सकता है जो बेस सबग्राफ के समान नहीं है, लेकिन इसके साथ केवल संगत है। यह अपने आप में एक मान्य सबग्राफ स्कीमा होना चाहिए, लेकिन निम्नलिखित तरीकों से बेस सबग्राफ के स्कीमा से विचलित हो सकता है:

- यह इकाई प्रकार जोड़ता या हटाता है
- यह इकाई प्रकारों से विशेषताएँ निकालता है
- यह प्रभावहीन गुणों को इकाई प्रकारों में जोड़ता है|
- यह प्रभाव वाले गुणों को प्रभावहीन गुणों में बदल देता है|
- यह इनम्स में महत्व देता है|
- यह इंटरफेस जोड़ता या हटाता है|
- यह कि, किन इकाई प्रकारों के लिए इंटरफ़ेस लागू होगा, इसे बदल देता है|

> **[सुविधा प्रबंधन](#experimental-features):** `ग्राफ्टिंग` को `विशेषताओं` के अंतर्गत घोषित किया जाना चाहिए कोड सबग्राफ मेनिफेस्ट में।

## फ़ाइल डेटा स्रोत

File data sources are a new subgraph functionality for accessing off-chain data during indexing in a robust, extendable way. File data sources support fetching files from IPFS and from Arweave.

> यह ऑफ-चेन डेटा के नियतात्मक अनुक्रमण के साथ-साथ स्वैच्छिक HTTP-स्रोत डेटा के संभावित परिचय के लिए आधार भी देता है।

### अवलोकन

हैंडलर निष्पादन के दौरान "इन लाइन" फ़ाइलों को लाने के बजाय, यह उन टेम्पलेट्स को प्रस्तुत करता है जिन्हें किसी दिए गए फ़ाइल पहचानकर्ता के लिए नए डेटा स्रोतों के रूप में उत्पन्न किया जा सकता है। ये नए डेटा स्रोत फ़ाइलें प्राप्त करते हैं, असफल होने पर पुनः प्रयास करते हैं, फ़ाइल मिलने पर एक समर्पित हैंडलर चलाते हैं।

यह [मौजूदा डेटा स्रोत टेम्प्लेट](https://thegraph.com/docs/en/developing/creating-a-subgraph/#data-source-templates) के समान है, जिनका उपयोग किया जाता है नए श्रृंखला-आधारित डेटा स्रोतों को गतिशील रूप से बनाने के लिए।

> यह मौजूदा `ipfs.cat` API को प्रतिस्थापित करता है

### Upgrade guide

#### `ग्राफ़-टीएस` और `ग्राफ़-क्ली` अपडेट करें

फ़ाइल डेटा स्रोतों के लिए ग्राफ़-टीएस >=0.29.0 और ग्राफ़-क्ली >=0.33.1 की आवश्यकता होती है

#### एक नया इकाई प्रकार जोड़ें जो फ़ाइलें मिलने पर अपडेट किया जाएगा

फ़ाइल डेटा स्रोत श्रृंखला-आधारित संस्थाओं तक पहुँच या अद्यतन नहीं कर सकते हैं, लेकिन फ़ाइल विशिष्ट संस्थाओं को अद्यतन करना चाहिए।

इसका मतलब हो सकता है कि फ़ील्ड को मौजूदा इकाइयों से अलग-अलग इकाइयों में विभाजित करना, एक साथ जुड़े हुए।

मूल संयुक्त इकाई:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  externalURL: String!
  ipfsURI: String!
  image: String!
  name: String!
  description: String!
  type: String!
  updatedAtTimestamp: BigInt
  owner: User!
}
```

नई, विभाजित इकाई:

```graphql
type Token @entity {
  id: ID!
  tokenID: BigInt!
  tokenURI: String!
  ipfsURI: TokenMetadata
  updatedAtTimestamp: BigInt
  owner: String!
}

type TokenMetadata @entity {
  id: ID!
  image: String!
  externalURL: String!
  name: String!
  description: String!
}
```

यदि पैरेंट इकाई और परिणामी फ़ाइल डेटा स्रोत इकाई के बीच संबंध 1:1 है, तो सबसे सरल पैटर्न मूल इकाई को लुकअप के रूप में IPFS CID का उपयोग करके परिणामी फ़ाइल इकाई से लिंक करना है। यदि आपको अपनी नई फ़ाइल-आधारित संस्थाओं को मॉडलिंग करने में कठिनाई हो रही है, तो डिस्कॉर्ड पर संपर्क करें!

> आप इन नेस्टेड इकाइयों के आधार पर पैरेंट इकाइयों को फ़िल्टर करने के लिए [नेस्टेड फ़िल्टर](https://thegraph.com/docs/en/querying/graphql-api/#example-for-nested-entity-filtering) का उपयोग कर सकते हैं।

#### Add a new templated data source with `kind: file/ipfs` or `kind: file/arweave`

यह वह डेटा स्रोत है जो ब्याज की फ़ाइल की पहचान होने पर उत्पन्न होगा।

```yaml
templates:
  - name: TokenMetadata
    kind: file/ipfs
    mapping:
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      file: ./src/mapping.ts
      handler: handleMetadata
      entities:
        - TokenMetadata
      abis:
        - name: Token
          file: ./abis/Token.json
```

> वर्तमान में `abis` की आवश्यकता है, हालांकि फ़ाइल डेटा स्रोतों के भीतर से अनुबंधों को कॉल करना संभव नहीं है

फ़ाइल डेटा स्रोत को विशेष रूप से उन सभी इकाई प्रकारों का उल्लेख करना चाहिए जिनके साथ यह `इकाइयों` के तहत इंटरैक्ट करेगा। अधिक विवरण के लिए [सीमाएं](#Limitations) देखें।

#### फ़ाइलों को संसाधित करने के लिए एक नया हैंडलर बनाएँ

इस हैंडलर को एक `बाइट्स` पैरामीटर स्वीकार करना चाहिए, जो फ़ाइल के मिलने पर उसकी सामग्री होगी, जिसे बाद में संसाधित किया जा सकता है। यह अक्सर एक JSON फ़ाइल होगी, जिसे `ग्राफ़-टीएस` हेल्पर्स ([दस्तावेज़ीकरण](https://thegraph.com/docs/en/developing/assemblyscript-api/#json) के साथ प्रोसेस किया जा सकता है -api))।

पढ़ने योग्य स्ट्रिंग के रूप में फ़ाइल की CID को `dataSource` के माध्यम से निम्नानुसार एक्सेस किया जा सकता है:

```typescript
const cid = dataSource.stringParam()
```

उदाहरण हैंडलर:

```typescript
import { json, Bytes, dataSource } from '@graphprotocol/graph-ts'
import { TokenMetadata } from '../generated/schema'

export function handleMetadata(content: Bytes): void {
  let tokenMetadata = new TokenMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()
  if (value) {
    const image = value.get('image')
    const name = value.get('name')
    const description = value.get('description')
    const externalURL = value.get('external_url')

    if (name && image && description && externalURL) {
      tokenMetadata.name = name.toString()
      tokenMetadata.image = image.toString()
      tokenMetadata.externalURL = externalURL.toString()
      tokenMetadata.description = description.toString()
    }

    tokenMetadata.save()
  }
}
```

#### आवश्यक होने पर फ़ाइल डेटा स्रोत स्पॉन करें

अब आप चेन-आधारित हैंडलर के निष्पादन के दौरान फ़ाइल डेटा स्रोत बना सकते हैं:

- ऑटो-जेनरेट किए गए `टेम्पलेट्स` से टेम्प्लेट आयात करें
- call `TemplateName.create(cid: string)` from within a mapping, where the cid is a valid content identifier for IPFS or Arweave

For IPFS, Graph Node supports [v0 and v1 content identifiers](https://docs.ipfs.tech/concepts/content-addressing/), and content identifers with directories (e.g. `bafyreighykzv2we26wfrbzkcdw37sbrby4upq7ae3aqobbq7i4er3tnxci/metadata.json`).

For Arweave, as of version 0.33.0 Graph Node can fetch files stored on Arweave based on their [transaction ID](https://docs.arweave.org/developers/server/http-api#transactions) from an Arweave gateway ([example file](https://bdxujjl5ev5eerd5ouhhs6o4kjrs4g6hqstzlci5pf6vhxezkgaa.arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA)). Arweave supports transactions uploaded via Bundlr, and Graph Node can also fetch files based on [Bundlr manifests](https://docs.bundlr.network/learn/gateways#indexing).

उदाहरण:

```typescript
import { TokenMetadata as TokenMetadataTemplate } from '../generated/templates'

const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
//This example code is for a Crypto coven subgraph. The above ipfs hash is a directory with token metadata for all crypto coven NFTs.

export function handleTransfer(event: TransferEvent): void {
  let token = Token.load(event.params.tokenId.toString())
  if (!token) {
    token = new Token(event.params.tokenId.toString())
    token.tokenID = event.params.tokenId

    token.tokenURI = '/' + event.params.tokenId.toString() + '.json'
    const tokenIpfsHash = ipfshash + token.tokenURI
    //This creates a path to the metadata for a single Crypto coven NFT. It concats the directory with "/" + filename + ".json"

    token.ipfsURI = tokenIpfsHash

    TokenMetadataTemplate.create(tokenIpfsHash)
  }

  token.updatedAtTimestamp = event.block.timestamp
  token.owner = event.params.to.toHexString()
  token.save()
}
```

This will create a new file data source, which will poll Graph Node's configured IPFS or Arweave endpoint, retrying if it is not found. When the file is found, the file data source handler will be executed.

यह उदाहरण CID का उपयोग पैरेंट `Token` इकाई और परिणामी `TokenMetadata` इकाई के बीच लुकअप के रूप में कर रहा है।

> पहले, यह वह बिंदु है जिस पर एक सबग्राफ डेवलपर फ़ाइल लाने के लिए `ipfs.cat(CID)` को कॉल करता था

बधाई हो, आप फ़ाइल डेटा स्रोतों का उपयोग कर रहे हैं!

#### अपने उप-अनुच्छेदों को तैनात करना

अब आप अपने सबग्राफ को किसी भी ग्राफ़ नोड >=v0.30.0-rc.0 पर `बना` और `तैनाती` कर सकते हैं।

#### परिसीमन

फ़ाइल डेटा स्रोत हैंडलर और संस्थाएँ अन्य सबग्राफ संस्थाओं से अलग हैं, यह सुनिश्चित करते हुए कि वे निष्पादित होने पर नियतात्मक हैं, और श्रृंखला-आधारित डेटा स्रोतों का कोई संदूषण सुनिश्चित नहीं करते हैं। विस्तार से:

- फ़ाइल डेटा स्रोतों द्वारा बनाई गई इकाइयाँ अपरिवर्तनीय हैं, और इन्हें अद्यतन नहीं किया जा सकता है
- फ़ाइल डेटा स्रोत हैंडलर अन्य फ़ाइल डेटा स्रोतों से संस्थाओं तक नहीं पहुँच सकते
- फ़ाइल डेटा स्रोतों से जुड़ी संस्थाओं को चेन-आधारित हैंडलर द्वारा एक्सेस नहीं किया जा सकता है

> हालांकि यह बाधा अधिकांश उपयोग-मामलों के लिए समस्याग्रस्त नहीं होनी चाहिए, यह कुछ के लिए जटिलता का परिचय दे सकती है। यदि आपको अपने फ़ाइल-आधारित डेटा को सबग्राफ में मॉडलिंग करने में समस्या आ रही है, तो कृपया डिस्कॉर्ड के माध्यम से संपर्क करें!

इसके अतिरिक्त, फ़ाइल डेटा स्रोत से डेटा स्रोत बनाना संभव नहीं है, चाहे वह ऑनचेन डेटा स्रोत हो या अन्य फ़ाइल डेटा स्रोत। भविष्य में यह प्रतिबंध हटाया जा सकता है।

#### सर्वोत्तम प्रथाएं

यदि आप NFT मेटाडेटा को संबंधित टोकन से लिंक कर रहे हैं, तो टोकन इकाई से मेटाडेटा इकाई को संदर्भित करने के लिए मेटाडेटा के IPFS हैश का उपयोग करें। एक आईडी के रूप में IPFS हैश का उपयोग करके मेटाडेटा इकाई को सहेजें।

फ़ाइल डेटा स्रोत बनाते समय आप [DataSource प्रसंग](https://thegraph.com/docs/en/developing/assemblyscript-api/#entity-and-data-source-context) का उपयोग कर सकते हैं अतिरिक्त जानकारी पास करें जो फ़ाइल डेटा स्रोत हैंडलर के लिए उपलब्ध होगी।

यदि आपके पास ऐसे निकाय हैं जो कई बार रीफ़्रेश किए गए हैं, तो IPFS हैश & amp का उपयोग करके अद्वितीय फ़ाइल-आधारित निकाय बनाएँ; इकाई आईडी, और श्रृंखला-आधारित इकाई में एक व्युत्पन्न क्षेत्र का उपयोग करके उनका संदर्भ लें।

> हम ऊपर दिए गए सुझाव को बेहतर बनाने के लिए काम कर रहे हैं, इसलिए क्वेरी केवल "नवीनतम" संस्करण लौटाती हैं

#### ज्ञात समस्याएँ

फ़ाइल डेटा स्रोतों को वर्तमान में ABI की आवश्यकता है, भले ही ABI का उपयोग नहीं किया जाता है ([issue](https://github.com/graphprotocol/graph-cli/issues/961))। वर्कअराउंड किसी भी एबीआई को जोड़ना है।

फ़ाइल डेटा स्रोतों के लिए हैंडलर उन फ़ाइलों में नहीं हो सकते हैं जो `eth_call` अनुबंध बाइंडिंग आयात करते हैं, "अज्ञात आयात: `ethereum::ethereum.call` परिभाषित नहीं किया गया है" ([ मुद्दा](https://github.com/graphprotocol/graph-cli/issues/4309))। वर्कअराउंड एक समर्पित फ़ाइल में फ़ाइल डेटा स्रोत हैंडलर बनाना है।

#### उदाहरण

[क्रिप्टो कॉवेन सबग्राफ माइग्रेशन](https://github.com/azf20/cryptocoven-api/tree/file-data-sources-refactor)

#### संदर्भ

[GIP फ़ाइल डेटा स्रोत](https://forum.thegraph.com/t/gip-file-data-sources/2721)
