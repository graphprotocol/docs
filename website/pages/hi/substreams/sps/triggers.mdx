---
title: सबस्ट्रीम्स ट्रिगर्स
---

कस्टम ट्रिगर्स आपको अपने subgraph मैपिंग फ़ाइल और इकाइयों (टेबल और फ़ील्ड के समान) में डेटा सीधे भेजने की अनुमति देते हैं, जो GraphQL परत का पूरा उपयोग करने में सक्षम बनाते हैं। अपने Substreams मॉड्यूल द्वारा उत्पन्न Protobuf परिभाषाओं को आयात करके, आप अपने subgraph के हैंडलर के भीतर इस डेटा को प्राप्त और प्रोसेस कर सकते हैं, जो subgraph ढांचे के भीतर कुशल और सुव्यवस्थित डेटा प्रबंधन सुनिश्चित करता है।

> Note: If you haven’t already, visit one of the How-To Guides found [here](/substreams/sps/introduction/) to scaffold your first project in the Development Container.

निम्नलिखित कोड यह दर्शाता है कि कैसे एक handleTransactions फ़ंक्शन को एक subgraph हैंडलर में परिभाषित किया जा सकता है। यह फ़ंक्शन कच्चे Substreams बाइट्स को एक पैरामीटर के रूप में प्राप्त करता है और उन्हें एक Transactions ऑब्जेक्ट में डिकोड करता है। प्रत्येक लेनदेन के लिए, एक नई subgraph एंटिटी बनाई जाती है।

```tsx
export function handleTransactions(bytes: Uint8Array): void {
  let transactions = assembly.eth.transaction.v1.Transactions.decode(bytes.buffer).transactions // 1.
  if (transactions.length == 0) {
    log.info('No transactions found', [])
    return
  }

  for (let i = 0; i < transactions.length; i++) {
    // 2.
    let transaction = transactions[i]

    let entity = new Transaction(transaction.hash) // 3.
    entity.from = transaction.from
    entity.to = transaction.to
    entity.save()
  }
}
```

यहां वह है जो आप mappings.ts फ़ाइल में देख रहे हैं:

1. Substreams डेटा को जनरेट किए गए Transactions ऑब्जेक्ट में डिकोड किया जाता है, यह ऑब्जेक्ट किसी अन्य AssemblyScript ऑब्जेक्ट की तरह उपयोग किया जाता है।
2. लेनदेन पर लूप करना
3. प्रत्येक लेनदेन के लिए एक नया subgraph entity बनाएं

एक ट्रिगर-आधारित subgraph के विस्तृत उदाहरण को देखने के लिए, [यहाँ क्लिक](/substreams/sps/tutorial/) करें।
