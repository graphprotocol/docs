---
title: सर्वोत्तम प्रथाओं को क्वेरी करना
---

ग्राफ़ ब्लॉकचेन से डेटा क्वेरी करने के लिए विकेंद्रीकृत तरीका प्रदान करता है।

ग्राफ़ नेटवर्क के डेटा को ग्राफ़िकल एपीआई के माध्यम से उजागर किया जाता है, जिससे ग्राफ़िकल भाषा के साथ डेटा को क्वेरी करना आसान हो जाता है।

यह पृष्ठ आवश्यक ग्राफ़िकल भाषा नियमों और ग्राफ़कॉल प्रश्नों के सर्वोत्तम अभ्यासों के माध्यम से आपका मार्गदर्शन करेगा।

---

## ग्राफ़कॉल एपीआई को क्वेरी करना

### एक ग्राफक्यूएल क्वेरी की शारीरिक रचना

REST API के विपरीत, एक रेखांकन API एक स्कीमा पर बनाया गया है जो परिभाषित करता है कि कौन से प्रश्न किए जा सकते हैं।

उदाहरण के लिए, `token` क्वेरी का उपयोग करके टोकन प्राप्त करने के लिए एक क्वेरी इस प्रकार दिखाई देगी:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

जो निम्नलिखित अनुमानित JSON प्रतिक्रिया लौटाएगा (_उचित `$id` चर मान_ पास करते समय):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

ग्राफ़िकल क्वेरीज़ ग्राफ़िकल भाषा का उपयोग करती हैं, जिसे [एक विनिर्देश](https://spec.graphql.org/) पर परिभाषित किया गया है।

उपरोक्त `GetToken` क्वेरी कई भाषा भागों से बना है (नीचे `[...]` प्लेसहोल्डर्स के साथ प्रतिस्थापित):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

जबकि सिंटैक्टिक डू और डॉनट्स की सूची लंबी है, ग्राफक्यूएल प्रश्नों को लिखते समय ध्यान में रखने के लिए आवश्यक नियम यहां दिए गए हैं:

- प्रत्येक `क्वेरीनाम` का उपयोग प्रति ऑपरेशन केवल एक बार किया जाना चाहिए।
- प्रत्येक `फ़ील्ड` का चयन में केवल एक बार उपयोग किया जाना चाहिए (हम `आईडी` को `टोकन` के अंतर्गत दो बार क्वेरी नहीं कर सकते हैं)
- कुछ `फ़ील्ड`एस या क्वेरीज़ (जैसे `टोकन`) जटिल प्रकार लौटाते हैं जिन्हें उप-फ़ील्ड के चयन की आवश्यकता होती है। अपेक्षित होने पर चयन प्रदान नहीं करना (या अपेक्षा न होने पर चयन प्रदान करना - उदाहरण के लिए, `id` पर) एक त्रुटि उत्पन्न करेगा। किसी फ़ील्ड प्रकार को जानने के लिए, कृपया [द ग्राफ़ एक्सप्लोरर](/network/explorer) देखें।
- किसी तर्क को असाइन किया गया कोई भी चर उसके प्रकार से मेल खाना चाहिए।
- चरों की दी गई सूची में, उनमें से प्रत्येक अद्वितीय होना चाहिए।
- सभी परिभाषित चर का उपयोग किया जाना चाहिए।

उपरोक्त नियमों का पालन करने में विफल रहने पर ग्राफ़ एपीआई की त्रुटि समाप्त हो जाएगी।

कोड उदाहरणों के साथ नियमों की पूरी सूची के लिए, कृपया हमारे ग्राफक्यूएल सत्यापन गाइड को देखें।

<br />

### एक ग्राफ़क्यूएल एपीआई के लिए एक प्रश्न भेजना

ग्राफक्यूएल एक भाषा और सम्मेलनों का समूह है जो HTTP पर परिवहन करता है।

इसका अर्थ है कि आप मानक `fetch` का उपयोग करके (मूल रूप से या `@whatwg-node/fetch` या `isomorphic-fetch`) के माध्यम से किसी GraphQL API को क्वेरी कर सकते हैं।

हालांकि, जैसा कि ["एप्लिकेशन से क्वेरी करना"](/querying/querying-from-an-application) में कहा गया है, हम आपको हमारे `ग्राफ़-क्लाइंट` का उपयोग करने की सलाह देते हैं जो अद्वितीय विशेषताओं का समर्थन करता है जैसे:

- क्रॉस-चेन सबग्राफ हैंडलिंग: एक ही क्वेरी में कई सबग्राफ से पूछताछ
- [स्वचालित ब्लॉक ट्रैकिंग](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [स्वचालित पृष्ठांकन](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- पूरी तरह से टाइप किया गया परिणाम

<br />

`ग्राफ़-क्लाइंट` के साथ ग्राफ़ को क्वेरी करने का तरीका यहां दिया गया है:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

["Querying from an application"](/querying/querying-from-an-application) में और अधिक ग्राफक्यूएल क्लाइंट विकल्प शामिल हैं।

<br />

अब जब हमने ग्राफकॉल क्वेरी सिंटैक्स के बुनियादी नियमों को कवर कर लिया है, तो आइए अब हम ग्राफकॉल क्वेरी राइटिंग की सर्वोत्तम प्रथाओं को देखें।

---

## ग्राफ़क्यूएल प्रश्न लिखना

### हमेशा स्टैटिक क्वेश्चन लिखें

एक सामान्य (खराब) अभ्यास निम्नानुसार गतिशील रूप से क्वेरी स्ट्रिंग्स का निर्माण करना है:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`
```

जबकि उपरोक्त स्निपेट एक वैध ग्राफक्यूएल क्वेरी उत्पन्न करता है, **इसमें कई कमियां हैं**:

- यह संपूर्ण क्वेरी को **समझने में कठिन** बनाता है
- डेवलपर **स्ट्रिंग इंटरपोलेशन को सुरक्षित रूप से साफ़ करने के लिए ज़िम्मेदार हैं**
- अनुरोध पैरामीटर ** सर्वर-साइड पर संभावित कैशिंग को रोकें** के हिस्से के रूप में चर के मान नहीं भेज रहे हैं
- यह **टूल्स को क्वेरी का स्थिर रूप से विश्लेषण करने से रोकता है** (उदा: लिंटर, या टाइप जेनरेशन टूल्स)

इस कारण से, हमेशा स्थिर स्ट्रिंग्स के रूप में प्रश्नों को लिखने की अनुशंसा की जाती है:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

ऐसा करने से **कई फायदे** मिलते हैं:

- **पढ़ने और बनाए रखने में आसान** क्वेरीज़
- ग्राफ़क्यूएल **सर्वर वेरिएबल सैनिटाइज़ेशन को हैंडल करता है**
- सर्वर-स्तर पर **वैरिएबल को कैश किया जा सकता है**
- **क्वेरी का सांख्यिकीय रूप से विश्लेषण टूल द्वारा किया जा सकता है** (निम्न अनुभागों में इस पर अधिक)

**नोट: स्थैतिक प्रश्नों में सशर्त रूप से फ़ील्ड कैसे शामिल करें**

हो सकता है कि हम `स्वामी` फ़ील्ड को केवल किसी विशेष स्थिति में शामिल करना चाहें।

इसके लिए, हम `@include(if:...)` निर्देश का इस प्रकार लाभ उठा सकते हैं:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

नोट: विपरीत निर्देश है `@skip(if: ...)`।

<br />

### प्रदर्शन युक्तियाँ

**"आपको जो चाहिए, उसे मांगें"**

ग्राफकॉल अपने "आस्क फॉर व्हाट यू वांट" टैगलाइन के लिए प्रसिद्ध हुआ।

इस कारण से, सभी उपलब्ध क्षेत्रों को व्यक्तिगत रूप से सूचीबद्ध किए बिना प्राप्त करने का कोई तरीका नहीं है।

ग्राफकलाइन एपीआई को क्वेरी करते समय, हमेशा केवल उन क्षेत्रों को क्वेरी करने के बारे में सोचें जो वास्तव में उपयोग किए जाएंगे।

ओवर-फ़ेचिंग का एक सामान्य कारण संस्थाओं का संग्रह है। डिफ़ॉल्ट रूप से, क्वेरी एक संग्रह में 100 इकाइयाँ प्राप्त करेंगी, जो आमतौर पर वास्तव में उपयोग की जाने वाली राशि से बहुत अधिक होती है, उदाहरण के लिए, उपयोगकर्ता को प्रदर्शित करने के लिए। इसलिए प्रश्नों को लगभग हमेशा पहले स्पष्ट रूप से सेट करना चाहिए, और यह सुनिश्चित करना चाहिए कि वे केवल उतने ही निकाय प्राप्त करें जितनी उन्हें वास्तव में आवश्यकता है। यह न केवल किसी क्वेरी में शीर्ष-स्तरीय संग्रहों पर लागू होता है, बल्कि संस्थाओं के नेस्टेड संग्रहों पर और भी अधिक लागू होता है।

उदाहरण के लिए, निम्न क्वेरी में:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

प्रतिक्रिया में 100 टोकन में से प्रत्येक के लिए 100 लेनदेन हो सकते हैं।

यदि एप्लिकेशन को केवल 10 लेन-देन की आवश्यकता है, तो क्वेरी को लेन-देन फ़ील्ड पर स्पष्ट रूप से `पहले: 10` सेट करना चाहिए।

**एकाधिक प्रश्नों का संयोजन**

आपके एप्लिकेशन को निम्नानुसार कई प्रकार के डेटा की क्वेरी करने की आवश्यकता हो सकती है:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

जबकि यह कार्यान्वयन पूरी तरह से मान्य है, इसके लिए ग्राफक्यूएल एपीआई के साथ दो राउंड ट्रिप की आवश्यकता होगी।

सौभाग्य से, एक ही ग्राफक्यूएल अनुरोध में कई प्रश्न भेजने के लिए भी मान्य है:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

यह दृष्टिकोण नेटवर्क पर बिताए गए समय को कम करके **समग्र प्रदर्शन में सुधार करेगा** (आपको एपीआई के लिए एक राउंड ट्रिप बचाता है) और **अधिक संक्षिप्त कार्यान्वयन** प्रदान करेगा।

<br />

### लीवरेज ग्राफक्यूएल फ़्रैगमेंट

ग्राफ़क्यूएल प्रश्नों को लिखने के लिए एक उपयोगी विशेषता ग्राफ़क्यूएल फ्रैगमेंट है।

निम्न क्वेरी को देखते हुए, आप देखेंगे कि कुछ फ़ील्ड एकाधिक चयन-सेट (`{ ... }`) में दोहराए जाते हैं:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

ऐसे दोहराए गए फ़ील्ड (`आईडी`, `सक्रिय`, `स्थिति`) कई समस्याएं लाते हैं:

- अधिक व्यापक प्रश्नों के लिए पढ़ना कठिन है
- प्रश्नों के आधार पर टाइपस्क्रिप्ट प्रकार उत्पन्न करने वाले टूल का उपयोग करते समय (_उस पर अधिक पिछले खंड में_), `newDelegate` और `oldDelegate` के परिणामस्वरूप दो अलग-अलग इनलाइन होंगे इंटरफेस।

क्वेरी का एक रिफैक्टर किया गया संस्करण निम्न होगा:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

रेखांकन `fragment` का उपयोग करने से पठनीयता में सुधार होगा (विशेष रूप से पैमाने पर) लेकिन इसके परिणामस्वरूप बेहतर टाइपस्क्रिप्ट प्रकार की पीढ़ी भी होगी।

टाइप जनरेशन टूल का उपयोग करते समय, उपरोक्त क्वेरी एक उचित `DelegateItemFragment` प्रकार उत्पन्न करेगी (_अंतिम "टूल" अनुभाग देखें_)।

<br />

### ग्राफकॉल फ्रैगमेंट क्या करें और क्या न करें

**फ़्रैगमेंट बेस एक प्रकार का होना चाहिए**

एक फ़्रैगमेंट गैर-लागू प्रकार पर आधारित नहीं हो सकता, संक्षेप में, **फ़ील्ड रहित प्रकार पर**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` एक **स्केलर** (देशी "सादा" प्रकार) है जिसे फ़्रैगमेंट के आधार के रूप में उपयोग नहीं किया जा सकता है।

**कैसे एक टुकड़ा फैलाने के लिए**

अंशों को विशिष्ट प्रकारों पर परिभाषित किया गया है और प्रश्नों के अनुसार उनका उपयोग किया जाना चाहिए।

उदाहरण:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` और `oldDelegate` `ट्रांसकोडर` प्रकार के होते हैं।

यहाँ `Vote` प्रकार का एक अंश फैलाना संभव नहीं है।

**फ्रैगमेंट को डेटा की परमाणु व्यापार इकाई के रूप में परिभाषित करें**

ग्राफक्लाइन फ्रैगमेंट को उनके उपयोग के आधार पर परिभाषित किया जाना चाहिए।

अधिकांश उपयोग-मामले के लिए, प्रति प्रकार एक खंड को परिभाषित करना (बार-बार फ़ील्ड उपयोग या प्रकार पीढ़ी के मामले में) पर्याप्त है।

यहाँ फ्रैगमेंट का उपयोग करने के लिए अंगूठे का एक नियम है:

- जब किसी क्वेरी में एक ही प्रकार के फ़ील्ड दोहराए जाते हैं, तो उन्हें एक फ़्रैगमेंट में समूहित करें
- जब समान लेकिन समान फ़ील्ड दोहराए जाते हैं, तो एकाधिक टुकड़े बनाएं, उदा:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## आवश्यक उपकरण

### ग्राफक्यूएल वेब-आधारित खोजकर्ता

अपने आवेदन में उन्हें चलाकर प्रश्नों पर ध्यान देना बोझिल हो सकता है। इस कारण से, अपने एप्लिकेशन में जोड़ने से पहले अपने प्रश्नों का परीक्षण करने के लिए [द ग्राफ़ एक्सप्लोरर](https://thegraph.com/explorer) का उपयोग करने में संकोच न करें। ग्राफ़ एक्सप्लोरर आपको अपने प्रश्नों का परीक्षण करने के लिए एक पूर्व-कॉन्फ़िगर ग्राफ़क्यूएल खेल का मैदान प्रदान करेगा।

यदि आप अपने प्रश्नों को डीबग/परीक्षण करने के लिए अधिक लचीले तरीके की तलाश कर रहे हैं, तो अन्य समान वेब-आधारित टूल उपलब्ध हैं जैसे [Altair](https://altair.sirmuel.design/) और [GraphiQL](https://graphiql-online.com/graphiql)।

<br />

### ग्राफक्यूएल लाइनिंग

उपर्युक्त सर्वोत्तम प्रथाओं और वाक्य-विन्यास नियमों को बनाए रखने के लिए, निम्नलिखित वर्कफ़्लो और IDE टूल का उपयोग करने की अत्यधिक अनुशंसा की जाती है।

**ग्राफक्यूएल ईएसलिंट**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) आपको शून्य प्रयास के साथ GraphQL सर्वोत्तम अभ्यासों के शीर्ष पर बने रहने में मदद करेगा।

["ऑपरेशन-अनुशंसित" सेटअप करें](https://github.com/dotansimha/graphql-eslint#available-configs) कॉन्फ़िगरेशन आवश्यक नियम लागू करेगा जैसे:

- `@graphql-eslint/fields-on-correct-type`: क्या फ़ील्ड उचित प्रकार पर उपयोग की जाती है?
- `@graphql-eslint/no-unused वेरिएबल्स`: क्या एक दिया गया वेरिएबल अप्रयुक्त रहना चाहिए?
- और अधिक!

यह आपको खेल के मैदान पर **बिना प्रश्नों का परीक्षण किए** त्रुटियों को पकड़ने या उन्हें उत्पादन में चलाने की अनुमति देगा!

<br />

### आईडीई प्लगइन्स

**वीएससीओडी और ग्राफक्यूएल**

[GraphQL VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) आपके विकास कार्यप्रवाह में एक उत्कृष्ट वृद्धि है जिसे आप प्राप्त कर सकते हैं:

- वाक्य - विन्यास पर प्रकाश डालना
- स्वत: पूर्ण सुझाव
- स्कीमा के खिलाफ सत्यापन
- snippets
- अंशों और इनपुट प्रकारों के लिए परिभाषा पर जाएं

यदि आप `graphql-eslint` का उपयोग कर रहे हैं, तो [ESLint VSCode एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) आपके कोड में इनलाइन त्रुटियों और चेतावनियों को सही ढंग से देखने के लिए आवश्यक है।

**वेबस्टॉर्म/इंटेलिज और ग्राफक्यूएल**

[JS GraphQL प्लगइन](https://plugins.jetbrains.com/plugin/8097-graphql/) आपके अनुभव को काफी बेहतर बना देगा, जब आप GraphQL के साथ काम कर रहे होंगे:

- वाक्य - विन्यास पर प्रकाश डालना
- स्वत: पूर्ण सुझाव
- स्कीमा के खिलाफ सत्यापन
- snippets

इस [वेबस्टॉर्म लेख](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) पर अधिक जानकारी जो प्लगइन की सभी मुख्य विशेषताओं को प्रदर्शित करती है।
