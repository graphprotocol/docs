---
title: ग्राफक्यूएल एपीआई
---

यह मार्गदर्शिका ग्राफ़िकल क्वेरी एपीआई की व्याख्या करती है जिसका उपयोग ग्राफ़ प्रोटोकॉल के लिए किया जाता है।

## Queries

अपने सबग्राफ स्कीमा में आप `Entities` नामक प्रकारों को परिभाषित करते हैं। प्रत्येक `एंटिटी` प्रकार के लिए, एक `एंटिटी` और `एंटियां` फ़ील्ड शीर्ष-स्तरीय `क्वेरी` प्रकार पर जेनरेट की जाएंगी। ध्यान दें कि ग्राफ़ का उपयोग करते समय `क्वेरी` को `graphql` क्वेरी के शीर्ष पर शामिल करने की आवश्यकता नहीं है।

### उदाहरण

आपके स्कीमा में परिभाषित एकल `टोकन` इकाई के लिए प्रश्न:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> **ध्यान दें:** किसी एक इकाई के लिए क्वेरी करते समय, `id` फ़ील्ड की आवश्यकता होती है, और यह एक स्ट्रिंग होना चाहिए।

सभी `टोकन` संस्थाओं को क्वेरी करें:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### छँटाई

किसी संग्रह की क्वेरी करते समय, `orderBy` पैरामीटर का उपयोग किसी विशिष्ट विशेषता के आधार पर क्रमित करने के लिए किया जा सकता है। इसके अतिरिक्त, `orderDirection` का उपयोग सॉर्ट दिशा, `asc` आरोही के लिए या `desc` अवरोही के लिए निर्दिष्ट करने के लिए किया जा सकता है।

#### उदाहरण

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### नेस्टेड इकाई छँटाई के लिए उदाहरण

ग्राफ़ नोड के अनुसार [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) संस्थाओं को क्रमबद्ध किया जा सकता है नेस्टेड संस्थाओं के आधार पर।

निम्नलिखित उदाहरण में, हम टोकन को उनके स्वामी के नाम से क्रमित करते हैं:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> वर्तमान में, आप `@entity` और `@derivedFrom` फ़ील्ड पर एक-स्तर गहन `String` या `ID` प्रकार से क्रमबद्ध कर सकते हैं। दुःखद है कि [इंटरफेस पर क्रमबद्ध करना और एक स्तर-गहन एंटिटीज़ पर फ़ील्ड के द्वारा क्रमबद्ध करना जो एरे होते हैं और घनिष्ठ एंटिटीज़ की अनुमति नहीं है।](https://github.com/graphprotocol/graph-node/pull/4058)

### पृष्ठ पर अंक लगाना

किसी संग्रह की क्वेरी करते समय, `पहले` पैरामीटर का उपयोग संग्रह की शुरुआत से पेजिनेट करने के लिए किया जा सकता है। यह ध्यान देने योग्य है कि डिफ़ॉल्ट सॉर्ट क्रम आईडी द्वारा आरोही अल्फ़ान्यूमेरिक क्रम में है, निर्माण समय के अनुसार नहीं।

इसके अलावा, `छोड़ें` पैरामीटर का उपयोग इकाइयों को छोड़ने और पेजिनेट करने के लिए किया जा सकता है। उदा. `first:100` पहले 100 इकाइयां दिखाता है और `first:100, skip:100` अगली 100 इकाइयां दिखाता है।

प्रश्नों को बहुत बड़े उपयोग से बचना चाहिए `छोड़ें` मान क्योंकि वे आम तौर पर खराब प्रदर्शन करते हैं। बड़ी संख्या में आइटम प्राप्त करने के लिए, पिछले उदाहरण में दिखाए गए विशेषता के आधार पर संस्थाओं के माध्यम से पृष्ठ बनाना बेहतर है।

#### उदाहरण का उपयोग करना `पहले`

पहले 10 टोकन को क्वेरी करें।:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

एक संग्रह के बीच में संस्थाओं के समूहों के लिए क्वेरी करने के लिए, `छोड़ें` पैरामीटर का उपयोग `पहले` पैरामीटर के साथ किया जा सकता है ताकि शुरुआत से शुरू होने वाली संस्थाओं की एक निर्दिष्ट संख्या को छोड़ा जा सके संग्रह का।

#### उदाहरण का उपयोग करना `पहले` और `छोड़ें`

क्वेरी 10 ` टोकन ` इकाइयां, संग्रह की शुरुआत से 10 स्थानों से ऑफसेट:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### उदाहरण का उपयोग करना `पहले` और ` id_ge`

यदि किसी ग्राहक को बड़ी संख्या में संस्थाओं को पुनः प्राप्त करने की आवश्यकता होती है, तो यह एक विशेषता पर आधार क्वेरी और उस विशेषता द्वारा फ़िल्टर करने के लिए बहुत अधिक प्रदर्शनकारी होता है। उदाहरण के लिए, क्लाइंट इस क्वेरी का उपयोग करके बड़ी संख्या में टोकन प्राप्त करेगा:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

पहली बार, यह `lastID = ""` के साथ क्वेरी भेजेगा, और अगली अनुरोधों के लिए `lastID` को पिछले अनुरोध में पिछली एंटिटी के `id` एट्रिब्यूट पर सेट करेगा। इस तरीके से, बढ़ते `skip` मूल्यों का उपयोग करने से बेहतर प्रदर्शन होगा।

### छनन

आप अपनी क्वेरी में `कहाँ` पैरामीटर का उपयोग विभिन्न गुणों के लिए फ़िल्टर करने के लिए कर सकते हैं। आप `जहां` पैरामीटर के भीतर एकाधिक मानों पर फ़िल्टर कर सकते हैं।

#### उदाहरण का उपयोग करना `कहाँ`

`असफल` परिणाम वाली क्वेरी चुनौतियां:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

मूल्य तुलना के लिए आप `_gt`, `_lte` जैसे प्रत्ययों का उपयोग कर सकते हैं:

#### श्रेणी फ़िल्टरिंग के लिए उदाहरण

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### ब्लॉक फ़िल्टरिंग के लिए उदाहरण

आप `_change_block(number_gte: Int)` द्वारा संस्थाओं को भी फ़िल्टर कर सकते हैं - यह उन संस्थाओं को फ़िल्टर करता है जिन्हें निर्दिष्ट ब्लॉक में या उसके बाद अपडेट किया गया था।

यदि आप केवल उन एंटिटीज़ को फ़ेच करने की तलाश में हैं जो बदल गए हैं, तो यह उपयोगी हो सकता है, उदाहरण के लिए, अंतिम बार आपने कब जांच की थी। या फिर यह जांचने या डीबग करने में उपयोगी हो सकता है कि आपके सबग्राफ़ में एंटिटीज़ कैसे बदल रहे हैं (यदि ब्लॉक फ़िल्टर के साथ मिलाकर उपयोग किया जाए, तो आप केवल विशिष्ट ब्लॉक में बदली हुई एंटिटीज़ को अलग कर सकते हैं)।

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### नेस्टेड इकाई फ़िल्टरिंग के लिए उदाहरण

`_` प्रत्यय वाले क्षेत्रों में नेस्टेड संस्थाओं के आधार पर फ़िल्टरिंग संभव है।

यह उपयोगी हो सकता है यदि आप केवल उन संस्थाओं को लाना चाहते हैं जिनके चाइल्ड-स्तरीय निकाय प्रदान की गई शर्तों को पूरा करते हैं।

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### लॉजिकल ऑपरेटर्स

ग्राफ़ नोड [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) के अनुसार आप एकाधिक समूह बना सकते हैं एक से अधिक मानदंडों के आधार पर परिणामों को फ़िल्टर करने के लिए `और` या `या` ऑपरेटरों का उपयोग करते हुए एक ही `जहां` तर्क में पैरामीटर।

##### `AND` Operator

निम्नलिखित उदाहरण में, हम `परिणाम` `सफल` और `number` `100` से अधिक या उसके बराबर वाली चुनौतियों के लिए फ़िल्टर कर रहे हैं।

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **सिंटैक्टिक शुगर:** आप `और` ऑपरेटर को कॉमा द्वारा अलग किए गए सब-एक्सप्रेशन को पास करके उपरोक्त क्वेरी को सरल बना सकते हैं।
> 
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### `OR` Operator

निम्नलिखित उदाहरण में, हम `परिणाम` `सफल` या `number` `100` से अधिक या उसके बराबर वाली चुनौतियों के लिए फ़िल्टर कर रहे हैं।

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **नोट**: क्वेरी तैयार करते समय, `या` ऑपरेटर का उपयोग करने का प्रभाव ध्यान में रखना महत्वपूर्ण है। जबकि `या` खोज परिणाम को बढ़ाने के लिए एक उपयोगी टूल हो सकता है, यह भी बहुत महंगा हो सकता है। `या` के मुख्य मुद्दों में से एक यह है कि यह क्वेरी को धीमी कर सकता है। इसका कारण है कि `या` डेटाबेस को कई इंडेक्स के माध्यम से स्कैन करने की आवश्यकता होती है, जो एक समय लेने वाली प्रक्रिया हो सकती है। इन मुद्दों से बचने के लिए, सलाह दी जाती है कि डेवलपर्स हमेशा संभव होते हुए और ऑपरेटर का उपयोग करें जबकि या। इससे अधिक ठोस फिल्टरिंग संभव होती है और तेज, अधिक सटीक क्वेरी के लिए ले जाता है।

#### सभी फ़िल्टर

पैरामीटर प्रत्यय की पूरी सूची:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> कृपया ध्यान दें कि कुछ प्रत्यय केवल विशिष्ट प्रकारों के लिए समर्थित हैं। उदाहरण के लिए, `बूलियन` केवल `_not`, `_in`, और `_not_in` का समर्थन करता है, लेकिन `_` केवल ऑब्जेक्ट और इंटरफ़ेस प्रकारों के लिए उपलब्ध है।

इसके अलावा, निम्न वैश्विक फ़िल्टर `जहां` तर्क के भाग के रूप में उपलब्ध हैं:

```gr
_change_block(number_gte: Int)
```

### समय-यात्रा क्वेरी

आप अपनी संस्थाओं की स्थिति को न केवल नवीनतम ब्लॉक के लिए पूछ सकते हैं, जो कि डिफ़ॉल्ट है, बल्कि अतीत में मनमाने ब्लॉक के लिए भी है। जिस ब्लॉक पर एक क्वेरी होनी चाहिए, उसे या तो उसके ब्लॉक नंबर या उसके ब्लॉक हैश द्वारा `ब्लॉक` तर्क को क्वेरी के टॉपलेवल फील्ड में शामिल करके निर्दिष्ट किया जा सकता है।

इस प्रकार के क्वेरी का परिणाम समय के साथ नहीं बदलेगा, अर्थात एक निश्चित पिछले ब्लॉक पर क्वेरी करने पर वही परिणाम होगा जो उसे कभी भी निष्पादित किया जाएगा, इस अपवाद के साथ कि यदि आप चेन के सिरे के बहुत करीब के एक ब्लॉक पर क्वेरी करते हैं तो यदि वह ब्लॉक मुख्य चेन पर नहीं होता है और चेन को संगठित किया जाता है तो परिणाम बदल सकता है। एक ब्लॉक अंतिम माना जाने के बाद, क्वेरी का परिणाम बदलने से बचेगा।

ध्यान दें कि वर्तमान अमल में अभी भी कुछ सीमाओं का सामना करना पड़ सकता है जो इन गारंटियों का उल्लंघन कर सकती हैं। अंतिम रूप से, यह प्रयोजन के लिए विशेषज्ञों द्वारा निर्मित हुआ है और इसमें कुछ सीमाएं हो सकती हैं। इम्प्लीमेंटेशन कभी-कभी नहीं बता सकता कि क्या एक दिए गए ब्लॉक हैश मुख्य श्रृंखला पर नहीं है, या यह भी नहीं बता सकता है कि अंतिम रूप से मान्य नहीं माना जा सकने वाले ब्लॉक के लिए ब्लॉक हैश द्वारा क्वेरी का परिणाम कितना दुविधापूर्ण हो सकता है जो क्वेरी के साथ समयानुसार चल रही एक ब्लॉक रीआर्गेनाइज़ेशन द्वारा प्रभावित हो सकता है। वे अंतिम रूप से मुख्य श्रृंखला पर होने वाले ब्लॉक हैश द्वारा क्वेरी के परिणामों पर कोई प्रभाव नहीं डालते हैं। इस मुद्दे में [इस मुद्दे](https://github.com/graphprotocol/graph-node/issues/1405) में विस्तार से समझाया गया है।

#### उदाहरण

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

यह क्वेरी `चैलेंज` संस्थाओं, और उनके संबद्ध `एप्लिकेशन` संस्थाओं को लौटा देगी, क्योंकि वे ब्लॉक संख्या 8,000,000 को संसाधित करने के बाद सीधे मौजूद थीं।

#### उदाहरण

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

यह क्वेरी `Challenge` संस्थाओं, और उनसे संबद्ध `अनुप्रयोग` संस्थाओं को लौटा देगी, क्योंकि वे दिए गए हैश के साथ ब्लॉक को संसाधित करने के बाद सीधे मौजूद थे।

### पूर्ण पाठ खोज प्रश्न

पूर्ण पाठ खोज क्वेरी फ़ील्ड, एक व्यक्तिगत रूप से जोड़ा जा सकता है और सबग्राफ़ स्कीमा में अनुकूलित किया जा सकता है, एक व्यक्तिगत पाठ खोज API प्रदान करते हैं। अपने सबग्राफ़ में पूर्ण पाठ खोज जोड़ने के लिए [पूर्णपाठ खोज फ़ील्ड का परिभाषित करना](/developing/creating-a-subgraph#defining-fulltext-search-fields) देखें।

शब्दों की आपूर्ति के लिए पूर्ण पाठ्य अन्वेषण में एक आवश्यक क्षेत्र `पाठ` है। इस `पाठ` खोज क्षेत्र में उपयोग करने के लिए कई विशेष पूर्ण-पाठ पत्र उपलब्ध हैं।

पूर्ण पाठ खोज ऑपरेटर:

| प्रतीक      | ऑपरेटर      | विवरण                                                                                                                                |
| ----------- | ----------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `&`     | `And`       | सभी प्रदान किए गए शब्दों को शामिल करने वाली संस्थाओं के लिए एक से अधिक खोज शब्दों को फ़िल्टर में संयोजित करने के लिए                 |
| &#x7c;      | `Or`        | या ऑपरेटर द्वारा अलग किए गए एकाधिक खोज शब्दों वाली क्वेरी सभी संस्थाओं को प्रदान की गई शर्तों में से किसी से मेल के साथ वापस कर देगी |
| `<->` | `Follow by` | दो शब्दों के बीच की दूरी निर्दिष्ट करें।                                                                                             |
| `:*`        | `Prefix`    | उन शब्दों को खोजने के लिए उपसर्ग खोज शब्द का उपयोग करें जिनके उपसर्ग मेल खाते हैं (2 वर्ण आवश्यक हैं।)                               |

#### उदाहरण

`or` ऑपरेटर का उपयोग करते हुए, यह क्वेरी ब्लॉग इकाइयों को उनके पूर्ण टेक्स्ट फ़ील्ड में "अराजकतावाद" या "crumpet" की विविधताओं के साथ फ़िल्टर करेगी।

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

`अनुसरण करें` ऑपरेटर पूर्ण टेक्स्ट दस्तावेज़ों में शब्दों को एक विशिष्ट दूरी के अलावा निर्दिष्ट करता है। निम्न क्वेरी सभी ब्लॉगों को "विकेंद्रीकरण" के बाद "दर्शन" के रूपांतरों के साथ वापस कर देगी

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

अधिक जटिल फिल्टर बनाने के लिए फुलटेक्स्ट ऑपरेटरों को मिलाएं। इस उदाहरण क्वेरी के अनुसरण के साथ एक बहाना खोज ऑपरेटर संयुक्त रूप से सभी ब्लॉग संस्थाओं को उन शब्दों से मिलाएगा जो "लू" से शुरू होते हैं और उसके बाद "संगीत"।

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### मान्यकरण

ग्राफ नोड लागू करता है [ विनिर्देशन आधारित ](https://spec.graphql.org/October2021/#sec-Validation) इसका उपयोग करके प्राप्त होने वाले ग्राफ़क्यूएल प्रश्नों का सत्यापन [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), जो [पर आधारित है ग्राफकल-जेएस संदर्भ कार्यान्वयन ](https://github.com/graphql/graphql-js/tree/main/src/validation)वे क्वेरीज़ जो सत्यापन नियम को विफल करती हैं, मानक त्रुटि के साथ ऐसा करती हैं - पर जाएँ [ अधिक जानने के लिए ग्राफ़िकल विनिर्देश](https://spec.graphql.org/October2021/#sec-Validation)।

## योजना

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

ग्राफक्यूएल स्कीमा आम तौर पर `क्वेरी`, `सदस्यता` और `म्यूटेशन` के रूट प्रकारों को परिभाषित करते हैं। ग्राफ़ केवल `क्वेरी` का समर्थन करता है। आपके सबग्राफ के लिए रूट `क्वेरी` प्रकार स्वचालित रूप से आपके सबग्राफ मेनिफ़ेस्ट में शामिल ग्राफ़क्यूएल स्कीमा से उत्पन्न होता है।

> **ध्यान दें:** हमारा एपीआई म्यूटेशन को उजागर नहीं करता है क्योंकि डेवलपर्स से उम्मीद की जाती है कि वे अपने एप्लिकेशन से अंतर्निहित ब्लॉकचेन के खिलाफ सीधे लेनदेन जारी करेंगे।

### इकाइयां

स्कीमा में `@entity` निर्देशक के साथ सभी GraphQL प्रकार को सत्तायें माना जाएगा और इनमें एक `ID` फ़ील्ड होना आवश्यक होगा।

> **ध्यान दें:** वर्तमान में, आपके स्कीमा के सभी प्रकारों में एक `@entity` निर्देश होना चाहिए। भविष्य में, हम किसी `@entity` निर्देश के बिना प्रकारों को मान ऑब्जेक्ट के रूप में मानेंगे, लेकिन यह अभी तक समर्थित नहीं है।

### सबग्राफ मेटाडेटा

सभी सबग्राफ में एक स्वतः उत्पन्न `_Meta_` ऑब्जेक्ट होता है, जो सबग्राफ मेटाडेटा तक पहुंच प्रदान करता है। इस प्रकार पूछताछ की जा सकती है:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

यदि कोई ब्लॉक प्रदान किया गया है, तो मेटाडेटा उस ब्लॉक का है, यदि नवीनतम अनुक्रमित ब्लॉक का उपयोग नहीं किया गया है। यदि प्रदान किया गया है, तो ब्लॉक सबग्राफ के प्रारंभ ब्लॉक के बाद होना चाहिए, और हाल ही में अनुक्रमित ब्लॉक से कम या उसके बराबर होना चाहिए।

`deployment` एक अद्वितीय आईडी है, जो `subgraph.yaml` फ़ाइल के IPFS CID के अनुरूप है।

`block` नवीनतम ब्लॉक के बारे में जानकारी प्रदान करता है (`_meta` को पारित किसी भी ब्लॉक बाधाओं को ध्यान में रखते हुए):

- हैश: ब्लॉक का हैश
- नंबर: ब्लॉक नंबर
- टाइमस्टैम्प: ब्लॉक का टाइमस्टैम्प, यदि उपलब्ध हो (यह वर्तमान में केवल ईवीएम नेटवर्क को इंडेक्स करने वाले सबग्राफ के लिए उपलब्ध है)

`hasIndexingErrors` एक बूलियन है जो यह पहचानता है कि सबग्राफ को कुछ पिछले ब्लॉक में इंडेक्सिंग त्रुटियों का सामना करना पड़ा या नहीं
