---
title: Sistemas Distribuídos
---

O The Graph é um protocolo implementado como um sistema distribuído.

Conexões falham. Pedidos chegam fora da ordem. Computadores diferentes, com relógios e estados fora de sincronia, processam pedidos relacionados. Servidores reiniciam. Reorganizações acontecem entre pedidos. Estes problemas são inerentes a todos os sistemas distribuídos, mas pioram em sistemas que operam em uma escala global.

Considere este exemplo do que pode ocorrer se um cliente consultar um Indexador sobre os dados mais recentes durante uma reorganização.

1. Indexador ingere o bloco 8
2. Pedido servido ao cliente para o bloco 8
3. Indexador ingere o bloco 9
4. Indexador ingere o bloco 10A
5. Pedido servido ao cliente para o bloco 10A
6. Indexador deteta reorganização ao 10B e faz rollback para o 10A
7. Pedido servido ao cliente para o bloco 9
8. Indexador ingere o bloco 10B
9. Indexador ingere o bloco 11
10. Pedido servido ao cliente para o bloco 11

Do ponto de vista do Indexador, está tudo a progredir logicamente. O tempo move-se para frente, porém tivemos que fazer rollback num bloco uncle e reproduzir o bloco sob consenso à frente, ainda por cima. No caminho, o Indexador serve pedidos com o último estado de que tem ciência naquela hora.

Do ponto de vista do cliente, no entanto, tudo parece caótico. O cliente observa que as respostas foram para os blocos 8, 10, 9 e 11 naquela ordem — o problema do "bloco bambo". Quando um cliente experiencia um bloco bambo, os dados podem aparentar se contradizer temporalmente. Isto só piora quando consideramos que os Indexadores não ingerem os blocos mais recentes simultaneamente, e os seus pedidos podem ser encaminhados para vários Indexadores.

É responsabilidade do cliente e do servidor trabalharem juntos para fornecer dados consistentes ao utilizador. Métodos diferentes devem ser usados, a depender da consistência desejada, já que não há um único programa correto para todos os problemas.

Raciocinar as implicações de sistemas distribuídos é difícil, mas a solução pode não ser! Nós estabelecemos APIs e padrões para ajudar-lhe a navegar alguns casos de uso comuns. Os seguintes exemplos ilustram esses padrões, mas ainda omitem detalhes exigidos pelo código de produção (como gestão de erros e cancelamento) para não ofuscar as ideias principais.

## Consulta por dados atualizados

The Graph provides the `block: { number_gte: $minBlock }` API, which ensures that the response is for a single block equal or higher to `$minBlock`. If the request is made to a `graph-node` instance and the min block is not yet synced, `graph-node` will return an error. If `graph-node` has synced min block, it will run the response for the latest block. If the request is made to an Edge & Node Gateway, the Gateway will filter out any Indexers that have not yet synced min block and make the request for the latest block the Indexer has synced.

We can use `number_gte` to ensure that time never travels backward when polling for data in a loop. Here is an example:

```javascript
/// Updates the protocol.paused variable to the latest
/// known value in a loop by fetching it using The Graph.
async function updateProtocolPaused() {
  // It's ok to start with minBlock at 0. The query will be served
  // using the latest block available. Setting minBlock to 0 is the
  // same as leaving out that argument.
  let minBlock = 0

  for (;;) {
    // Schedule a promise that will be ready once
    // the next Ethereum block will likely be available.
    const nextBlock = new Promise((f) => {
      setTimeout(f, 14000)
    })

    const query = `
        query GetProtocol($minBlock: Int!) {
            protocol(block: { number_gte: $minBlock }  id: "0") {
              paused
            }
            _meta {
                block {
                    number
                }
            }
        }`

    const variables = { minBlock }
    const response = await graphql(query, variables)
    minBlock = response._meta.block.number

    // TODO: Do something with the response data here instead of logging it.
    console.log(response.protocol.paused)

    // Sleep to wait for the next block
    await nextBlock
  }
}
```

## Como retirar um conjunto de itens relacionados

Outro caso de uso é o retiro de um grande conjunto, ou mais geralmente, de itens relacionados em múltiplos pedidos. Ao contrário do caso da consulta (onde a consistência desejada era acelerar no tempo), a consistência desejada é para um único ponto no tempo.

Here we will use the `block: { hash: $blockHash }` argument to pin all of our results to the same block.

```javascript
/// Gets a list of domain names from a single block using pagination
async function getDomainNames() {
  // Set a cap on the maximum number of items to pull.
  let pages = 5
  const perPage = 1000

  // The first query will get the first page of results and also get the block
  // hash so that the remainder of the queries are consistent with the first.
  const listDomainsQuery = `
    query ListDomains($perPage: Int!) {
        domains(first: $perPage) {
            name
            id
        }
        _meta {
            block {
                hash
            }
        }
    }`

  let data = await graphql(listDomainsQuery, { perPage })
  let result = data.domains.map((d) => d.name)
  let blockHash = data._meta.block.hash

  let query
  // Continue fetching additional pages until either we run into the limit of
  // 5 pages total (specified above) or we know we have reached the last page
  // because the page has fewer entities than a full page.
  while (data.domains.length == perPage && --pages) {
    let lastID = data.domains[data.domains.length - 1].id
    query = `
        query ListDomains($perPage: Int!, $lastID: ID!, $blockHash: Bytes!) {
            domains(first: $perPage, where: { id_gt: $lastID }, block: { hash: $blockHash }) {
                name
                id
            }
        }`

    data = await graphql(query, { perPage, lastID, blockHash })

    // Accumulate domain names into the result
    for (domain of data.domains) {
      result.push(domain.name)
    }
  }
  return result
}
```

Note que em caso de uma reorganização, o cliente deve tentar novamente a partir do primeiro pedido, para atualizar o hash do bloco a um block que não é uncle.
