---
title: Estrutura de Testes de Unidades
---

Learn how to use Matchstick, a unit testing framework developed by [LimeChain](https://limechain.tech/). Matchstick enables Subgraph developers to test their mapping logic in a sandboxed environment and successfully deploy their Subgraphs.

## Benefits of Using Matchstick

- It's written in Rust and optimized for high performance.
- It gives you access to developer features, including the ability to mock contract calls, make assertions about the store state, monitor Subgraph failures, check test performance, and many more.

## Como Come√ßar

### Install Dependencies

In order to use the test helper methods and run tests, you need to install the following dependencies:

```sh
yarn add --dev matchstick-as
```

### Install PostgreSQL

`graph-node` depends on PostgreSQL, so if you don't already have it, then you will need to install it.

> Note: It's highly recommended to use the commands below to avoid unexpected errors.

#### Using MacOS

Installation command:

```sh
brew install postgresql
```

Create a symlink to the latest libpq.5.lib _You may need to create this dir first_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Using Linux

Installation command (depends on your distro):

```sh
sudo apt install postgresql
```

### Using WSL (Windows Subsystem for Linux)

Pode usar o Matchstick no WSL tanto com a abordagem do Docker quanto com a abordagem bin√°ria. Como o WSL pode ser um pouco complicado, aqui est√£o algumas dicas caso encontre problemas

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

ou

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Please make sure you're on a newer version of Node.js graph-cli doesn't support **v10.19.0** anymore, and that is still the default version for new Ubuntu images on WSL. For instance Matchstick is confirmed to be working on WSL with **v18.1.0**, you can switch to it either via **nvm** or if you update your global Node.js. Don't forget to delete `node_modules` and to run `npm install` again after updating you nodejs! Then, make sure you have **libpq** installed, you can do that by running

```
sudo apt-get install libpq-dev
```

And finally, do not use `graph test` (which uses your global installation of graph-cli and for some reason that looks like it's broken on WSL currently), instead use `yarn test` or `npm run test` (that will use the local, project-level instance of graph-cli, which works like a charm). For that you would of course need to have a `"test"` script in your `package.json` file which can be something as simple as

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### Using Matchstick

To use **Matchstick** in your Subgraph project just open up a terminal, navigate to the root folder of your project and simply run `graph test [options] <datasource>` - it downloads the latest **Matchstick** binary and runs the specified test or all tests in a test folder (or all existing tests if no datasource flag is specified).

### Op√ß√µes de CLI

Isto executar√° todos os testes na pasta-teste:

```sh
graph test
```

Isto executar√° um teste chamado gravity.test.ts e/ou todos os testes dentro de uma pasta chamada gravity:

```sh
graph test gravity
```

Isto s√≥ executar√° esse arquivo de teste espec√≠fico:

```sh
graph test path/to/file.test.ts
```

**Options:**

```sh
-c, --coverage                Run the tests in coverage mode
-d, --docker                  Run the tests in a docker container (Note: Please execute from the root folder of the Subgraph)
-f, --force                   Binary: Redownloads the binary. Docker: Redownloads the Dockerfile and rebuilds the docker image.
-h, --help                    Show usage information
-l, --logs                    Logs to the console information about the OS, CPU model and download url (debugging purposes)
-r, --recompile               Forces tests to be recompiled
-v, --version <tag>           Choose the version of the rust binary that you want to be downloaded/used
```

### Docker

From `graph-cli 0.25.2`, the `graph test` command supports running `matchstick` in a docker container with the `-d` flag. The docker implementation uses [bind mount](https://docs.docker.com/storage/bind-mounts/) so it does not have to rebuild the docker image every time the `graph test -d` command is executed. Alternatively you can follow the instructions from the [matchstick](https://github.com/LimeChain/matchstick#docker-) repository to run docker manually.

‚ùó `graph test -d` forces `docker run` to run with flag `-t`. This must be removed to run inside non-interactive environments (like GitHub CI).

‚ùó If you have previously ran `graph test` you may encounter the following error during docker build:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

In this case create a `.dockerignore` in the root folder and add `node_modules/binary-install-raw/bin`

### Configura√ß√£o

Matchstick can be configured to use a custom tests, libs and manifest path via `matchstick.yaml` config file:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Demo Subgraph

You can try out and play around with the examples from this guide by cloning the [Demo Subgraph repo](https://github.com/LimeChain/demo-subgraph)

### Tutoriais de v√≠deo

Also you can check out the video series on ["How to use Matchstick to write unit tests for your Subgraphs"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Estrutura de testes

_**IMPORTANT: The test structure described below depends on `matchstick-as` version >=0.5.0**_

### describe()

`describe(name: String , () => {})` - Defines a test group.

**_Notes:_**

- _Describes are not mandatory. You can still use test() the old way, outside of the describe() blocks_

Exemplo:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

Nested `describe()` example:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Defines a test case. You can use test() inside of describe() blocks or independently.

Exemplo:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Isto deve criar uma nova Entidade", () => {
    ...
  })
})
```

ou

```typescript
test("handleNewGravatar() deve criar uma nova entidade", () => {
  ...
})


```

---

### beforeAll()

Executa um bloco de c√≥digo antes de quaisquer dos testes no arquivo. Se o `beforeAll` for declarado dentro de um bloco `describe`, ele √© executado no come√ßo daquele bloco `describe`.

Exemplos:

O c√≥digo dentro do `beforeAll` ser√° executado uma vez antes de _todos_ os testes no arquivo.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("Quando a entidade n√£o existe", () => {
  test("ela deve criar um novo Gravatar com a id 0x1", () => {
    ...
  })
})

describe("Quando a entidade j√° existe", () => {
  test("ela deve atualizar o Gravatar com a id 0x0", () => {
    ...
  })
})
```

O c√≥digo antes do `beforeAll` ser√° executado uma vez antes de todos os testes no primeiro bloco describe

```typescript
mport { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = ‚ÄúPrimeiro Gravatar‚Äù
    gravatar.save()
    ...
  })

  test("atualiza Gravatar com id 0x0", () => {
    ...
  })

  test("cria novo Gravatar com id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Executa um bloco de c√≥digo depois de todos os testes no arquivo. Se o `afterAll` for declarado dentro de um bloco `describe`, ele ser√° executado no final desse bloco `describe`.

Exemplo:

O c√≥digo dentro do `afterAll` ser√° executado uma vez depois de _todos_ os testes no arquivo.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("cria Gravatar com id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("atualiza Gravatar com id 0x0", () => {
    ...
  })
})
```

O c√≥digo dentro do `afterAll` ser√° executado uma vez depois de todos os testes no primeiro bloco describe

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
	afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
	})

  test("Cria uma nova entidade com Id 0x0", () => {
    ...
  })

  test("Cria uma nova entidade com Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("atualiza Gravatar com id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Executa um bloco de c√≥digo antes de cada teste no arquivo. Se o `beforeEach` for declarado dentro de um bloco `describe`, ele ser√° executado antes de cada teste nesse bloco `describe`.

Exemplos: O c√≥digo dentro do `beforeEach` ser√° executado antes de cada teste.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- limpa o armazenamento antes de cada teste no arquivo
})

describe("handleNewGravatars, () => {
  test("Teste que exige armazenamento limpo", () => {
    ...
  })

  test("Segundo que exige armazenamento limpo", () => {
    ...
  })
})

 ...
```

O c√≥digo antes do `beforeEach` ser√° executado antes de cada teste no describe

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'Primeiro Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Atualiza o displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'Primeiro Gravatar')

    // c√≥digo que deve atualizar o displayName para 1o. Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1o. Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Atualiza o imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // c√≥digo que deve mudar imageUrl para https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Executa um bloco de c√≥digo depois de cada teste no arquivo. Se o `afterEach` for declarado dentro de um bloco `describe`, ser√° executado ap√≥s cada teste nesse `describe`.

Exemplos:

O c√≥digo dentro do `afterEach` ser√° executado ap√≥s cada teste.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúPrimeiro Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Atualiza o displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "Primeiro Gravatar")

    // c√≥digo que deve mudar o displayName para 1o. Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1o. Gravatar")
  })

  test("Atualiza o imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // c√≥digo que deve mudar o imageUrl para https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

O c√≥digo dentro do `afterEach` ser√° executado ap√≥s cada teste nesse describe

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "Primeiro Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "Primeiro Gravatar")

    // c√≥digo que deve atualizar o displayName para 1o. Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1o. Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // c√≥digo que deve mudar o imageUrl para https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Asserts

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

A partir da vers√£o 0.6.0, asserts tamb√©m apoiam mensagens de erro personalizadas

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id deve ser 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Valor deve ser igual a 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar n√£o deve estar armazenado')
assert.addressEquals(Address.zero(), Address.zero(), 'Address deve ser zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes devem ser iguais')
assert.i32Equals(2, 2, 'I32 deve ser igual a 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt deve ser igual 1')
assert.booleanEquals(true, true, 'Boolean deve ser true')
assert.stringEquals('1', '1', 'String deve ser igual a 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arranjos devem ser iguais')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuplas devem ser iguais',
)
assert.assertTrue(true, 'Deve ser true')
assert.assertNull(null, 'Deve ser null')
assert.assertNotNull('not null', 'Deve n√£o ser null')
assert.entityCount('Gravatar', 1, 'Deve haver 2 Gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'Template GraphTokenLockWallet template deve ter uma fonte de dados')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet deve ter uma fonte de dados para address zero',
)
```

## Como Escrever um Teste de Unidade

Vamos ver como seria um simples teste unit√°rio usando os exemplos de Gravatar no [Subgraph de Demonstra√ß√£o](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

Suponhamos que temos a seguinte fun√ß√£o de handler (com duas fun√ß√µes de helper para facilitar):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownerAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Primeiro, devemos criar um arquivo de teste no nosso projeto. Este √© um exemplo de como ele pode ficar:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Criar uma entidade de teste e guarda no armazenamento como estado inicial (opcional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Criar eventos simulados
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Chamar fun√ß√µes de mapeamento passando os eventos que acabamos de criar
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assertar o estado do armazenamento
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Limpar o armazenamento para come√ßar o pr√≥ximo teste do zero
  clearStore()
})

test('Next test', () => {
  //...
})
```

Quanta coisa! Primeiro, note que estamos a importar coisas do `matchstick-as`, a nossa biblioteca de helper do AssemblyScript (distribu√≠da como um m√≥dulo npm). O reposit√≥rio est√° [aqui](https://github.com/LimeChain/matchstick-as). O `matchstick-as` nos d√° alguns m√©todos de teste √∫teis e define a fun√ß√£o `test()`, que usaremos para construir os nossos blocos de teste. O resto √© bem simples ‚Äî veja o que acontece:

- Configuramos nosso estado inicial e adicionamos uma entidade de Gravatar personalizada;
- Definimos dois eventos `NewGravatar` com os seus dados, usando a fun√ß√£o `createNewGravatarEvent()`;
- Chamamos m√©todos de handlers para estes eventos ‚Äî `handleNewGravatars()` ‚Äî e passamos a lista dos nossos eventos personalizados;
- Garantimos o estado da loja. Como isto funciona? ‚Äî Passamos uma combina√ß√£o do tipo e da id da Entidade. Depois conferimos um campo espec√≠fico naquela Entidade e garantimos que ela tem o valor que esperamos que tenha. Estamos a fazer isto tanto para a Entidade Gravatar inicial adicionada ao armazenamento, quanto para as duas entidades Gravatar adicionadas ao chamar a fun√ß√£o de handler;
- E por √∫ltimo ‚Äî limpamos o armazenamento com `clearStore()`, para que o nosso pr√≥ximo teste comece com um objeto de armazenamento novo em folha. Podemos definir quantos blocos de teste quisermos.

Prontinho ‚Äî criamos o nosso primeiro teste! üëè

Now in order to run our tests you simply need to run the following in your Subgraph root folder:

`graph test Gravity`

E se tudo der certo, deve receber a seguinte resposta:

![Matchstick diz "Todos os testes passados!‚Äù](/img/matchstick-tests-passed.png)

## Cen√°rios de teste comuns

### Como hidratar o armazenamento com um certo estado

Os utilizadores podem hidratar o armazenamento com um conjunto conhecido de entidades. Aqui est√° um exemplo para inicializar o armazenamento com uma entidade Gravatar:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Como chamar uma fun√ß√£o de mapeamento com um evento

Um utilizador pode criar um evento personalizado e pass√°-lo a uma fun√ß√£o de mapeamento ligada ao armazenamento:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Como chamar todos os mapeamentos com fixa√ß√µes de eventos

Os utilizadores podem chamar os mapeamentos com fixa√ß√µes de teste.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Como simular chamadas de contratos

Os utilizadores podem simular chamadas de contratos:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Como demonstrado, para simular uma chamada de contrato e conseguir um valor de retorno de linha-dura, o utilizador deve fornecer um endere√ßo de contrato, nome de fun√ß√£o, assinatura de fun√ß√£o, arranjo de argumentos ‚Äî e claro, o valor de retorno.

Os utilizadores tamb√©m podem simular regressos de fun√ß√µes:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Como simular arquivos IPFS (do matchstick 0.4.1)

Os utilizadores podem simular arquivos IPFS com a fun√ß√£o `mockIpfsFile(hash, filePath)`. A fun√ß√£o aceita dois argumentos: o primeiro √© o hash/caminho do arquivo IPFS, e o segundo √© o caminho a um arquivo local.

NOTE: When testing `ipfs.map/ipfs.mapJSON`, the callback function must be exported from the test file in order for matchstick to detect it, like the `processGravatar()` function in the test example bellow:

Arquivo `test.ts`:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Export ipfs.map() callback in order for matchstick to detect it
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

Arquivo `utils.ts`:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// callback do ipfs.map
export function processGravatar(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Callbacks tamb√©m podem criar entidades
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// fun√ß√£o que chama o ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Como afirmar o estado do armazenamento

Os utilizadores podem afirmar o estado final (ou parcial) do armazenamento atrav√©s de entidades de afirma√ß√£o. Para isto, o utilizador precisa fornecer um tipo de Entidade, a ID espec√≠fica de uma Entidade, o nome de um campo naquela Entidade, e o valor esperado do campo. Aqui vai um exemplo r√°pido:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

A fun√ß√£o assert.fieldEquals() conferir√° a igualdade do campo dado contra o valor dado esperado. O teste acabar√° em erro, com mensagem correspondente, caso os valores **N√ÉO** sejam iguais. Caso contr√°rio, o teste ter√° √™xito.

### Como interagir com metadados de Eventos

Os utilizadores podem usar metadados-padr√£o de transa√ß√µes, que podem ser retornados como um ethereum.Event com a fun√ß√£o `newMockEvent()`. O seguinte exemplo mostra como podes ler/escrever a estes campos no objeto de Evento:

```typescript
// Leitura
let logType = newGravatarEvent.logType

// Escrita
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Como afirmar a igualdade das vari√°veis

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Como afirmar que uma Entidade **n√£o** est√° no armazenamento

Os utilizadores podem afirmar que uma entidade n√£o existe no armazenamento. A fun√ß√£o toma um tipo e uma id de entidade. Caso a entidade esteja, de facto, na loja, o teste acabar√° em erro, com uma mensagem de erro relevante. Veja um exemplo r√°pido de como usar esta funcionalidade:

```typescript
assert.notInStore('Gravatar', '23')
```

### Impress√£o do armazenamento completo, ou de entidades individuais dele (para debugging)

Pode imprimir o armazenamento inteiro na consola com esta fun√ß√£o de helper:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

Desde a vers√£o 0.6.0, o `logStore` n√£o imprime mais campos derivados; em vez disto, os utilizadores podem usar a nova fun√ß√£o `logEntity`. O `logEntity` pode ser usado para imprimir qualquer entidade, n√£o s√≥ as que t√™m campos derivados. O `logEntity` pega o tipo e a ID da entidade, e um flag `showRelated` para indicar se os utilizadores querem imprimir as entidades derivadas relacionadas.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### Falhas esperadas

Os utilizadores podem encontrar falhas esperadas, com o flag shouldFail nas fun√ß√µes <code>test()</code>:

```typescript
test(
  'Deve chamar um erro',
  () => {
    throw new Error()
  },
  true,
)
```

Caso o teste seja marcado com <code>shouldFail = true</code> mas N√ÉO falhe, isto ser√° mostrado como um erro nos logs e o bloco de teste n√£o ter√° √™xito. E se for marcado com <code>shouldFail = false</code> (o estado normal), o executor de teste travar√°.

### Logging

Ter logs personalizados nos testes de unidade √© a mesma coisa que logar nos mapeamentos. A diferen√ßa √© que o objeto do log deve ser importado do matchstick-as, em vez do graph-ts. Aqui vai um exemplo simples com todos os tipos de log n√£o-cr√≠ticos:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Sucesso!". []);
});
test("Error", () => {
    log.error("Erro! :( ", []);
});
test("Debug", () => {
    log.debug("Debug em progresso...", []);
});
test("Info", () => {
    log.info("Informa√ß√£o!", []);
});
test("Warning", () => {
    log.warning("Cuidado!", []);
});
```

Os utilizadores tamb√©m podem simular uma falha cr√≠tica, como no seguinte:

```typescript
test('Explodir tudo', () = {
  log.critical('√â boooomba!')
})
```

Logar erros cr√≠ticos interromper√° a execu√ß√£o dos testes e causar√° um desastre. Afinal, queremos ter certeza que o seu c√≥digo n√£o tenha logs cr√≠ticos no lan√ßamento; perceberia imediatamente se isto acontecer.

### Como testar campos derivados

Testar campos derivados permite aos utilizadores configurar um campo numa entidade e atualizar outra automaticamente, caso ela derive um dos seus campos da primeira entidade.

Antes da vers√£o `0.6.0`, era poss√≠vel resgatar as entidades derivadas ao acess√°-las como propriedades ou campos de entidade, como no seguinte exemplo:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

Desde a vers√£o `0.6.0`, isto √© feito com a fun√ß√£o `loadRelated` do graph-node. As entidades derivadas podem ser acessadas como s√£o nos handlers.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Teste de `loadInBlock`

Desde a vers√£o `0.6.0`, √© poss√≠vel testar o `loadInBlock` com o `mockInBlockStore`, que permite a simula√ß√£o de entidades no cache de blocos.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Pode usar entity.loadInBlock() para retirar a entidade do armazenamento do cache no bloco atual', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Retorna null ao chamar entity.loadInBlock() se uma entidade n√£o existir no bloco atual", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Como testar fontes de dados din√¢micas

Testing dynamic data sources can be be done by mocking the return value of the `context()`, `address()` and `network()` functions of the dataSource namespace. These functions currently return the following: `context()` - returns an empty entity (DataSourceContext), `address()` - returns `0x0000000000000000000000000000000000000000`, `network()` - returns `mainnet`. The `create(...)` and `createWithContext(...)` functions are mocked to do nothing so they don't need to be called in the tests at all. Changes to the return values can be done through the functions of the `dataSourceMock` namespace in `matchstick-as` (version 0.3.0+).

Exemplo abaixo:

Primeiro temos o seguinte handler de eventos (que foi apropriado intencionalmente para demonstrar a falsifica√ß√£o de fontes de dados):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

E ent√£o, temos o teste que usa um dos m√©todos do namespace dataSourceMock para determinar um novo valor de retorno para todas as fun√ß√µes do dataSource:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Note que o <code>dataSourceMock.resetValues()</code> √© chamado no final. Isto √© porque os valores s√£o lembrados quando mudados, e devem ser reconfigurados caso queira voltar aos valores padr√£o.

### Teste de cria√ß√£o de fontes de dados din√¢micas

As of version `0.6.0`, it is possible to test if a new data source has been created from a template. This feature supports both ethereum/contract and file/ipfs templates. There are four functions for this:

- `assert.dataSourceCount(templateName, expectedCount)` can be used to assert the expected count of data sources from the specified template
- `assert.dataSourceExists(templateName, address/ipfsHash)` asserts that a data source with the specified identifier (could be a contract address or IPFS file hash) from a specified template was created
- `logDataSources(templateName)` prints all data sources from the specified template to the console for debugging purposes
- `readFile(path)` reads a JSON file that represents an IPFS file and returns the content as Bytes

#### Testing `ethereum/contract` templates

```typescript
test('ethereum/contract dataSource creation example', () => {
  // Assert there are no dataSources created from GraphTokenLockWallet template
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // Create a new GraphTokenLockWallet datasource with address 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Add a second dataSource with context
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert there are now 2 dataSources
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // Assert that a dataSource with address "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" was created
  // Keep in mind that `Address` type is transformed to lower case when decoded, so you have to pass the address as all lower case when asserting if it exists
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### Example `logDataSource` output

```bash
üõ†  {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
}
```

#### Testing `file/ipfs` templates

Similarly to contract dynamic data sources, users can test test file data sources and their handlers

##### Example `subgraph.yaml`

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### Example `schema.graphql`

```graphql
"""
Token Lock Wallets que t√™m GRT trancado
"""
type TokenLockMetadata @entity {
  "Endere√ßo da token lock wallet"
  id: ID!
  "Come√ßo da agenda de lan√ßamento"
  startTime: BigInt!
  "Final da agenda de lan√ßamento"
  endTime: BigInt!
  "N√∫mero de per√≠odos entre o in√≠cio e o fim"
  periods: BigInt!
  "Hora quando os lan√ßamentos come√ßam"
  releaseStartTime: BigInt!
}
```

##### Example `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Exemplo de handler

```typescript
export function handleMetadata(content: Bytes): void {
  // dataSource.stringParams() returns the File DataSource CID
  // stringParam() will be mocked in the handler test
  // for more info https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Exxemplo de teste

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () => {
  // Generate the dataSource CID from the ipfsHash + ipfs path file
  // For example QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // Create a new dataSource using the generated CID
  GraphTokenLockMetadata.create(CID)

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Now we have to mock the dataSource metadata and specifically dataSource.stringParam()
  // dataSource.stringParams actually uses the value of dataSource.address(), so we will mock the address using dataSourceMock from  matchstick-as
  // First we will reset the values and then use dataSourceMock.setAddress() to set the CID
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)

  // Now we need to generate the Bytes to pass to the dataSource handler
  // For this case we introduced a new function readFile, that reads a local json and returns the content as Bytes
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Now we will test if a TokenLockMetadata was created
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Cobertura de Testes

Using **Matchstick**, Subgraph developers are able to run a script that will calculate the test coverage of the written unit tests.

The test coverage tool takes the compiled test `wasm` binaries and converts them to `wat` files, which can then be easily inspected to see whether or not the handlers defined in `subgraph.yaml` have been called. Since code coverage (and testing as whole) is in very early stages in AssemblyScript and WebAssembly, **Matchstick** cannot check for branch coverage. Instead we rely on the assertion that if a given handler has been called, the event/function for it have been properly mocked.

### Pr√©-requisitos

To run the test coverage functionality provided in **Matchstick**, there are a few things you need to prepare beforehand:

#### Exportar seus handlers

In order for **Matchstick** to check which handlers are being run, those handlers need to be exported from the **test file**. So for instance in our example, in our gravity.test.ts file we have the following handler being imported:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

In order for that function to be visible (for it to be included in the `wat` file **by name**) we need to also export it, like this:

```typescript
export { handleNewGravatar }
```

### Uso

Assim que tudo estiver pronto, para executar a ferramenta de cobertura de testes, basta:

```sh
graph test -- -c
```

You could also add a custom `coverage` command to your `package.json` file, like so:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Isto executar√° a ferramenta de cobertura. Ver√°s algo parecido com isto no terminal:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 Ô∏è
Reading generated test modules... üîéÔ∏è

Generating coverage report üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Dura√ß√£o do teste na sa√≠da do log

A sa√≠da do log inclui a dura√ß√£o do teste. Veja um exemplo:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Erros comuns do compilador

> <code>Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined</code>

This means you have used `console.log` in your code, which is not supported by AssemblyScript. Please consider using the [Logging API](/subgraphs/developing/creating/graph-ts/api/#logging-api)

> <code>ERROR TS2554: Expected ? arguments, but got ?.</code>
>
> <code>return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);</code>
>
> <code>in ~lib/matchstick-as/assembly/defaults.ts(18,12)</code>
>
> <code>ERROR TS2554: Expected ? arguments, but got ?.</code>
>
> <code>return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);</code>
>
> <code>in ~lib/matchstick-as/assembly/defaults.ts(24,12)</code>

The mismatch in arguments is caused by mismatch in `graph-ts` and `matchstick-as`. The best way to fix issues like this one is to update everything to the latest released version.

## Outros Recursos

For any additional support, check out this [demo Subgraph repo using Matchstick](https://github.com/LimeChain/demo-subgraph#readme_).

## Feedback

Caso tenha qualquer pergunta, opini√£o, pedidos de recursos, ou s√≥ quer entrar em contacto, venha para o Discord do The Graph ‚Äî l√°, temos um canal dedicado ao Matchstick, chamado üî•| unit-testing.
