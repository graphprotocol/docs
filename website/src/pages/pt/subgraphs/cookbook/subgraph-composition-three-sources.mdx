---
title: Como Agregar Dados com a Composição de Subgraphs
sidebarTitle: Construa um Subgraph Compostável com Múltiplos Subgraphs
---

Otimize o seu Subgraph mesclando dados de três Subgraphs de origem, independentes, num único Subgraph compostável para melhorar a agregação de dados.

> Avisos Importantes:
>
> - A composição de um subgraph está incorporada à CLI, e a implantação é feita com o [Subgraph Studio](https://thegraph.com/studio/).
> - Este recurso requer a versão 1.3.0 de `specVersion`.

## Visão geral

A composição de Subgraphs permite o uso de um Subgraph como fonte de dados para outro, e também permite que ele consuma e responda às mudanças de entidades. Em vez de buscar diretamente os dados na chain, um Subgraph pode procurar atualizações de outro Subgraph e reagir às mudanças. Isso serve para agregar dados de vários Subgraphs ou desencadear ações com base em atualizações externas.

## Pré-requisitos

Para implantar **todos os** Subgraphs localmente, é necessário ter o seguinte:

- Uma instância do [Graph Node](https://github.com/graphprotocol/graph-node) em execução local
- Uma instância de [IPFS](https://docs.ipfs.tech/) em execução local
- [Node.js](https://nodejs.org) e npm

## Como Começar

O guia a seguir fornece exemplos para a definição de três Subgraphs de origem para criar um poderoso Subgraph composto.

### Especificações

- Para fins de simplicidade, todos os Subgraphs de origem usam apenas handlers de blocos. No entanto, num ambiente real, cada Subgraph de origem usará dados de contratos inteligentes diferentes.
- Os exemplos abaixo mostram como importar e estender o schema de outro Subgraph para melhorar a sua funcionalidade.
- Cada Subgraph de origem é otimizado com uma entidade específica.
- Todos os comandos listados instalam as dependências necessárias, geram código baseado no schema da GraphQL, constroem o Subgraph, e o implantam na instância local do Graph Node.

### Step 1. Deploy Block Time Source Subgraph

This first source Subgraph calculates the block time for each block.

- It imports schemas from other Subgraphs and adds a `block` entity with a `timestamp` field, representing the time each block was mined.
- It listens to time-related blockchain events (e.g., block timestamps) and processes this data to update the Subgraph's entities accordingly.

To deploy this Subgraph locally, run the following commands:

```bash
npm install
npm run codegen
npm run build
npm run create-local
npm run deploy-local
```

### Step 2. Deploy Block Cost Source Subgraph

This second source Subgraph indexes the cost of each block.

#### Key Functions

- It imports schemas from other Subgraphs and adds a `block` entity with cost-related fields.
- It listens to blockchain events related to costs (e.g. gas fees, transaction costs) and processes this data to update the Subgraph's entities accordingly.

To deploy this Subgraph locally, run the same commands as above.

### Step 3. Define Block Size in Source Subgraph

This third source Subgraph indexes the size of each block. To deploy this Subgraph locally, run the same commands as above.

#### Key Functions

- It imports existing schemas from other Subgraphs and adds a `block` entity with a `size` field representing each block's size.
- It listens to blockchain events related to block sizes (e.g., storage or volume) and processes this data to update the Subgraph's entities accordingly.

### Step 4. Combine Into Block Stats Subgraph

This composed Subgraph combines and aggregates the information from the three source Subgraphs above, providing a unified view of block statistics. To deploy this Subgraph locally, run the same commands as above.

> Note:
>
> - Any change to a source Subgraph will likely generate a new deployment ID.
> - Be sure to update the deployment ID in the data source address of the Subgraph manifest to take advantage of the latest changes.
> - All source Subgraphs should be deployed before the composed Subgraph is deployed.

#### Key Functions

- It provides a consolidated data model that encompasses all relevant block metrics.
- It combines data from three source Subgraphs, and provides a comprehensive view of block statistics, enabling more complex queries and analyses.

## Conclusão

- This powerful tool will scale your Subgraph development and allow you to combine multiple Subgraphs.
- The setup includes the deployment of three source Subgraphs and one final deployment of the composed Subgraph.
- This feature unlocks scalability, simplifying both development and maintenance efficiency.

## Outros Recursos

- Check out all the code for this example in [this GitHub repo](https://github.com/isum/subgraph-composition-example).
- To add advanced features to your Subgraph, check out [Subgraph advanced features](/developing/creating/advanced/).
- To learn more about aggregations, check out [Timeseries and Aggregations](/subgraphs/developing/creating/advanced/#timeseries-and-aggregations).
