---
title: Indizierung Überblick
sidebarTitle: Überblick
---

Indexer sind Knotenbetreiber im Graph Network, die Graph Tokens (GRT) einsetzen, um Indizierungs- und Abfrageverarbeitungsdienste anzubieten. Indexer verdienen Abfragegebühren und Indexing Rewards für ihre Dienste. Sie verdienen auch Abfragegebühren, die gemäß einer exponentiellen Rabattfunktion zurückerstattet werden.

Die im Protokoll eingesetzte GRT unterliegt einer Nachfrist und kann reduziert werden, wenn Indexierer böswillig sind und Anwendungen falsche Daten präsentieren oder wenn sie falsch indizieren. Indexer erhalten auch Belohnungen für den Einsatz, den Delegatoren für ihren Beitrag zum Netzwerk geben.

Die Indexierer wählen die zu indexierenden Subgraphen auf der Grundlage des Kurationssignals des Subgraphen aus, wobei die Kuratoren GRT einsetzen, um anzugeben, welche Subgraphen von hoher Qualität sind und priorisiert werden sollten. Verbraucher (z. B. Anwendungen) können auch Parameter dafür festlegen, welche Indexierer Abfragen für ihre Teilgraphen verarbeiten, und Präferenzen für die Preisgestaltung für Abfragen festlegen.

## FAQ

### Wie hoch ist der Mindesteinsatz, der erforderlich ist, um ein Indexierer im Netzwerk zu sein?

Der Mindesteinsatz für einen Indexer ist derzeit auf 100.000 GRT festgelegt.

### Welche Einnahmequellen gibt es für einen Indexierer?

**Query fee rebates** - Zahlungen für die Bedienung von Abfragen im Netz. Diese Zahlungen werden über Statuskanäle zwischen einem Indexer und einem Gateway vermittelt. Jede Abfrageanfrage eines Gateways enthält eine Zahlung und die entsprechende Antwort einen Nachweis für die Gültigkeit des Abfrageergebnisses.

**Indexierungsbelohnungen** - Die Indexierungsbelohnungen werden über eine jährliche protokollweite Inflation von 3% an Indexer verteilt, die Subgraph-Einsätze für das Netzwerk indexieren.

### Wie werden die Indexierungsprämien verteilt?

Indexierungsbelohnungen stammen aus der Protokollinflation, die auf 3 % pro Jahr festgelegt ist. Sie werden auf der Grundlage des Anteils aller Kurationssignale auf jedem Subgraphen verteilt und dann anteilig an die Indexierer auf der Grundlage ihres zugewiesenen Anteils an diesem Subgraphen verteilt. \*\*Eine Zuteilung muss mit einem gültigen Indizierungsnachweis (POI) abgeschlossen werden, der die in der Schlichtungscharta festgelegten Standards erfüllt, um für Belohnungen in Frage zu kommen.

Die Community hat zahlreiche Tools zur Berechnung von Rewards erstellt, die in der [Community-Guides-Sammlung](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c) zusammengefasst sind. Eine aktuelle Liste von Tools finden Sie auch in den Channels #Delegators und #Indexers auf dem [Discord-Server](https://discord.gg/graphprotocol). Hier verlinken wir einen [empfohlenen Allokationsoptimierer](https://github.com/graphprotocol/allocation-optimizer), der in den Indexer-Software-Stack integriert ist.

### Was ist ein Indizierungsnachweis (proof of indexing - POI)?

POIs werden im Netzwerk verwendet, um zu überprüfen, ob ein Indexierer die von ihm zugewiesenen Subgraphen indexiert. Ein POI für den ersten Block der aktuellen Epoche muss beim Schließen einer Zuweisung eingereicht werden, damit diese Zuweisung für die Indexierung belohnt werden kann. Ein POI für einen Block ist eine Zusammenfassung aller Entity-Store-Transaktionen für einen bestimmten Subgraph-Einsatz bis zu diesem Block und einschließlich.

### Wann werden Indizierungsprämien verteilt?

Zuteilungen sind kontinuierlich anfallende Belohnungen, während sie aktiv sind und innerhalb von 28 Epochen zugeteilt werden. Belohnungen werden von den Indexierern gesammelt und verteilt, sobald ihre Zuteilungen geschlossen sind. Das geschieht entweder manuell, wenn der Indexierer das Schließen erzwingen möchte, oder nach 28 Epochen kann ein Delegator die Zuordnung für den Indexer schließen, aber dies führt zu keinen Belohnungen. 28 Epochen ist die maximale Zuweisungslebensdauer (im Moment dauert eine Epoche etwa 24 Stunden).

### Können ausstehende Indizierungsprämien überwacht werden?

Der RewardsManager-Vertrag verfügt über eine schreibgeschützte Funktion [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316), mit der die ausstehenden Rewards für eine bestimmte Zuweisung überprüft werden können.

Viele der von der Community erstellten Dashboards enthalten ausstehende Prämienwerte und können einfach manuell überprüft werden, indem Sie diesen Schritten folgen:

1. Abfrage des [mainnet Subgraphen] (https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one), um die IDs für alle aktiven Zuweisungen zu erhalten:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Verwenden Sie Etherscan, um `getRewards()` aufzurufen:

- Navigieren Sie zu [Etherscan-Schnittstelle zu Rewards-Vertrag](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)
- Zum Aufrufen von `getRewards()`:
  - Erweitern Sie das Dropdown-Menü **9. getRewards**.
  - Geben Sie die **allocationID** in die Eingabe ein.
  - Klicken Sie auf die Schaltfläche **Abfrage**.

### Was sind Streitfälle und wo kann ich sie einsehen?

Sowohl die Abfragen als auch die Zuordnungen des Indexierers können während des Streitzeitraums auf The Graph angefochten werden. Die Streitdauer variiert je nach Streitfall. Abfragen/Bescheinigungen haben ein 7-Epochen-Streitfenster, während Zuweisungen 56 Epochen haben. Nach Ablauf dieser Fristen können weder Zuweisungen noch Rückfragen angefochten werden. Wenn eine Streitigkeit eröffnet wird, wird von den Fischern eine Kaution von mindestens 10.000 GRT verlangt, die gesperrt wird, bis die Streitigkeit abgeschlossen ist und eine Lösung gefunden wurde. Fischer sind alle Netzwerkteilnehmer, die Streitigkeiten eröffnen.

Bei Streitigkeiten gibt es **drei** mögliche Ergebnisse, so auch bei der Kaution der Fischer.

- Wird die Anfechtung zurückgewiesen, werden die von den Fischern hinterlegten GRT verbrannt, und der angefochtene Indexierer wird nicht gekürzt.
- Wird der Streitfall durch ein Unentschieden entschieden, wird die Kaution des Fischers zurückerstattet und der strittige Indexierer wird nicht gekürzt.
- Wird dem Einspruch stattgegeben, werden die von den Fischern eingezahlten GRT zurückerstattet, der strittige Indexer wird gekürzt und die Fischer erhalten 50 % der gekürzten GRT.

Streitfälle können in der Benutzeroberfläche auf der Profilseite eines Indexierers unter der Registerkarte `Disputes` angezeigt werden.

### Was sind Rückerstattungen von Abfragegebühren und wann werden sie ausgeschüttet?

Die Abfragegebühren werden vom Gateway eingezogen und gemäß der exponentiellen Rabattfunktion an die Indexierer verteilt (siehe GIP [hier](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). Die exponentielle Rabattfunktion wird vorgeschlagen, um sicherzustellen, dass die Indexierer das beste Ergebnis erzielen, indem sie die Abfragen treu bedienen. Sie bietet den Indexierern einen Anreiz, einen hohen Einsatz (der bei Fehlern bei der Bedienung einer Anfrage gekürzt werden kann) im Verhältnis zur Höhe der Abfragegebühren, die sie einnehmen können, zu leisten.

Sobald eine Zuteilung abgeschlossen ist, können die Rabatte vom Indexierer beansprucht werden. Nach der Beantragung werden die Abfragegebührenrabatte auf der Grundlage der Abfragegebührenkürzung und der exponentiellen Rabattfunktion an den Indexer und seine Delegatoren verteilt.

### Was ist die Kürzung der Abfragegebühr und die Kürzung der Indizierungsprämie?

Die Werte `queryFeeCut` und `indexingRewardCut` sind Delegationsparameter, die der Indexer zusammen mit cooldownBlocks setzen kann, um die Verteilung von GRT zwischen dem Indexer und seinen Delegatoren zu kontrollieren. Siehe die letzten Schritte in [Staking im Protokoll](/indexing/overview/#stake-in-the-protocol) für Anweisungen zur Einstellung der Delegationsparameter.

- **queryFeeCut** - der Prozentsatz der Rückerstattungen von Abfragegebühren, der an den Indexer verteilt wird. Wenn dieser Wert auf 95 % gesetzt ist, erhält der Indexer 95 % der Abfragegebühren, die beim Abschluss einer Zuteilung anfallen, während die restlichen 5 % an die Delegatoren gehen.

- **indexingRewardCut** - der Prozentsatz der Indizierung Rewards, der an den Indexer verteilt wird. Wenn dieser Wert auf 95 % gesetzt ist, erhält der Indexierer 95 % der Rewards für die Indizierung, wenn eine Zuweisung abgeschlossen wird, und die Delegatoren teilen sich die restlichen 5 %.

### Woher wissen die Indexierer, welche Subgraphen indexiert werden sollen?

Indexierer können sich durch die Anwendung fortgeschrittener Techniken für die Indizierung von Subgraphen unterscheiden, aber um eine allgemeine Vorstellung zu vermitteln, werden wir einige Schlüsselmetriken diskutieren, die zur Bewertung von Subgraphen im Netzwerk verwendet werden:

- **Kurationssignal** - Der Anteil des Netzwerkkurationssignals, der auf einen bestimmten Subgraphen angewandt wird, ist ein guter Indikator für das Interesse an diesem Subgraphen, insbesondere während der Bootstrap-Phase, wenn das Abfragevolumen ansteigt.

- **Eingezogene Abfragegebühren** - Die historischen Daten zum Volumen der für einen bestimmten Subgraphen eingezogenen Abfragegebühren sind ein guter Indikator für die zukünftige Nachfrage.

- **Einsatzhöhe** - Die Beobachtung des Verhaltens anderer Indexierer oder die Betrachtung des Anteils am Gesamteinsatz, der bestimmten Subgraphen zugewiesen wird, kann es einem Indexierer ermöglichen, die Angebotsseite für Subgraphenabfragen zu überwachen, um Subgraphen zu identifizieren, in die das Netzwerk Vertrauen zeigt, oder Subgraphen, die möglicherweise einen Bedarf an mehr Angebot aufweisen.

- **Subgraphen ohne Indizierungsbelohnungen** - Einige Subgraphen erzeugen keine Indizierungsbelohnungen, hauptsächlich weil sie nicht unterstützte Funktionen wie IPFS verwenden oder weil sie ein anderes Netzwerk außerhalb des Hauptnetzes abfragen. Wenn ein Subgraph keine Indizierungsbelohnungen erzeugt, wird eine entsprechende Meldung angezeigt.

### Welche Hardware-Anforderungen gibt es?

- **Small** - Ausreichend, um mit der Indizierung mehrerer Subgraphen zu beginnen, wird wahrscheinlich erweitert werden müssen.
- **Standard** - Standardeinstellung, wie sie in den k8s/terraform-Beispielmanifesten verwendet wird.
- **Medium** - Produktionsindexer, der 100 Subgraphen und 200-500 Anfragen pro Sekunde unterstützt.
- **Large** - Vorbereitet, um alle derzeit verwendeten Subgraphen zu indizieren und Anfragen für den entsprechenden Verkehr zu bedienen.

| Konfiguration | Postgres<br />(CPUs) | Postgres<br />(Speicher in GB) | Postgres<br />(Festplatte in TB) | VMs<br />(CPUs) | VMs<br />(Speicher in GB) |
| --- | :-: | :-: | :-: | :-: | :-: |
| Small | 4 | 8 | 1 | 4 | 16 |
| Standard | 8 | 30 | 1 | 12 | 48 |
| Medium | 16 | 64 | 2 | 32 | 64 |
| Large | 72 | 468 | 3.5 | 48 | 184 |

### Was sind einige grundlegende Sicherheitsvorkehrungen, die ein Indexierer treffen sollte?

- **Operator Wallet** - Die Einrichtung einer Operator Wallet ist eine wichtige Vorsichtsmaßnahme, da sie es einem Indexierer ermöglicht, eine Trennung zwischen seinen Schlüsseln, die den Einsatz kontrollieren, und den Schlüsseln, die für den täglichen Betrieb zuständig sind, aufrechtzuerhalten. Siehe [Stake im Protocol](/indexing/overview/#stake-in-the-protocol) für Anweisungen.

- **Firewall** - Nur der Indexierer-Dienst muss öffentlich zugänglich gemacht werden, und es sollte besonders darauf geachtet werden, dass die Admin-Ports und der Datenbankzugriff gesperrt werden: der Graph Node JSON-RPC-Endpunkt (Standard-Port: 8030), der Indexer-Management-API-Endpunkt (Standard-Port: 18000) und der Postgres-Datenbank-Endpunkt (Standard-Port: 5432) sollten nicht öffentlich zugänglich sein.

## Infrastruktur

Im Zentrum der Infrastruktur eines Indexierers steht der Graph Node, der die indizierten Netzwerke überwacht, Daten gemäß einer Subgraph-Definition extrahiert und lädt und sie als [GraphQL API](/about/#how-the-graph-works) bereitstellt. Der Graph Node muss mit einem Endpunkt verbunden sein, der Daten aus jedem indizierten Netzwerk ausgibt; ein IPFS-Knoten für die Datenbeschaffung; eine PostgreSQL-Datenbank für die Speicherung; und Indexer-Komponenten, die seine Interaktionen mit dem Netzwerk erleichtern.

- **PostgreSQL-Datenbank** - Der Hauptspeicher für den Graphenknoten, in dem die Subgraphen-Daten gespeichert werden. Der Indexer-Dienst und der Agent verwenden die Datenbank auch zum Speichern von Statuskanaldaten, Kostenmodellen, Indizierungsregeln und Zuordnungsaktionen.

- **Datenendpunkt** - Bei EVM-kompatiblen Netzwerken muss der Graph Node mit einem Endpunkt verbunden sein, der eine EVM-kompatible JSON-RPC-API bereitstellt. Dabei kann es sich um einen einzelnen Client handeln oder um ein komplexeres Setup, das die Last auf mehrere Clients verteilt. Es ist wichtig, sich darüber im Klaren zu sein, dass bestimmte Subgraphen besondere Client-Fähigkeiten erfordern, wie z. B. den Archivmodus und/oder die Paritätsverfolgungs-API.

- **IPFS-Knoten (Version kleiner als 5)** - Die Metadaten für die Subgraph-Bereitstellung werden im IPFS-Netzwerk gespeichert. Der Graph Node greift in erster Linie auf den IPFS-Knoten während der Bereitstellung des Subgraphen zu, um das Subgraphen-Manifest und alle verknüpften Dateien zu holen. Netzwerk-Indizierer müssen keinen eigenen IPFS-Knoten hosten, ein IPFS-Knoten für das Netzwerk wird unter https://ipfs.thegraph.com gehostet.

- **Indexierer-Dienst** - Erledigt alle erforderlichen externen Kommunikationen mit dem Netz. Teilt Kostenmodelle und Indizierungsstatus, leitet Abfrageanfragen von Gateways an einen Graph Node weiter und verwaltet die Abfragezahlungen über Statuskanäle mit dem Gateway.

- **Indexierer-Agent** - Erleichtert die Interaktionen des Indexierers in der Kette, einschließlich der Registrierung im Netzwerk, der Verwaltung von Subgraph-Einsätzen in seine(n) Graph-Knoten und der Verwaltung von Zuweisungen.

- **Prometheus Metrics Server** - Die Komponenten Graph Node und Indexierer protokollieren ihre Metriken auf dem Metrics Server.

Hinweis: Um eine flexible Skalierung zu unterstützen, wird empfohlen, Abfrage- und Indizierungsbelange auf verschiedene Knotengruppen zu verteilen: Abfrageknoten und Indexknoten.

### Übersicht über Ports

> **Wichtig**: Seien Sie vorsichtig damit, Ports öffentlich zugänglich zu machen - **Verwaltungsports** sollten unter Verschluss gehalten werden. Dies gilt auch für den Graph Node JSON-RPC und die Indexierer-Verwaltungsendpunkte, die im Folgenden beschrieben werden.

#### Graph-Knoten

| Port | Verwendungszweck | Routen | CLI-Argument | Umgebungsvariable |
| --- | --- | --- | --- | --- |
| 8000 | GraphQL HTTP Server<br />(für Subgraph-Abfragen) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port | - |
| 8001 | GraphQL WS<br />(für Subgraphen-Abonnements) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port | - |
| 8020 | JSON-RPC<br />(zum Verwalten von Deployments) | / | \--admin-port | - |
| 8030 | Status der Indizierung von Subgraphen API | /graphql | \--index-node-port | - |
| 8040 | Prometheus-Metriken | /metrics | \--metrics-port | - |

#### Indexer-Service

| Port | Verwendungszweck | Routen | CLI-Argument | Umgebungsvariable |
| --- | --- | --- | --- | --- |
| 7600 | GraphQL HTTP Server<br />(für bezahlte Subgraph-Abfragen) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port | `INDEXER_SERVICE_PORT` |
| 7300 | Prometheus-Metriken | /metrics | \--metrics-port | - |

#### Indexierer-Agent

| Port | Verwendungszweck        | Routen | CLI-Argument               | Umgebungsvariable                       |
| ---- | ----------------------- | ------ | -------------------------- | --------------------------------------- |
| 8000 | Indexer-Verwaltungs-API | /      | \--indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Einrichten einer Server-Infrastruktur mit Terraform auf Google Cloud

> Hinweis: Indexierer können alternativ AWS, Microsoft Azure oder Alibaba nutzen.

#### Installieren Sie die Voraussetzungen

- Google Cloud-SDK
- Kubectl-Befehlszeilentool
- Terraform

#### Erstellen Sie ein Google Cloud-Projekt

- Klonen oder navigieren Sie zum [Indexierer-Repository] (https://github.com/graphprotocol/indexer).

- Navigieren Sie zum Verzeichnis `./terraform`, in dem alle Befehle ausgeführt werden sollen.

```sh
cd terraform
```

- Authentifizieren Sie sich bei Google Cloud und erstellen Sie ein neues Projekt.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Verwenden Sie die Abrechnungsseite der Google Cloud Console, um die Abrechnung für das neue Projekt zu aktivieren.

- Erstellen Sie eine Google Cloud-Konfiguration.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Aktivieren Sie die erforderlichen Google Cloud-APIs.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Erstellen Sie ein Service-Konto.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Aktivieren Sie das Peering zwischen der Datenbank und dem Kubernetes-Cluster, der im nächsten Schritt erstellt wird.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer Networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Erstellen Sie eine minimale Terraform-Konfigurationsdatei (aktualisieren Sie sie nach Bedarf).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database passowrd>"
EOF
```

#### Verwenden Sie Terraform zum Erstellen einer Infrastruktur

Bevor Sie irgendwelche Befehle ausführen, lesen Sie [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) und erstellen Sie eine Datei `terraform.tfvars` in diesem Verzeichnis (oder ändern Sie die im letzten Schritt erstellte Datei). Für jede Variable, bei der Sie die Standardeinstellung überschreiben oder einen Wert festlegen möchten, geben Sie eine Einstellung in `terraform.tfvars` ein.

- Führen Sie zum Erstellen der Infrastruktur die folgenden Befehle aus.

```sh
# Erforderliche Plugins installieren
terraform init

# Plan für die zu erstellenden Ressourcen anzeigen
terraform plan

# Erstellen Sie die Ressourcen (dies kann bis zu 30 Minuten dauern)
terraform apply
```

Laden Sie die Anmeldedaten für den neuen Cluster in `~/.kube/config` herunter und setzen Sie ihn als Standardkontext.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Erstellen der Kubernetes-Komponenten für den Indexierer

- Kopieren Sie das Verzeichnis `k8s/overlays` in ein neues Verzeichnis `$dir,` und passen Sie den Eintrag `bases` in `$dir/kustomization.yaml` so an, dass er auf das Verzeichnis `k8s/base` zeigt.

- Lesen Sie alle Dateien in `$dir` durch und passen Sie alle Werte wie in den Kommentaren angegeben an.

Stellen Sie alle Ressourcen mit `kubectl apply -k $dir` bereit.

### Graph-Knoten

[Graph Node] (https://github.com/graphprotocol/graph-node) ist eine quelloffene Rust-Implementierung, die die Ethereum-Blockchain mit Ereignisquellen versorgt, um einen Datenspeicher deterministisch zu aktualisieren, der über den GraphQL-Endpunkt abgefragt werden kann. Entwickler verwenden Subgraphen zur Definition ihres Schemas und eine Reihe von Mappings zur Umwandlung der von der Blockchain bezogenen Daten. Der Graph Node übernimmt die Synchronisierung der gesamten Kette, die Überwachung auf neue Blöcke und die Bereitstellung über einen GraphQL-Endpunkt.

#### Einstieg in den Sourcecode

#### Installieren Sie die Voraussetzungen

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Zusätzliche Anforderungen für Ubuntu-Benutzer** - Um einen Graph Node unter Ubuntu zu betreiben, sind möglicherweise einige zusätzliche Pakete erforderlich.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Konfiguration

1. Starten Sie einen PostgreSQL-Datenbankserver

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Klonen Sie das [Graph-Knoten](https://github.com/graphprotocol/graph-node)-Repo und erstellen Sie den Sourcecode durch Ausführen von `cargo build`

3. Nachdem alle Abhängigkeiten eingerichtet sind, starten Sie den Graph Node:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.thegraph.com
```

#### Erste Schritte mit Docker

#### Voraussetzungen

- **Ethereum-Knoten** - Standardmäßig verwendet das Docker-Compose-Setup mainnet: [http://host.docker.internal:8545](http://host.docker.internal:8545), um sich mit dem Ethereum-Knoten auf Ihrem Host-Rechner zu verbinden. Sie können diesen Netzwerknamen und die Url ersetzen, indem Sie die Datei `docker-compose.yaml` aktualisieren.

#### Konfiguration

1. Klonen Sie den Graph-Knoten und navigieren Sie zum Docker-Verzeichnis:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Nur für Linux-Benutzer - Verwenden Sie die Host-IP-Adresse anstelle von `host.docker.internal` in der Datei `docker-compose.yaml ` mit Hilfe des mitgelieferten Skripts:

```sh
./setup.sh
```

3. Starten Sie einen lokalen Graph-Knoten, der sich mit Ihrem Ethereum-Endpunkt verbindet:

```sh
docker-compose up
```

### Indexierer-Komponenten

Um erfolgreich am Netzwerk teilzunehmen, sind fast ständige Überwachung und Interaktion erforderlich. Daher haben wir eine Reihe von Typescript-Anwendungen entwickelt, um die Teilnahme am Indexierers-Netzwerk zu erleichtern. Es gibt drei Indexierer-Komponenten:

- **Indexierer-Agent** - Der Agent überwacht das Netzwerk und die eigene Infrastruktur des Indexierers und verwaltet, welche Subgraph-Einsätze indiziert und der Onchain zugewiesen werden und wie viel davon jeweils zugewiesen wird.

- **Indexierer-Dienst** - Die einzige Komponente, die extern zugänglich gemacht werden muss. Der Dienst leitet Subgraph-Abfragen an den Graph-Knoten weiter, verwaltet Zustandskanäle für Abfragezahlungen und gibt wichtige Informationen zur Entscheidungsfindung an Clients wie die Gateways weiter.

- **Indexierer CLI** - Die Befehlszeilenschnittstelle zur Verwaltung des Indexierer-Agenten. Sie ermöglicht Indexern die Verwaltung von Kostenmodellen, manuellen Zuweisungen, Aktionswarteschlangen und Indizierungsregeln.

#### Erste Schritte

Der Indexierer-Agent und der Indexierer-Service sollten sich in Ihrer Graph Node-Infrastruktur befinden. Es gibt viele Möglichkeiten, virtuelle Ausführungsumgebungen für Ihre Indexierer-Komponenten einzurichten; hier erklären wir, wie Sie sie auf Baremetal mit NPM-Paketen oder Source oder über Kubernetes und Docker auf der Google Cloud Kubernetes Engine ausführen. Wenn sich diese Datenbeispiele nicht gut auf Ihre Infrastruktur übertragen lassen, wird es wahrscheinlich einen Community-Leitfaden geben, auf den Sie sich beziehen können. Kommen Sie auf [Discord] (https://discord.gg/graphprotocol) vorbei! Vergessen Sie nicht, [stake in the protocol](/indexing/overview/#stake-in-the-protocol), bevor Sie Ihre Indexierer-Komponenten starten!

#### Aus NPM-Paketen

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### Vom Sourcecode

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Verwenden von Docker

- Ziehen Sie Bilder aus der Registrierung

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Oder erstellen Sie Images lokal aus dem Sourcecode

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Führen Sie die Komponenten aus

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**HINWEIS**: Nach dem Start der Container sollte der Indexierer-Dienst unter [http://localhost:7600](http://localhost:7600) erreichbar sein und der Indexierer-Agent sollte die Indexer-Verwaltungs-API unter [http://localhost:18000/](http://localhost:18000/) zur Verfügung stellen.

#### Verwendung von K8s und Terraform

Sehen Sie den Abschnitt [Einrichten der Serverinfrastruktur mit Terraform in Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Verwendung

> HINWEIS: Alle Laufzeit-Konfigurationsvariablen können entweder als Parameter auf den Befehl beim Start oder mithilfe von Umgebungsvariablen im Format `COMPONENT_NAME_VARIABLE_NAME`(z. B. `INDEXER_AGENT_ETHEREUM`) angewandt werden.

#### Indexierer-Agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexierer-Service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexierer-CLI

Das Indexierer-CLI ist ein Plugin für [`@graphprotocol/graph-cli`] (https://www.npmjs.com/package/@graphprotocol/graph-cli), das im Terminal unter `graph indexer` erreichbar ist.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Indexierer-Verwaltung mit Indexierer-CLI

Das vorgeschlagene Werkzeug für die Interaktion mit der **Indexierer-Management-API** ist das **Indexierer-CLI**, eine Erweiterung des **Graph CLI**. Der Indexierer-Agent benötigt Input von einem Indexierer, um im Namen des Indexers autonom mit dem Netzwerk zu interagieren. Die Mechanismen zur Definition des Verhaltens des Indexer-Agenten sind der **Zuweisungsmanagement**-Modus und **Indexierungsregeln**. Im automatischen Modus kann ein Indexierer **Indizierungsregeln** verwenden, um seine spezifische Strategie für die Auswahl von Subgraphen anzuwenden, die er indizieren und für die er Abfragen liefern soll. Die Regeln werden über eine GraphQL-API verwaltet, die vom Agenten bereitgestellt wird und als Indexierer Management API bekannt ist. Im manuellen Modus kann ein Indexierer Zuordnungsaktionen über die **Aktionswarteschlange** erstellen und sie explizit genehmigen, bevor sie ausgeführt werden. Im Überwachungsmodus werden **Indizierungsregeln** verwendet, um die **Aktionswarteschlange** zu füllen, und erfordern ebenfalls eine ausdrückliche Genehmigung für die Ausführung.

#### Verwendung

Die **Indexierer-CLI** verbindet sich mit dem Indexierer-Agenten, in der Regel über Port-Forwarding, so dass die CLI nicht auf demselben Server oder Cluster laufen muss. Um Ihnen den Einstieg zu erleichtern und etwas Kontext zu liefern, wird die CLI hier kurz beschrieben.

- `graph indexer connect <url>` - Verbindet mit der Indexierer-Verwaltungs-API. Typischerweise wird die Verbindung zum Server über Port-Forwarding geöffnet, so dass die CLI einfach aus der Ferne bedient werden kann. (Datenbeispiel: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Holt eine oder mehrere Indizierungsregeln unter Verwendung von `all` als `<deployment-id>`, um alle Regeln zu erhalten, oder `global`, um die globalen Standardwerte zu erhalten. Ein zusätzliches Argument `--merged` kann verwendet werden, um anzugeben, dass einsatzspezifische Regeln mit der globalen Regel zusammengeführt werden. Auf diese Weise werden sie im Indexer-Agent angewendet.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Eine oder mehrere Indizierungsregeln setzen.

- `graph indexer rules start [options] <deployment-id>` - Startet die Indizierung eines Subgraph-Einsatzes, wenn dieser verfügbar ist, und setzt seine `decisionBasis` auf `always`, so dass der Indexierer-Agent immer die Indizierung dieses Einsatzes wählt. Wenn die globale Regel auf `always` gesetzt ist, werden alle verfügbaren Subgraphen im Netzwerk indiziert.

- `graph indexer rules stop [options] <deployment-id->` - Stoppt die Indizierung eines Einsatzes und setzt seine `decisionBasis` auf never, so dass er diesen Einsatz bei der Entscheidung über die zu indizierenden Einsätze überspringt.

- `graph indexer rules maybe [options] <deployment-id>` - Setzt die `decisionBasis` für ein Deployment auf `rules`, so dass der Indexierer-Agent Indizierungsregeln verwendet, um zu entscheiden, ob dieses Deployment indiziert werden soll.

- `graph indexer actions get [options] <action-id>` - Holt eine oder mehrere Aktionen mit `all` oder lässt `action-id` leer, um alle Aktionen zu erhalten. Ein zusätzliches Argument `--status` kann verwendet werden, um alle Aktionen mit einem bestimmten Status auszugeben.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Aktion zur Warteschlangenzuordnung

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Aktion zur Neuzuweisung der Warteschlange

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Aktion zum Aufheben der Warteschlangenzuordnung

- `graph indexer actions cancel [<action-id> ...]` - Abbrechen aller Aktionen in der Warteschlange, wenn id nicht angegeben ist, sonst Abbrechen eines Arrays von id mit Leerzeichen als Trennzeichen

- `graph indexer actions approve [<action-id> ...]` - Mehrere Aktionen zur Ausführung freigeben

- `graph indexer actions execute approve` - Erzwingt die sofortige Ausführung genehmigter Aktionen durch den Worker

Alle Befehle, die Regeln in der Ausgabe anzeigen, können zwischen den unterstützten Ausgabeformaten (`table`, `yaml` und `json`) mit dem Argument `-output` wählen.

#### Indizierungsregeln

Indizierungsregeln können entweder als globale Standardwerte oder für bestimmte Subgraph-Einsätze unter Verwendung ihrer IDs angewendet werden. Die Felder `deployment` und `decisionBasis` sind obligatorisch, während alle anderen Felder optional sind. Wenn eine Indizierungsregel `rules` als `decisionBasis` hat, dann vergleicht der Indexierer-Agent die Schwellenwerte dieser Regel, die nicht Null sind, mit den Werten, die aus dem Netzwerk für den entsprechenden Einsatz geholt wurden. Wenn der Subgraph-Einsatz Werte über (oder unter) einem der Schwellenwerte hat, wird er für die Indizierung ausgewählt.

Wenn zum Beispiel die globale Regel einen `minStake` von **5** (GRT) hat, wird jeder Einsatz von Subgraphen, dem mehr als 5 (GRT) zugewiesen wurden, indiziert. Zu den Schwellenwertregeln gehören `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, und `minAverageQueryFees`.

Datenmodell:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Beispiel für die Verwendung der Indizierungsregel:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Befehlszeilenschnittstelle (CLI) für die Aktionswarteschlange

Das indexierer-cli bietet ein `actions`-Modul für die manuelle Arbeit mit der Aktionswarteschlange. Es verwendet die **Graphql-API**, die vom Indexierer-Verwaltungsserver gehostet wird, um mit der Aktions-Warteschlange zu interagieren.

Der Action Execution Worker holt sich nur dann Elemente aus der Warteschlange, um sie auszuführen, wenn sie den Status `ActionStatus = approved` haben. Im empfohlenen Pfad werden Aktionen der Warteschlange mit ActionStatus = queued hinzugefügt, so dass sie dann genehmigt werden müssen, um in der Kette ausgeführt zu werden. Der allgemeine Ablauf sieht dann wie folgt aus:

- Aktion, die vom Drittanbieter-Optimierungstool oder vom indexer-cli-Benutzer zur Warteschlange hinzugefügt wurde
- Indexierer kann die `indexer-cli` verwenden, um alle in der Warteschlange stehenden Aktionen zu sehen
- Indexierer (oder andere Software) kann Aktionen in der Warteschlange mit Hilfe des `indexer-cli` genehmigen oder abbrechen. Die Befehle approve und cancel nehmen ein Array von Aktions-Ids als Eingabe.
- Der Ausführungsworker fragt die Warteschlange regelmäßig nach genehmigten Aktionen ab. Er holt die `approved` Aktionen aus der Warteschlange, versucht, sie auszuführen, und aktualisiert die Werte in der Datenbank je nach Ausführungsstatus auf `success` oder `failed`.
- Ist eine Aktion erfolgreich, stellt der Worker sicher, dass eine Indizierungsregel vorhanden ist, die dem Agenten mitteilt, wie er die Zuweisung in Zukunft verwalten soll. Dies ist nützlich, wenn manuelle Aktionen durchgeführt werden, während sich der Agent im `auto`- oder `oversight`-Modus befindet.
- Der Indexierer kann die Aktionswarteschlange überwachen, um einen Überblick über die Ausführung von Aktionen zu erhalten und bei Bedarf Aktionen, deren Ausführung fehlgeschlagen ist, erneut zu genehmigen und zu aktualisieren. Die Aktionswarteschlange bietet einen Überblick über alle in der Warteschlange stehenden und ausgeführten Aktionen.

Datenmodell:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Verwendungsbeispiel aus dem Sourcecode:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Beachten Sie, dass unterstützte Aktionstypen für das Allokationsmanagement unterschiedliche Eingabeanforderungen haben:

- `Allocate` - Zuweisung eines Einsatzes für einen bestimmten Einsatz von Subgraphen

  - erforderliche Aktionsparameter:
    - deploymentID
    - amount

- `Unallocate` - Beendigung der Zuweisung, wodurch der Einsatz für eine andere Zuweisung frei wird

  - erforderliche Aktionsparameter:
    - allocationID
    - deploymentID
  - optionale Aktionsparameter:
    - poi
    - force (erzwingt die Verwendung des bereitgestellten POI, auch wenn es nicht mit dem übereinstimmt, was der Graph-Knoten bereitstellt)

- `Reallocate` - Zuordnung atomar schließen und eine neue Zuordnung für denselben Einsatz von Subgraphen öffnen

  - erforderliche Aktionsparameter:
    - allocationID
    - deploymentID
    - amount
  - optionale Aktionsparameter:
    - poi
    - force (erzwingt die Verwendung des bereitgestellten POI, auch wenn es nicht mit dem übereinstimmt, was der Graph-Knoten bereitstellt)

#### Kostenmodelle

Kostenmodelle ermöglichen eine dynamische Preisgestaltung für Abfragen auf der Grundlage von Markt- und Abfrageattributen. Der Indexierer-Service teilt ein Kostenmodell mit den Gateways für jeden Subgraphen, für den sie beabsichtigen, auf Anfragen zu antworten. Die Gateways wiederum nutzen das Kostenmodell, um Entscheidungen über die Auswahl der Indexer pro Anfrage zu treffen und die Bezahlung mit den ausgewählten Indexern auszuhandeln.

#### Agora

Die Agora-Sprache bietet ein flexibles Format zur Deklaration von Kostenmodellen für Abfragen. Ein Agora-Preismodell ist eine Folge von Anweisungen, die für jede Top-Level-Abfrage in einer GraphQL-Abfrage nacheinander ausgeführt werden. Für jede Top-Level-Abfrage bestimmt die erste Anweisung, die ihr entspricht, den Preis für diese Abfrage.

Eine Anweisung besteht aus einem Prädikat, das zum Abgleich von GraphQL-Abfragen verwendet wird, und einem Kostenausdruck, der bei der Auswertung die Kosten in dezimalen GRT ausgibt. Werte in der benannten Argumentposition einer Abfrage können im Prädikat erfasst und im Ausdruck verwendet werden. Globale Werte können auch gesetzt und durch Platzhalter in einem Ausdruck ersetzt werden.

Beispielkostenmodell:

```
# Diese Anweisung erfasst den Wert „skip“,
# verwendet einen booleschen Ausdruck im Prädikat, um mit bestimmten Abfragen übereinzustimmen, die `skip` verwenden
# und einen Kostenausdruck, um die Kosten auf der Grundlage des `skip`-Wertes und des globalen SYSTEM_LOAD-Wertes zu berechnen
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# Diese Vorgabe passt auf jeden GraphQL-Ausdruck.
# Sie verwendet ein Global, das in den Ausdruck eingesetzt wird, um die Kosten zu berechnen
default => 0.1 * $SYSTEM_LOAD;
```

Beispiel für eine Abfragekostenberechnung unter Verwendung des obigen Modells:

| Abfrage                                                                      | Preis   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### Anwendung des Kostenmodells

Kostenmodelle werden über die Indexierer-CLI angewendet, die sie zum Speichern in der Datenbank an die Indexierer-Verwaltungs-API des Indexierer-Agenten übergibt. Der Indexierer-Service holt sie dann ab und stellt Gateways die Kostenmodelle zur Verfügung, jedesmal wenn sie danach fragen.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interaktion mit dem Netzwerk

### Einsatz im Protokoll

Die ersten Schritte zur Teilnahme am Netzwerk als Indexierer sind die Genehmigung des Protokolls, der Einsatz von Geldern und (optional) die Einrichtung einer Betreiberadresse für die täglichen Interaktionen mit dem Protokoll.

> Hinweis: In dieser Anleitung wird Remix für die Interaktion mit dem Vertrag verwendet, aber Sie können auch das Tool Ihrer Wahl verwenden ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/) und [MyCrypto](https://www.mycrypto.com/account) sind einige andere bekannte Tools).

Sobald ein Indexer GRT im Protokoll verankert hat, können die [Indexierer-Komponenten](/indexing/overview/#indexer-components) gestartet werden und ihre Interaktionen mit dem Netzwerk beginnen.

#### Genehmigen Sie Token

1. Öffnen Sie die [Remix-App] (https://remix.ethereum.org/) in einem Browser

2. Erstellen Sie im `File Explorer` eine Datei mit dem Namen **GraphToken.abi** mit dem [Token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. Wählen Sie die Datei `GraphToken.abi` aus und öffnen Sie sie im Editor. Wechseln Sie in der Remix-Benutzeroberfläche zum Abschnitt `Deploy and run transactions`.

4. Wählen Sie unter environment die Option `Injected Web3` und unter `Account` die Adresse Ihres Indexierers aus.

5. Legen Sie die GraphToken-Vertragsadresse fest - Fügen Sie die GraphToken-Vertragsadresse (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) neben `At Address` ein und klicken Sie zum Anwenden auf die Schaltfläche `At address`.

6. Rufen Sie die Funktion `approve(spender, amount)` auf, um den Einsatzvertrag zu genehmigen. Geben Sie in `spender` die Adresse des Einsatzvertrags (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) und in `amount` die zu setzenden Token (in wei) ein.

#### Stake-Token

1. Öffnen Sie die [Remix-App] (https://remix.ethereum.org/) in einem Browser

2. Erstellen Sie im `File Explorer` eine Datei mit dem Namen **Staking.abi** mit dem Staking-ABI.

3. Wählen Sie die Datei `Staking.abi` aus und öffnen Sie sie im Editor. Wechseln Sie in der Remix-Benutzeroberfläche zum Abschnitt `Deploy and run transactions`.

4. Wählen Sie unter environment die Option `Injected Web3` und unter `Account` die Adresse Ihres Indexierers aus.

5. Legen Sie die Adresse des Abtretungsvertrags fest - Fügen Sie die Adresse des Abtretungsvertrags (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) neben `At Address` ein und klicken Sie auf die Schaltfläche `At address`, um sie anzuwenden.

6. Rufen Sie `stake()` auf, um GRT in das Protokoll aufzunehmen.

7. (Optional) Indexierer können eine andere Adresse als Operator für ihre Indexer-Infrastruktur genehmigen, um die Schlüssel, die die Fonds kontrollieren, von denen zu trennen, die alltägliche Aktionen wie die Zuweisung auf Subgraphen und die Bedienung (bezahlter) Abfragen durchführen. Um den Betreiber zu setzen, rufen Sie `setOperator()` mit der Betreiberadresse auf.

8. (Optional) Um die Verteilung von Belohnungen zu kontrollieren und Delegatoren strategisch anzulocken, können Indexierer ihre Delegationsparameter aktualisieren, indem sie ihren `indexingRewardCut` (Teile pro Million), `queryFeeCut` (Teile pro Million) und `cooldownBlocks` (Anzahl der Blöcke) aktualisieren. Dazu rufen Sie `setDelegationParameters()` auf. Das folgende Beispiel stellt den `queryFeeCut` so ein, dass 95% der Abfragerabatte an den Indexierer und 5% an die Delegatoren verteilt werden, stellt den `indexingRewardCut` so ein, dass 60% der Indexierungsbelohnungen an den Indexierer und 40% an die Delegatoren verteilt werden, und stellt die `cooldownBlocks` Periode auf 500 Blöcke.

```
setDelegationParameters(950000, 600000, 500)
```

### Einstellung der Delegationsparameter

Die Funktion `setDelegationParameters()` im [Staking Contract] (https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) ist für Indexierer von entscheidender Bedeutung, da sie es ihnen ermöglicht, Parameter zu setzen, die ihre Interaktion mit Delegatoren definieren und ihre Reward-Aufteilung und Delegationskapazität beeinflussen.

### Festlegen der Delegationsparameter

Gehen Sie wie folgt vor, um die Delegationsparameter über die Graph Explorer-Schnittstelle einzustellen:

1. Navigieren Sie zu [Graph Explorer] (https://thegraph.com/explorer/).
2. Verbinden Sie Ihre Wallet. Wählen Sie Multisig (z. B. Gnosis Safe) und dann Mainnet aus. Hinweis: Sie müssen diesen Vorgang für Arbitrum One wiederholen.
3. Verbinden Sie die Wallet, die Sie als Unterzeichner haben.
4. Navigieren Sie zum Abschnitt 'Settings' und wählen Sie 'Delegation Parameters'. Diese Parameter sollten so konfiguriert werden, dass eine effektive Kürzung innerhalb des gewünschten Bereichs erreicht wird. Nach Eingabe der Werte in die vorgesehenen Eingabefelder berechnet die Schnittstelle automatisch den effektiven Anteil. Passen Sie diese Werte nach Bedarf an, um den gewünschten Prozentsatz der effektiven Kürzung zu erreichen.
5. Übermitteln Sie die Transaktion an das Netz.

> Hinweis: Diese Transaktion muss von den Unterzeichnern der Multisig-Wallets bestätigt werden.

### Die Lebensdauer einer Zuweisung

Nachdem sie von einem Indexer erstellt wurde, durchläuft eine ordnungsgemäße Zuordnung zwei Zustände.

- **Aktiv** - Sobald eine Zuweisung in der Kette erstellt wurde ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)), wird sie als **aktiv** betrachtet. Ein Teil des eigenen und/oder delegierten Einsatzes des Indexierers wird einem Subgraph-Einsatz zugewiesen, was ihm erlaubt, Rewards für die Indizierung zu beanspruchen und Abfragen für diesen Subgraph-Einsatz zu bedienen. Der Indexierer-Agent verwaltet die Erstellung von Zuweisungen basierend auf den Indexierer-Regeln.

- **Geschlossen** - Ein Indexierer kann eine Zuweisung schließen, sobald 1 Epoche vergangen ist ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) oder sein Indexierer-Agent schließt die Zuweisung automatisch nach der **maxAllocationEpochs** (derzeit 28 Tage). Wenn eine Zuweisung mit einem gültigen Indizierungsnachweis (POI) geschlossen wird, werden die Rewards für die Indizierung an den Indexierer und seine Delegatoren verteilt ([lweitere Informationen](/indexing/overview/#how-are-indexing-rewards-distributed)).

Indexierern wird empfohlen, die Offchain-Synchronisierungsfunktionalität zu nutzen, um den Einsatz von Subgraphen mit dem Chainhead zu synchronisieren, bevor die Zuweisung Onchain erstellt wird. Diese Funktion ist besonders nützlich für Subgraphen, bei denen die Synchronisierung länger als 28 Epochen dauert oder die Gefahr eines unbestimmten Fehlers besteht.
