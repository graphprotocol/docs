---
title: AssemblyScript-Migrationsleitfaden
---

Bis jetzt haben Subgraphen eine der [ersten Versionen von AssemblyScript](https://github.com/AssemblyScript/assemblyscript/tree/v0.6) (v0.6) verwendet. Endlich haben wir Unterst√ºtzung f√ºr die [neueste verf√ºgbare Version](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10) hinzugef√ºgt! üéâ

Dies erm√∂glicht es den Entwicklern von Subgrafen, neuere Funktionen der AS-Sprache und der Standardbibliothek zu nutzen.

Diese Anleitung gilt f√ºr alle, die `graph-cli`/`graph-ts` unter Version `0.22.0` verwenden. Wenn Sie bereits eine h√∂here (oder gleiche) Version als diese haben, haben Sie bereits Version `0.19.10` von AssemblyScript verwendet üôÇ

> Anmerkung: Ab `0.24.0` kann `graph-node` beide Versionen unterst√ºtzen, abh√§ngig von der im Subgraph-Manifest angegebenen `apiVersion`.

## Besonderheiten

### Neue Funktionalit√§t

- `TypedArray` kann nun aus `ArrayBuffer` mit Hilfe der [neuen statischen Methode `wrap`](https://www.assemblyscript.org/stdlib/typedarray.html#static-members) ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1)) erstellt werden
- Neue Standard-Bibliotheksfunktionen: `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare`und `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Unterst√ºtzung f√ºr x instanceof GenericClass hinzugef√ºgt ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- `StaticArray<T>`, hinzugef√ºgt, eine effizientere Array-Variante ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- `Array<T>#flat` hinzugef√ºgt ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- `radix`-Argument bei `Number#toString` implementiert ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- Unterst√ºtzung f√ºr Trennzeichen in Flie√ükomma-Literalen hinzugef√ºgt ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7))
- Unterst√ºtzung f√ºr Funktionen erster Klasse hinzugef√ºgt ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0))
- Buildins hinzugef√ºgt: `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- `Array/TypedArray/String#at` implementiert ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- Unterst√ºtzung f√ºr Template-Literal-Strings hinzugef√ºgt ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- Hinzuf√ºgen von `encodeURI(Component)` und `decodeURI(Component)` ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- Hinzuf√ºgen von `toString`, `toDateString` und `toTimeString` zu `Date` ([v0.18.29](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- Hinzuf√ºgen von `toUTCString` f√ºr `Date` ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- Hinzuf√ºgen von `nonnull/NonNullable` integrierten Typ ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### Optimierungen

- `Math`-Funktionen wie `exp`, `exp2`, `log`, `log2` und `pow` wurden durch schnellere Varianten ersetzt ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- Leicht optimierte `Math.mod` ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- Mehr Feldzugriffe in std Map und Set zwischengespeichert ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
- Optimieren f√ºr Zweierpotenzen in `ipow32/64` ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### Sonstiges

- Der Typ eines Array-Literal kann nun aus seinem Inhalt abgeleitet werden ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- stdlib auf Unicode 13.0.0 ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0)) aktualisiert

## Wie kann man upgraden?

1. √Ñndern Sie Ihre Mappings `apiVersion` in `subgraph.yaml` auf `0.0.9`:

```yaml
...
dataSources:
  ...
    Kartierung:
      ...
      apiVersion: 0.0.9
      ...
```

2. Aktualisieren Sie die `graph-cli`, die Sie verwenden, auf die `latest` Version, indem Sie sie ausf√ºhren:

```bash
# wenn es global installiert ist
npm install --global @graphprotocol/graph-cli@latest

# oder in Ihrem Subgrafen, wenn Sie es als Entwicklerabh√§ngigkeit haben
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. Machen Sie dasselbe f√ºr `graph-ts`, aber anstatt es global zu installieren, speichern Sie es in Ihren Hauptabh√§ngigkeiten:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. Befolgen Sie den Rest der Anleitung, um die Sprach√§nderungen zu beheben.
5. F√ºhren Sie `codegen` und `deploy` erneut aus.

## Einschneidende Ver√§nderungen

### Nullbarkeit

In der √§lteren Version von AssemblyScript konnten Sie Code wie diesen erstellen:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

Da der Wert in der neueren Version jedoch nullbar ist, m√ºssen Sie dies wie folgt √ºberpr√ºfen:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` is not null anymore
}
```

Oder erzwingen Sie es wie folgt:

```typescript
let maybeValue = load()! // bricht zur Laufzeit ab, wenn der Wert null ist

maybeValue.aMethod()
```

Wenn Sie unsicher sind, welche Sie w√§hlen sollen, empfehlen wir Ihnen, immer die sichere Variante zu verwenden. Wenn der Wert nicht vorhanden ist, sollten Sie einfach eine fr√ºhe if-Anweisung mit einem Return in Ihrem Subgraf-Handler ausf√ºhren.

### Variable Beschattung

Fr√ºher konnte man [variable shadowing](https://en.wikipedia.org/wiki/Variable_shadowing) machen und Code wie dieser w√ºrde funktionieren:

```typescript
let a = 10
let b = 20
let a = a + b
```

Jetzt ist dies jedoch nicht mehr m√∂glich und der Compiler gibt diesen Fehler zur√ºck:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

Sie m√ºssen Ihre doppelten Variablen umbenennen, wenn Sie Variable Beschattung verwendet haben.

### Null-Vergleiche

Wenn Sie das Upgrade f√ºr Ihren Subgrafen durchf√ºhren, k√∂nnen manchmal solche Fehler wie diese auftreten:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

Zur L√∂sung des Problems k√∂nnen Sie die `if`-Anweisung einfach wie folgt √§ndern:

```typescript
  if (!decimals) {

  // oder

  if (decimals === null) {
```

Dasselbe gilt, wenn Sie != statt == verwenden.

### Casting

Fr√ºher war es √ºblich, das Schl√ºsselwort `as` f√ºr das Casting zu verwenden, etwa so:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // equivalent to: <Uint8Array>byteArray
```

Dies funktioniert jedoch nur in zwei Szenarien:

- Primitives Casting (zwischen Typen wie `u8`, `i32`, `bool`; z. B.: `let b: isize = 10; b as usize`);
- Upcasting bei der Klassenvererbung (subclass ‚Üí superclass)

Beispiele:

```typescript
// primitives Casting
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
// upcasting bei Klassenvererbung
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // gleich wie: bytes as Uint8Array
```

Es gibt zwei Szenarien, in denen man casten m√∂chte, aber die Verwendung von `as`/`<T>var` **ist nicht sicher**:

- Downcasting bei der Klassenvererbung (superclass ‚Üí subclass)
- Zwischen zwei Typen, die eine gemeinsame Oberklasse haben

```typescript
// Downcasting bei Klassenvererbung
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // bricht zur Laufzeit ab :(
```

```typescript
// zwischen zwei Typen, die sich eine Oberklasse teilen
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // bricht zur Laufzeit ab :(
```

F√ºr diese F√§lle k√∂nnen Sie die Funktion `changetype<T>` verwenden:

```typescript
// Downcasting bei Klassenvererbung
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // funktioniert :)
```

```typescript
// zwischen zwei Typen, die sich eine Oberklasse teilen
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // funktioniert :)
```

Wenn Sie nur die Nullbarkeit entfernen wollen, k√∂nnen Sie weiterhin den `as`-Operator (oder `<T>variable`) verwenden, aber stellen Sie sicher, dass Sie wissen, dass der Wert nicht Null sein kann, sonst bricht es.

```typescript
// die NULL-Zul√§ssigkeit entfernen
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // die NULL-Zul√§ssigkeit sicher entfernen
}

let newBalance = new AccountBalance(balanceId)
```

F√ºr den Fall der Nullbarkeit empfehlen wir, einen Blick auf die [Nullability-Check-Funktion] (https://www.assemblyscript.org/basics.html#nullability-checks) zu werfen, sie wird Ihren Code sauberer machen üôÇ

Au√üerdem haben wir ein paar weitere statische Methoden in einigen Typen hinzugef√ºgt, um das Casting zu erleichtern:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### Nullbarkeitspr√ºfung mit Eigenschaftszugriff

Um die [Nullability-Check-Funktion] (https://www.assemblyscript.org/basics.html#nullability-checks) zu verwenden, k√∂nnen Sie entweder `if`-Anweisungen oder den tern√§ren Operator (`?` und `:`) wie folgt verwenden:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// oder

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

Das funktioniert jedoch nur, wenn Sie das `if` / tern√§r auf eine Variable anwenden, nicht auf einen Eigenschaftszugriff, wie hier:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // l√§sst sich nicht kompilieren
```

Das gibt folgenden Fehler aus:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

To fix this issue, you can create a variable for that property access so that the compiler can do the nullability check magic:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // l√§sst sich prima kompilieren :)
```

### Operator-√úberlastung mit Eigenschaftszugriff

Wenn Sie versuchen, (z.B.) einen Typ, der NULL-Werte (aus einem Eigenschaftszugriff) zul√§sst, mit einem Typ, der keine NULL-Werte zul√§sst, zu summieren, gibt der AssemblyScript-Compiler keine Fehlermeldung aus, dass einer der Werte NULL-Werte zul√§sst, sondern kompiliert es einfach stillschweigend, so dass die M√∂glichkeit besteht, dass der Code zur Laufzeit nicht funktioniert.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // gibt Kompilierzeitfehler √ºber die Nullbarkeit

let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // gibt keine Kompilierzeitfehler, wie es sollte
```

Wir haben diesbez√ºglich ein Problem mit dem AssemblyScript-Compiler er√∂ffnet. Wenn Sie diese Art von Vorg√§ngen jedoch in Ihren Subgraf-Zuordnungen ausf√ºhren, sollten Sie sie zun√§chst so √§ndern, dass zuvor eine Nullpr√ºfung durchgef√ºhrt wird.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // jetzt ist `n` garantiert ein BigInt
```

### Wert-Initialisierung

Wenn Sie einen Code wie diesen haben:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

Es wird zwar kompiliert, bricht aber zur Laufzeit ab. Dies liegt daran, dass der Wert nicht initialisiert wurde. Stellen Sie daher sicher, dass Ihr Subgraf seine Werte initialisiert hat, etwa so:

```typescript
var value = new Type() // initialized
value.x = 10
value.y = 'content'
```

Auch wenn Sie nullf√§hige Eigenschaften in einer GraphQL-Entit√§t haben, gehen Sie wie folgt vor:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

Und Sie haben einen √§hnlichen Code wie diesen:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

Sie m√ºssen sicherstellen, dass Sie den Wert `total.amount` initialisieren, denn wenn Sie versuchen, wie in der letzten Zeile auf die Summe zuzugreifen, wird das Programm abst√ºrzen. Sie m√ºssen ihn also entweder zuerst initialisieren:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

Oder Sie k√∂nnen einfach Ihr GraphQL-Schema so √§ndern, dass Sie keinen nullbaren Typ f√ºr diese Eigenschaft verwenden, dann werden wir sie im Schritt `codegen` mit Null initialisieren üòâ

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest') // initialisiert bereits Eigenschaften, die keine NULL-Werte zulassen
}

total.amount = total.amount + BigInt.fromI32(1)
```

### Initialisierung von Klasseneigenschaften

Wenn Sie Klassen mit Eigenschaften exportieren, die andere Klassen sind (von Ihnen selbst oder von der Standardbibliothek deklariert), dann ist dies der Fall:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

Der Compiler wird einen Fehler machen, weil Sie entweder einen Initialisierer f√ºr die Eigenschaften hinzuf√ºgen m√ºssen, die Klassen sind, oder den Operator `!` hinzuf√ºgen m√ºssen:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// or

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// or

export class Something {
  value!: Thing
}
```

### Array initialization

Die Klasse `Array` akzeptiert immer noch eine Zahl, um die L√§nge der Liste zu initialisieren, aber Sie sollten vorsichtig sein, weil Operationen wie `.push` die Gr√∂√üe tats√§chlich erh√∂hen, anstatt z.B. zum Anfang hinzuzuf√ºgen:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // size 6 :(
```

Je nach den Typen, die Sie verwenden (z. B. nullbare Typen) und wie Sie darauf zugreifen, kann es zu einem Laufzeitfehler wie diesem kommen:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

Um tats√§chlich am Anfang zu pushen, sollte man entweder das `Array` mit der Gr√∂√üe Null initialisieren, wie hier:

```typescript
let arr = new Array<string>(0) // []

arr.push('something') // ["something"]
```

Oder Sie sollten es per Index mutieren:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'something' // ["something", "", "", "", ""]
```

### GraphQL-Schema

Dies ist keine direkte AssemblyScript-√Ñnderung, aber Sie m√ºssen m√∂glicherweise Ihre Datei `schema.graphql` aktualisieren.

Jetzt k√∂nnen Sie in Ihren Typen keine Felder mehr definieren, die nicht nullbare Listen sind. Wenn Sie √ºber ein Schema wie dieses verf√ºgen:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something]! # no longer valid
}
```

Sie m√ºssen ein `!` an das Mitglied des Typs List hinzuf√ºgen, etwa so:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # valid
}
```

Dies hat sich aufgrund von Unterschieden in der Nullbarkeit zwischen AssemblyScript-Versionen ge√§ndert und h√§ngt mit der Datei `src/generated/schema.ts` (Standardpfad, vielleicht haben Sie diesen ge√§ndert) zusammen.

### Sonstiges

- `Map#set` und `Set#add` wurden an die Spezifikation angepasst und geben `this` zur√ºck ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Arrays erben nicht mehr von ArrayBufferView, sondern sind jetzt eigenst√§ndig ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Klassen, die aus Objektliteralen initialisiert werden, k√∂nnen nicht mehr einen Konstruktor definieren ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Das Ergebnis einer `**`-Bin√§roperation ist jetzt die Ganzzahl im gemeinsamen Nenner, wenn beide Operanden Ganzzahlen sind. Zuvor war das Ergebnis eine Flie√ükommazahl, wie beim Aufruf von `Math/f.pow` ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- `NaN` auf `false` verzerren, wenn nach ‚Äöbool‚Äò gecastet wird ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9))
- Beim Verschieben eines kleinen Integer-Wertes vom Typ `i8`/`u8` oder `i16`/`u16` beeinflussen nur die 3 bzw. 4 niedrigstwertigen Bits des RHS-Wertes das Ergebnis, analog zum Ergebnis einer `i32.shl`, das nur von den 5 niedrigstwertigen Bits des RHS-Wertes beeinflusst wird. Beispiel: `someI8 << 8` erzeugte zuvor den Wert `0`, erzeugt aber jetzt `someI8`, da die RHS als `8 & 7 = 0` (3 Bits) ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0)) maskiert wird
- Fehlerbehebung bei relationalen String-Vergleichen bei unterschiedlichen Gr√∂√üen ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
