---
title: Anleitung zur Migration von GraphQL-Validierungen
---

Bald wird „graph-node“ eine 100-prozentige Abdeckung der [GraphQL Validations-Spezifikation](https://spec.graphql.org/June2018/#sec-Validation) unterstützen.

Frühere Versionen von „graph-node“ unterstützten nicht alle Validierungen und lieferten optimierte Antworten – daher ignorierte „graph-node“ bei Unklarheiten ungültige GraphQL-Operationskomponenten.

Die Unterstützung von GraphQL-Validierungen ist die Grundlage für die kommenden neuen Funktionen und die umfassende Leistung von The Graph Network.

Dadurch wird auch der Determinismus der Abfrageantworten sichergestellt, eine wichtige Anforderung für The Graph Network.

**Durch die Aktivierung der GraphQL-Validierungen werden einige vorhandene Abfragen unterbrochen,** die an die Graph-API gesendet werden.

Um diese Validierungen einzuhalten, befolgen Sie bitte den Migrationsleitfaden.

> ⚠️ Wenn Sie Ihre Abfragen nicht migrieren, bevor die Validierungen eingeführt werden, werden Fehler zurückgegeben und möglicherweise Ihre Frontends/Clients beschädigt.

## Migrationsleitfaden

Mit dem CLI-Migrationstool können Sie Probleme in Ihren GraphQL-Vorgängen finden und beheben. Alternativ können Sie den Endpunkt Ihres GraphQL-Clients aktualisieren, um den Endpunkt „https://api-next.thegraph.com/subgraphs/name/$GITHUB_USER/$SUBGRAPH_NAME“ zu verwenden. Wenn Sie Ihre Abfragen anhand dieses Endpunkts testen, können Sie die Probleme in Ihren Abfragen leichter finden.

> Nicht alle Subgrafen müssen migriert werden, wenn Sie [GraphQL ESlint](https://the-guild.dev/graphql/eslint/docs) oder [GraphQL Code Generator](https://the-guild.dev/graphql/codegen) verwenden, stellen sie bereits sicher, dass Ihre Abfragen gültig sind.

## Migrations-CLI-Tool

**Die meisten GraphQL-Operationsfehler können im Voraus in Ihrer Codebasis gefunden werden.**

Aus diesem Grund bieten wir eine reibungslose Validierung Ihrer GraphQL-Operationen während der Entwicklung oder im CI.

[`@graphql-validate/cli`](https://github.com/saihaj/graphql-validate) ist ein einfaches CLI-Tool, das bei der Validierung von GraphQL-Operationen anhand eines bestimmten Schemas hilft.

### **Erste Schritte**

Sie können das Tool wie folgt ausführen:

```bash
npx @graphql-validate/cli -s https://api-next.thegraph.com/subgraphs/name/$GITHUB_USER/$SUBGRAPH_NAME -o *.graphql
```

**Anmerkungen:**

- Setzen oder ersetzen Sie $GITHUB_USER, $SUBGRAPH_NAME durch die entsprechenden Werte. Wie z.B.: [`artblocks/art-blocks`](https://api.thegraph.com/subgraphs/name/artblocks/art-blocks)
- Die bereitgestellte Vorschau-Schema-URL (https://api-next.thegraph.com/) ist stark ratenbeschränkt und wird eingestellt, sobald alle Benutzer auf die neue Version migrieren werden. **Verwenden Sie es nicht in der Produktion.**
- Operationen werden in Dateien mit den folgenden Erweiterungen identifiziert [`.graphql`,](https://www.graphql-tools.com/docs/schema-loading#graphql-file-loader)[`.ts`, `.tsx`, `.js`, `jsx`](https://www.graphql-tools.com/docs/schema-loading#code-file-loader) (`-o` option).

### CLI-Ausgabe

Das CLI-Tool „[@graphql-validate/cli](https://github.com/saihaj/graphql-validate)“ gibt alle GraphQL-Operationsfehler wie folgt aus:

![Error output from CLI](https://i.imgur.com/x1cBdhq.png)

Zu jedem Fehler finden Sie eine Beschreibung, Dateipfad und -position sowie einen Link zu einem Lösungsbeispiel (siehe folgenden Abschnitt).

## Führen Sie Ihre lokalen Abfragen anhand des Vorschauschemas aus

Wir stellen einen Endpunkt „https://api-next.thegraph.com/“ bereit, der eine „graph-node“-Version ausführt, bei der Validierungen aktiviert sind.

Sie können Abfragen ausprobieren, indem Sie diese an folgende Adresse senden:

- `https://api-next.thegraph.com/subgraphs/id/<Qm...>`

oder

- `https://api-next.thegraph.com/subgraphs/name/<GITHUB_USER>/<SUBGRAPH_NAME>`

Um Abfragen zu bearbeiten, bei denen Validierungsfehler gemeldet wurden, können Sie Ihr bevorzugtes GraphQL-Abfragetool wie Altair oder [GraphiQL] (https://cloud.hasura.io/public/graphiql) verwenden und Ihre Abfrage ausprobieren. Diese Tools markieren diese Fehler auch in ihrer Benutzeroberfläche, noch bevor Sie sie ausführen.

## So lösen Sie Probleme

Below, you will find all the GraphQL validations errors that could occur on your existing GraphQL operations.

### GraphQL variables, operations, fragments, or arguments must be unique

We applied rules for ensuring that an operation includes a unique set of GraphQL variables, operations, fragments, and arguments.

A GraphQL operation is only valid if it does not contain any ambiguity.

To achieve that, we need to ensure that some components in your GraphQL operation must be unique.

Here's an example of a few invalid operations that violates these rules:

**Duplicate Query name (#UniqueOperationNamesRule)**

```graphql
# The following operation violated the UniqueOperationName
# rule, since we have a single operation with 2 queries
# with the same name
query myData {
  id
}

query myData {
  name
}
```

_Lösung:_

```graphql
query myData {
  id
}

query myData2 {
  # rename the second query
  name
}
```

**Duplicate Fragment name (#UniqueFragmentNamesRule)**

```graphql
# The following operation violated the UniqueFragmentName
# rule.
query myData {
  id
  ...MyFields
}

fragment MyFields {
  metadata
}

fragment MyFields {
  name
}
```

_Lösung:_

```graphql
query myData {
  id
  ...MyFieldsName
  ...MyFieldsMetadata
}

fragment MyFieldsMetadata { # assign a unique name to fragment
  metadata
}

fragment MyFieldsName { # assign a unique name to fragment
  name
}
```

**Duplicate variable name (#UniqueVariableNamesRule)**

```graphql
# The following operation violates the UniqueVariables
query myData($id: String, $id: Int) {
  id
  ...MyFields
}
```

_Lösung:_

```graphql
query myData($id: String) {
  # keep the relevant variable (here: `$id: String`)
  id
  ...MyFields
}
```

**Duplicate argument name (#UniqueArgument)**

```graphql
# The following operation violated the UniqueArguments
query myData($id: ID!) {
  userById(id: $id, id: "1") {
    id
  }
}
```

_Lösung:_

```graphql
query myData($id: ID!) {
  userById(id: $id) {
    id
  }
}
```

**Duplicate anonymous query (#LoneAnonymousOperationRule)**

Also, using two anonymous operations will violate the `LoneAnonymousOperation` rule due to conflict in the response structure:

```graphql
# This will fail if executed together in
# a single operation with the following two queries:
query {
  someField
}

query {
  otherField
}
```

_Lösung:_

```graphql
query {
  someField
  otherField
}
```

Or name the two queries:

```graphql
query FirstQuery {
  someField
}

query SecondQuery {
  otherField
}
```

### Overlapping Fields

A GraphQL selection set is considered valid only if it correctly resolves the eventual result set.

If a specific selection set, or a field, creates ambiguity either by the selected field or by the arguments used, the GraphQL service will fail to validate the operation.

Here are a few examples of invalid operations that violate this rule:

**Conflicting fields aliases (#OverlappingFieldsCanBeMergedRule)**

```graphql
# Aliasing fields might cause conflicts, either with
# other aliases or other fields that exist on the
# GraphQL schema.
query {
  dogs {
    name: nickname
    name
  }
}
```

_Lösung:_

```graphql
query {
  dogs {
    name: nickname
    originalName: name # alias the original `name` field
  }
}
```

**Conflicting fields with arguments (#OverlappingFieldsCanBeMergedRule)**

```graphql
# Different arguments might lead to different data,
# so we can't assume the fields will be the same.
query {
  dogs {
    doesKnowCommand(dogCommand: SIT)
    doesKnowCommand(dogCommand: HEEL)
  }
}
```

_Lösung:_

```graphql
query {
  dogs {
    knowsHowToSit: doesKnowCommand(dogCommand: SIT)
    knowsHowToHeel: doesKnowCommand(dogCommand: HEEL)
  }
}
```

Also, in more complex use-cases, you might violate this rule by using two fragments that might cause a conflict in the eventually expected set:

```graphql
query {
  # Eventually, we have two "x" definitions, pointing
  # to different fields!
  ...A
  ...B
}

fragment A on Type {
  x: a
}

fragment B on Type {
  x: b
}
```

In addition to that, client-side GraphQL directives like `@skip` and `@include` might lead to ambiguity, for example:

```graphql
fragment mergeSameFieldsWithSameDirectives on Dog {
  name @include(if: true)
  name @include(if: false)
}
```

[You can read more about the algorithm here.](https://spec.graphql.org/June2018/#sec-Field-Selection-Merging)

### Unused Variables or Fragments

A GraphQL operation is also considered valid only if all operation-defined components (variables, fragments) are used.

Here are a few examples for GraphQL operations that violates these rules:

**Unused variable** (#NoUnusedVariablesRule)

```graphql
# Invalid, because $someVar is never used.
query something($someVar: String) {
  someData
}
```

_Lösung:_

```graphql
query something {
  someData
}
```

**Unused Fragment** (#NoUnusedFragmentsRule)

```graphql
# Invalid, because fragment AllFields is never used.
query something {
  someData
}

fragment AllFields { # unused :(
  name
  age
}
```

_Lösung:_

```graphql
# Invalid, because fragment AllFields is never used.
query something {
  someData
}

# remove the `AllFields` fragment
```

### Invalid or missing Selection-Set (#ScalarLeafsRule)

Also, a GraphQL field selection is only valid if the following is validated:

- An object field must-have selection set specified.
- An edge field (scalar, enum) must not have a selection set specified.

Here are a few examples of violations of these rules with the following Schema:

```graphql
type Image {
  url: String!
}

type User {
  id: ID!
  avatar: Image!
}

type Query {
  user: User!
}
```

**Invalid Selection-Set**

```graphql
query {
  user {
    id { # Invalid, because "id" is of type ID and does not have sub-fields

    }
  }
}
```

_Lösung:_

```graphql
query {
  user {
    id
  }
}
```

**Missing Selection-Set**

```graphql
query {
  user {
    id
    image # `image` requires a Selection-Set for sub-fields!
  }
}
```

_Lösung:_

```graphql
query {
  user {
    id
    image {
      src
    }
  }
}
```

### Incorrect Arguments values (#VariablesInAllowedPositionRule)

GraphQL operations that pass hard-coded values to arguments must be valid, based on the value defined in the schema.

Here are a few examples of invalid operations that violate these rules:

```graphql
query purposes {
  # If "name" is defined as "String" in the schema,
  # this query will fail during validation.
  purpose(name: 1) {
    id
  }
}

# This might also happen when an incorrect variable is defined:

query purposes($name: Int!) {
  # If "name" is defined as `String` in the schema,
  # this query will fail during validation, because the
  # variable used is of type `Int`
  purpose(name: $name) {
    id
  }
}
```

### Unknown Type, Variable, Fragment, or Directive (#UnknownX)

The GraphQL API will raise an error if any unknown type, variable, fragment, or directive is used.

Those unknown references must be fixed:

- rename if it was a typo
- otherwise, remove

### Fragment: invalid spread or definition

**Invalid Fragment spread (#PossibleFragmentSpreadsRule)**

A Fragment cannot be spread on a non-applicable type.

Example, we cannot apply a `Cat` fragment to the `Dog` type:

```graphql
query {
	dog {
		...CatSimple
  }
}

fragment CatSimple on Cat {
  # ...
}
```

**Invalid Fragment definition (#FragmentsOnCompositeTypesRule)**

All Fragment must be defined upon (using `on ...`) a composite type, in short: object, interface, or union.

The following examples are invalid, since defining fragments on scalars is invalid.

```graphql
fragment fragOnScalar on Int {
  # we cannot define a fragment upon a scalar (`Int`)
  something
}

fragment inlineFragOnScalar on Dog {
  ... on Boolean {
    # `Boolean` is not a subtype of `Dog`
    somethingElse
  }
}
```

### Directives usage

**Directive cannot be used at this location (#KnownDirectivesRule)**

Only GraphQL directives (`@...`) supported by The Graph API can be used.

Here is an example with The GraphQL supported directives:

```graphql
query {
  dog {
    name @include(true)
    age @skip(true)
  }
}
```

_Note: `@stream`, `@live`, `@defer` are not supported._

**Directive can only be used once at this location (#UniqueDirectivesPerLocationRule)**

The directives supported by The Graph can only be used once per location.

Folgendes ist ungültig (und überflüssig):

```graphql
query {
  dog {
    name @include(true) @include(true)
  }
}
```
