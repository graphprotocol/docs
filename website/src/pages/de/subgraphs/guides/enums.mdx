---
title: NFT-Marktplätze mit Enums kategorisieren
---

Verwenden Sie Enums, um Ihren Code sauberer und weniger fehleranfällig zu machen. Hier finden Sie ein vollständiges Beispiel für die Verwendung von Enums auf NFT-Marktplätzen.

## Was sind Enums?

Enums oder Aufzählungstypen sind ein spezieller Datentyp, mit dem Sie eine Reihe von bestimmten, zulässigen Werten definieren können.

### Beispiel für Enums in Ihrem Schema

If you're building a Subgraph to track the ownership history of tokens on a marketplace, each token might go through different ownerships, such as `OriginalOwner`, `SecondOwner`, and `ThirdOwner`. By using enums, you can define these specific ownerships, ensuring only predefined values are assigned.

Sie können Enums in Ihrem Schema definieren, und sobald sie definiert sind, können Sie die String-Darstellung der Enum-Werte verwenden, um ein Enum-Feld auf einer Entität zu setzen.

So könnte eine Enum-Definition in Ihrem Schema aussehen, basierend auf dem obigen Beispiel:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

This means that when you use the `TokenStatus` type in your schema, you expect it to be exactly one of predefined values: `OriginalOwner`, `SecondOwner`, or `ThirdOwner`, ensuring consistency and validity.

Um mehr über Enums zu erfahren, lesen Sie [Erstellen eines Subgraphen](/developing/creating-a-subgraph/#enums) und [GraphQL-Dokumentation](https://graphql.org/learn/schema/#enumeration-types).

## Vorteile der Verwendung von Enums

- **Klarheit:** Enums bieten aussagekräftige Namen für Werte, wodurch die Daten leichter zu verstehen sind.
- **Validierung:** Enums erzwingen strenge Wertedefinitionen, die ungültige Dateneinträge verhindern.
- **Pflegeleichtigkeit:** Wenn Sie Kategorien ändern oder neue hinzufügen müssen, können Sie dies mit Hilfe von Enums gezielt tun.

### Ohne Enums

Wenn Sie sich dafür entscheiden, den Typ als String zu definieren, anstatt eine Enum zu verwenden, könnte Ihr Code wie folgt aussehen:

```graphql
type Token @entity {
  id: ID!
  tokenId: BigInt!
  owner: Bytes! # Eigentümer des Tokens
  tokenStatus: String! # String-Feld zur Verfolgung des Token-Status
  timestamp: BigInt!
}
```

In diesem Schema ist `TokenStatus` eine einfache Zeichenfolge ohne spezifische, zulässige Werte.

#### Warum ist das ein Problem?

- Es gibt keine Beschränkung der `TokenStatus`-Werte, so dass jede beliebige Zeichenfolge versehentlich zugewiesen werden kann. Das macht es schwer sicherzustellen, dass nur gültige Status wie `OriginalOwner`, `SecondOwner` oder `ThirdOwner` gesetzt werden.
- Es ist leicht, Tippfehler zu machen, wie z. B. `Orgnalowner` anstelle von `OriginalOwner`, was die Daten und mögliche Abfragen unzuverlässig macht.

### Mit Enums

Anstelle der Zuweisung von Freiform-Strings können Sie ein Enum für `TokenStatus` mit spezifischen Werten definieren: `OriginalOwner`, `SecondOwner`, oder `ThirdOwner`. Die Verwendung einer Aufzählung stellt sicher, dass nur erlaubte Werte verwendet werden.

Enums bieten Typsicherheit, minimieren das Risiko von Tippfehlern und gewährleisten konsistente und zuverlässige Ergebnisse.

## Definieren von Enums für NFT-Marktplätze

> Hinweis: Die folgende Anleitung verwendet den CryptoCoven NFT Smart Contract.

To define enums for the various marketplaces where NFTs are traded, use the following in your Subgraph schema:

```gql
# Enum für Marktplätze, mit denen der CryptoCoven-Vertrag interagiert (wahrscheinlich ein Trade/Mint)
enum Marketplace {
  OpenSeaV1 # Repräsentiert, wenn ein CryptoCoven NFT auf dem Marktplatz gehandelt wird
  OpenSeaV2 # Stellt dar, wenn ein CryptoCoven NFT auf dem OpenSeaV2-Marktplatz gehandelt wird
  SeaPort # Stellt dar, wenn ein CryptoCoven NFT auf dem SeaPort-Marktplatz gehandelt wird
  LooksRare # Stellt dar, wenn ein CryptoCoven NFT auf dem LookRare-Marktplatz gehandelt wird.
  # ...und andere Marktplätze
}
```

## Verwendung von Enums für NFT-Marktplätze

Once defined, enums can be used throughout your Subgraph to categorize transactions or events.

Bei der Protokollierung von NFT-Verkäufen können Sie beispielsweise mit Hilfe des Enums den Marktplatz angeben, der an dem Geschäft beteiligt ist.

### Implementieren einer Funktion für NFT-Marktplätze

So können Sie eine Funktion implementieren, die den Namen des Marktplatzes als String aus der Aufzählung abruft:

```ts
export function getMarketplaceName(marketplace: Marketplace): string {
  // Using if-else statements to map the enum value to a string
  if (marketplace === Marketplace.OpenSeaV1) {
    return 'OpenSeaV1' // If the marketplace is OpenSea, return its string representation
  } else if (marketplace === Marketplace.OpenSeaV2) {
    return 'OpenSeaV2'
  } else if (marketplace === Marketplace.SeaPort) {
    return 'SeaPort' // If the marketplace is SeaPort, return its string representation
  } else if (marketplace === Marketplace.LooksRare) {
    return 'LooksRare' // If the marketplace is LooksRare, return its string representation
    // ... and other market places
  }
}
```

## Best Practices for Using Enums

- **Consistent Naming:** Use clear, descriptive names for enum values to improve readability.
- **Centralized Management:** Keep enums in a single file for consistency. This makes enums easier to update and ensures they are the single source of truth.
- **Documentation:** Add comments to enum to clarify their purpose and usage.

## Using Enums in Queries

Enums in queries help you improve data quality and make your results easier to interpret. They function as filters and response elements, ensuring consistency and reducing errors in marketplace values.

**Specifics**

- **Filtering with Enums:** Enums provide clear filters, allowing you to confidently include or exclude specific marketplaces.
- **Enums in Responses:** Enums guarantee that only recognized marketplace names are returned, making the results standardized and accurate.

### Sample Queries

#### Query 1: Account With The Highest NFT Marketplace Interactions

This query does the following:

- It finds the account with the highest unique NFT marketplace interactions, which is great for analyzing cross-marketplace activity.
- The marketplaces field uses the marketplace enum, ensuring consistent and validated marketplace values in the response.

```gql
{
  accounts(first: 1, orderBy: uniqueMarketplacesCount, orderDirection: desc) {
    id
    sendCount
    receiveCount
    totalSpent
    uniqueMarketplacesCount
    marketplaces {
      marketplace # This field returns the enum value representing the marketplace
    }
  }
}
```

#### Returns

This response provides account details and a list of unique marketplace interactions with enum values for standardized clarity:

```gql
{
  "data": {
    "accounts": [
      {
        "id": "0xb3abc96cb9a61576c03c955d75b703a890a14aa0",
        "sendCount": "44",
        "receiveCount": "44",
        "totalSpent": "1197500000000000000",
        "uniqueMarketplacesCount": "7",
        "marketplaces": [
          {
            "marketplace": "OpenSeaV1"
          },
          {
            "marketplace": "OpenSeaV2"
          },
          {
            "marketplace": "GenieSwap"
          },
          {
            "marketplace": "CryptoCoven"
          },
          {
            "marketplace": "Unknown"
          },
          {
            "marketplace": "LooksRare"
          },
          {
            "marketplace": "NFTX"
          }
        ]
      }
    ]
  }
}
```

#### Query 2: Most Active Marketplace for CryptoCoven transactions

This query does the following:

- It identifies the marketplace with the highest volume of CryptoCoven transactions.
- It uses the marketplace enum to ensure that only valid marketplace types appear in the response, adding reliability and consistency to your data.

```gql
{
  marketplaceInteractions(first: 1, orderBy: transactionCount, orderDirection: desc) {
    marketplace
    transactionCount
  }
}
```

#### Result 2

The expected response includes the marketplace and the corresponding transaction count, using the enum to indicate the marketplace type:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "Unknown",
        "transactionCount": "222"
      }
    ]
  }
}
```

#### Query 3: Marketplace Interactions with High Transaction Counts

This query does the following:

- It retrieves the top four marketplaces with over 100 transactions, excluding "Unknown" marketplaces.
- It uses enums as filters to ensure that only valid marketplace types are included, increasing accuracy.

```gql
{
  marketplaceInteractions(
    first: 4
    orderBy: transactionCount
    orderDirection: desc
    where: { transactionCount_gt: "100", marketplace_not: "Unknown" }
  ) {
    marketplace
    transactionCount
  }
}
```

#### Result 3

Expected output includes the marketplaces that meet the criteria, each represented by an enum value:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "NFTX",
        "transactionCount": "201"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "148"
      },
      {
        "marketplace": "CryptoCoven",
        "transactionCount": "117"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "111"
      }
    ]
  }
}
```

## Zusätzliche Ressourcen

For additional information, check out this guide's [repo](https://github.com/chidubemokeke/Subgraph-Tutorial-Enums).
