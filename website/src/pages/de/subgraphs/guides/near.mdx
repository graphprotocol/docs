---
title: Aufbau von Subgraphen auf NEAR
---

This guide is an introduction to building Subgraphs indexing smart contracts on the [NEAR blockchain](https://docs.near.org/).

## Was ist NEAR?

[NEAR](https://near.org/) ist eine Smart-Contract-Plattform zur Erstellung dezentraler Anwendungen. Besuchen Sie die [offizielle Dokumentation](https://docs.near.org/concepts/basics/protocol) für weitere Informationen.

## What are NEAR Subgraphs?

The Graph gives developers tools to process blockchain events and make the resulting data easily available via a GraphQL API, known individually as a Subgraph. [Graph Node](https://github.com/graphprotocol/graph-node) is now able to process NEAR events, which means that NEAR developers can now build Subgraphs to index their smart contracts.

Subgraphs are event-based, which means that they listen for and then process onchain events. There are currently two types of handlers supported for NEAR Subgraphs:

- Blockhandler: diese werden bei jedem neuen Block ausgeführt
- Empfangshandler: werden jedes Mal ausgeführt, wenn eine Nachricht auf einem bestimmten Konto ausgeführt wird

[Aus der NEAR-Dokumentation] (https://docs.near.org/build/data-infrastructure/lake-data-structures/receipt):

> Eine Quittung ist das einzige handlungsfähige Objekt im System. Wenn wir auf der NEAR-Plattform von der „Verarbeitung einer Transaktion“ sprechen, bedeutet dies letztendlich, dass an einem bestimmten Punkt „Quittungen angewendet werden“.

## Aufbau eines NEAR-Subgraphen

`@graphprotocol/graph-cli` is a command-line tool for building and deploying Subgraphs.

`@graphprotocol/graph-ts` is a library of Subgraph-specific types.

NEAR Subgraph development requires `graph-cli` above version `0.23.0`, and `graph-ts` above version `0.23.0`.

> Building a NEAR Subgraph is very similar to building a Subgraph that indexes Ethereum.

There are three aspects of Subgraph definition:

**subgraph.yaml:** the Subgraph manifest, defining the data sources of interest, and how they should be processed. NEAR is a new `kind` of data source.

**schema.graphql:** a schema file that defines what data is stored for your Subgraph, and how to query it via GraphQL. The requirements for NEAR Subgraphs are covered by [the existing documentation](/developing/creating-a-subgraph/#the-graphql-schema).

**AssemblyScript-Mappings:** [AssemblyScript-Code](/subgraphs/developing/creating/graph-ts/api/), der die Ereignisdaten in die in Ihrem Schema definierten Entitäten übersetzt. Die NEAR-Unterstützung führt NEAR-spezifische Datentypen und neue JSON-Parsing-Funktionen ein.

Bei der Entwicklung von Subgraphen gibt es zwei wichtige Befehle:

```bash
$ graph codegen # erzeugt Typen aus der im Manifest angegebenen Schemadatei
$ graph build # generiert Web Assembly aus den AssemblyScript-Dateien und bereitet alle Subgraph-Dateien in einem /build-Ordner vor
```

### Subgraph-Manifest-Definition

The Subgraph manifest (`subgraph.yaml`) identifies the data sources for the Subgraph, the triggers of interest, and the functions that should be run in response to those triggers. See below for an example Subgraph manifest for a NEAR Subgraph:

```yaml
specVersion: 1.3.0
schema:
  file: ./src/schema.graphql # link to the schema file
dataSources:
  - kind: near
    network: near-mainnet
    source:
      account: app.good-morning.near # This data source will monitor this account
      startBlock: 10662188 # Required for NEAR
    mapping:
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      blockHandlers:
        - handler: handleNewBlock # the function name in the mapping file
      receiptHandlers:
        - handler: handleReceipt # the function name in the mapping file
      file: ./src/mapping.ts # link to the file with the Assemblyscript mappings
```

- NEAR Subgraphs introduce a new `kind` of data source (`near`)
- Das `network` sollte einem Netz auf dem hostenden Graph Node entsprechen. In Subgraph Studio ist das Mainnet von NEAR `near-mainnet` und das Testnetz von NEAR `near-testnet`
- NEAR-Datenquellen führen ein optionales Feld `source.account` ein, das eine von Menschen lesbare ID ist, die einem [NEAR-Konto] (https://docs.near.org/concepts/protocol/account-model) entspricht. Dies kann ein Konto oder ein Unterkonto sein.
- NEAR-Datenquellen führen ein alternatives optionales Feld `source.accounts` ein, das optionale Suffixe und Präfixe enthält. Es müssen mindestens Präfix oder Suffix angegeben werden, da sie mit jedem Konto übereinstimmen, das mit der Liste der Werte beginnt bzw. endet. Das folgende Beispiel würde passen: `[app|good].*[morning.near|morning.testnet]`. Wenn nur eine Liste von Präfixen oder Suffixen erforderlich ist, kann das andere Feld weggelassen werden.

```yaml
accounts:
  prefixes:
    - app
    - good
  suffixes:
    - morning.near
    - morning.testnet
```

NEAR-Datenquellen unterstützen zwei Arten von Handlern:

- `blockHandlers`: werden bei jedem neuen NEAR-Block ausgeführt. Es ist kein `source.account` erforderlich.
- `receiptHandlers`: wird bei jeder Quittung ausgeführt, bei der das `source.account` der Datenquelle der Empfänger ist. Beachten Sie, dass nur exakte Übereinstimmungen verarbeitet werden ([Unterkonten](https://docs.near.org/tutorials/crosswords/basics/add-functions-call#create-a-subaccount) müssen als unabhängige Datenquellen hinzugefügt werden).

### Schema-Definition

Schema definition describes the structure of the resulting Subgraph database and the relationships between entities. This is agnostic of the original data source. There are more details on Subgraph schema definition [here](/developing/creating-a-subgraph/#the-graphql-schema).

### AssemblyScript-Mappings

Die Handler für die Ereignisverarbeitung sind in [AssemblyScript](https://www.assemblyscript.org/) geschrieben.

Die NEAR-Indizierung führt NEAR-spezifische Datentypen in die [AssemblyScript API](/subgraphs/developing/creating/graph-ts/api/) ein.

```typescript

class ExecutionOutcome {
      gasBurnt: u64,
      blockHash: Bytes,
      id: Bytes,
      logs: Array<string>,
      receiptIds: Array<Bytes>,
      tokensBurnt: BigInt,
      executorId: String,
  }

class ActionReceipt {
      predecessorId: string,
      receiverId: string,
      id: CryptoHash,
      signerId: string,
      gasPrice: BigInt,
      outputDataReceivers: Array<DataReceiver>,
      inputDataIds: Array<CryptoHash>,
      actions: Array<ActionValue>,
  }

class BlockHeader {
      height: u64,
      prevHeight: u64,// Immer Null wenn Version < V3
      epochId: Bytes,
      nextEpochId: Bytes,
      chunksIncluded: u64,
      hash: Bytes,
      prevHash: Bytes,
      timestampNanosec: u64,
      randomValue: Bytes,
      gasPrice: BigInt,
      totalSupply: BigInt,
      latestProtocolVersion: u32,
  }

class ChunkHeader {
      gasUsed: u64,
      gasLimit: u64,
      shardId: u64,
      chunkHash: Bytes,
      prevBlockHash: Bytes,
      balanceBurnt: BigInt,
  }

class Block {
      Autor: String,
      header: BlockHeader,
      chunks: Array<ChunkHeader>,
  }

class ReceiptWithOutcome {
      outcome: ExecutionOutcome,
      receipt: ActionReceipt,
      block: Block,
  }
```

Diese Typen werden an Block- und Quittungshandler weitergegeben:

- Block-Handler erhalten einen `Block`
- Empfangshandler erhalten einen `ReceiptWithOutcome`

Otherwise, the rest of the [AssemblyScript API](/subgraphs/developing/creating/graph-ts/api/) is available to NEAR Subgraph developers during mapping execution.

Dazu gehört eine neue JSON-Parsing-Funktion - Logs auf NEAR werden häufig als stringifizierte JSONs ausgegeben. Eine neue Funktion `json.fromString(...)` ist als Teil der [JSON-API] (/subgraphs/developing/creating/graph-ts/api/#json-api) verfügbar, damit Entwickler diese Protokolle einfach verarbeiten können.

## Bereitstellen eines NEAR- Subgraphen

Once you have a built Subgraph, it is time to deploy it to Graph Node for indexing. NEAR Subgraphs can be deployed to any Graph Node `>=v0.26.x` (this version has not yet been tagged & released).

Subgraph Studio und der Upgrade Indexierer auf The Graph Network unterstützen derzeit die Indizierung von NEAR Mainnet und Testnet in der Betaphase, mit den folgenden Netzwerknamen:

- `near-mainnet`
- `near-testnet`

More information on creating and deploying Subgraphs on Subgraph Studio can be found [here](/deploying/deploying-a-subgraph-to-studio/).

As a quick primer - the first step is to "create" your Subgraph - this only needs to be done once. On Subgraph Studio, this can be done from [your Dashboard](https://thegraph.com/studio/): "Create a Subgraph".

Once your Subgraph has been created, you can deploy your Subgraph by using the `graph deploy` CLI command:

```sh
$ graph create --node <graph-node-url> <subgraph-name> # creates a Subgraph on a local Graph Node (on Subgraph Studio, this is done via the UI)
$ graph deploy --node <graph-node-url> --ipfs https://api.thegraph.com/ipfs/ <subgraph-name> # uploads the build files to a specified IPFS endpoint, and then deploys the Subgraph to a specified Graph Node based on the manifest IPFS hash
```

The node configuration will depend on where the Subgraph is being deployed.

### Subgraph Studio

```sh
graph auth
graph deploy <subgraph-name>
```

### Lokaler Graph-Knoten (basierend auf der Standardkonfiguration)

```sh
graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 <subgraph-name>
```

Once your Subgraph has been deployed, it will be indexed by Graph Node. You can check its progress by querying the Subgraph itself:

```graphql
{
  _meta {
    block {
      number
    }
  }
}
```

### Indizieren von NEAR mit einem lokalen Graph-Knoten

Für den Betrieb eines Graph-Knotens, der NEAR indiziert, gelten die folgenden betrieblichen Anforderungen:

- NEAR Indexierer Framework mit Firehose-Instrumentierung
- NEAR-Firehose-Komponente(n)
- Graph-Knoten mit konfiguriertem Firehose-Endpunkt

Wir werden in Kürze weitere Informationen zum Betrieb der oben genannten Komponenten bereitstellen.

## Abfrage eines NEAR-Subgraphen

The GraphQL endpoint for NEAR Subgraphs is determined by the schema definition, with the existing API interface. Please visit the [GraphQL API documentation](/subgraphs/querying/graphql-api/) for more information.

## Beispiele von Subgraphen

Here are some example Subgraphs for reference:

[NEAR Blocks](https://github.com/graphprotocol/graph-tooling/tree/main/examples/near-blocks)

[NEAR Quittungen](https://github.com/graphprotocol/graph-tooling/tree/main/examples/near-receipts)

## FAQ

### Wie funktioniert die Beta-Version?

NEAR support is in beta, which means that there may be changes to the API as we continue to work on improving the integration. Please email near@thegraph.com so that we can support you in building NEAR Subgraphs, and keep you up to date on the latest developments!

### Can a Subgraph index both NEAR and EVM chains?

Nein, ein Subgraph kann nur Datenquellen von einer Kette oder einem Netzwerk unterstützen.

### Can Subgraphs react to more specific triggers?

Zurzeit werden nur Auslöser für Sperren und Quittungen unterstützt. Wir untersuchen derzeit Auslöser für Funktionsaufrufe an ein bestimmtes Konto. Wir sind auch an der Unterstützung von Ereignisauslösern interessiert, sobald NEAR über eine native Ereignisunterstützung verfügt.

### Werden Empfangshandler für Konten und deren Unterkonten ausgelöst?

Wenn ein `account` angegeben wird, wird nur der exakte Kontoname abgeglichen. Es ist möglich, Unterkonten abzugleichen, indem ein Feld `account` mit `suffixes` und `prefixes` angegeben wird, um Konten und Unterkonten abzugleichen, z. B. würde das folgende Feld allen Unterkonten von `mintbase1.near` entsprechen:

```yaml
accounts:
  suffixes:
    - mintbase1.near
```

### Can NEAR Subgraphs make view calls to NEAR accounts during mappings?

Dies wird nicht unterstützt. Wir prüfen derzeit, ob diese Funktion für die Indizierung erforderlich ist.

### Can I use data source templates in my NEAR Subgraph?

Dies wird derzeit nicht unterstützt. Wir prüfen derzeit, ob diese Funktion für die Indizierung erforderlich ist.

### Ethereum Subgraphs support "pending" and "current" versions, how can I deploy a "pending" version of a NEAR Subgraph?

Pending functionality is not yet supported for NEAR Subgraphs. In the interim, you can deploy a new version to a different "named" Subgraph, and then when that is synced with the chain head, you can redeploy to your primary "named" Subgraph, which will use the same underlying deployment ID, so the main Subgraph will be instantly synced.

### My question hasn't been answered, where can I get more help building NEAR Subgraphs?

If it is a general question about Subgraph development, there is a lot more information in the rest of the [Developer documentation](/subgraphs/quick-start/). Otherwise please join [The Graph Protocol Discord](https://discord.gg/graphprotocol) and ask in the #near channel or email near@thegraph.com.

## References

- [NEAR Entwicklerdokumentation](https://docs.near.org/tutorials/crosswords/basics/set-up-skeleton)
