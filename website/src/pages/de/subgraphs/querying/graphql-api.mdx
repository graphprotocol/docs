---
title: GraphQL-API
---

Erfahren Sie mehr über die GraphQL Query API, die in The Graph verwendet wird.

## Was ist GraphQL?

[GraphQL] (https://graphql.org/learn/) ist eine Abfragesprache für APIs und eine Laufzeitumgebung für die Ausführung dieser Abfragen mit Ihren vorhandenen Daten. The Graph verwendet GraphQL zur Abfrage von Subgraphen.

Um die größere Rolle, die GraphQL spielt, zu verstehen, lesen Sie [Entwickeln](/subgraphs/entwickeln/einfuehrung/) und [Erstellen eines Subgraphen](/entwickeln/einen-subgraph-erstellen/).

## Abfragen mit GraphQL

In Ihrem Subgraph-Schema definieren Sie Typen namens `Entities`. Für jeden `Entity`-Typ werden `entity`- und `entities`-Felder auf der obersten Ebene des `Query`-Typs erzeugt.

> Hinweis: Bei der Verwendung von The Graph muss `query` nicht am Anfang der `graphql`-Abfrage stehen.

### Beispiele

Abfrage nach einer einzelnen, in Ihrem Schema definierten Entität `Token`:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> Hinweis: Bei der Abfrage einer einzelnen Entität ist das Feld `id` erforderlich und muss als String geschrieben werden.

Abfrage aller `Token`-Entitäten:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Sortierung

Wenn Sie eine Sammlung abfragen, können Sie:

- den Parameter `orderBy` verwenden, um nach einem bestimmten Attribut zu sortieren.
- `orderDirection` verwenden, um die Sortierrichtung anzugeben, `asc` für aufsteigend oder `desc` für absteigend.

#### Beispiel

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### Beispiel für die Sortierung verschachtelter Entitäten

Ab Graph Node [`v0.30.0`] (https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) können Entitäten auf der Basis von verschachtelten Entitäten sortiert werden.

Im folgenden Beispiel werden die Token nach dem Namen ihres Besitzers sortiert:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> Derzeit können Sie nach den Typen `String` oder `ID` auf den Feldern `@entity` und `@derivedFrom` sortieren. Leider wird die [Sortierung nach Schnittstellen auf Entitäten mit einer Tiefe von einer Ebene] (https://github.com/graphprotocol/graph-node/pull/4058), die Sortierung nach Feldern, die Arrays und verschachtelte Entitäten sind, noch nicht unterstützt.

### Pagination

Wenn Sie eine Sammlung abfragen, ist es am besten, dies zu tun:

- Verwenden Sie den Parameter `first`, um vom Anfang der Sammlung an zu paginieren.
  - Die Standardsortierung erfolgt nach `ID` in aufsteigender alphanumerischer Reihenfolge, **nicht** nach Erstellungszeit.
- Verwenden Sie den Parameter `skip`, um Entitäten zu überspringen und zu paginieren. Zum Beispiel zeigt `first:100` die ersten 100 Entitäten und `first:100, skip:100` zeigt die nächsten 100 Entitäten.
- Vermeiden Sie die Verwendung von `skip`-Werten in Abfragen, da diese im Allgemeinen schlecht funktionieren. Um eine große Anzahl von Elementen abzurufen, ist es am besten, die Entitäten auf der Grundlage eines Attributs zu durchblättern, wie im obigen Beispiel gezeigt.

#### Beispiel mit `first`

Die Abfrage für die ersten 10 Token:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

Um nach Gruppen von Entitäten in der Mitte einer Sammlung zu suchen, kann der Parameter `skip` in Verbindung mit dem Parameter `first` verwendet werden, um eine bestimmte Anzahl von Entitäten zu überspringen, beginnend am Anfang der Sammlung.

#### Beispiel mit `first` und `skip`

Abfrage von 10 „Token“-Entitäten, versetzt um 10 Stellen vom Beginn der Sammlung:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Beispiel mit `first` und `id_ge`

Wenn ein Client eine große Anzahl von Entitäten abrufen muss, ist es leistungsfähiger, Abfragen auf ein Attribut zu stützen und nach diesem Attribut zu filtern. Zum Beispiel könnte ein Client mit dieser Abfrage eine große Anzahl von Token abrufen:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

Beim ersten Mal würde es die Abfrage mit `lastID = „“` senden, und bei nachfolgenden Anfragen würde es `lastID` auf das Attribut `id` der letzten Entität in der vorherigen Anfrage setzen. Dieser Ansatz ist wesentlich leistungsfähiger als die Verwendung steigender `skip`-Werte.

### Filtering

- Sie können den Parameter `where` in Ihren Abfragen verwenden, um nach verschiedenen Eigenschaften zu filtern.
- Sie können nach mehreren Werten innerhalb des Parameters `where` filtern.

#### Beispiel mit `where`

Abfrage von Herausforderungen mit `failed`-Ergebnis:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Sie können Suffixe wie `_gt`, `_lte` für den Wertevergleich verwenden:

#### Example for range filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Example for block filtering

Sie können auch Entitäten filtern, die in oder nach einem bestimmten Block mit `_change_block(number_gte: Int)` aktualisiert wurden.

Dies kann nützlich sein, wenn Sie nur Entitäten abrufen möchten, die sich geändert haben, z. B. seit der letzten Abfrage. Oder es kann nützlich sein, um zu untersuchen oder zu debuggen, wie sich Entitäten in Ihrem Subgraphen ändern (wenn Sie dies mit einem Blockfilter kombinieren, können Sie nur Entitäten isolieren, die sich in einem bestimmten Block geändert haben).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### Example for nested entity filtering

Die Filterung nach verschachtelten Entitäten ist in den Feldern mit dem Suffix `_`möglich.

This can be useful if you are looking to fetch only entities whose child-level entities meet the provided conditions.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Logical operators

Seit Graph Node [`v0.30.0`] (https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) können Sie mehrere Parameter im selben `where`-Argument gruppieren, indem Sie die `und`- oder `oder`-Operatoren verwenden, um Ergebnisse nach mehr als einem Kriterium zu filtern.

##### Operator `AND`

Das folgende Beispiel filtert nach Challenges mit `outcome` `succeeded` und `number` größer als oder gleich `100`.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Syntaktischer Zucker:** Sie können die obige Abfrage vereinfachen, indem Sie den „und“-Operator entfernen und einen durch Kommata getrennten Unterausdruck übergeben.
>
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### Operator `OR`

The following example filters for challenges with `outcome` `succeeded` or `number` greater than or equal to `100`.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Note**: When constructing queries, it is important to consider the performance impact of using the `or` operator. While `or` can be a useful tool for broadening search results, it can also have significant costs. One of the main issues with `or` is that it can cause queries to slow down. This is because `or` requires the database to scan through multiple indexes, which can be a time-consuming process. To avoid these issues, it is recommended that developers use and operators instead of or whenever possible. This allows for more precise filtering and can lead to faster, more accurate queries.

#### All Filters

Full list of parameter suffixes:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`, but `_` is available only for object and interface types.

In addition, the following global filters are available as part of `where` argument:

```graphql
_change_block(number_gte: Int)
```

### Time-travel queries

You can query the state of your entities not just for the latest block, which is the default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the chain, the result might change if that block turns out to **not** be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

> Note: The current implementation is still subject to certain limitations that might violate these guarantees. The implementation can not always tell that a given block hash is not on the main chain at all, or if a query result by a block hash for a block that is not yet considered final could be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### Beispiel

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### Beispiel

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### Fulltext Search Queries

Fulltext search query fields provide an expressive text search API that can be added to the Subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developing/creating-a-subgraph/#defining-fulltext-search-fields) to add fulltext search to your Subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

Fulltext search operators:

| Symbol | Operator    | Beschreibung                                                                                                                         |
| ------ | ----------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `&`    | `And`       | For combining multiple search terms into a filter for entities that include all of the provided terms                                |
| &#x7c; | `Or`        | Queries with multiple search terms separated by the or operator will return all entities with a match from any of the provided terms |
| `<->`  | `Follow by` | Specify the distance between two words.                                                                                              |
| `:*`   | `Prefix`    | Use the prefix search term to find words whose prefix match (2 characters required.)                                                 |

#### Beispiele

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Validierung

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## Schema

The schema of your dataSources, i.e. the entity types, values, and relationships that are available to query, are defined through the [GraphQL Interface Definition Language (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your Subgraph is automatically generated from the GraphQL schema that's included in your [Subgraph manifest](/developing/creating-a-subgraph/#components-of-a-subgraph).

> Note: Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### Entities

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.

### Subgraph Metadata

All Subgraphs have an auto-generated `_Meta_` object, which provides access to Subgraph metadata. This can be queried as follows:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

If a block is provided, the metadata is as of that block, if not the latest indexed block is used. If provided, the block must be after the Subgraph's start block, and less than or equal to the most recently indexed block.

`deployment` is a unique ID, corresponding to the IPFS CID of the `subgraph.yaml` file.

`block` provides information about the latest block (taking into account any block constraints passed to `_meta`):

- hash: the hash of the block
- number: the block number
- timestamp: the timestamp of the block, if available (this is currently only available for Subgraphs indexing EVM networks)

`hasIndexingErrors` is a boolean identifying whether the Subgraph encountered indexing errors at some past block
