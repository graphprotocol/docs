---
title: Rahmen f√ºr Einheitstests
---

Lernen Sie die Verwendung von Matchstick, einem von [LimeChain] (https://limechain.tech/) entwickelten Unit-Testing-Framework. Matchstick erm√∂glicht es Subgraph-Entwicklern, ihre Mapping-Logik in einer Sandbox-Umgebung zu testen und ihre Subgraphen erfolgreich einzusetzen.

## Vorteile der Verwendung von Matchstick

- Es ist in Rust geschrieben und f√ºr hohe Leistung optimiert.
- Sie erm√∂glicht Ihnen den Zugriff auf Entwicklerfunktionen, einschlie√ülich der M√∂glichkeit, Vertragsaufrufe nachzubilden, Behauptungen √ºber den Speicherzustand aufzustellen, Fehler in Subgraphen zu √ºberwachen, die Testleistung zu √ºberpr√ºfen und vieles mehr.

## Erste Schritte

### Abh√§ngigkeiten installieren

Um die Testhilfsmethoden verwenden und Tests ausf√ºhren zu k√∂nnen, m√ºssen Sie die folgenden Abh√§ngigkeiten installieren:

```sh
yarn add --dev Matchstick-as
```

### Install PostgreSQL

`graph-node` depends on PostgreSQL, so if you don't already have it, then you will need to install it.

> Note: It's highly recommended to use the commands below to avoid unexpected errors.

#### Using MacOS

Installation command:

```sh
brew install postgresql
```

Create a symlink to the latest libpq.5.lib _You may need to create this dir first_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Using Linux

Installation command (depends on your distro):

```sh
sudo apt install postgresql
```

### Verwendung von WSL (Windows Subsystem f√ºr Linux)

Sie k√∂nnen Matchstick auf WSL sowohl mit dem Docker-Ansatz als auch mit dem bin√§ren Ansatz verwenden. Da WSL ein wenig knifflig sein kann, hier ein paar Tipps, falls Sie auf Probleme sto√üen wie

```
static BYTES = Symbol(‚ÄûBytes‚Äú) SyntaxError: Unerwartetes Token =
```

oder

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Bitte stellen Sie sicher, dass Sie eine neuere Version von Node.js verwenden. graph-cli unterst√ºtzt **v10.19.0** nicht mehr, und das ist immer noch die Standardversion f√ºr neue Ubuntu-Images auf WSL. Zum Beispiel ist Matchstick best√§tigt, dass es auf WSL mit **v18.1.0** funktioniert, Sie k√∂nnen entweder √ºber **nvm** darauf umsteigen oder wenn Sie Ihr globales Node.js aktualisieren. Vergessen Sie nicht, `node_modules` zu l√∂schen und `npm install` erneut auszuf√ºhren, nachdem Sie Ihr nodejs aktualisiert haben! Stellen Sie dann sicher, dass Sie **libpq** installiert haben, indem Sie

```
sudo apt-get install libpq-dev
```

Und schlie√ülich, verwenden Sie nicht `graph test` (das Ihre globale Installation von graph-cli verwendet und aus irgendeinem Grund sieht es so aus, als ob es auf der WSL derzeit nicht funktioniert), sondern verwenden Sie `yarn test` oder `npm run test` (das wird die lokale Instanz von graph-cli auf Projektebene verwenden, was wunderbar funktioniert). Daf√ºr m√ºssen Sie nat√ºrlich ein `‚Äûtest‚Äú-Skript in Ihrer `package.json\`-Datei haben, was etwas so einfaches sein kann wie

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### Using Matchstick

To use **Matchstick** in your Subgraph project just open up a terminal, navigate to the root folder of your project and simply run `graph test [options] <datasource>` - it downloads the latest **Matchstick** binary and runs the specified test or all tests in a test folder (or all existing tests if no datasource flag is specified).

### CLI-Optionen

Dadurch werden alle Tests im Testordner ausgef√ºhrt:

```sh
graph test
```

Dies f√ºhrt einen Test namens gravity.test.ts und/oder alle Tests in einem Ordner namens gravity aus:

```sh
graph test gravity
```

Dadurch wird nur diese spezielle Testdatei ausgef√ºhrt:

```sh
graph test path/to/file.test.ts
```

**Optionen:**

```sh
-c, --coverage                Run the tests in coverage mode
-d, --docker                  Run the tests in a docker container (Note: Please execute from the root folder of the subgraph)
-f, --force                   Binary: Redownloads the binary. Docker: Redownloads the Dockerfile and rebuilds the docker image.
-h, --help                    Show usage information
-l, --logs                    Logs to the console information about the OS, CPU model and download url (debugging purposes)
-r, --recompile               Forces tests to be recompiled
-v, --version &amp;lt; tag&amp;gt;           Choose the version of the rust binary that you want to be downloaded/used
```

### Docker

Ab `graph-cli 0.25.2` unterst√ºtzt der Befehl `graph test` die Ausf√ºhrung von `matchstick` in einem Docker-Container mit dem `-d` Flag. Die Docker-Implementierung verwendet [bind mount](https://docs.docker.com/storage/bind-mounts/), so dass sie das Docker-Image nicht jedes Mal neu erstellen muss, wenn der Befehl `graph test -d` ausgef√ºhrt wird. Alternativ k√∂nnen Sie den Anweisungen aus dem [matchstick](https://github.com/LimeChain/matchstick#docker-) Repository folgen, um docker manuell zu starten.

‚ùó `graph test -d` forces `docker run` to run with flag `-t`. This must be removed to run inside non-interactive environments (like GitHub CI).

‚ùó If you have previously ran `graph test` you may encounter the following error during docker build:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

In this case create a `.dockerignore` in the root folder and add `node_modules/binary-install-raw/bin`

### Konfiguration

Matchstick can be configured to use a custom tests, libs and manifest path via `matchstick.yaml` config file:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Demo Subgraph

You can try out and play around with the examples from this guide by cloning the [Demo Subgraph repo](https://github.com/LimeChain/demo-subgraph)

### Video-Tutorials

Also you can check out the video series on ["How to use Matchstick to write unit tests for your Subgraphs"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Struktur der Tests

WICHTIG: Die unten beschriebene Teststruktur h√§ngt von der Version `matchstick-as` >=0.5.0\*\*_ ab.

### describe()

`describe(name: String , () => {})` - Defines a test group.

**_Notes:_**

- _Describes are not mandatory. You can still use test() the old way, outside of the describe() blocks_

Beispiel:

```typescript
Importiere { describe, test } von "Matchstick-as/assembly/index"
importiere { handleNewGravatar } von "../.. src/gravity"

describe("handleNewGravatar()", () => {
  test("Soll eine neue Gravatar Entity erstellen", () => {
    ...
  })
})
```

Nested `describe()` example:

```typescript
Importiere { describe, test } von "Matchstick-as/assembly/index"
importiere { handleUpdatedGravatar } von "../.. src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("Wenn Entit√§t existiert", () => {
    test("aktualisiert die Entit√§t", () => {
      ...
    })
  })

  beschreibt ("Wenn Entit√§t nicht existiert", () => {
    test("Es erzeugt ein neues Entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Defines a test case. You can use test() inside of describe() blocks or independently.

Beispiel:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

oder

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Runs a code block before any of the tests in the file. If `beforeAll` is declared inside of a `describe` block, it runs at the beginning of that `describe` block.

Beispiele:

Code inside `beforeAll` will execute once before _all_ tests in the file.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

Code inside `beforeAll` will execute once before all tests in the first describe block

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Runs a code block after all of the tests in the file. If `afterAll` is declared inside of a `describe` block, it runs at the end of that `describe` block.

Beispiel:

Code inside `afterAll` will execute once after _all_ tests in the file.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

Code inside `afterAll` will execute once after all tests in the first describe block

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
	afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
	})

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Runs a code block before every test. If `beforeEach` is declared inside of a `describe` block, it runs before each test in that `describe` block.

Examples: Code inside `beforeEach` will execute before each tests.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

Code inside `beforeEach` will execute only before each test in the that describe

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Updates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

F√ºhrt einen Codeblock nach jedem Test aus. Wenn `afterEach` innerhalb eines `describe`-Blocks deklariert ist, wird es nach jedem Test in diesem `describe`-Block ausgef√ºhrt.

Beispiele:

Code inside `afterEach` will execute after every test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Code inside `afterEach` will execute after each test in that describe

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Asserts

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

As of version 0.6.0, asserts support custom error messages as well

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id should be 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value should equal 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar should not be in store')
assert.addressEquals(Address.zero(), Address.zero(), 'Address should be zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes should be equal')
assert.i32Equals(2, 2, 'I32 should equal 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt should equal 1')
assert.booleanEquals(true, true, 'Boolean should be true')
assert.stringEquals('1', '1', 'String should equal 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arrays should be equal')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuples should be equal',
)
assert.assertTrue(true, 'Should be true')
assert.assertNull(null, 'Should be null')
assert.assertNotNull('not null', 'Should be not null')
assert.entityCount('Gravatar', 1, 'There should be 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet template should have one data source')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet should have a data source for zero address',
)
```

## Write a Unit Test

Let's see how a simple unit test would look like using the Gravatar examples in the [Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

Assuming we have the following handler function (along with two helper functions to make our life easier):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownerAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

We first have to create a test file in our project. This is an example of how that might look like:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})
```

Das ist eine Menge zum Auspacken! Zun√§chst einmal ist es wichtig zu wissen, dass wir Dinge aus `matchstick-as` importieren, unserer AssemblyScript-Hilfsbibliothek (die als npm-Modul verteilt wird). Sie k√∂nnen das Repository [hier] finden (https://github.com/LimeChain/matchstick-as). `matchstick-as` stellt uns n√ºtzliche Testmethoden zur Verf√ºgung und definiert auch die Funktion `test()`, die wir zum Erstellen unserer Testbl√∂cke verwenden werden. Der Rest ist ziemlich einfach - hier ist, was passiert:

- Wir richten unseren Ausgangszustand ein und f√ºgen eine benutzerdefinierte Gravatar-Entit√§t hinzu;
- Wir definieren zwei ‚ÄûNewGravatar‚Äú-Ereignisobjekte zusammen mit ihren Daten, indem wir die Funktion ‚ÄûCreateNewGravatarEvent()‚Äú verwenden;
- Wir rufen Handler-Methoden f√ºr diese Ereignisse auf - ‚ÄûhandleNewGravatars()‚Äú - und √ºbergeben die Liste unserer eigenen Ereignisse;
- Wir behaupten den Zustand des Ladens. Wie funktioniert das? - Wir √ºbergeben eine eindeutige Kombination aus Entity-Typ und ID. Dann √ºberpr√ºfen wir ein bestimmtes Feld dieser Entit√§t und stellen sicher, dass es den erwarteten Wert hat. Wir tun dies sowohl f√ºr die urspr√ºngliche Gravatar-Entit√§t, die wir dem Speicher hinzugef√ºgt haben, als auch f√ºr die beiden Gravatar-Entit√§ten, die hinzugef√ºgt werden, wenn die Handler-Funktion aufgerufen wird;
- Und schlie√ülich bereinigen wir den Speicher mit `clearStore()`, damit unser n√§chster Test mit einem frischen und leeren Speicherobjekt beginnen kann. Wir k√∂nnen so viele Testbl√∂cke definieren, wie wir wollen.

There we go - we've created our first test! üëè

Now in order to run our tests you simply need to run the following in your Subgraph root folder:

`graph test Gravity`

And if all goes well you should be greeted with the following:

![Matchstick saying ‚ÄúAll tests passed!‚Äù](/img/matchstick-tests-passed.png)

## Common test scenarios

### Hydrating the store with a certain state

Die Benutzer k√∂nnen den Shop mit einer bekannten Reihe von Entit√§ten best√ºcken. Hier ist ein Beispiel f√ºr die Initialisierung des Speichers mit einer Gravatar-Entit√§t:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Calling a mapping function with an event

Ein Benutzer kann ein benutzerdefiniertes Ereignis erstellen und es an eine Mapping-Funktion √ºbergeben, die an den Speicher gebunden ist:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Calling all of the mappings with event fixtures

Users can call the mappings with test fixtures.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Mocking contract calls

Users can mock contract calls:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Wie gezeigt, muss der Benutzer eine Vertragsadresse, einen Funktionsnamen, eine Funktionssignatur, ein Array von Argumenten und nat√ºrlich den R√ºckgabewert angeben, um einen Vertragsaufruf und einen Hardcore-R√ºckgabewert nachzuahmen.

Users can also mock function reverts:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Mocking IPFS files (from matchstick 0.4.1)

Benutzer k√∂nnen IPFS-Dateien mit der Funktion ‚ÄûmockIpfsFile(hash, filePath)‚Äú simulieren. Die Funktion akzeptiert zwei Argumente, das erste ist der Hash/Pfad der IPFS-Datei und das zweite ist der Pfad zu einer lokalen Datei.

HINWEIS: Beim Testen von `ipfs.map/ipfs.mapJSON` muss die Callback-Funktion aus der Testdatei exportiert werden, damit Matchstick sie erkennen kann, wie die Funktion `processGravatar()` im untenstehenden Testbeispiel:

`.test.ts` file:

```typescript
importiere { assert, test, mockIpfsFile } von 'matchstick-as/assembly/index'
importieren { ipfs } von '@graphprotocol/graph-ts'
importiere { gravatarFromIpfs } von './utils'

// ipfs.map()-Callback exportieren, damit Matchstick ihn erkennen kann
exportiere { processGravatar } aus './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` file:

```typescript
import { Address, ethereum, JSONValue, Wert, ipfs, json, Bytes } von "@graphprotocol/graph-ts"
importieren { Gravatar } von "../../generated/schema"

...

// ipfs. ap Callback
Export Funktion processGravatar(Wert: JSONValue, userData: Wert): void {
  // Siehe JSONValue Dokumentation f√ºr Details zum Umgang mit
  // mit JSON-Werten
  let obj = value. oObject()
  let id = obj. et('id')

  wenn (! d) {
    return
  }

  // Callbacks k√∂nnen auch Objekte
  let gravatar = new Gravatar(id. oString())
  Gravatar. isplayName = userData.toString() + id.toString()
  gravatar.save()
}

// Funktion, die ipfs aufruft. bei
Export Funktion gravatarFromIpfs(): void {
  let rawData = ipfs. at("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json. romBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData. et("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id. oString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Asserting the state of the store

Users are able to assert the final (or midway) state of the store through asserting entities. In order to do this, the user has to supply an Entity type, the specific ID of an Entity, a name of a field on that Entity, and the expected value of the field. Here's a quick example:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Running the assert.fieldEquals() function will check for equality of the given field against the given expected value. The test will fail and an error message will be outputted if the values are **NOT** equal. Otherwise the test will pass successfully.

### Interacting with Event metadata

Users can use default transaction metadata, which could be returned as an ethereum.Event by using the `newMockEvent()` function. The following example shows how you can read/write to those fields on the Event object:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Asserting variable equality

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Asserting that an Entity is **not** in the store

Users can assert that an entity does not exist in the store. The function takes an entity type and an id. If the entity is in fact in the store, the test will fail with a relevant error message. Here's a quick example of how to use this functionality:

```typescript
assert.notInStore('Gravatar', '23')
```

### Printing the whole store, or single entities from it (for debug purposes)

You can print the whole store to the console using this helper function:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

As of version 0.6.0, `logStore` no longer prints derived fields, instead users can use the new `logEntity` function. Of course `logEntity` can be used to print any entity, not just ones that have derived fields. `logEntity` takes the entity type, entity id and a `showRelated` flag to indicate if users want to print the related derived entities.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### Expected failure

Users can have expected test failures, using the shouldFail flag on the test() functions:

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Wenn der Test mit shouldFail = true gekennzeichnet ist, aber NICHT fehlschl√§gt, wird dies in den Protokollen als Fehler angezeigt und der Testblock schl√§gt fehl. Wenn der Test mit shouldFail = false markiert ist (der Standardstatus), st√ºrzt der Test-Executor ab.

### Protokollierung

Die Verwendung von benutzerdefinierten Protokollen in den Unit-Tests ist genau dasselbe wie die Protokollierung in den Mappings. Der Unterschied besteht darin, dass das Log-Objekt von matchstick-as und nicht von graph-ts importiert werden muss. Hier ist ein einfaches Beispiel mit allen unkritischen Protokolltypen:

```typescript
importiere { test } aus "matchstick-as/assembly/index";
importiere { log } aus "matchstick-as/assembly/log";

test("Success", () => {
    log. uccess("Erfolg!". []);
});
test("Error", () => {
    log. rror("Error :( ", []);
});
test("Debug", () => {
    log. ebug("Debugging...", []);
});
test("Info", () => {
    log. nfo("Info!", []);
});
test("Warnung", () => {
    log.warning("Warnung!", []);
});
```

Users can also simulate a critical failure, like so:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Die Protokollierung kritischer Fehler wird die Ausf√ºhrung der Tests stoppen und alles in die Luft jagen. Schlie√ülich wollen wir sicherstellen, dass Ihr Code bei der Bereitstellung keine kritischen Protokolle enth√§lt, und Sie sollten sofort bemerken, wenn das passiert.

### Testing derived fields

Testing derived fields is a feature which allows users to set a field on a certain entity and have another entity be updated automatically if it derives one of its fields from the first entity.

Before version `0.6.0` it was possible to get the derived entities by accessing them as entity fields/properties, like so:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

As of version `0.6.0`, this is done by using the `loadRelated` function of graph-node, the derived entities can be accessed the same way as in the handlers.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Testing `loadInBlock`

As of version `0.6.0`, users can test `loadInBlock` by using the `mockInBlockStore`, it allows mocking entities in the block cache.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Can use entity.loadInBlock() to retrieve entity from cache store in the current block', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Returns null when calling entity.loadInBlock() if an entity doesn't exist in the current block", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Testing dynamic data sources

Testing dynamic data sources can be be done by mocking the return value of the `context()`, `address()` and `network()` functions of the dataSource namespace. These functions currently return the following: `context()` - returns an empty entity (DataSourceContext), `address()` - returns `0x0000000000000000000000000000000000000000`, `network()` - returns `mainnet`. The `create(...)` and `createWithContext(...)` functions are mocked to do nothing so they don't need to be called in the tests at all. Changes to the return values can be done through the functions of the `dataSourceMock` namespace in `matchstick-as` (version 0.3.0+).

Example below:

Zun√§chst haben wir den folgenden Event-Handler (der absichtlich umgewidmet wurde, um Datasource Mocking zu zeigen):

```typescript
Export Funktion handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet. oad(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet. okenDestinationsApproved = true
  }
  let context = dataSource. ontext()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet. etBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

Und dann haben wir den Test mit einer der Methoden im dataSourceMock-Namensraum, um einen neuen R√ºckgabewert f√ºr alle dataSource-Funktionen festzulegen:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '. /../src/token-lock-wallet'
Import { ApproveTokenDestinations } von '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
Import { TokenLockWallet } von '. /../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address. romString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  Wallet. ave()
  la√üt context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock. etReturnValues(addressString, 'rinkeby', context)
  let event = change type<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet. okenDestinationsApproved)

  handleApproveTokenDestinations(event)

  Wallet.load(address.toHexString())!
  assert. ssertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Beachten Sie, dass dataSourceMock.resetValues() am Ende aufgerufen wird. Das liegt daran, dass die Werte gespeichert werden, wenn sie ge√§ndert werden, und dass sie zur√ºckgesetzt werden m√ºssen, wenn Sie zu den Standardwerten zur√ºckkehren m√∂chten.

### Testing dynamic data source creation

As of version `0.6.0`, it is possible to test if a new data source has been created from a template. This feature supports both ethereum/contract and file/ipfs templates. There are four functions for this:

- `assert.dataSourceCount(templateName, expectedCount)` can be used to assert the expected count of data sources from the specified template
- `assert.dataSourceExists(templateName, address/ipfsHash)` asserts that a data source with the specified identifier (could be a contract address or IPFS file hash) from a specified template was created
- `logDataSources(templateName)` prints all data sources from the specified template to the console for debugging purposes
- `readFile(path)` reads a JSON file that represents an IPFS file and returns the content as Bytes

#### Testing `ethereum/contract` templates

```typescript
test('ethereum/contract dataSource creation example', () =&amp;gt; {
 // Assert, dass keine dataSources aus der GraphTokenLockWallet-Vorlage erstellt wurden
 assert. dataSourceCount('GraphTokenLockWallet', 0)

 // Erstellen einer neuen GraphTokenLockWallet-Datenquelle mit der Adresse 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
 GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert, dass die Datenquelle erstellt wurde
 assert.dataSourceCount('GraphTokenLockWallet', 1)

 // Eine zweite Datenquelle mit Kontext hinzuf√ºgen
 let context = new DataSourceContext()
 context.set('contextVal', Value.fromI32(325))

 GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert, dass es jetzt 2 Datenquellen gibt
 assert.dataSourceCount('GraphTokenLockWallet', 2)

 // Assert, dass eine Datenquelle mit der Adresse "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" erstellt wurde
 // Beachten Sie, dass der Typ `Address` bei der Dekodierung in Kleinbuchstaben umgewandelt wird, so dass Sie die Adresse in Kleinbuchstaben √ºbergeben m√ºssen, wenn Sie behaupten, dass sie existiert
 assert. dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

 logDataSources('GraphTokenLockWallet')
})
```

##### Example `logDataSource` output

```bash
üõ†Ô∏è {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "Adresse: "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "Adresse: "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "Daten": 325
      }
    }
  }
}
```

#### Testing `file/ipfs` templates

√Ñhnlich wie bei den vertraglich vereinbarten dynamischen Datenquellen k√∂nnen die Benutzer auch Dateidatenquellen und ihre Bearbeiter testen

##### Example `subgraph.yaml`

```yaml
...
Vorlagen:
 - Art: Datei/ipfs
    Name: GraphTokenLockMetadaten
    Netzwerk: mainnet
    Zuweisung:
      Art: Ethereum/Ereignisse
      apiVersion: 0.0.9
      Sprache: wasm/assemblyscript
      Datei: ./src/token-lock-wallet.ts
      handler: handleMetadata
      Entit√§ten:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          Datei: ./abis/GraphTokenLockWallet.json
```

##### Example `schema.graphql`

```graphql
"""
Token Sperr-Wallets, die gesperrte GRT
"""
Typ TokenLockMetadata @entity {
  "Die Adresse der Token Sperr-Wallet"
  id: ID!
  "Startzeit des Release-Zeitplans"
  startTime: BigInt!
  "Endzeit des Release-Zeitplans"
  EndTime: BigInt!
  "Anzahl der Perioden zwischen Startzeit und Endzeit"
  Perioden: BigInt!
  "Time when the release start"
  releaseStartTime: BigInt!
}
```

##### Example `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Example handler

```typescript
export function handleMetadata(content: Bytes): void {
 // dataSource.stringParams() gibt die CID der File DataSource zur√ºck
 // stringParam() wird im Handler-Test gemockt
 // f√ºr weitere Informationen https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
 let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
 const value = json.fromBytes(content).toObject()

 if (value) {
 const startTime = value. get('startTime')
 const endTime = value.get('endTime')
 const periods = value.get('periods')
 const releaseStartTime = value.get('releaseStartTime')

 if (startTime &amp;amp;&amp;amp; endTime &amp;amp;&amp;amp; periods &amp;amp;&amp;amp; releaseStartTime) {
 tokenMetadata. startTime = startTime.toBigInt()
 tokenMetadata.endTime = endTime.toBigInt()
 tokenMetadata.periods = periods.toBigInt()
 tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
 }

 tokenMetadata.save()
 }
}
```

##### Example test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '.. /../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () =&amp;gt; {
 // Generieren Sie die dataSource CID aus der ipfsHash + ipfs Pfaddatei
 // Zum Beispiel QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example. json
 const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
 const CID = `${ipfshash}/example.json`

 // Erstellen einer neuen dataSource mit der generierten CID
 GraphTokenLockMetadata.create(CID)

 // Assert, dass die dataSource erstellt wurde
 assert. dataSourceCount('GraphTokenLockMetadata', 1)
 assert.dataSourceExists('GraphTokenLockMetadata', CID)
 logDataSources('GraphTokenLockMetadata')

 // Nun m√ºssen wir die dataSource-Metadaten und insbesondere dataSource. stringParam()
 // dataSource.stringParams verwendet eigentlich den Wert von dataSource.address(), also werden wir die Adresse mit dataSourceMock von matchstick-as nachbilden
 // Zuerst werden wir die Werte zur√ºcksetzen und dann dataSourceMock.setAddress() verwenden, um die CID zu setzen
 dataSourceMock. resetValues()
 dataSourceMock.setAddress(CID)

 // Nun m√ºssen wir die Bytes generieren, um sie an den dataSource-Handler zu √ºbergeben
 // F√ºr diesen Fall haben wir eine neue Funktion readFile eingef√ºhrt, die ein lokales json liest und den Inhalt als Bytes zur√ºckgibt
 const content = readFile(`path/to/metadata. json`)
 handleMetadata(content)

 // Nun testen wir, ob ein TokenLockMetadata erstellt wurde
 const metadata = TokenLockMetadata.load(CID)

 assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
 assert. bigIntEquals(metadata!.periods, BigInt.fromI32(1))
 assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
 assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Test Coverage

Mit **Matchstick** k√∂nnen die Entwickler von Subgraph ein Skript ausf√ºhren, das die Testabdeckung der geschriebenen Unit-Tests berechnet.

Das Testabdeckungswerkzeug nimmt die kompilierten Test-Bin√§rdateien ‚Äûwasm‚Äú und konvertiert sie in ‚Äöwat‚Äò-Dateien, die dann leicht inspiziert werden k√∂nnen, um zu sehen, ob die in ‚Äûsubgraph.yaml‚Äú definierten Handler aufgerufen wurden oder nicht. Da die Codeabdeckung (und das Testen als Ganzes) in AssemblyScript und WebAssembly noch in den Kinderschuhen steckt, kann **Matchstick** nicht auf Zweigabdeckung pr√ºfen. Stattdessen verlassen wir uns auf die Behauptung, dass, wenn ein bestimmter Handler aufgerufen wurde, das Ereignis/die Funktion f√ºr diesen Handler korrekt gespottet wurde.

### Voraussetzungen

Um die Testabdeckungsfunktion von **Matchstick** nutzen zu k√∂nnen, m√ºssen Sie einige Dinge vorbereiten:

#### Export your handlers

Damit **Matchstick** pr√ºfen kann, welche Handler ausgef√ºhrt werden, m√ºssen diese Handler aus der **Testdatei** exportiert werden. In unserem Beispiel haben wir also in der Datei gravity.test.ts den folgenden Handler importiert:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

In order for that function to be visible (for it to be included in the `wat` file **by name**) we need to also export it, like this:

```typescript
export { handleNewGravatar }
```

### Verwendung

Once that's all set up, to run the test coverage tool, simply run:

```sh
graph test -- -c
```

You could also add a custom `coverage` command to your `package.json` file, like so:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

That will execute the coverage tool and you should see something like this in the terminal:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 Ô∏è
Reading generated test modules... üîéÔ∏è

Generating coverage report üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Test run time duration in the log output

The log output includes the test run duration. Here's an example:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Common compiler errors

> Critical: Could not create WasmInstance from valid module with context: unknown import: wasi_snapshot_preview1::fd_write has not been defined

Dies bedeutet, dass Sie `console.log` in Ihrem Code verwendet haben, was von AssemblyScript nicht unterst√ºtzt wird. Bitte verwenden Sie die [Logging API](/subgraphs/developing/creating/graph-ts/api/#logging-api)

> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
>
> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

The mismatch in arguments is caused by mismatch in `graph-ts` and `matchstick-as`. The best way to fix issues like this one is to update everything to the latest released version.

## Zus√§tzliche Ressourcen

For any additional support, check out this [demo Subgraph repo using Matchstick](https://github.com/LimeChain/demo-subgraph#readme_).

## Feedback

If you have any questions, feedback, feature requests or just want to reach out, the best place would be The Graph Discord where we have a dedicated channel for Matchstick, called üî•| unit-testing.
