---
title: Rahmen für Einheitstests
---

Lernen Sie die Verwendung von Matchstick, einem von [LimeChain] (https://limechain.tech/) entwickelten Unit-Testing-Framework. Matchstick ermöglicht es Subgraph-Entwicklern, ihre Mapping-Logik in einer Sandbox-Umgebung zu testen und ihre Subgraphen erfolgreich einzusetzen.

## Vorteile der Verwendung von Matchstick

- Es ist in Rust geschrieben und für hohe Leistung optimiert.
- Sie ermöglicht Ihnen den Zugriff auf Entwicklerfunktionen, einschließlich der Möglichkeit, Vertragsaufrufe nachzubilden, Behauptungen über den Speicherzustand aufzustellen, Fehler in Subgraphen zu überwachen, die Testleistung zu überprüfen und vieles mehr.

## Erste Schritte

### Abhängigkeiten installieren

Um die Testhilfsmethoden verwenden und Tests ausführen zu können, müssen Sie die folgenden Abhängigkeiten installieren:

```sh
yarn add --dev Matchstick-as
```

### Install PostgreSQL

`graph-node` depends on PostgreSQL, so if you don't already have it, then you will need to install it.

> Note: It's highly recommended to use the commands below to avoid unexpected errors.

#### Using MacOS

Installation command:

```sh
brew install postgresql
```

Create a symlink to the latest libpq.5.lib _You may need to create this dir first_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### Using Linux

Installation command (depends on your distro):

```sh
sudo apt install postgresql
```

### Verwendung von WSL (Windows Subsystem für Linux)

Sie können Matchstick auf WSL sowohl mit dem Docker-Ansatz als auch mit dem binären Ansatz verwenden. Da WSL ein wenig knifflig sein kann, hier ein paar Tipps, falls Sie auf Probleme stoßen wie

```
static BYTES = Symbol(„Bytes“) SyntaxError: Unerwartetes Token =
```

oder

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Bitte stellen Sie sicher, dass Sie eine neuere Version von Node.js verwenden. graph-cli unterstützt **v10.19.0** nicht mehr, und das ist immer noch die Standardversion für neue Ubuntu-Images auf WSL. Zum Beispiel ist Matchstick bestätigt, dass es auf WSL mit **v18.1.0** funktioniert, Sie können entweder über **nvm** darauf umsteigen oder wenn Sie Ihr globales Node.js aktualisieren. Vergessen Sie nicht, `node_modules` zu löschen und `npm install` erneut auszuführen, nachdem Sie Ihr nodejs aktualisiert haben! Stellen Sie dann sicher, dass Sie **libpq** installiert haben, indem Sie

```
sudo apt-get install libpq-dev
```

Und schließlich, verwenden Sie nicht `graph test` (das Ihre globale Installation von graph-cli verwendet und aus irgendeinem Grund sieht es so aus, als ob es auf der WSL derzeit nicht funktioniert), sondern verwenden Sie `yarn test` oder `npm run test` (das wird die lokale Instanz von graph-cli auf Projektebene verwenden, was wunderbar funktioniert). Dafür müssen Sie natürlich ein `„test“-Skript in Ihrer `package.json\`-Datei haben, was etwas so einfaches sein kann wie

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### Using Matchstick

To use **Matchstick** in your Subgraph project just open up a terminal, navigate to the root folder of your project and simply run `graph test [options] <datasource>` - it downloads the latest **Matchstick** binary and runs the specified test or all tests in a test folder (or all existing tests if no datasource flag is specified).

### CLI-Optionen

Dadurch werden alle Tests im Testordner ausgeführt:

```sh
graph test
```

Dies führt einen Test namens gravity.test.ts und/oder alle Tests in einem Ordner namens gravity aus:

```sh
graph test gravity
```

Dadurch wird nur diese spezielle Testdatei ausgeführt:

```sh
graph test path/to/file.test.ts
```

**Optionen:**

```sh
-c, --coverage                Run the tests in coverage mode
-d, --docker                  Run the tests in a docker container (Note: Please execute from the root folder of the subgraph)
-f, --force                   Binary: Redownloads the binary. Docker: Redownloads the Dockerfile and rebuilds the docker image.
-h, --help                    Show usage information
-l, --logs                    Logs to the console information about the OS, CPU model and download url (debugging purposes)
-r, --recompile               Forces tests to be recompiled
-v, --version &amp;lt; tag&amp;gt;           Choose the version of the rust binary that you want to be downloaded/used
```

### Docker

Ab `graph-cli 0.25.2` unterstützt der Befehl `graph test` die Ausführung von `matchstick` in einem Docker-Container mit dem `-d` Flag. Die Docker-Implementierung verwendet [bind mount](https://docs.docker.com/storage/bind-mounts/), so dass sie das Docker-Image nicht jedes Mal neu erstellen muss, wenn der Befehl `graph test -d` ausgeführt wird. Alternativ können Sie den Anweisungen aus dem [matchstick](https://github.com/LimeChain/matchstick#docker-) Repository folgen, um docker manuell zu starten.

❗ `graph test -d` forces `docker run` to run with flag `-t`. This must be removed to run inside non-interactive environments (like GitHub CI).

❗ If you have previously ran `graph test` you may encounter the following error during docker build:

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

In this case create a `.dockerignore` in the root folder and add `node_modules/binary-install-raw/bin`

### Konfiguration

Matchstick can be configured to use a custom tests, libs and manifest path via `matchstick.yaml` config file:

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Demo Subgraph

You can try out and play around with the examples from this guide by cloning the [Demo Subgraph repo](https://github.com/LimeChain/demo-subgraph)

### Video-Tutorials

Also you can check out the video series on ["How to use Matchstick to write unit tests for your Subgraphs"](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Struktur der Tests

WICHTIG: Die unten beschriebene Teststruktur hängt von der Version `matchstick-as` >=0.5.0\*\*\_ ab.

### describe()

`describe(name: String , () => {})` - Defines a test group.

**_Notes:_**

- _Describes are not mandatory. You can still use test() the old way, outside of the describe() blocks_

Beispiel:

```typescript
Importiere { describe, test } von "Matchstick-as/assembly/index"
importiere { handleNewGravatar } von "../.. src/gravity"

describe("handleNewGravatar()", () => {
  test("Soll eine neue Gravatar Entity erstellen", () => {
    ...
  })
})
```

Nested `describe()` example:

```typescript
Importiere { describe, test } von "Matchstick-as/assembly/index"
importiere { handleUpdatedGravatar } von "../.. src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("Wenn Entität existiert", () => {
    test("aktualisiert die Entität", () => {
      ...
    })
  })

  beschreibt ("Wenn Entität nicht existiert", () => {
    test("Es erzeugt ein neues Entity", () => {
      ...
    })
  })
})
```

---

### test()

`test(name: String, () =>, should_fail: bool)` - Defines a test case. You can use test() inside of describe() blocks or independently.

Beispiel:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

oder

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

Runs a code block before any of the tests in the file. If `beforeAll` is declared inside of a `describe` block, it runs at the beginning of that `describe` block.

Beispiele:

Code inside `beforeAll` will execute once before _all_ tests in the file.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = “First Gravatar”
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

Code inside `beforeAll` will execute once before all tests in the first describe block

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = “First Gravatar”
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Runs a code block after all of the tests in the file. If `afterAll` is declared inside of a `describe` block, it runs at the end of that `describe` block.

Beispiel:

Code inside `afterAll` will execute once after _all_ tests in the file.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

Code inside `afterAll` will execute once after all tests in the first describe block

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
	afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
	})

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Runs a code block before every test. If `beforeEach` is declared inside of a `describe` block, it runs before each test in that `describe` block.

Examples: Code inside `beforeEach` will execute before each tests.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

Code inside `beforeEach` will execute only before each test in the that describe

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Updates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Führt einen Codeblock nach jedem Test aus. Wenn `afterEach` innerhalb eines `describe`-Blocks deklariert ist, wird es nach jedem Test in diesem `describe`-Block ausgeführt.

Beispiele:

Code inside `afterEach` will execute after every test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = “First Gravatar”
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Code inside `afterEach` will execute after each test in that describe

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Asserts

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

As of version 0.6.0, asserts support custom error messages as well

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id should be 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value should equal 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar should not be in store')
assert.addressEquals(Address.zero(), Address.zero(), 'Address should be zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes should be equal')
assert.i32Equals(2, 2, 'I32 should equal 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt should equal 1')
assert.booleanEquals(true, true, 'Boolean should be true')
assert.stringEquals('1', '1', 'String should equal 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arrays should be equal')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuples should be equal',
)
assert.assertTrue(true, 'Should be true')
assert.assertNull(null, 'Should be null')
assert.assertNotNull('not null', 'Should be not null')
assert.entityCount('Gravatar', 1, 'There should be 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet template should have one data source')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet should have a data source for zero address',
)
```

## Write a Unit Test

Let's see how a simple unit test would look like using the Gravatar examples in the [Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

Assuming we have the following handler function (along with two helper functions to make our life easier):

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownerAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

We first have to create a test file in our project. This is an example of how that might look like:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})
```

Das ist eine Menge zum Auspacken! Zunächst einmal ist es wichtig zu wissen, dass wir Dinge aus `matchstick-as` importieren, unserer AssemblyScript-Hilfsbibliothek (die als npm-Modul verteilt wird). Sie können das Repository [hier] finden (https://github.com/LimeChain/matchstick-as). `matchstick-as` stellt uns nützliche Testmethoden zur Verfügung und definiert auch die Funktion `test()`, die wir zum Erstellen unserer Testblöcke verwenden werden. Der Rest ist ziemlich einfach - hier ist, was passiert:

- Wir richten unseren Ausgangszustand ein und fügen eine benutzerdefinierte Gravatar-Entität hinzu;
- Wir definieren zwei „NewGravatar“-Ereignisobjekte zusammen mit ihren Daten, indem wir die Funktion „CreateNewGravatarEvent()“ verwenden;
- Wir rufen Handler-Methoden für diese Ereignisse auf - „handleNewGravatars()“ - und übergeben die Liste unserer eigenen Ereignisse;
- Wir behaupten den Zustand des Ladens. Wie funktioniert das? - Wir übergeben eine eindeutige Kombination aus Entity-Typ und ID. Dann überprüfen wir ein bestimmtes Feld dieser Entität und stellen sicher, dass es den erwarteten Wert hat. Wir tun dies sowohl für die ursprüngliche Gravatar-Entität, die wir dem Speicher hinzugefügt haben, als auch für die beiden Gravatar-Entitäten, die hinzugefügt werden, wenn die Handler-Funktion aufgerufen wird;
- Und schließlich bereinigen wir den Speicher mit `clearStore()`, damit unser nächster Test mit einem frischen und leeren Speicherobjekt beginnen kann. Wir können so viele Testblöcke definieren, wie wir wollen.

There we go - we've created our first test! 👏

Now in order to run our tests you simply need to run the following in your Subgraph root folder:

`graph test Gravity`

And if all goes well you should be greeted with the following:

![Matchstick saying “All tests passed!”](/img/matchstick-tests-passed.png)

## Common test scenarios

### Hydrating the store with a certain state

Die Benutzer können den Shop mit einer bekannten Reihe von Entitäten bestücken. Hier ist ein Beispiel für die Initialisierung des Speichers mit einer Gravatar-Entität:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Calling a mapping function with an event

Ein Benutzer kann ein benutzerdefiniertes Ereignis erstellen und es an eine Mapping-Funktion übergeben, die an den Speicher gebunden ist:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Calling all of the mappings with event fixtures

Users can call the mappings with test fixtures.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Mocking contract calls

Users can mock contract calls:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Wie gezeigt, muss der Benutzer eine Vertragsadresse, einen Funktionsnamen, eine Funktionssignatur, ein Array von Argumenten und natürlich den Rückgabewert angeben, um einen Vertragsaufruf und einen Hardcore-Rückgabewert nachzuahmen.

Users can also mock function reverts:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Mocking IPFS files (from matchstick 0.4.1)

Benutzer können IPFS-Dateien mit der Funktion „mockIpfsFile(hash, filePath)“ simulieren. Die Funktion akzeptiert zwei Argumente, das erste ist der Hash/Pfad der IPFS-Datei und das zweite ist der Pfad zu einer lokalen Datei.

HINWEIS: Beim Testen von `ipfs.map/ipfs.mapJSON` muss die Callback-Funktion aus der Testdatei exportiert werden, damit Matchstick sie erkennen kann, wie die Funktion `processGravatar()` im untenstehenden Testbeispiel:

`.test.ts` file:

```typescript
importiere { assert, test, mockIpfsFile } von 'matchstick-as/assembly/index'
importieren { ipfs } von '@graphprotocol/graph-ts'
importiere { gravatarFromIpfs } von './utils'

// ipfs.map()-Callback exportieren, damit Matchstick ihn erkennen kann
exportiere { processGravatar } aus './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` file:

```typescript
import { Address, ethereum, JSONValue, Wert, ipfs, json, Bytes } von "@graphprotocol/graph-ts"
importieren { Gravatar } von "../../generated/schema"

...

// ipfs. ap Callback
Export Funktion processGravatar(Wert: JSONValue, userData: Wert): void {
  // Siehe JSONValue Dokumentation für Details zum Umgang mit
  // mit JSON-Werten
  let obj = value. oObject()
  let id = obj. et('id')

  wenn (! d) {
    return
  }

  // Callbacks können auch Objekte
  let gravatar = new Gravatar(id. oString())
  Gravatar. isplayName = userData.toString() + id.toString()
  gravatar.save()
}

// Funktion, die ipfs aufruft. bei
Export Funktion gravatarFromIpfs(): void {
  let rawData = ipfs. at("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json. romBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData. et("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id. oString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Asserting the state of the store

Users are able to assert the final (or midway) state of the store through asserting entities. In order to do this, the user has to supply an Entity type, the specific ID of an Entity, a name of a field on that Entity, and the expected value of the field. Here's a quick example:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Running the assert.fieldEquals() function will check for equality of the given field against the given expected value. The test will fail and an error message will be outputted if the values are **NOT** equal. Otherwise the test will pass successfully.

### Interacting with Event metadata

Users can use default transaction metadata, which could be returned as an ethereum.Event by using the `newMockEvent()` function. The following example shows how you can read/write to those fields on the Event object:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Asserting variable equality

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Asserting that an Entity is **not** in the store

Users can assert that an entity does not exist in the store. The function takes an entity type and an id. If the entity is in fact in the store, the test will fail with a relevant error message. Here's a quick example of how to use this functionality:

```typescript
assert.notInStore('Gravatar', '23')
```

### Printing the whole store, or single entities from it (for debug purposes)

You can print the whole store to the console using this helper function:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

Seit Version 0.6.0 druckt `logStore` keine abgeleiteten Felder mehr aus, stattdessen können Benutzer die neue Funktion `logEntity` verwenden. Natürlich kann `logEntity` verwendet werden, um jede Entität zu drucken, nicht nur solche, die abgeleitete Felder haben. Die Funktion `logEntity` nimmt den Entitätstyp, die Entitäts-ID und ein `showRelated`-Flag, um anzugeben, ob der Benutzer die zugehörigen abgeleiteten Entitäten ausgeben möchte.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### Expected failure

Users can have expected test failures, using the shouldFail flag on the test() functions:

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

Wenn der Test mit shouldFail = true gekennzeichnet ist, aber NICHT fehlschlägt, wird dies in den Protokollen als Fehler angezeigt und der Testblock schlägt fehl. Wenn der Test mit shouldFail = false markiert ist (der Standardstatus), stürzt der Test-Executor ab.

### Protokollierung

Die Verwendung von benutzerdefinierten Protokollen in den Unit-Tests ist genau dasselbe wie die Protokollierung in den Mappings. Der Unterschied besteht darin, dass das Log-Objekt von matchstick-as und nicht von graph-ts importiert werden muss. Hier ist ein einfaches Beispiel mit allen unkritischen Protokolltypen:

```typescript
importiere { test } aus "matchstick-as/assembly/index";
importiere { log } aus "matchstick-as/assembly/log";

test("Success", () => {
    log. uccess("Erfolg!". []);
});
test("Error", () => {
    log. rror("Error :( ", []);
});
test("Debug", () => {
    log. ebug("Debugging...", []);
});
test("Info", () => {
    log. nfo("Info!", []);
});
test("Warnung", () => {
    log.warning("Warnung!", []);
});
```

Users can also simulate a critical failure, like so:

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

Die Protokollierung kritischer Fehler wird die Ausführung der Tests stoppen und alles in die Luft jagen. Schließlich wollen wir sicherstellen, dass Ihr Code bei der Bereitstellung keine kritischen Protokolle enthält, und Sie sollten sofort bemerken, wenn das passiert.

### Testing derived fields

Testing derived fields is a feature which allows users to set a field on a certain entity and have another entity be updated automatically if it derives one of its fields from the first entity.

Before version `0.6.0` it was possible to get the derived entities by accessing them as entity fields/properties, like so:

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

As of version `0.6.0`, this is done by using the `loadRelated` function of graph-node, the derived entities can be accessed the same way as in the handlers.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Testing `loadInBlock`

As of version `0.6.0`, users can test `loadInBlock` by using the `mockInBlockStore`, it allows mocking entities in the block cache.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Can use entity.loadInBlock() to retrieve entity from cache store in the current block', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Returns null when calling entity.loadInBlock() if an entity doesn't exist in the current block", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Testing dynamic data sources

Testing dynamic data sources can be be done by mocking the return value of the `context()`, `address()` and `network()` functions of the dataSource namespace. These functions currently return the following: `context()` - returns an empty entity (DataSourceContext), `address()` - returns `0x0000000000000000000000000000000000000000`, `network()` - returns `mainnet`. The `create(...)` and `createWithContext(...)` functions are mocked to do nothing so they don't need to be called in the tests at all. Changes to the return values can be done through the functions of the `dataSourceMock` namespace in `matchstick-as` (version 0.3.0+).

Example below:

Zunächst haben wir den folgenden Event-Handler (der absichtlich umgewidmet wurde, um Datasource Mocking zu zeigen):

```typescript
Export Funktion handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet. oad(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet. okenDestinationsApproved = true
  }
  let context = dataSource. ontext()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet. etBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

Und dann haben wir den Test mit einer der Methoden im dataSourceMock-Namensraum, um einen neuen Rückgabewert für alle dataSource-Funktionen festzulegen:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '. /../src/token-lock-wallet'
Import { ApproveTokenDestinations } von '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
Import { TokenLockWallet } von '. /../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address. romString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  Wallet. ave()
  laßt context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock. etReturnValues(addressString, 'rinkeby', context)
  let event = change type<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet. okenDestinationsApproved)

  handleApproveTokenDestinations(event)

  Wallet.load(address.toHexString())!
  assert. ssertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Beachten Sie, dass dataSourceMock.resetValues() am Ende aufgerufen wird. Das liegt daran, dass die Werte gespeichert werden, wenn sie geändert werden, und dass sie zurückgesetzt werden müssen, wenn Sie zu den Standardwerten zurückkehren möchten.

### Testing dynamic data source creation

As of version `0.6.0`, it is possible to test if a new data source has been created from a template. This feature supports both ethereum/contract and file/ipfs templates. There are four functions for this:

- `assert.dataSourceCount(templateName, expectedCount)` can be used to assert the expected count of data sources from the specified template
- `assert.dataSourceExists(templateName, address/ipfsHash)` asserts that a data source with the specified identifier (could be a contract address or IPFS file hash) from a specified template was created
- logDataSources(templateName)\` gibt alle Datenquellen der angegebenen Vorlage zu Debugging-Zwecken auf der Konsole aus
- `readFile(path)` reads a JSON file that represents an IPFS file and returns the content as Bytes

#### Testing `ethereum/contract` templates

```typescript
test('ethereum/contract dataSource creation example', () =&amp;gt; {
 // Assert, dass keine dataSources aus der GraphTokenLockWallet-Vorlage erstellt wurden
 assert. dataSourceCount('GraphTokenLockWallet', 0)

 // Erstellen einer neuen GraphTokenLockWallet-Datenquelle mit der Adresse 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
 GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert, dass die Datenquelle erstellt wurde
 assert.dataSourceCount('GraphTokenLockWallet', 1)

 // Eine zweite Datenquelle mit Kontext hinzufügen
 let context = new DataSourceContext()
 context.set('contextVal', Value.fromI32(325))

 GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert, dass es jetzt 2 Datenquellen gibt
 assert.dataSourceCount('GraphTokenLockWallet', 2)

 // Assert, dass eine Datenquelle mit der Adresse "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" erstellt wurde
 // Beachten Sie, dass der Typ `Address` bei der Dekodierung in Kleinbuchstaben umgewandelt wird, so dass Sie die Adresse in Kleinbuchstaben übergeben müssen, wenn Sie behaupten, dass sie existiert
 assert. dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

 logDataSources('GraphTokenLockWallet')
})
```

##### Example `logDataSource` output

```bash
🛠️ {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "Adresse: "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "Adresse: "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "Daten": 325
      }
    }
  }
}
```

#### Testing `file/ipfs` templates

Ähnlich wie bei den vertraglich vereinbarten dynamischen Datenquellen können die Benutzer auch Dateidatenquellen und ihre Bearbeiter testen

##### Example `subgraph.yaml`

```yaml
...
Vorlagen:
 - Art: Datei/ipfs
    Name: GraphTokenLockMetadaten
    Netzwerk: mainnet
    Zuweisung:
      Art: Ethereum/Ereignisse
      apiVersion: 0.0.9
      Sprache: wasm/assemblyscript
      Datei: ./src/token-lock-wallet.ts
      handler: handleMetadata
      Entitäten:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          Datei: ./abis/GraphTokenLockWallet.json
```

##### Example `schema.graphql`

```graphql
"""
Token Sperr-Wallets, die gesperrte GRT
"""
Typ TokenLockMetadata @entity {
  "Die Adresse der Token Sperr-Wallet"
  id: ID!
  "Startzeit des Release-Zeitplans"
  startTime: BigInt!
  "Endzeit des Release-Zeitplans"
  EndTime: BigInt!
  "Anzahl der Perioden zwischen Startzeit und Endzeit"
  Perioden: BigInt!
  "Time when the release start"
  releaseStartTime: BigInt!
}
```

##### Example `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Example handler

```typescript
export function handleMetadata(content: Bytes): void {
 // dataSource.stringParams() gibt die CID der File DataSource zurück
 // stringParam() wird im Handler-Test gemockt
 // für weitere Informationen https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
 let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
 const value = json.fromBytes(content).toObject()

 if (value) {
 const startTime = value. get('startTime')
 const endTime = value.get('endTime')
 const periods = value.get('periods')
 const releaseStartTime = value.get('releaseStartTime')

 if (startTime &amp;amp;&amp;amp; endTime &amp;amp;&amp;amp; periods &amp;amp;&amp;amp; releaseStartTime) {
 tokenMetadata. startTime = startTime.toBigInt()
 tokenMetadata.endTime = endTime.toBigInt()
 tokenMetadata.periods = periods.toBigInt()
 tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
 }

 tokenMetadata.save()
 }
}
```

##### Example test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '.. /../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () =&amp;gt; {
 // Generieren Sie die dataSource CID aus der ipfsHash + ipfs Pfaddatei
 // Zum Beispiel QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example. json
 const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
 const CID = `${ipfshash}/example.json`

 // Erstellen einer neuen dataSource mit der generierten CID
 GraphTokenLockMetadata.create(CID)

 // Assert, dass die dataSource erstellt wurde
 assert. dataSourceCount('GraphTokenLockMetadata', 1)
 assert.dataSourceExists('GraphTokenLockMetadata', CID)
 logDataSources('GraphTokenLockMetadata')

 // Nun müssen wir die dataSource-Metadaten und insbesondere dataSource. stringParam()
 // dataSource.stringParams verwendet eigentlich den Wert von dataSource.address(), also werden wir die Adresse mit dataSourceMock von matchstick-as nachbilden
 // Zuerst werden wir die Werte zurücksetzen und dann dataSourceMock.setAddress() verwenden, um die CID zu setzen
 dataSourceMock. resetValues()
 dataSourceMock.setAddress(CID)

 // Nun müssen wir die Bytes generieren, um sie an den dataSource-Handler zu übergeben
 // Für diesen Fall haben wir eine neue Funktion readFile eingeführt, die ein lokales json liest und den Inhalt als Bytes zurückgibt
 const content = readFile(`path/to/metadata. json`)
 handleMetadata(content)

 // Nun testen wir, ob ein TokenLockMetadata erstellt wurde
 const metadata = TokenLockMetadata.load(CID)

 assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
 assert. bigIntEquals(metadata!.periods, BigInt.fromI32(1))
 assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
 assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## Test Coverage

Mit **Matchstick** können die Entwickler von Subgraph ein Skript ausführen, das die Testabdeckung der geschriebenen Unit-Tests berechnet.

Das Testabdeckungswerkzeug nimmt die kompilierten Test-Binärdateien „wasm“ und konvertiert sie in ‚wat‘-Dateien, die dann leicht inspiziert werden können, um zu sehen, ob die in „subgraph.yaml“ definierten Handler aufgerufen wurden oder nicht. Da die Codeabdeckung (und das Testen als Ganzes) in AssemblyScript und WebAssembly noch in den Kinderschuhen steckt, kann **Matchstick** nicht auf Zweigabdeckung prüfen. Stattdessen verlassen wir uns auf die Behauptung, dass, wenn ein bestimmter Handler aufgerufen wurde, das Ereignis/die Funktion für diesen Handler korrekt gespottet wurde.

### Voraussetzungen

Um die Testabdeckungsfunktion von **Matchstick** nutzen zu können, müssen Sie einige Dinge vorbereiten:

#### Export your handlers

Damit **Matchstick** prüfen kann, welche Handler ausgeführt werden, müssen diese Handler aus der **Testdatei** exportiert werden. In unserem Beispiel haben wir also in der Datei gravity.test.ts den folgenden Handler importiert:

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

In order for that function to be visible (for it to be included in the `wat` file **by name**) we need to also export it, like this:

```typescript
export { handleNewGravatar }
```

### Verwendung

Once that's all set up, to run the test coverage tool, simply run:

```sh
graph test -- -c
```

You could also add a custom `coverage` command to your `package.json` file, like so:

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Hopefully that should execute the coverage tool without any issues. You should see something like this in the terminal:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 ️
Reading generated test modules... 🔎️

Generating coverage report 📝

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Test run time duration in the log output

The log output includes the test run duration. Here's an example:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Common compiler errors

> Kritisch: WasmInstance konnte nicht aus einem gültigen Modul mit Kontext erstellt werden: unknown import: wasi_snapshot_preview1::fd_write wurde nicht definiert

Dies bedeutet, dass Sie `console.log` in Ihrem Code verwendet haben, was von AssemblyScript nicht unterstützt wird. Bitte verwenden Sie die [Logging API](/subgraphs/developing/creating/graph-ts/api/#logging-api)

> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
>
> ERROR TS2554: Expected ? arguments, but got ?.
>
> return new ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

The mismatch in arguments is caused by mismatch in `graph-ts` and `matchstick-as`. The best way to fix issues like this one is to update everything to the latest released version.

## Zusätzliche Ressourcen

For any additional support, check out this [demo Subgraph repo using Matchstick](https://github.com/LimeChain/demo-subgraph#readme_).

## Feedback

If you have any questions, feedback, feature requests or just want to reach out, the best place would be The Graph Discord where we have a dedicated channel for Matchstick, called 🔥| unit-testing.
