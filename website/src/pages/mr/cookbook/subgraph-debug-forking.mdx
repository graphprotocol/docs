---
title: फॉर्क्स वापरून जलद आणि सुलभ सबग्राफ डीबगिंग
---

बर्‍याच प्रणाली मोठ्या प्रमाणात डेटावर प्रक्रिया करतात त्याप्रमाणे, ग्राफचे इंडेक्सर्स (ग्राफ नोड्स) लक्ष्य ब्लॉकचेनसह तुमचा सबग्राफ समक्रमित करण्यासाठी थोडा वेळ लागू शकतात. डीबगिंगच्या उद्देशाने झटपट बदल आणि इंडेक्सिंगसाठी आवश्यक असलेली दीर्घ प्रतीक्षा वेळ यांच्यातील तफावत अत्यंत प्रतिकूल आहे आणि आम्हाला याची चांगली जाणीव आहे. म्हणूनच आम्ही **सबग्राफ फोर्किंग** सादर करत आहोत, जे [LimeChain](https://limechain.tech/) ने विकसित केले आहे आणि या लेखात मी तुम्हाला हे वैशिष्ट्य दाखवणार आहे की हे वैशिष्ट्य सबग्राफ डीबगिंगचा वेग वाढवण्यासाठी कसा वापरला जाऊ शकतो!

## ठीक आहे, ते काय आहे?

**सबग्राफ फोर्किंग** ही _दुसऱ्या_ सबग्राफच्या स्टोअरमधून (सामान्यत: रिमोट एक) घटक आणण्याची प्रक्रिया आहे.

डीबगिंगच्या संदर्भात, **सबग्राफ फोर्किंग** तुम्हाला तुमचा अयशस्वी सबग्राफ ब्लॉक _X_ येथे वाट न पाहता डीबग करण्याची अनुमती देते _X_ ला ब्लॉक करण्यासाठी सिंक-अप करण्यासाठी.

## काय?! कसे?

जेव्हा तुम्ही इंडेक्सिंगसाठी रिमोट ग्राफ नोडवर सबग्राफ उपयोजित करता आणि तो ब्लॉक _X_ वर अयशस्वी होतो, तेव्हा चांगली बातमी अशी आहे की आलेख नोड अजूनही त्याचे स्टोअर वापरून GraphQL क्वेरी सर्व्ह करेल, जे _X_ अवरोधित करण्यासाठी समक्रमित केले आहे. खूप छान आहे! याचा अर्थ ब्लॉक _X_ अनुक्रमित करताना उद्भवणाऱ्या बगचे निराकरण करण्यासाठी आम्ही या "अप-टू-डेट" स्टोअरचा लाभ घेऊ शकतो.

थोडक्यात, आम्ही एका रिमोट ग्राफ नोडवरून _अयशस्वी सबग्राफ फोर्क करणार आहोत_ ज्याला _X_ ब्लॉक _X_ वर डीबग केलेला स्थानिकरित्या उपयोजित सबग्राफ प्रदान करण्यासाठी अनुक्रमणिका स्थितीचे अद्ययावत दृश्य.

## कृपया, मला काही कोड दाखवा!

सबग्राफ डीबगिंगवर लक्ष केंद्रित करण्यासाठी, चला गोष्टी सोप्या ठेवूया आणि [उदाहरण-सबग्राफ< सोबत चालवूया ](https://github.com/graphprotocol/graph-tooling/tree/main/examples/ethereum-gravatar) इथरियम ग्रॅविटी स्मार्ट कॉन्ट्रॅक्टचे अनुक्रमणिका.

कोणत्याही बगशिवाय `Gravatar`s अनुक्रमित करण्यासाठी परिभाषित हँडलर येथे आहेत:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

अरेरे, किती दुर्दैवी आहे, जेव्हा मी माझा परिपूर्ण दिसणारा सबग्राफ [होस्टेड सर्व्हिस](https://thegraph.com/hosted-service/) वर तैनात करतो तेव्हा तो _"Gravatar आढळले नाही!"_ त्रुटी.

निराकरण करण्याचा प्रयत्न करण्याचा नेहमीचा मार्ग आहे:

1. मॅपिंग स्त्रोतामध्ये बदल करा, जो तुम्हाला विश्वास आहे की समस्या सोडवेल (जेव्हा मला माहित आहे की ते होणार नाही).
2. [होस्टेड सर्व्हिस](https://thegraph.com/hosted-service/) (किंवा अन्य रिमोट ग्राफ नोड) वर सबग्राफ पुन्हा तैनात करा.
3. ते समक्रमित होण्याची प्रतीक्षा करा.
4. तो पुन्हा खंडित झाल्यास 1 वर परत जा, अन्यथा: हुर्रे!

सामान्य डीबग प्रक्रियेसाठी हे खरोखरच परिचित आहे, परंतु एक पायरी आहे जी प्रक्रिया अत्यंत मंद करते: _3. ते समक्रमित होण्याची प्रतीक्षा करा._

**सबग्राफ फोर्किंग** वापरून आम्ही मूलत: ही पायरी काढून टाकू शकतो. ते कसे दिसते ते येथे आहे:

0. **_योग्य फोर्क-बेस_** सेटसह स्थानिक आलेख नोड स्पिन-अप करा.
1. मॅपिंग स्त्रोतामध्ये बदल करा, जो तुम्हाला विश्वास आहे की समस्या सोडवेल.
2. स्थानिक ग्राफ नोडवर तैनात करा, **_अयशस्वी सबग्राफ फोर्किंग_** आणि ** _समस्याग्रस्त ब्लॉकपासून सुरू होत आहे_**.
3. तो पुन्हा खंडित झाल्यास, 1 वर परत जा, अन्यथा: हुर्रे!

आता, तुमच्याकडे 2 प्रश्न असू शकतात:

1. fork-base काय???
2. फोर्किंग होईल कोणासोबत?!

आणि मी उत्तर देतो:

1. `फोर्क-बेस` ही "बेस" URL आहे, जसे की जेव्हा _सबग्राफ आयडी_ जोडली जाते तेव्हा परिणामी URL (`<fork- बेस>/<subgraph-id>`) हा सबग्राफ स्टोअरसाठी एक वैध GraphQL एंडपॉइंट आहे.
2. काटा काढणे सोपे आहे, घाम गाळण्याची गरज नाही:

```bash
$ आलेख तैनात <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

तसेच, सबग्राफ मॅनिफेस्टमधील `dataSources.source.startBlock` फील्ड समस्याग्रस्त ब्लॉकच्या संख्येवर सेट करण्यास विसरू नका, जेणेकरून तुम्ही अनावश्यक ब्लॉक्सची अनुक्रमणिका वगळू शकता आणि फोर्कचा फायदा घेऊ शकता!

तर, मी काय करतो ते येथे आहे:

0. मी स्थानिक आलेख नोड स्पिन-अप करतो ([हे कसे करायचे ते येथे आहे](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) `फोर्क-बेस` पर्याय यावर सेट केला आहे: `https://api.thegraph.com/subgraphs/id/`, कारण मी सबग्राफ फोर्क करीन, मी तैनात केलेली बग्गी पूर्वी, [HostedService](https://thegraph.com/hosted-service/) वरून.

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

1. After careful inspection I notice that there is a mismatch in the `id` representations used when indexing `Gravatar`s in my two handlers. While `handleNewGravatar` converts it to a hex (`event.params.id.toHex()`), `handleUpdatedGravatar` uses an int32 (`event.params.id.toI32()`) which causes the `handleUpdatedGravatar` to panic with "Gravatar not found!". I make them both convert the `id` to a hex.
2. मी बदल केल्यानंतर मी माझा सबग्राफ स्थानिक ग्राफ नोडवर तैनात करतो,**_अयशस्वी सबग्राफ फोर्किंग_** आणि सेटिंग `dataSources.source.startBlock``subgraph.yaml` मध्ये `6190343` ला:

```bash
$ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

3. मी स्थानिक ग्राफ नोडद्वारे तयार केलेल्या लॉगची तपासणी करतो आणि हुर्रे!, सर्वकाही कार्य करत असल्याचे दिसते.
4. मी माझा आता बग-मुक्त सबग्राफ रिमोट ग्राफ नोडवर उपयोजित करतो आणि आनंदाने जगतो! (बटाटे नाहीत)
5. शेवट...
