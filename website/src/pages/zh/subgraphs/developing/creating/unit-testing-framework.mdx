---
title: å•å…ƒæµ‹è¯•æ¡†æ¶
---

å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Matchstickï¼Œä¸€ä¸ªç”± [LimeChain]å¼€å‘çš„å•å…ƒæµ‹è¯•æ¡†æ¶(https://limechain.tech/)ã€‚ Matchstickä½¿å­å›¾å¼€å‘è€…èƒ½å¤Ÿåœ¨æ²™ç›’ç¯å¢ƒä¸­æµ‹è¯•å…¶ç»˜å›¾é€»è¾‘å¹¶æˆåŠŸåœ°éƒ¨ç½²å…¶å­å›¾ã€‚

## ä½¿ç”¨Matchstickçš„å¥½å¤„

- å®ƒç”¨Rustç¼–å†™å¹¶ä¼˜åŒ–é«˜æ€§èƒ½ã€‚
- å®ƒå…è®¸æ‚¨è®¿é—®å¼€å‘è€…åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ¨¡æ‹Ÿåˆçº¦é€šè¯çš„èƒ½åŠ› å¯¹å•†åº—çŠ¶æ€è¿›è¡Œæ–­è¨€ã€ç›‘è§†å­å›¾å¤±è´¥ã€æ£€æŸ¥æµ‹è¯•æ€§èƒ½ç­‰ç­‰ã€‚

## å¼€å§‹

### å®‰è£…ä¾èµ–é¡¹

ä¸ºäº†ä½¿ç”¨æµ‹è¯•è¾…åŠ©å™¨æ–¹æ³•å¹¶è¿è¡Œæµ‹è¯•ï¼Œæ‚¨éœ€è¦å®‰è£…ä»¥ä¸‹ä¾èµ–é¡¹ï¼š

```sh
yarn add --dev matchstick-as
```

### å®‰è£…PostgreSQL

`graph-node`ä¾èµ–äºPostgreSQLï¼Œæ‰€ä»¥å¦‚æœä½ è¿˜æ²¡æœ‰å®ƒï¼Œä½ å°†éœ€è¦å®‰è£…å®ƒã€‚

> æ³¨æ„ï¼šå¼ºçƒˆå»ºè®®ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥é¿å…æ„å¤–é”™è¯¯ã€‚

#### ä½¿ç”¨ MacOS

å®‰è£…å‘½ä»¤ï¼š

```sh
é…¿é€ å®‰è£…postgresql
```

åˆ›å»ºåˆ°æœ€æ–° libpq.5. lib çš„ç¬¦å·é“¾æ¥ï¼Œå¯èƒ½éœ€è¦é¦–å…ˆåˆ›å»ºè¿™ä¸ªç›®å½•/usr/local/opt/postgreql/lib/\`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### ä½¿ç”¨ Linux

å®‰è£…å‘½ä»¤(å–å†³äºæ‚¨çš„æ‹†åˆ†)ï¼š

```sh
sudo apt install postgresql
```

### ä½¿ç”¨ WSL (windowå­ç³»ç»Ÿä¸º Linux)

å¯ä»¥ä½¿ç”¨ Docker æ–¹æ³•å’ŒäºŒè¿›åˆ¶æ–¹æ³•åœ¨ WSL ä¸Šä½¿ç”¨ Matchstickã€‚ç”±äº WSL å¯èƒ½æœ‰ç‚¹å¤æ‚ï¼Œæ‰€ä»¥è¿™é‡Œæœ‰ä¸€äº›æç¤ºï¼Œä»¥é˜²æ‚¨é‡åˆ°è¯¸å¦‚

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

æˆ–è€…

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

è¯·ç¡®ä¿æ‚¨æ˜¯æ–°ç‰ˆæœ¬çš„ Node.js graph-cli ä¸æ”¯æŒ **v10.19.0** ï¼Œè¿™ä»ç„¶æ˜¯WSLä¸Šæ–°çš„ Ubuntu å›¾åƒçš„é»˜è®¤ç‰ˆæœ¬ã€‚ ä¾‹å¦‚ï¼ŒMatchstickè¢«ç¡®è®¤åœ¨ WSL ä½¿ç”¨ **v18.1.0 **ï¼Œæ‚¨å¯ä»¥é€šè¿‡ **nvm** åˆ‡æ¢åˆ°å®ƒï¼Œä¹Ÿå¯ä»¥æ›´æ–°æ‚¨çš„å…¨å±€Node.jsã€‚ åˆ«å¿˜äº†åœ¨æ›´æ–°èŠ‚ç‚¹ååˆ é™¤ `node_modules` å¹¶é‡æ–°è¿è¡Œ `npm install` ï¼ ç„¶åï¼Œè¯·ç¡®ä¿æ‚¨å·²ç»å®‰è£…äº† **libpq** ï¼Œæ‚¨å¯ä»¥é€šè¿‡è¿è¡Œæ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚

```
sudo apt-get install libpq-dev
```

æœ€åï¼Œ ä¸è¦ä½¿ç”¨ `graph test` (å®ƒä½¿ç”¨æ‚¨çš„å…¨å±€å®‰è£…å›¾å½¢-cli ï¼Œå¹¶ä¸”å‡ºäºæŸäº›åŸå› çœ‹èµ·æ¥åƒå½“å‰WSL ä¸Šçš„æ•…éšœ)ï¼Œ ç›¸åï¼Œä½¿ç”¨ `yarn test` æˆ– `npm è¿è¡Œæµ‹è¯•` (è¿™å°†ä½¿ç”¨å½“åœ°ã€é¡¹ç›®ä¸€çº§çš„graph-cli å®ä¾‹ï¼Œå®ƒç±»ä¼¼äºä¸€ä¸ªå­—ç¬¦)ã€‚ å› æ­¤ï¼Œä½ å½“ç„¶éœ€è¦åœ¨ä½ çš„`package.json` æ–‡ä»¶ä¸­æœ‰ä¸€ä¸ª "test"" è„šæœ¬ï¼Œè¿™ä¸ªè„šæœ¬å¯ä»¥åƒè¿™æ ·ç®€å•ã€‚

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### ä½¿ç”¨ Matchstick

è¦åœ¨å­å›¾é¡¹ç›®ä¸­ä½¿ç”¨**Matchstick**ï¼Œåªéœ€æ‰“å¼€ä¸€ä¸ªç»ˆç«¯ï¼Œå¯¼èˆªåˆ°é¡¹ç›®çš„æ ¹æ–‡ä»¶å¤¹ï¼Œç„¶åç®€å•åœ°è¿è¡Œ`graph test [options] <datasource>`-å®ƒä¸‹è½½æœ€æ–°çš„**Matchstick**äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå¹¶åœ¨æµ‹è¯•æ–‡ä»¶å¤¹ä¸­è¿è¡ŒæŒ‡å®šçš„æµ‹è¯•æˆ–æ‰€æœ‰æµ‹è¯•ï¼ˆå¦‚æœæœªæŒ‡å®šæ•°æ®æºæ ‡å¿—ï¼Œåˆ™è¿è¡Œæ‰€æœ‰ç°æœ‰æµ‹è¯•ï¼‰ã€‚

### CLI é€‰é¡¹

è¿™å°†è¿è¡Œæµ‹è¯•æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰æµ‹è¯•ï¼š

```sh
graph test
```

è¿™å°†è¿è¡Œåä¸ºgravity.test.tsçš„æµ‹è¯•å’Œ/æˆ–åä¸ºgravityçš„æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰æµ‹è¯•ï¼š

```sh
graph test Gravity
```

è¿™å°†ä»…è¿è¡Œç‰¹å®šçš„æµ‹è¯•æ–‡ä»¶ï¼š

```sh
graph test path/to/file.test.ts
```

**é€‰é¡¹:**

```sh
-c, --coverage                Run the tests in coverage mode
-d, --docker                  Run the tests in a docker container (Note: Please execute from the root folder of the Subgraph)
-f, --force                   Binary: Redownloads the binary. Docker: Redownloads the Dockerfile and rebuilds the docker image.
-h, --help                    Show usage information
-l, --logs                    Logs to the console information about the OS, CPU model and download url (debugging purposes)
-r, --recompile               Forces tests to be recompiled
-v, --version <tag>           Choose the version of the rust binary that you want to be downloaded/used
```

### Docker

ä» `graph-cli 0.25.2`, `graph test` å‘½ä»¤æ”¯æŒä½¿ç”¨ `-d` æ ‡å¿—åœ¨ä¸€ä¸ªç å¤´å®¹å™¨ä¸­è¿è¡Œ `matchstick` ã€‚ åœæ³Šå™¨å®ç°ä½¿ç”¨ [ç»‘å®šæŒ‚è½½](https://docs.docker.com/storage/bind-mounts/)ï¼Œæ‰€ä»¥å®ƒä¸å¿…åœ¨æ‰§è¡Œ"Graph test -d" å‘½ä»¤æ—¶é‡å»ºåœæ³Šå™¨å›¾åƒã€‚ ä½ ä¹Ÿå¯ä»¥æŒ‰ç…§ [matchstick](https://github.com/LimeChain/matchstick#docker-)çš„æŒ‡ä»¤æ‰‹åŠ¨è¿è¡Œåœé ä»“åº“ã€‚

â— `graph test -d` å¼ºåˆ¶`docker run` ä½¿ç”¨æ ‡å¿—`-t`è¿è¡Œã€‚è¿™å¿…é¡»ç§»é™¤ä»¥åœ¨éäº¤äº’ç¯å¢ƒä¸­è¿è¡Œ(å¦‚GitHub CI)ã€‚

â— å¦‚æœä½ ä»¥å‰è¿è¡Œè¿‡`graph test`, åœ¨dockeræ„å»ºè¿‡ç¨‹ä¸­å¯èƒ½ä¼šé‡åˆ°ä»¥ä¸‹é”™è¯¯ï¼š

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåœ¨æ ¹æ–‡ä»¶å¤¹ä¸­åˆ›å»º `.dockerignore` å¹¶æ·»åŠ  `node_modules/biny-install-raw/bin`ã€‚

### é…ç½®

Matchstickå¯ä»¥é€šè¿‡`matchstick.yaml`é…ç½®æ–‡ä»¶é…ç½®ä¸ºä½¿ç”¨è‡ªå®šä¹‰æµ‹è¯•ã€åº“å’Œæ¸…å•è·¯å¾„ï¼š

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### æ¼”ç¤ºå­å›¾

ä½ å¯ä»¥å°è¯•é€šè¿‡å…‹éš†[Demo Subgraph repo](https://github.com/LimeChain/demo-subgraph) æ¥ä½¿ç”¨æœ¬æŒ‡å—çš„ç¤ºä¾‹ã€‚

### è§†é¢‘æ•™ç¨‹

æ­¤å¤–ï¼Œæ‚¨è¿˜å¯ä»¥æŸ¥çœ‹[â€œå¦‚ä½•ä½¿ç”¨Matchstickä¸ºå­å›¾ç¼–å†™å•å…ƒæµ‹è¯•â€ç³»åˆ—è§†é¢‘](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)ã€‚

## æµ‹è¯•ç»“æ„

_**IMPORTANTï¼šä¸‹é¢æè¿°çš„æµ‹è¯•ç»“æ„å–å†³äº`matchstick-as`ç‰ˆæœ¬ >=0.5.0**_

### æè¿°ï¼ˆï¼‰

`description(name: String , () => {})` - å®šä¹‰æµ‹è¯•ç»„ã€‚

**_æ³¨æ„:_**

- æè¿°ä¸æ˜¯å¼ºåˆ¶æ€§çš„ã€‚æ‚¨ä»ç„¶å¯ä»¥åœ¨describeï¼ˆï¼‰åŒºå—ä¹‹å¤–ï¼Œä»¥æ—§çš„æ–¹å¼ä½¿ç”¨testï¼ˆï¼‰

ä¾‹å­:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Gravatar entity", () => {
    ...
  })
})
```

åµŒå¥—çš„ `descrip()` ç¤ºä¾‹ï¼š

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("When entity exists", () => {
    test("updates the entity", () => {
      ...
    })
  })

  describe("When entity does not exists", () => {
    test("it creates a new entity", () => {
      ...
    })
  })
})
```

---

### æµ‹è¯•ï¼ˆï¼‰

`test(name: String, () =>, should_fail: bool)` - å®šä¹‰æµ‹è¯•æ¡ˆä¾‹ã€‚æ‚¨å¯ä»¥åœ¨æè¿°() å—å†…æˆ–ç‹¬ç«‹ä½¿ç”¨test()ã€‚

ä¾‹å­:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Should create a new Entity", () => {
    ...
  })
})
```

æˆ–è€…

```typescript
test("handleNewGravatar() should create a new entity", () => {
  ...
})


```

---

### beforeAll()

åœ¨æ–‡ä»¶ä¸­çš„ä»»ä½•æµ‹è¯•ä¹‹å‰è¿è¡Œä»£ç åŒºå—ã€‚å¦‚æœ`beforeAll`åœ¨`describe`åŒºå—å†…å£°æ˜ï¼Œå®ƒå°†åœ¨è¯¥`describe`åŒºå—çš„å¼€å¤´è¿è¡Œã€‚

ä¾‹å­ï¼š

`beforeAll`ä¸­çš„ä»£ç å°†åœ¨ç¬¬ä¸€ä¸ªæè¿°åŒºå—ä¸­çš„æ‰€æœ‰æµ‹è¯•ä¹‹å‰æ‰§è¡Œä¸€æ¬¡ã€‚

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
  ...
})

describe("When the entity does not exist", () => {
  test("it should create a new Gravatar with id 0x1", () => {
    ...
  })
})

describe("When entity already exists", () => {
  test("it should update the Gravatar with id 0x0", () => {
    ...
  })
})
```

`beforeAll`ä¸­çš„ä»£ç å°†åœ¨ç¬¬ä¸€ä¸ªæè¿°åŒºå—ä¸­çš„æ‰€æœ‰æµ‹è¯•ä¹‹å‰æ‰§è¡Œä¸€æ¬¡ã€‚

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = â€œFirst Gravatarâ€
    gravatar.save()
    ...
  })

  test("updates Gravatar with id 0x0", () => {
    ...
  })

  test("creates new Gravatar with id 0x1", () => {
    ...
  })
})
```

---

### afterAll()

åœ¨æ¯æ¬¡æµ‹è¯•åè¿è¡Œä»£ç åŒºå—ã€‚å¦‚æœ`afterAll`åœ¨`describe` åŒºå—ä¸­å£°æ˜ï¼Œåˆ™åœ¨è¯¥`describe` åŒºå—ä¸­çš„æ¯ä¸ªæµ‹è¯•ä¹‹åè¿è¡Œã€‚

ä¾‹å­:

`afterAll`ä¸­çš„ä»£ç å°†åœ¨ç¬¬ä¸€ä¸ªæè¿°åŒºå—ä¸­çš„æ‰€æœ‰æµ‹è¯•ä¹‹åæ‰§è¡Œä¸€æ¬¡ã€‚

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

`afterAll`ä¸­çš„ä»£ç å°†åœ¨ç¬¬ä¸€ä¸ªæè¿°åŒºå—ä¸­çš„æ‰€æœ‰æµ‹è¯•ä¹‹åæ‰§è¡Œä¸€æ¬¡ã€‚

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
	afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
	})

  test("It creates a new entity with Id 0x0", () => {
    ...
  })

  test("It creates a new entity with Id 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

åœ¨æ–‡ä»¶ä¸­çš„ä»»ä½•æµ‹è¯•ä¹‹å‰è¿è¡Œä»£ç åŒºå—ã€‚å¦‚æœ`beforeEach`åœ¨`describe`åŒºå—å†…å£°æ˜ï¼Œå®ƒå°†åœ¨è¯¥`describe`åŒºå—çš„æ¯æ¬¡æµ‹è¯•ä¹‹å‰è¿è¡Œã€‚

ç¤ºä¾‹ï¼šåœ¨æ¯æ¬¡æµ‹è¯•ä¹‹å‰ï¼Œ`beforeEach`ä¸­çš„ä»£ç å°†ä¼šæ‰§è¡Œã€‚

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- clear the store before each test in the file
})

describe("handleNewGravatars, () => {
  test("A test that requires a clean store", () => {
    ...
  })

  test("Second that requires a clean store", () => {
    ...
  })
})

 ...
```

`beforeEach` é‡Œçš„ä»£ç å°†ä»…åœ¨æè¿°ä¸­çš„æ¯ä¸ªæµ‹è¯•ä¹‹å‰æ‰§è¡Œã€‚

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Updates the displayName', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Updates the imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

åœ¨æ–‡ä»¶ä¸­çš„ä»»ä½•æµ‹è¯•ä¹‹å‰è¿è¡Œä»£ç åŒºå—ã€‚å¦‚æœ`beforeEach`åœ¨`describe`åŒºå—å†…å£°æ˜ï¼Œå®ƒå°†åœ¨è¯¥`describe`åŒºå—çš„æ¯æ¬¡æµ‹è¯•ä¹‹å‰è¿è¡Œã€‚

ä¾‹å­ï¼š

`AfterEach`ä¸­çš„ä»£ç å°†ä»…åœ¨æè¿°ä¸­çš„æ¯ä¸ªæµ‹è¯•ä¹‹åæ‰§è¡Œã€‚

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = â€œFirst Gravatarâ€
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

`AfterEach`ä¸­çš„ä»£ç å°†ä»…åœ¨æè¿°ä¸­çš„æ¯ä¸ªæµ‹è¯•ä¹‹åæ‰§è¡Œã€‚

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Updates the displayName", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code that should update the displayName to 1st Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Updates the imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code that should changes the imageUrl to https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## åˆ¤æ–­

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

æˆªè‡³ç‰ˆæœ¬ 0.6.0ï¼Œæˆ‘ä»¬ä¹Ÿæ”¯æŒè‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ã€‚

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id should be 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'Value should equal 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar should not be in store')
assert.addressEquals(Address.zero(), Address.zero(), 'Address should be zero')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Bytes should be equal')
assert.i32Equals(2, 2, 'I32 should equal 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt should equal 1')
assert.booleanEquals(true, true, 'Boolean should be true')
assert.stringEquals('1', '1', 'String should equal 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Arrays should be equal')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Tuples should be equal',
)
assert.assertTrue(true, 'Should be true')
assert.assertNull(null, 'Should be null')
assert.assertNotNull('not null', 'Should be not null')
assert.entityCount('Gravatar', 1, 'There should be 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'GraphTokenLockWallet template should have one data source')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Address.zero().toHexString(),
  'GraphTokenLockWallet should have a data source for zero address',
)
```

## ç¼–å†™ä¸€ä¸ªå•å…ƒæµ‹è¯•

è®©æˆ‘ä»¬çœ‹çœ‹ä¸€ä¸ªç®€å•çš„å•å…ƒæµ‹è¯•ï¼Œå¦‚ä½•çœ‹èµ·æ¥åƒåœ¨ [Demo Subgraph](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts)ä¸­ä½¿ç”¨ Gravatar ç¤ºä¾‹ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹å¤„ç†ç¨‹åºå‡½æ•°ï¼ˆä»¥åŠä¸¤ä¸ªå¸®åŠ©å‡½æ•°ï¼Œä»¥ä½¿æˆ‘ä»¬çš„ç”Ÿæ´»æ›´è½»æ¾ï¼‰ï¼š

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownerAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

æˆ‘ä»¬é¦–å…ˆå¿…é¡»åœ¨é¡¹ç›®ä¸­åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–‡ä»¶ã€‚è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œè¯´æ˜å®ƒå¯èƒ½æ˜¯ä»€ä¹ˆæ ·å­çš„ï¼š

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})
```

è¿˜æœ‰å¾ˆå¤šä¸œè¥¿å¯ä»¥è§£åŒ…ï¼ é¦–å…ˆï¼Œæˆ‘ä»¬æ³¨æ„åˆ°çš„ä¸€ä¸ªé‡è¦é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ­£åœ¨ä» `matchstick-as`ã€æˆ‘ä»¬çš„ AssemblyScript åŠ©æ‰‹åº“ä¸­å¯¼å…¥ä¸€äº›ä¸œè¥¿(ä½œä¸ºnpm æ¨¡å—åˆ†å‘)ã€‚ æ‚¨å¯ä»¥åœ¨[è¿™é‡Œ](https://github.com/LimeChain/matchstick-as)æ‰¾åˆ°ä»“åº“ã€‚ `matchstick-as`ä¸ºæˆ‘ä»¬æä¾›äº†æœ‰ç”¨çš„æµ‹è¯•æ–¹æ³•ï¼Œå¹¶å®šä¹‰äº†`test()`åŠŸèƒ½ï¼Œæˆ‘ä»¬å°†ç”¨å®ƒæ¥æ„å»ºæˆ‘ä»¬çš„æµ‹è¯•å—ã€‚ å…¶å®ƒéƒ¨åˆ†ç›¸å½“ç›´æˆªäº†å½“â€•â€•è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆäº‹ï¼š

- æˆ‘ä»¬æ­£åœ¨è®¾ç½®æˆ‘ä»¬çš„åˆå§‹çŠ¶æ€å¹¶æ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰çš„ Gravatar å®ä½“ã€‚
- æˆ‘ä»¬ä½¿ç”¨ `createNewGravatarEvent()` å‡½æ•°å®šä¹‰ä¸¤ä¸ª`NewGravatar`äº‹ä»¶å¯¹è±¡åŠå…¶æ•°æ®ï¼›
- æˆ‘ä»¬æ­£åœ¨è°ƒç”¨è¿™äº›äº‹ä»¶çš„å¤„ç†æ–¹æ³• - `handleNewGravatars()` å¹¶åœ¨æˆ‘ä»¬çš„è‡ªå®šä¹‰äº‹ä»¶åˆ—è¡¨ä¸­ä¼ é€’ï¼›
- æˆ‘ä»¬æ–­å®šå­˜å‚¨çš„çŠ¶æ€ã€‚é‚£æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ- æˆ‘ä»¬ä¼ é€’ä¸€ä¸ªå®ä½“ç±»å‹å’Œ id çš„å”¯ä¸€ç»„åˆã€‚ç„¶åæˆ‘ä»¬æ£€æŸ¥è¯¥å®ä½“çš„ä¸€ä¸ªç‰¹å®šå­—æ®µï¼Œå¹¶æ–­å®šå®ƒå…·æœ‰æˆ‘ä»¬æœŸæœ›çš„å€¼ã€‚æˆ‘ä»¬ä¸ºæˆ‘ä»¬æ·»åŠ åˆ°å­˜å‚¨çš„åˆå§‹ Gravatar å®ä½“ï¼Œä»¥åŠå½“å¤„ç†å‡½æ•°è¢«è°ƒç”¨æ—¶è¢«æ·»åŠ çš„ä¸¤ä¸ª Gravatar å®ä½“éƒ½åšè¿™ä¸ªã€‚
- æœ€åâ€”â€”æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ `clearStore()` æ¥æ¸…ç†å†…å­˜ï¼Œä»¥ä¾¿æˆ‘ä»¬çš„ä¸‹ä¸€æ¬¡æµ‹è¯•èƒ½å¤Ÿä»¥ä¸€ä¸ªæ–°çš„å’Œç©ºçš„å‚¨å­˜å¯¹è±¡å¼€å§‹ã€‚ æˆ‘ä»¬å¯ä»¥å®šä¹‰æˆ‘ä»¬æƒ³è¦çš„å°½å¯èƒ½å¤šçš„è¯•éªŒåŒºå—ã€‚

å¥½äº†ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ç¬¬ä¸€ä¸ªæµ‹è¯•ï¼ğŸ‘

ç°åœ¨ï¼Œä¸ºäº†è¿è¡Œæˆ‘ä»¬çš„æµ‹è¯•ï¼Œæ‚¨åªéœ€åœ¨å­å›¾æ ¹æ–‡ä»¶å¤¹ä¸­è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

`graph test Gravity`

å¦‚æœä¸€åˆ‡é¡ºåˆ©ï¼Œæ‚¨åº”è¯¥ä¼šæ”¶åˆ°ä»¥ä¸‹ä¿¡æ¯ï¼š

![Matchstickè¡¨ç¤ºâ€œé€šè¿‡æ‰€æœ‰æµ‹è¯•ï¼â€](/img/matchstick-tests-passed.png)

## å¸¸è§æµ‹è¯•åœºæ™¯

### ä½¿ç”¨ç‰¹å®šçŠ¶æ€æ¥å¡«å……å­˜å‚¨

ç”¨æˆ·èƒ½å¤Ÿç”¨ä¸€ç»„å·²çŸ¥çš„å®ä½“æ¥è¡¥å……å­˜å‚¨ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç”¨Gravatarå®ä½“åˆå§‹åŒ–å­˜å‚¨çš„ä¾‹å­ã€‚

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### ç”¨ä¸€ä¸ªäº‹ä»¶è°ƒç”¨ä¸€ä¸ªæ˜ å°„å‡½æ•°

ç”¨æˆ·å¯ä»¥åˆ›å»ºè‡ªå®šä¹‰äº‹ä»¶å¹¶å°†å…¶ä¼ é€’ç»™ç»‘å®šåˆ°å­˜å‚¨çš„æ˜ å°„å‡½æ•°ï¼š

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### ç”¨äº‹ä»¶å¤¹å…·è°ƒç”¨æ‰€æœ‰çš„æ˜ å°„å…³ç³»

ç”¨æˆ·å¯ä»¥ç”¨æµ‹è¯•å¤¹å…·è°ƒç”¨æ‰€æœ‰çš„æ˜ å°„å…³ç³»ã€‚

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### æ¨¡æ‹Ÿåˆçº¦è°ƒç”¨

ç”¨æˆ·å¯ä»¥æ¨¡æ‹Ÿåˆçº¦è°ƒç”¨ï¼š

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

å¦‚å›¾æ‰€ç¤ºï¼Œä¸ºäº†æ¨¡æ‹Ÿåˆçº¦è°ƒç”¨å¹¶å®ç°è¿”å›å€¼ï¼Œç”¨æˆ·å¿…é¡»æä¾›åˆçº¦åœ°å€ã€å‡½æ•°åã€å‡½æ•°ç­¾åã€å‚æ•°æ•°ç»„ï¼Œå½“ç„¶è¿˜æœ‰è¿”å›å€¼ã€‚

ç”¨æˆ·è¿˜å¯ä»¥æ¨¡æ‹Ÿå‡½æ•°è¿˜åŸï¼š

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### æ¨¡æ‹ŸIPFSæ–‡ä»¶(from matchstick 0.4.1)

ç”¨æˆ·å¯ä»¥ä½¿ç”¨ `mockIpfsFile(hash, filePath)` å‡½æ•°æ¨¡æ‹ŸIPFS æ–‡ä»¶ã€‚ å‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯IPFS æ–‡ä»¶å“ˆå¸Œ/è·¯å¾„ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯æœ¬åœ°æ–‡ä»¶çš„è·¯å¾„ã€‚

æ³¨æ„ï¼šåœ¨æµ‹è¯•`ipfs.map/ipfs.mapJSON`,æ—¶ï¼Œå¿…é¡»ä»æµ‹è¯•æ–‡ä»¶ä¸­å¯¼å‡ºå›è°ƒå‡½æ•°ï¼Œä»¥ä¾¿matchstckæ£€æµ‹åˆ°å®ƒï¼Œå¦‚ä¸‹é¢æµ‹è¯•ç¤ºä¾‹ä¸­çš„`processGravatar()` å‡½æ•°ï¼š

`.test.ts` file:

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Export ipfs.map() callback in order for matchstick to detect it
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

`utils.ts` file:

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// ipfs.map callback
export function processGravatar(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Callbacks can also created entities
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// function that calls ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### æ–­å®šå­˜å‚¨çš„çŠ¶æ€

ç”¨æˆ·èƒ½å¤Ÿé€šè¿‡æ–­å®šå®ä½“æ–­å®šå­˜å‚¨çš„æœ€ç»ˆï¼ˆæˆ–ä¸­é€”ï¼‰çŠ¶æ€ã€‚ä¸ºæ­¤ï¼Œç”¨æˆ·å¿…é¡»æä¾›å®ä½“ç±»å‹ã€å®ä½“çš„ç‰¹å®šIDã€è¯¥å®ä½“ä¸Šçš„å­—æ®µåç§°ä»¥åŠå­—æ®µçš„é¢„æœŸå€¼ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå¿«é€Ÿç¤ºä¾‹ï¼š

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

æ­£åœ¨è¿è¡Œassert.fieldEquals() å‡½æ•°å°†æ£€æŸ¥ç»™å®šå­—æ®µçš„å‡ç­‰æ€§ä¸ç»™å®šçš„é¢„æœŸå€¼ã€‚ æµ‹è¯•å°†å¤±è´¥ï¼Œå¦‚æœå€¼ä¸º **NOT** åˆ™è¾“å‡ºé”™è¯¯æ¶ˆæ¯ã€‚å¦åˆ™æµ‹è¯•å°†æˆåŠŸé€šè¿‡ã€‚

### ä¸äº‹ä»¶å…ƒæ•°æ®äº¤äº’

ç”¨æˆ·å¯ä»¥ä½¿ç”¨ `newMockEvent()` å‡½æ•°è¿”å›é»˜è®¤çš„äº¤æ˜“å…ƒæ•°æ®ã€‚äº‹ä»¶å¯ä»¥ä½¿ç”¨ `newMockEvent()` å‡½æ•°ã€‚ ä¸‹é¢çš„ç¤ºä¾‹æ˜¾ç¤ºæ‚¨å¦‚ä½•åœ¨äº‹ä»¶å¯¹è±¡ä¸Šè¯»/å†™åˆ°é‚£äº›å­—æ®µï¼š

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### æ–­å®šå˜é‡ç›¸ç­‰

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### æ–­å®šå®ä½“**ä¸**åœ¨å­˜å‚¨ä¸­

ç”¨æˆ·å¯ä»¥æ–­å®šå®ä½“åœ¨å­˜å‚¨ä¸­ä¸å­˜åœ¨ã€‚è¯¥å‡½æ•°æ¥å—å®ä½“ç±»å‹å’Œidã€‚å¦‚æœå®ä½“å®é™…ä¸Šåœ¨å­˜å‚¨ä¸­ï¼Œæµ‹è¯•å°†å¤±è´¥ï¼Œå¹¶æ˜¾ç¤ºç›¸å…³é”™è¯¯æ¶ˆæ¯ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•ä½¿ç”¨æ­¤åŠŸèƒ½çš„å¿«é€Ÿç¤ºä¾‹ï¼š

```typescript
assert.notInStore('Gravatar', '23')
```

### æ‰“å°æ•´ä¸ªå†…å­˜æˆ–å•ä¸ªå®ä½“(ç”¨äºè°ƒè¯•ç›®çš„)

æ‚¨å¯ä»¥ä½¿ç”¨æ­¤åŠ©æ‰‹åŠŸèƒ½å°†æ•´ä¸ªå­˜å‚¨ç™»è½½åˆ°æ§åˆ¶å°ï¼š

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

ä» 0.6.0ç‰ˆæœ¬ `logStore` ä¸å†æ‰“å°æ´¾ç”Ÿå­—æ®µï¼Œè€Œæ˜¯ç”¨æˆ·å¯ä»¥ä½¿ç”¨æ–°çš„ `logEntity` å‡½æ•°ã€‚ å½“ç„¶ï¼Œ`logEntity`å¯ä»¥ç”¨äºæ‰“å°ä»»ä½•å®ä½“ï¼Œè€Œä¸ä»…ä»…æ˜¯æœ‰è¡ç”Ÿå­—æ®µçš„å®ä½“ã€‚ `logEntity` éœ€è¦å®ä½“ç±»å‹ã€å®ä½“IDå’Œä¸€ä¸ª`showRelated`æ ‡å¿—æ¥è¡¨ç¤ºç”¨æˆ·æ˜¯å¦æƒ³æ‰“å°ç›¸å…³æ´¾ç”Ÿå®ä½“ã€‚

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### é¢„æœŸæ•…éšœ

ä½¿ç”¨testï¼ˆï¼‰å‡½æ•°ä¸Šçš„shouldFailæ ‡å¿—ï¼Œç”¨æˆ·å¯èƒ½ä¼šå‡ºç°é¢„æœŸçš„æµ‹è¯•å¤±è´¥ï¼š

```typescript
test(
  'Should throw an error',
  () => {
    throw new Error()
  },
  true,
)
```

å¦‚æœæµ‹è¯•æ ‡è®°ä¸ºshould fail=trueä½†ä¸å¤±è´¥ï¼Œåˆ™å°†åœ¨æ—¥å¿—ä¸­æ˜¾ç¤ºä¸ºé”™è¯¯ï¼Œæµ‹è¯•åŒºå—å°†å¤±è´¥ã€‚æ­¤å¤–ï¼Œå¦‚æœæ ‡è®°ä¸ºshouldFail=falseï¼ˆé»˜è®¤çŠ¶æ€ï¼‰ï¼Œæµ‹è¯•æ‰§è¡Œå™¨å°†å´©æºƒã€‚

### æ—¥å¿—

åœ¨å•å…ƒæµ‹è¯•ä¸­è®°å½•è‡ªå®šä¹‰æ—¥å¿—ä¸åœ¨æ˜ å°„ä¸­è®°å½•å®Œå…¨ç›¸åŒã€‚ä¸åŒä¹‹å¤„åœ¨äºï¼Œæ—¥å¿—å¯¹è±¡éœ€è¦ä»matchstick-as è€Œä¸æ˜¯graph-tså¯¼å…¥ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ‰€æœ‰éå…³é”®æ—¥å¿—ç±»å‹çš„ç®€å•ç¤ºä¾‹ï¼š

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

ç”¨æˆ·è¿˜å¯ä»¥æ¨¡æ‹Ÿä¸¥é‡æ•…éšœï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```typescript
test('Blow everything up', () => {
  log.critical('Boom!')
})
```

è®°å½•å…³é”®é”™è¯¯å°†åœæ­¢æµ‹è¯•çš„æ‰§è¡Œï¼Œå¹¶ä½¿ä¸€åˆ‡å´©æºƒã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬å¸Œæœ›ç¡®ä¿æ‚¨çš„ä»£ç åœ¨éƒ¨ç½²ä¸­æ²¡æœ‰å…³é”®æ—¥å¿—ï¼Œå¦‚æœå‘ç”Ÿè¿™ç§æƒ…å†µï¼Œæ‚¨åº”è¯¥ç«‹å³æ³¨æ„ã€‚

### æµ‹è¯•æ´¾ç”Ÿå­—æ®µ

æµ‹è¯•æ´¾ç”Ÿå­—æ®µæ˜¯ä¸€ä¸ªåŠŸèƒ½ï¼Œç”¨æˆ·å¯ä»¥åœ¨æŸä¸ªå®ä½“ä¸Šè®¾ç½®ä¸€ä¸ªå­—æ®µï¼Œå¦‚æœå®ƒä»ç¬¬ä¸€ä¸ªå®ä½“ä¸­è·å¾—ä¸€ä¸ªå­—æ®µï¼Œåˆ™å¦ä¸€ä¸ªå®ä½“ä¼šè‡ªåŠ¨æ›´æ–°ã€‚

åœ¨ç‰ˆæœ¬ `0.6.0` ä¹‹å‰ï¼Œå¯ä»¥é€šè¿‡ä»¥å®ä½“å­—æ®µ/å±æ€§è®¿é—®å®ƒä»¬æ¥è·å–æ´¾ç”Ÿå®ä½“ï¼Œå°±åƒè¿™æ ·ï¼š

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

æˆªè‡³ç‰ˆæœ¬`0.6'ã€‚ `, é€šè¿‡ä½¿ç”¨graphèŠ‚ç‚¹çš„ `loadRelated` å‡½æ•°æ¥åšåˆ°è¿™ä¸€ç‚¹, æ´¾ç”Ÿçš„å®ä½“å¯ä»¥ä»¥ä¸å¤„ç†å™¨ç›¸åŒçš„æ–¹å¼è®¿é—®ã€‚

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### æµ‹è¯• `loadInBlock`

ä»ç‰ˆæœ¬ `0.6.0` å¼€å§‹ï¼Œç”¨æˆ·å¯ä»¥ä½¿ç”¨ `mockInBlockStore` æµ‹è¯•`loadInBlock` ï¼Œå®ƒå…è®¸åœ¨åŒºå—ç¼“å­˜ä¸­æ¨¡æ‹Ÿå®ä½“ã€‚

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Can use entity.loadInBlock() to retrieve entity from cache store in the current block', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Returns null when calling entity.loadInBlock() if an entity doesn't exist in the current block", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### æµ‹è¯•åŠ¨æ€æ•°æ®æº

å¯ä»¥é€šè¿‡æ¨¡æ‹Ÿæ•°æ®æºå‘½åç©ºé—´çš„`context()`ã€`address()`å’Œ`network()`çš„è¿”å›å€¼æ¥æµ‹è¯•åŠ¨æ€æ•°æ®æºã€‚ è¿™äº›å‡½æ•°ç›®å‰è¿”å›ä»¥ä¸‹å†…å®¹ï¼š`context()` - è¿”å›ä¸€ä¸ªç©ºå®ä½“(DataSourceContext)ã€`address()` - è¿”å› `0x000000000000000000000000`ã€`net()` - è¿”å› `mainnet` ã€‚ `create(...)` å’Œ `createWidext(...)` ä¸¤ä¸ªå‡½æ•°éƒ½è¢«å˜²è®½ï¼Œå®Œå…¨ä¸éœ€è¦åœ¨æµ‹è¯•ä¸­è°ƒç”¨ã€‚ å¯¹è¿”å›å€¼çš„æ›´æ”¹å¯ä»¥é€šè¿‡`matchstick-as`ä¸­çš„`dataSourceMock`å‘½åç©ºé—´çš„å‡½æ•°è¿›è¡Œ(ç‰ˆæœ¬ 0.3.0+)ã€‚

ç¤ºä¾‹å¦‚ä¸‹ï¼š

é¦–å…ˆï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹äº‹ä»¶å¤„ç†ç¨‹åºï¼ˆå®ƒè¢«æœ‰æ„åœ°é‡æ–°ç”¨äºå±•ç¤ºæ¨¡æ‹Ÿæ•°æ®æºï¼‰ï¼š

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨dataSourceMockå‘½åç©ºé—´ä¸­çš„ä¸€ä¸ªæ–¹æ³•è¿›è¡Œæµ‹è¯•ï¼Œä¸ºæ‰€æœ‰dataSourceå‡½æ•°è®¾ç½®ä¸€ä¸ªæ–°è¿”å›å€¼ï¼š

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Data source simple mocking example', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

æ³¨æ„ï¼ŒdataSourceMock.resetValuesï¼ˆï¼‰åœ¨æœ«å°¾è¢«è°ƒç”¨ã€‚è¿™æ˜¯å› ä¸ºå€¼åœ¨æ›´æ”¹æ—¶ä¼šè¢«è®°ä½ï¼Œå¦‚æœè¦è¿”å›åˆ°é»˜è®¤å€¼ï¼Œåˆ™éœ€è¦é‡æ–°è®¾ç½®ã€‚

### æµ‹è¯•åŠ¨æ€æ•°æ®æºåˆ›å»º

ä»ç‰ˆæœ¬ `0.6.0` å¼€å§‹ï¼Œå¯ä»¥æµ‹è¯•æ˜¯å¦ä»æ¨¡æ¿åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„æ•°æ®æºã€‚ æ­¤åŠŸèƒ½æ”¯æŒetherum/contract å’Œ file/ipfs æ¨¡æ¿ã€‚ä¸ºæ­¤æœ‰å››ä¸ªå‡½æ•°ï¼š

- `assert.dataSourceCount(templateNameï¼ŒexpectedCount)` å¯ä»¥ç”¨æ¥ç¡®å®šæŒ‡å®šæ¨¡æ¿ä¸­çš„æ•°æ®æºçš„é¢„æœŸæ•°é‡
- `assert. ataSourceExists(templateName) address/ipfsHash)`å£°ç§°ï¼Œä»ä¸€ä¸ªæŒ‡å®šçš„æ¨¡æ¿åˆ›å»ºäº†å¸¦æœ‰æŒ‡å®šæ ‡è¯†ç¬¦çš„æ•°æ®æº(å¯ä»¥æ˜¯åˆçº¦åœ°å€æˆ–IPFS æ–‡ä»¶å“ˆå¸Œ)
- `logDataSources(templateName)` å°†æŒ‡å®šæ¨¡æ¿ä¸­çš„æ‰€æœ‰æ•°æ®æºæ‰“å°åˆ°æ§åˆ¶å°ä»¥è¿›è¡Œè°ƒè¯•
- `readFile(path)` è¯»å–ä¸€ä¸ª JSON æ–‡ä»¶ï¼Œè¡¨ç¤ºä¸€ä¸ª IPFS æ–‡ä»¶ï¼Œå¹¶è¿”å›å†…å®¹ä¸ºå­—èŠ‚

#### æµ‹è¯•`etherum/contract`æ¨¡æ¿

```typescript
test('ethereum/contract dataSource creation example', () => {
  // Assert there are no dataSources created from GraphTokenLockWallet template
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // Create a new GraphTokenLockWallet datasource with address 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Add a second dataSource with context
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Assert there are now 2 dataSources
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // Assert that a dataSource with address "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" was created
  // Keep in mind that `Address` type is transformed to lower case when decoded, so you have to pass the address as all lower case when asserting if it exists
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### ç¤ºä¾‹ `logDataSource` è¾“å‡º

```bash
ğŸ›   {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
}
```

#### æµ‹è¯•`file/ipfs`æ¨¡æ¿

ç±»ä¼¼äºåˆçº¦åŠ¨æ€æ•°æ®æºï¼Œç”¨æˆ·å¯ä»¥æµ‹è¯•æ–‡ä»¶æ•°æ®æºåŠå…¶å¤„ç†ç¨‹åº

##### ç¤ºä¾‹ `subgraph.yaml`

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### ç¤ºä¾‹ `schema.graphql`

```graphql
"""
Token Lock Wallets which hold locked GRT
"""
type TokenLockMetadata @entity {
  "The address of the token lock wallet"
  id: ID!
  "Start time of the release schedule"
  startTime: BigInt!
  "End time of the release schedule"
  endTime: BigInt!
  "Number of periods between start time and end time"
  periods: BigInt!
  "Time when the releases start"
  releaseStartTime: BigInt!
}
```

##### ç¤ºä¾‹ `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### ç¤ºä¾‹å¤„ç†ç¨‹åºï¼š

```typescript
export function handleMetadata(content: Bytes): void {
  // dataSource.stringParams() returns the File DataSource CID
  // stringParam() will be mocked in the handler test
  // for more info https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Example test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('file/ipfs dataSource creation example', () => {
  // Generate the dataSource CID from the ipfsHash + ipfs path file
  // For example QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // Create a new dataSource using the generated CID
  GraphTokenLockMetadata.create(CID)

  // Assert the dataSource has been created
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Now we have to mock the dataSource metadata and specifically dataSource.stringParam()
  // dataSource.stringParams actually uses the value of dataSource.address(), so we will mock the address using dataSourceMock from  matchstick-as
  // First we will reset the values and then use dataSourceMock.setAddress() to set the CID
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)

  // Now we need to generate the Bytes to pass to the dataSource handler
  // For this case we introduced a new function readFile, that reads a local json and returns the content as Bytes
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Now we will test if a TokenLockMetadata was created
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata!.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata!.startTime, BigInt.fromI32(1))
})
```

## æµ‹è¯•è¦†ç›–ç‡

ä½¿ç”¨**Matchstick**ï¼Œå­å›¾å¼€å‘è€…å¯ä»¥è¿è¡Œä¸€ä¸ªè„šæœ¬ï¼Œè®¡ç®—ç¼–å†™çš„å•å…ƒæµ‹è¯•çš„æµ‹è¯•è¦†ç›–ç‡ã€‚

æµ‹è¯•è¦†ç›–å·¥å…·æ¥å—å·²ç¼–è¯‘çš„æµ‹è¯• `wasm` äºŒè¿›åˆ¶å¹¶å°†å®ƒä»¬è½¬æ¢ä¸º `wat` æ–‡ä»¶ï¼Œ ç„¶åä¾¿äºæ£€æŸ¥ï¼Œçœ‹çœ‹æ˜¯å¦`subgraph.yaml`ä¸­å®šä¹‰çš„å¤„ç†ç¨‹åºå·²è¢«è°ƒç”¨ã€‚ å› ä¸ºä»£ç è¦†ç›–é¢(å’Œæ•´ä¸ªæµ‹è¯•)åœ¨ AssemblyScript å’Œ WebAssembly ä¸­å¤„äºæ—©æœŸé˜¶æ®µï¼Œ**Matchstick** æ— æ³•æ£€æŸ¥åˆ†æ”¯è¦†ç›–é¢ã€‚ ç›¸åï¼Œæˆ‘ä»¬ä¾èµ–çš„æ˜¯è¿™æ ·ä¸€ç§è¯´æ³•ï¼šå¦‚æœä¸€ä¸ªå¤„ç†ç¨‹åºè¢«è°ƒç”¨äº†ï¼Œå®ƒçš„äº‹ä»¶/åŠŸèƒ½å°±è¢«æ°å½“åœ°ä»¿æ•ˆäº†ã€‚

### å…ˆå†³æ¡ä»¶

è¦è¿è¡Œåœ¨ **Matchstick\*** ä¸­æä¾›çš„æµ‹è¯•è¦†ç›–åŠŸèƒ½ï¼Œæ‚¨éœ€è¦äº‹å…ˆå‡†å¤‡å‡ ä»¶äº‹ï¼š

#### å¯¼å‡ºå¤„ç†ç¨‹åº

ä¸ºäº†è®©**Matchstick** æ£€æŸ¥å“ªäº›å¤„ç†ç¨‹åºæ­£åœ¨è¿è¡Œï¼Œè¿™äº›å¤„ç†ç¨‹åºéœ€è¦ä» **æµ‹è¯•æ–‡ä»¶** å¯¼å‡ºã€‚ å› æ­¤ï¼Œä¾‹å¦‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œåœ¨æˆ‘ä»¬çš„gravity.test.tsæ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹å¤„ç†ç¨‹åºè¢«å¯¼å…¥ï¼š

```typescript
import { handleNewGravatar } from '../../src/gravity'
```

ä¸ºäº†è®©è¿™ä¸ªå‡½æ•°å¯è§ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦å¯¼å‡ºå®ƒ(**ä»¥åå­—**å†™å…¥`wat`æ–‡ä»¶)ã€‚ åƒè¿™æ ·ï¼š

```typescript
export { handleNewGravatar }
```

### ä½¿ç”¨æ–¹æ³•

è®¾ç½®å¥½åï¼Œè¦è¿è¡Œæµ‹è¯•è¦†ç›–å·¥å…·ï¼Œåªéœ€è¿è¡Œï¼š

```sh
graph test -- -c
```

ä½ ä¹Ÿå¯ä»¥åœ¨ä½ çš„ `package.json` æ–‡ä»¶ä¸­æ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰çš„ `coverage` å‘½ä»¤ï¼Œå°±åƒè¿™æ ·ï¼š

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

å¸Œæœ›è¿™å¯ä»¥æ¯«æ— é—®é¢˜åœ°æ‰§è¡Œè¦†ç›–å·¥å…·ã€‚æ‚¨åº”è¯¥åœ¨ç»ˆç«¯ä¸­çœ‹åˆ°ç±»ä¼¼çš„å†…å®¹ï¼š

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 ï¸
Reading generated test modules... ğŸ”ï¸

Generating coverage report ğŸ“

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### æ—¥å¿—è¾“å‡ºä¸­çš„æµ‹è¯•è¿è¡ŒæŒç»­æ—¶é—´

æ—¥å¿—è¾“å‡ºåŒ…æ‹¬æµ‹è¯•è¿è¡ŒæŒç»­æ—¶é—´ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š



## å¸¸è§ç¼–è¯‘å™¨é”™è¯¯

> å…³é”®ï¼šæ— æ³•ä»å…·æœ‰èƒŒæ™¯çš„æœ‰æ•ˆæ¨¡å—åˆ›å»ºWasmInstanceï¼šæœªçŸ¥å¯¼å…¥ï¼šwasi_snapshot_preview1:ï¼šå°šæœªå®šä¹‰fd_write

è¿™æ„å‘³ç€æ‚¨åœ¨ä»£ç ä¸­ä½¿ç”¨äº†`console.log`ï¼Œä¸è¢« AssemblyScript æ”¯æŒã€‚è¯·è€ƒè™‘ä½¿ç”¨ [æ—¥å¿—API](/subgraphs/developing/creating/graph-ts/api/#logging-api)ã€‚

> ERROR TS2554: Expected ? arguments, but got ?.
>
> è¿”å›ethereum.Block(defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(18,12)
>
> ERROR TS2554: Expected ? arguments, but got ?.
>
> è¿”å›æ–°ethereum.Transaction(defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt);
>
> in ~lib/matchstick-as/assembly/defaults.ts(24,12)

å‚æ•°ä¸­çš„ä¸åŒ¹é…æ˜¯ç”±`graph-ts`å’Œ`matchstick-as`ä¸­çš„ä¸åŒ¹é…é€ æˆçš„ã€‚ è§£å†³è¿™ç±»é—®é¢˜çš„æœ€ä½³æ–¹æ³•æ˜¯æ›´æ–°æœ€æ–°å‘å¸ƒçš„ç‰ˆæœ¬ã€‚

## å…¶ä»–èµ„æº

å¦‚éœ€ä»»ä½•é¢å¤–æ”¯æŒï¼Œè¯·æŸ¥çœ‹æ­¤[ä½¿ç”¨Matchstickçš„æ¼”ç¤ºå­å›¾ä»“åº“](https://github.com/LimeChain/demo-subgraph#readme_)ã€‚

## åé¦ˆ

å¦‚æœæ‚¨æœ‰ä»»ä½•é—®é¢˜ã€åé¦ˆã€ç‰¹å¾è¯·æ±‚æˆ–åªæ˜¯æƒ³ä¸æˆ‘ä»¬è”ç³»ï¼Œæœ€å¥½çš„åœ°æ–¹æ˜¯ Graph Discordï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä¸“é—¨çš„ Matchstick é¢‘é“ï¼Œåä¸º ğŸ”¥| å•å…ƒæµ‹è¯•ã€‚
