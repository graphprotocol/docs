---
title: 查询最佳实践
---

Graph提供了一种去中心化的方式来查询区块链中的数据。它的数据是通过GraphQL API公开的，这使得使用GraphQL语言进行查询更加容易。

学习基本的 GraphQL 语言规则和最佳做法，以优化您的子图。

---

## 查询GraphQL API

### GraphQL查询的剖析

与REST API不同，GraphQL API构建在定义可以执行哪些查询的模式之上。

例如，使用`token`查询获取代币如下所示：

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

它将返回以下可预测的 JSON 响应(_当传递适当的 $id 变量值时_)：

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQL 查询使用基于[规范](https://spec.graphql.org/)定义的 GraphQL 语言。

上述`GetToken`查询由多语言部分组成(用`[...]`占位符替换)：

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" 代表一个选择集, 我们正在从`queryName`查询域。
    [field]
    [field]
  }
}
```

## 写入 GraphQL 查询规则

- 每个操作只能使用一次`queryName`。
- 每个`字段`必须只能在选择中使用一次 (我们不能在 `token` 下查询`id` 两次)。
- 有些`字段`或查询(如`tokens`)返回了需要选择子字段的复杂类型。 预期时不提供选择(或在不预期时提供选择――例如在`id`上――会引起错误。 要知道一个字段类型，请参阅[Graph Explorer](/subgraphs/explorer/)。
- 分配给参数的任何变量都必须匹配其类型。
- 在给定的变量列表中，每个变量必须是唯一的。
- 必须使用所有已定义的变量。

> 注意：如果不遵循这些规则，将导致从 The Graph API中发生错误。

有关包含代码示例的完整规则列表，请查看[GraphQL Validations guide](/resources/migration-guides/graphql-validations-migration-guide/)。

### 向 GraphQL API 发送查询

GraphQL 是一种通过 HTTP 传输的语言和一组协议。

这意味着您可以使用标准的 `fetch` (nomatily or through `@whatwg-node/fetch` 或 `isomorphic-fetch`)查询一个 GraphQL API。

然而，正如[“查询申请”]（/subgraphs/querying/from-an-application/）中提到的那样，建议使用 `graph-client` ，支持以下独特功能：

- 跨链子图处理: 在一个查询中从多个子图进行查询
- [自动区块跟踪](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [自动分页](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- 完全类型化的结果

以下是如何使用 `Graph-client` 查询The Graph：

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

更多GraphQL客户端替代方案在[“从应用程序查询”](/subgraphs/querying/from-an-application/)中介绍。

---

## 最佳实践

### 始终编写静态查询

一个常见的(不好的) 实践是动态构建查询字符串，如下所示：

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

虽然上面的代码片段产生了一个有效的 GraphQL 查询，但**它有许多缺点** ：

- 它使得**更难理解** 整个查询
- 开发者**负责安全清理字符串内插值**
- 不将变量的值作为请求参数的一部分发送以**防止服务器侧可能缓存**
- 它**阻止工具静态分析查询** (例如: Linter, 或类型代工具)

因此，建议始终将查询写为静态字符串：

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

这样做会带有**许多优点**：

- **易读和维护** 查询
- GraphQL **服务器处理变量净化**
- **变量可以缓存到 **服务器级别
- **查询可以通过工具进行静态分析** (在以下章节中更多关于此问题)

### 如何在静态查询中有条件地包含字段

您可能只想在特定条件下包含 '所有者' 字段。

为此，你可以将`@include(if:...)`的指令应用如下：

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

> 注意： 相反的指令是 `@skip(if: ...)` 。

### 问你所想

GraphQL以其“问你所想”的口号而闻名。

因此，在GraphQL中，不单独列出所有可用字段，就无法获取所有可用字段。

- 在查询GraphQL API时，请始终考虑只查询实际使用的字段。
- 请确保查询仅获取您实际需要的更多实体。 默认情况下，查询将会在集合中获取100个实体，这通常比实际使用的要多得多，如用于显示用户。这不仅适用于查询中的顶层集合，更适用于实体嵌套集合。

例如，在以下查询中：

```graphql
query listTokens {
  tokens {
    # 获取最多100个token
    id
    transactions {
      # 获取最多100个交易
      id
    }
  }
}
```

该响应可以包含每100个代币交易中的100个交易。

如果应用程序只需要10笔交易，查询应在交易字段中明确设置 `first: 10`。

### 使用单个查询请求多个记录

默认情况下，子图表有一个单数实体用于一个记录。对于多个记录，请使用复数实体和过滤器：`其中：{id_in:[X,Y,Z]}`或者`其中： {volume_gt:100000}`。

低效查询示例：

```graphql
query SingleRecord {
  entity(id: X) {
    id
    name
  }
}
query SingleRecord {
  entity(id: Y) {
    id
    name
  }
}
```

优化查询示例：

```graphql
query ManyRecords {
  entities(where: { id_in: [X, Y] }) {
    id
    name
  }
}
```

### Combine multiple queries in a single request

Your application might require querying multiple types of data as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

While this implementation is totally valid, it will require two round trips with the GraphQL API.

Fortunately, it is also valid to send multiple queries in the same GraphQL request as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

This approach will **improve the overall performance** by reducing the time spent on the network (saves you a round trip to the API) and will provide a **more concise implementation**.

### 利用GraphQL片段

A helpful feature to write GraphQL queries is GraphQL Fragment.

Looking at the following query, you will notice that some fields are repeated across multiple Selection-Sets (`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

Such repeated fields (`id`, `active`, `status`) bring many issues:

- More extensive queries become harder to read.
- When using tools that generate TypeScript types based on queries (_more on that in the last section_), `newDelegate` and `oldDelegate` will result in two distinct inline interfaces.

A refactored version of the query would be the following:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# 我们在代码转换器定义了一个碎片（子类型）
# 将查询中重复的域分解
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

Using GraphQL `fragment` will improve readability (especially at scale) and result in better TypeScript types generation.

When using the types generation tool, the above query will generate a proper `DelegateItemFragment` type (_see last "Tools" section_).

### GraphQL片段的注意事项

### 片段必须是一种类型

A Fragment cannot be based on a non-applicable type, in short, **on type not having fields**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` is a **scalar** (native "plain" type) that cannot be used as a fragment's base.

#### 如何传播片段

Fragments are defined on specific types and should be used accordingly in queries.

例子:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` and `oldDelegate` are of type `Transcoder`.

It is not possible to spread a fragment of type `Vote` here.

#### 将片段定义为数据的原子业务单元。

GraphQL `Fragment`s must be defined based on their usage.

For most use-case, defining one fragment per type (in the case of repeated fields usage or type generation) is sufficient.

Here is a rule of thumb for using fragments:

- When fields of the same type are repeated in a query, group them in a `Fragment`.
- When similar but different fields are repeated, create multiple fragments, for instance:

```graphql
# base fragment (主要在上架中使用)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (当查询投票中一个选项的细节)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The Essential Tools

### GraphQL基于web的浏览器

Iterating over queries by running them in your application can be cumbersome. For this reason, don't hesitate to use [Graph Explorer](https://thegraph.com/explorer) to test your queries before adding them to your application. Graph Explorer will provide you a preconfigured GraphQL playground to test your queries.

If you are looking for a more flexible way to debug/test your queries, other similar web-based tools are available such as [Altair](https://altairgraphql.dev/) and [GraphiQL](https://graphiql-online.com/graphiql).

### GraphQL Linting

In order to keep up with the mentioned above best practices and syntactic rules, it is highly recommended to use the following workflow and IDE tools.

**GraphQL ESLint**

[GraphQL ESLint](https://the-guild.dev/graphql/eslint/docs/getting-started) will help you stay on top of GraphQL best practices with zero effort.

[Setup the "operations-recommended"](https://the-guild.dev/graphql/eslint/docs/configs) config will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: should a given variable stay unused?
- 还有更多！

This will allow you to **catch errors without even testing queries** on the playground or running them in production!

### IDE插件

**VSCode and GraphQL**

The [GraphQL VSCode extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) is an excellent addition to your development workflow to get:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets
- Go to definition for fragments and input types

If you are using `graphql-eslint`, the [ESLint VSCode extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) is a must-have to visualize errors and warnings inlined in your code correctly.

**WebStorm/Intellij and GraphQL**

The [JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-graphql/) will significantly improve your experience while working with GraphQL by providing:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets

For more information on this topic, check out the [WebStorm article](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) which showcases all the plugin's main features.
