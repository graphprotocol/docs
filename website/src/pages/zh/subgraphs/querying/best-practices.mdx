---
title: 查询最佳实践
---

Use The Graph's GraphQL API to query [Subgraph](/subgraphs/developing/subgraphs/) data efficiently. This guide outlines essential GraphQL rules, guides, and best practices to help you write optimized, reliable queries.

---

## 查询GraphQL API

### GraphQL查询的剖析

> GraphQL queries use the GraphQL language, which is defined in the [GraphQL specification](https://spec.graphql.org/).

Unlike REST APIs, GraphQL APIs are built on a schema-driven design that defines which queries can be performed.

Here's a typical query to fetch a `token`:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

which will return a predictable JSON response (when passing the proper `$id` variable value):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

上述`GetToken`查询由多语言部分组成(用`[...]`占位符替换)：

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" 代表一个选择集, 我们正在从`queryName`查询域。
    [field]
    [field]
  }
}
```

### 写入 GraphQL 查询规则

> Important: Failing to follow these rules will result in an error from The Graph API.

1. 每个操作只能使用一次`queryName`。
2. Each `field` must be used only once in a selection (you cannot query `id` twice under `token`).
3. Complex types require a selection of sub-fields.
   - For example, some `fields' or queries (like `tokens`) return complex types which will require a selection of sub-fields. Not providing a selection when expected or providing one when not expected will raise an error, such as `id\`. To know a field type, please refer to [Graph Explorer](/subgraphs/explorer/).
4. 分配给参数的任何变量都必须匹配其类型。
5. Variables must be uniquely defined and used.

**For a complete list of rules with code examples, check out the [GraphQL Validations guide](/resources/migration-guides/graphql-validations-migration-guide/)**.

### How to Send a Query to a GraphQL API

[GraphQL is a query language](https://graphql.org/learn/) and a set of conventions for APIs, typically used over HTTP to request and send data between clients and servers. This means that you can query a GraphQL API using standard `fetch` (natively or via `@whatwg-node/fetch` or `isomorphic-fetch`).

However, as recommended in [Querying from an Application](/subgraphs/querying/from-an-application/), it's best to use `graph-client`, which supports the following unique features:

- 跨链子图处理: 在一个查询中从多个子图进行查询
- [自动区块跟踪](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [自动分页](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- 完全类型化的结果

Example query using `graph-client`:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

For more alternatives, see ["Querying from an Application"](/subgraphs/querying/from-an-application/).

---

## 最佳实践

### 1. Always Write Static Queries

A common bad practice is to dynamically build a query string as follows:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

While the example above produces a valid GraphQL query, it comes with several issues:

- The full query is harder to understand.
- Developers are responsible for safely sanitizing the string interpolation.
- Not sending the values of the variables as part of the request can block server-side caching.
- It prevents tools from statically analyzing the query (e.g.linters or type generation tools).

Instead, it's recommended to **always write queries as static strings**.

Example of static string:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

Static strings have several **key advantages**:

- Queries are easier to read, manage, and debug.
- Variable sanitization is handled by the GraphQL server.
- Variables can be cached at the server level.
- Queries can be statically analyzed by tools (see [GraphQL Essential Tools](/subgraphs/querying/best-practices/#graphql-essential-tools-guides)).

### 2. Include Fields Conditionally in Static Queries

Including fields in static queries only for a particular condition improves performance and keeps responses lightweight by fetching only the necessary data when it's relevant.

- The `@include(if:...)` directive tells the query to **include** a specific field only if the given condition is true.
- The `@skip(if: ...)` directive tells the query to **exclude** a specific field if the given condition is true.

Example using `owner` field with `@include(if:...)` directive:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

### 3. Ask Only For What You Want

GraphQL is known for its "Ask for what you want” tagline, which is why it requires explicitly listing each field you want. There's no built-in way to fetch all available fields automatically.

- When querying GraphQL APIs, always think of querying only the fields that will actually be used.
- 请确保查询仅获取您实际需要的更多实体。 默认情况下，查询将会在集合中获取100个实体，这通常比实际使用的要多得多，如用于显示用户。这不仅适用于查询中的顶层集合，更适用于实体嵌套集合。

例如，在以下查询中：

```graphql
query listTokens {
  tokens {
    # 获取最多100个token
    id
    transactions {
      # 获取最多100个交易
      id
    }
  }
}
```

该响应可以包含每100个代币交易中的100个交易。

If the application only needs 10 transactions, the query should explicitly set **`first: 10`** on the transactions field.

### 4. Use a Single Query to Request Multiple Records

默认情况下，子图表有一个单数实体用于一个记录。对于多个记录，请使用复数实体和过滤器：`其中：{id_in:[X,Y,Z]}`或者`其中： {volume_gt:100000}`。

低效查询示例：

```graphql
query SingleRecord {
  entity(id: X) {
    id
    name
  }
}
query SingleRecord {
  entity(id: Y) {
    id
    name
  }
}
```

优化查询示例：

```graphql
query ManyRecords {
  entities(where: { id_in: [X, Y] }) {
    id
    name
  }
}
```

### 5. Combine Multiple Queries in a Single Request

您的应用程序可能需要查询多种类型的数据，如下所示：

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

While this implementation is valid, it will require two round trips with the GraphQL API.

It's best to send multiple queries in the same GraphQL request as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

Sending multiple queries in the same GraphQL request **improves the overall performance** by reducing the time spent on the network (saves you a round trip to the API) and provides a **more concise implementation**.

### 6. Leverage GraphQL Fragments

编写GraphQL查询的一个有用功能是GraphQL片段。

查看以下查询，您会注意到某些字段在多个选择集(`{ ... }`) 中重复：

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

此类重复字段（`id`, `active`, `status`）会带来许多问题：

- 更广泛的查询变得更难阅读。
- 当使用基于查询生成类型的 TypeScript 类型的工具 (_more on that in the last section_), `newDelegate`和`oldDelegate`将导致两个不同的内联接口。

An optimized version of the query would be the following:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# 我们在代码转换器定义了一个碎片（子类型）
# 将查询中重复的域分解
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

Using a GraphQL `fragment` improves readability (especially at scale) and results in better TypeScript types generation.

当使用类型生成工具时，上面的查询将生成一个适当的`DelegateItemFragment` 类型(_see last "Tools" section _)。

## GraphQL Fragment Guidelines

### Dos and Don'ts for Fragments

1. Fragments cannot be based on non-applicable types (types without fields).
2. `BigInt` cannot be used as a fragment's base because it's a **scalar** (native "plain" type).

例子:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

3. Fragments belong to specific types and must be used with those same types in queries.
4. Spread only fragments matching the correct type.

例子:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

- `newDelegate` and `oldDelegate` are of type `Transcoder`. It's not possible to spread a fragment of type `Vote` here.

5. Fragments must be defined based on their specific usage.
6. Define fragments as an atomic business unit of data.

---

### How to Define `Fragment` as an Atomic Business Unit of Data

> For most use-cases, defining one fragment per type (in the case of repeated fields usage or type generation) is enough.

Here is a rule of thumb for using fragments:

- When fields of the same type are repeated in a query, group them in a `Fragment`.
- When similar but different fields are repeated, create multiple fragments.

例子:

```graphql
# base fragment (主要在上架中使用)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (当查询投票中一个选项的细节)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## GraphQL Essential Tools Guides

### Test Queries with Graph Explorer

Before integrating GraphQL queries into your dapp, it's best to test them. Instead of running them directly in your app, use a web-based playground.

Start with [Graph Explorer](https://thegraph.com/explorer), a preconfigured GraphQL playground built specifically for Subgraphs. You can experiment with queries and see the structure of the data returned without writing any frontend code.

If you want alternatives to debug/test your queries, check out other similar web-based tools:

- [GraphiQL](https://graphiql-online.com/graphiql)
- [Altair](https://altairgraphql.dev/)

### Setting up Workflow and IDE Tools

In order to keep up with querying best practices and syntax rules, use the following workflow and IDE tools.

#### GraphQL ESLint

1. Install GraphQL ESLint

Use [GraphQL ESLint](https://the-guild.dev/graphql/eslint/docs/getting-started) to enforce best practices and syntax rules with zero effort.

2. Use the ["operations-recommended"](https://the-guild.dev/graphql/eslint/docs/configs) config

This will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: Ensures fields match the proper type.
- `@graphql-eslint/no-unused variables`: Flags unused variables in your queries.

Result: You'll **catch errors without even testing queries** on the playground or running them in production!

#### Use IDE plugins

GraphQL plugins streamline your workflow by offering real-time feedback while you code. They highlight mistakes, suggest completions, and help you explore your schema faster.

1. VS Code

Install the [GraphQL VS Code extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) to unlock:

- 语法高亮
- 自动完成建议
- 针对模式的验证
- 代码片段
- 转到片段和输入类型的定义

If you are using `graphql-eslint`, use the [ESLint VS Code extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) to visualize errors and warnings inlined in your code correctly.

2. WebStorm/Intellij and GraphQL

Install the [JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-graphql/). It significantly improves the experience of working with GraphQL by providing:

- 语法高亮
- 自动完成建议
- 针对模式的验证
- 代码片段

了解更多关于此主题的信息，请查阅[WebStorm 文章](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/)，该插件的所有主要功能。
