---
title: Indexing का अवलोकन
sidebarTitle: Overview
---

Indexers, The Graph Network में node operators होते हैं जो Graph Tokens (GRT) stake करके indexing और query processing services प्रदान करते हैं। वे अपनी सेवाओं के लिए query fees और indexing rewards अर्जित करते हैं। इसके अलावा, उन्हें query fees भी मिलती हैं, जो एक exponential rebate function के अनुसार rebate की जाती हैं।

जीआरटी जो प्रोटोकॉल में दांव पर लगा है, विगलन अवधि के अधीन है और यदि अनुक्रमणिका दुर्भावनापूर्ण हैं और अनुप्रयोगों को गलत डेटा प्रदान करते हैं या यदि वे गलत तरीके से अनुक्रमणित करते हैं तो इसे घटाया जा सकता है। इंडेक्सर्स नेटवर्क में योगदान करने के लिए डेलीगेटर्स से प्रत्यायोजित हिस्सेदारी के लिए पुरस्कार भी अर्जित करते हैं।

Indexers किसी सबग्राफ के curation signal के आधार पर उसे चुनते हैं, जहाँ Curators GRT को स्टेक करते हैं ताकि यह संकेत दिया जा सके कि कौन से Subgraph उच्च-गुणवत्ता वाले हैं और प्राथमिकता दी जानी चाहिए। Consumers (जैसे कि applications) यह भी निर्धारित कर सकते हैं कि कौन से Indexers उनके सबग्राफ के लिए queries को प्रोसेस करें और query fee pricing के लिए अपनी प्राथमिकताएँ सेट कर सकते हैं।

## FAQ

### नेटवर्क पर Indexer बनने के लिए न्यूनतम स्टेक कितना आवश्यक है?

Indexer के लिए न्यूनतम स्टेक वर्तमान में 100K GRT निर्धारित है।

### एक Indexer के लिए राजस्व स्रोत क्या हैं?

**पूछताछ शुल्क rebates** - नेटवर्क पर क्वेरी सर्व करने के लिए किए गए भुगतान। ये भुगतान एक Indexer और एक गेटवे के बीच स्टेट चैनलों के माध्यम से संचालित होते हैं। गेटवे से प्रत्येक क्वेरी अनुरोध में एक भुगतान शामिल होता है और संबंधित प्रतिक्रिया में क्वेरी परिणाम की वैधता का प्रमाण होता है।

**indexing रिवार्ड्स** - 3% वार्षिक प्रोटोकॉल-वाइड मुद्रास्फीति के माध्यम से उत्पन्न, indexing रिवार्ड्स उन Indexers को वितरित किए जाते हैं जो नेटवर्क के लिए सबग्राफ डिप्लॉयमेंट को इंडेक्स कर रहे हैं।

### Indexing इनाम कैसे वितरित किए जाते हैं?

Indexing rewards प्रोटोकॉल मुद्रास्फीति से आते हैं, जो 3% वार्षिक जारी करने के लिए सेट किया गया है। इन्हें सभी सबग्राफ पर कुल क्यूरेशन सिग्नल के अनुपात के आधार पर वितरित किया जाता है, और फिर Indexers को उनके द्वारा उस सबग्राफ पर आवंटित स्टेक के अनुपात में वितरित किया जाता है। **एक आवंटन को मान्य प्रूफ ऑफ Indexing (POI) के साथ बंद किया जाना चाहिए, जो मध्यस्थता चार्टर द्वारा निर्धारित मानकों को पूरा करता हो, ताकि इसे पुरस्कारों के लिए योग्य माना जा सके।**

समुदाय द्वारा कई उपकरण बनाए गए हैं जो इनाम की गणना करने में मदद करते हैं; आपको इनका संग्रह [Community Guides collection](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c) में संगठित रूप में मिलेगा। आप #Delegators और #Indexers चैनलों में भी उपकरणों की एक अद्यतन सूची [Discord server](https://discord.gg/graphprotocol) पर पा सकते हैं। यहाँ हम एक [recommended allocation optimiser](https://github.com/graphprotocol/allocation-optimizer) को लिंक कर रहे हैं जो indexer software stack के साथ एकीकृत है।

### Indexing का प्रमाण (POI) क्या है?

POIs का उपयोग नेटवर्क में यह सत्यापित करने के लिए किया जाता है कि कोई Indexer उन सबग्राफ को Indexing कर रहा है जिन पर उन्होंने आवंटन किया है। जब किसी आवंटन को बंद किया जाता है, तो वर्तमान युग के पहले ब्लॉक के लिए एक POI प्रस्तुत करना आवश्यक होता है ताकि वह आवंटन Indexing पुरस्कारों के लिए पात्र हो सके। किसी ब्लॉक के लिए POI उस ब्लॉक तक और उसमें शामिल सभी entity store लेनदेन के लिए एक डाइजेस्ट होता है, जो एक विशिष्ट Subgraph परिनियोजन के लिए होता है।

### indexing पुरस्कार कब वितरित किए जाते हैं?

आवंटन सक्रिय रहते हुए और 28 युगों के भीतर आवंटित होने पर लगातार इनाम अर्जित करते रहते हैं। इनाम Indexers द्वारा एकत्र किए जाते हैं और तब वितरित किए जाते हैं जब उनके आवंटन बंद हो जाते हैं। यह या तो मैन्युअल रूप से होता है, जब भी Indexer उन्हें बलपूर्वक बंद करना चाहता है, या 28 युगों के बाद एक Delegator Indexer के लिए आवंटन बंद कर सकता है, लेकिन इससे कोई इनाम नहीं मिलता। 28 युग अधिकतम आवंटन अवधि है (फिलहाल, एक युग लगभग ~24 घंटे तक चलता है)।

### क्या लंबित indexing पुरस्कारों की निगरानी की जा सकती है?

RewardsManager contract में एक केवल-पढ़ने योग्य [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316) फ़ंक्शन है, जिसका उपयोग किसी विशिष्ट आवंटन के लिए लंबित इनाम की जाँच करने के लिए किया जा सकता है।

कई समुदाय द्वारा बनाए गए डैशबोर्ड में पेंडिंग रिवॉर्ड्स के मान होते हैं और इन्हें मैन्युअल रूप से निम्नलिखित कदमों का पालन करके आसानी से चेक किया जा सकता है:

1. [mainnet सबग्राफ](https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one) को क्वेरी करें ताकि सभी सक्रिय आवंटनों के लिए ID प्राप्त की जा सके।

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Etherscan का उपयोग करके `getRewards()` कॉल करें:

- [ईथरस्कैन इंटरफेस पर रिवॉर्ड्स contract](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract) पर जाएं।
- `getRewards()` को कॉल करने के लिए:
  - **9. getRewards** ड्रॉपडाउन का विस्तार करें।
  - इनपुट में **allocationID** दर्ज करें।
  - कृपया **Query** बटन पर क्लिक करें।

### क्या होते हैं और मैं उन्हें कहाँ देख सकता हूँ?

Indexers की queries और आवंटन दोनों को The Graph में विवाद अवधि के दौरान विवादित किया जा सकता है। विवाद अवधि विवाद के प्रकार के अनुसार भिन्न होती है। Queries/अभिप्रमाणन के लिए 7 अवधियों को विवाद विंडो होती है, जबकि आवंटन के लिए 56 युगों की अवधि होती है। इन अवधियों के बीतने के बाद, आवंटन या queries के खिलाफ कोई विवाद नहीं खोला जा सकता। जब कोई विवाद खोला जाता है, तो Fishermen को न्यूनतम 10,000 GRT की जमा राशि की आवश्यकता होती है, जिसे विवाद के अंतिम निर्णय और समाधान दिए जाने तक लॉक कर दिया जाता है। Fishermen वे नेटवर्क प्रतिभागी होते हैं जो विवाद खोलते हैं।

विवादों के **तीन** संभावित परिणाम होते हैं, और मछुआरों की जमा राशि भी।

- यदि विवाद अस्वीकार कर दिया जाता है, तो फ़िशरमैन द्वारा जमा किया गया GRT नष्ट कर दिया जाएगा, और विवादित Indexer पर कोई दंड नहीं लगाया जाएगा।
- यदि विवाद ड्रा के रूप में निपटाया जाता है, तो मछुआरों की जमा राशि वापस कर दी जाएगी, और विवादित Indexer पर कोई दंड नहीं लगाया जाएगा।
- यदि विवाद स्वीकार कर लिया जाता है, तो मछुआरों द्वारा जमा किया गया GRT वापस कर दिया जाएगा, विवादित Indexer को दंडित किया जाएगा, और मछुआरों को दंडित किए गए GRT का 50% मिलेगा।

विवादों को UI में एक Indexer's प्रोफ़ाइल पृष्ठ पर Disputes टैब के अंतर्गत देखा जा सकता है।

### पूछताछ शुल्क रिबेट्स क्या हैं और वे कब वितरित किए जाते हैं?

पूछताछ शुल्क गेटवे द्वारा एकत्र किए जाते हैं और Indexers को घातांकीय छूट फ़ंक्शन के अनुसार वितरित किए जाते हैं (देखें GIP [यहाँ](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162))। घातांकीय छूट फ़ंक्शन को यह सुनिश्चित करने के तरीके के रूप में प्रस्तावित किया गया है कि Indexers queries की सही सेवा करके सर्वोत्तम परिणाम प्राप्त करें। यह Indexers को एक बड़ी मात्रा में स्टेक आवंटित करने के लिए प्रोत्साहित करके काम करता है (जो किसी queries की सेवा करते समय गलती करने पर स्लैश किया जा सकता है) जो वे एकत्र कर सकने वाली पूछताछ शुल्क की मात्रा के सापेक्ष होती है।

एक बार आवंटन बंद हो जाने के बाद, रिबेट्स को Indexer द्वारा क्लेम किया जा सकता है। क्लेम करने पर, पूछताछ शुल्क रिबेट्स को Indexer और उनके Delegators के बीच पूछताछ शुल्क कट और घातीय रिबेट फ़ंक्शन के आधार पर वितरित किया जाता है।

### पूछताछ शुल्क कटौती और indexing पुरस्कार कटौती क्या हैं?

`queryFeeCut` और `indexingRewardCut` मान delegation पैरामीटर हैं, जिन्हें Indexer cooldownBlocks के साथ सेट कर सकता है ताकि Indexer और उनके Delegators के बीच GRT के वितरण को नियंत्रित किया जा सके। Delegation पैरामीटर सेट करने के निर्देशों के लिए [Staking in the Protocol](/indexing/overview/#stake-in-the-protocol) के अंतिम चरण देखें।

- **queryFeeCut** - वह % जो पूछताछ शुल्क रिबेट्स में से Indexer को वितरित किया जाएगा। यदि इसे 95% पर सेट किया गया है, तो जब एक एलोकेशन बंद होगी, तो Indexer को अर्जित किए गए पूछताछ शुल्क का 95% प्राप्त होगा, और शेष 5% Delegators को जाएगा।

- **indexingRewardCut** - वह % जो Indexing पुरस्कारों में से Indexer को वितरित किया जाएगा। यदि इसे 95% पर सेट किया जाता है, तो जब कोई आवंटन बंद होता है, तो Indexer को Indexing पुरस्कारों का 95% प्राप्त होगा और Delegators शेष 5% को साझा करेंगे।

### Indexers को कैसे पता चलता है कि कौन से सबग्राफ को index करना है?

Indexers उन्नत तकनीकों को लागू करके सबग्राफ indexing निर्णय लेने में खुद को अलग कर सकते हैं, लेकिन सामान्य विचार देने के लिए, हम नेटवर्क में सबग्राफ का मूल्यांकन करने के लिए उपयोग की जाने वाली कुछ प्रमुख मीट्रिक्स पर चर्चा करेंगे:

- **Curation signal** - किसी विशेष Subgraph पर लागू किए गए नेटवर्क curation signal का अनुपात उस Subgraph में रुचि का एक अच्छा संकेतक होता है, विशेष रूप से प्रारंभिक चरण में जब क्वेरी वॉल्यूम बढ़ रहा होता है।

- **क्वेरी फीस संग्रहित **- किसी विशेष सबग्राफ के लिए संग्रहित क्वेरी फीस की ऐतिहासिक डेटा भविष्य की मांग का एक अच्छा संकेतक है।

- **राशि दांव पर लगी हुई** - अन्य Indexers के व्यवहार की निगरानी करना या कुल दांव का विशिष्ट सबग्राफ की ओर आवंटित अनुपात देखना, एक Indexer को सबग्राफ क्वेरी के लिए आपूर्ति पक्ष की निगरानी करने में मदद कर सकता है। इससे वे उन सबग्राफ की पहचान कर सकते हैं जिनमें नेटवर्क आत्मविश्वास दिखा रहा है या ऐसे सबग्राफ जिनमें अधिक आपूर्ति की आवश्यकता हो सकती है।

- **Subgraph जिनके लिए कोई indexing रिवार्ड नहीं है -**कुछ सबग्राफ को indexing इनाम नहीं मिलते हैं, मुख्य रूप से इसलिए क्योंकि वे असमर्थित सुविधाओं जैसे कि IPFS का उपयोग कर रहे हैं या वे मुख्य नेटवर्क के बाहर किसी अन्य नेटवर्क से क्वेरी कर रहे हैं। यदि कोई सबग्राफ indexing इनाम उत्पन्न नहीं कर रहा है, तो आपको उस पर एक संदेश दिखाई देगा।

### हार्डवेयर आवश्यकताएँ क्या हैं?

- **छोटा** - शुरुआत में कुछ सबग्राफ को index करने के लिए पर्याप्त, लेकिन संभवतः विस्तार करने की आवश्यकता होगी।
- **स्टैंडर्ड **- डिफ़ॉल्ट सेटअप, यह वही है जो उदाहरण k8s/terraform परिनियोजन मैनिफेस्ट में उपयोग किया जाता है।
- **मध्यम**- एक प्रोडक्शन Indexer जो 100 सबग्राफ को सपोर्ट करता है और 200-500 अनुरोध प्रति सेकंड प्रोसेस करता है।
- **बड़ा **- वर्तमान में उपयोग किए जा रहे सभी सबग्राफ को इंडेक्स करने और संबंधित ट्रैफ़िक के लिए अनुरोधों को सर्व करने के लिए तैयार।

| सेटअप | Postgres<br />(CPUs) | Postgres<br />(मेमोरी in GBs) | Postgres<br />(डिस्क in TBs) | VMs<br />(CPUs) | VMs<br />(मेमोरी in GBs) |
| --- | :-: | :-: | :-: | :-: | :-: |
| छोटा | 4 | 8 | 1 | 4 | 16 |
| मानक | 8 | 30 | 1 | 12 | 48 |
| मध्यम | 16 | 64 | 2 | 32 | 64 |
| बड़ा | 72 | 468 | 3.5 | 48 | 184 |

### कोई Indexer को कौन-कौन सी बुनियादी सुरक्षा सावधानियाँ बरतनी चाहिए?

- **ऑपरेटर वॉलेट** - एक ऑपरेटर वॉलेट सेट अप करना एक महत्वपूर्ण एहतियात है क्योंकि यह एक Indexer को अपने उन कुंजियों के बीच अलगाव बनाए रखने की अनुमति देता है जो स्टेक को नियंत्रित करती हैं और वे जो दिन-प्रतिदिन के संचालन के नियंत्रण में होती हैं। निर्देशों के लिए (Stake in Protocol](/indexing/overview/#stake-in-the-protocol) देखें।

- **Firewall**- केवल Indexer सेवा को सार्वजनिक रूप से एक्सपोज़ किया जाना चाहिए और विशेष ध्यान एडमिन पोर्ट्स और डेटाबेस एक्सेस को लॉक करने पर दिया जाना चाहिए: Graph Node JSON-RPC एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 8030), Indexer प्रबंधन API एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 18000), और Postgres डेटाबेस एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 5432) को एक्सपोज़ नहीं किया जाना चाहिए।

## इंफ्रास्ट्रक्चर

Indexer के इंफ्रास्ट्रक्चर के केंद्र में Graph Node होता है, जो इंडेक्स किए गए नेटवर्क की निगरानी करता है, डेटा को सबग्राफ परिभाषा के अनुसार निकालता और लोड करता है, और इसे एक [GraphQL API](/about/#how-the-graph-works) के रूप में सर्व करता है। Graph Node को प्रत्येक इंडेक्स किए गए नेटवर्क से डेटा एक्सपोज़ करने वाले एक एंडपॉइंट से कनेक्ट करने की आवश्यकता होती है; डेटा स्रोत करने के लिए एक IPFS नोड; अपने स्टोर के लिए एक PostgreSQL डेटाबेस; और Indexer घटकों से, जो इसे नेटवर्क के साथ इंटरैक्शन की सुविधा प्रदान करते हैं।

- **PostgreSQL डेटाबेस** - यह Graph Node के लिए मुख्य स्टोर है, जहाँ Subgraph डेटा संग्रहीत किया जाता है। Indexer सेवा और एजेंट भी इस डेटाबेस का उपयोग state channel डेटा, cost models, Indexing नियमों और allocation क्रियाओं को संग्रहीत करने के लिए करते हैं।

- **डेटा एंडपॉइंट** - EVM-संगत नेटवर्क्स के लिए, Graph Node को एक ऐसे एंडपॉइंट से कनेक्ट करने की आवश्यकता होती है जो EVM-संगत JSON-RPC API को एक्सपोज़ करता हो। यह एक सिंगल क्लाइंट के रूप में हो सकता है या यह एक अधिक जटिल सेटअप हो सकता है जो मल्टीपल क्लाइंट्स के बीच लोड बैलेंस करता हो। यह जानना महत्वपूर्ण है कि कुछ सबग्राफ को विशेष क्लाइंट क्षमताओं की आवश्यकता हो सकती है, जैसे कि आर्काइव मोड और/या पैरिटी ट्रेसिंग API।

- **IPFS node (संस्करण 5 से कम)** - सबग्राफ डिप्लॉयमेंट मेटाडेटा IPFS नेटवर्क पर स्टोर किया जाता है। The Graph Node मुख्य रूप से सबग्राफ डिप्लॉयमेंट के दौरान IPFS node तक पहुंचता है ताकि सबग्राफ मैनिफेस्ट और सभी लिंक की गई फ़ाइलों को प्राप्त किया जा सके। नेटवर्क Indexers को अपना स्वयं का IPFS node होस्ट करने की आवश्यकता नहीं है, नेटवर्क के लिए एक IPFS node होस्ट किया गया है: https://ipfs.thegraph.com.

- **Indexer सेवा** - आवश्यक बाहरी संचार को नेटवर्क के साथ संभालती है। लागत मॉडल और इंडेक्सिंग स्थितियों को साझा करती है, गेटवे से आने वाले क्वेरी अनुरोधों को एक Graph Node तक पहुंचाती है, और गेटवे के साथ स्टेट चैनलों के माध्यम से क्वेरी भुगतान को प्रबंधित करती है।

- **Indexer agent** - ऑनचेन पर Indexers की इंटरैक्शन को सुविधाजनक बनाता है, जिसमें नेटवर्क पर पंजीकरण करना, अपने ग्राफ-नोड पर सबग्राफ परिनियोजन का प्रबंधन करना और आवंटनों का प्रबंधन करना शामिल है।

- **Prometheus मेट्रिक्स सर्वर** - The Graph Node और Indexer घटक अपने मेट्रिक्स को मेट्रिक्स सर्वर में लॉग करते हैं।

कृपया ध्यान दें: चुस्त स्केलिंग का समर्थन करने के लिए, यह अनुशंसा की जाती है कि क्वेरी और indexing संबंधी चिंताओं को विभिन्न सेट के नोड्स के बीच विभाजित किया जाए: क्वेरी नोड्स और इंडेक्स नोड्स।

### पोर्ट्स का अवलोकन

> **महत्वपूर्ण**: पोर्ट्स को सार्वजनिक रूप से एक्सपोज़ करने में सावधानी बरतें - **प्रशासनिक पोर्ट्स** को सुरक्षित रखा जाना चाहिए। इसमें नीचे दिए गए Graph Node JSON-RPC और Indexer प्रबंधन एंडपॉइंट्स शामिल हैं।

#### Graph Node

| पोर्ट | उद्देश्य | रूट्स | आर्गुमेंट्स | पर्यावरण वेरिएबल्स |
| --- | --- | --- | --- | --- |
| 8000 | GraphQL HTTP server<br />(for Subgraph queries) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port | - |
| 8001 | GraphQL WS<br />(for सबग्राफ subscriptions) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port | - |
| 8020 | JSON-RPC<br />(for managing deployments) | / | \--admin-port | - |
| 8030 | Subgraph indexing status API | /graphql | \--index-node-port | - |
| 8040 | Prometheus मेट्रिक्स | /metrics | \--metrics-port | - |

#### Indexer सेवा

| पोर्ट | उद्देश्य | Routes | CLI Argument | Environment Variable |
| --- | --- | --- | --- | --- |
| 7600 | GraphQL HTTP server<br />(भुगतान किए गए सबग्राफ क्वेरीज़ के लिए) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port | `INDEXER_SERVICE_PORT` |
| 7300 | Prometheus मेट्रिक्स | /metrics | \--metrics-port | - |

#### Indexer एजेंट

| पोर्ट | उद्देश्य            | Routes | CLI Argument               | Environment Variable                    |
| ----- | ------------------- | ------ | -------------------------- | --------------------------------------- |
| 8000  | Indexer प्रबंधन API | /      | \--indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Google Cloud पर Terraform का उपयोग करके सर्वर अवसंरचना सेटअप करें

> Indexers वैकल्पिक रूप से AWS, Microsoft Azure, या Alibaba का उपयोग कर सकते हैं।

#### आवश्यक पूर्वापेक्षाएँ स्थापित करें

- Google Cloud SDK
- Kubectl कमांड लाइन टूल
- Terraform

#### Google Cloud प्रोजेक्ट बनाएं

- Clone करें या [Indexer repository](https://github.com/graphprotocol/indexer) पर जाएं।

- `./terraform` डायरेक्टरी पर जाएं, यही वह स्थान है जहां सभी कमांड निष्पादित की जानी चाहिए।

```sh
cd terraform
```

- Google Cloud के साथ प्रमाणीकृत करें और एक नया प्रोजेक्ट बनाएं।

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Google Cloud Console के बिलिंग पेज का उपयोग करके नए प्रोजेक्ट के लिए बिलिंग सक्षम करें।

- Google Cloud कॉन्फ़िगरेशन बनाएँ।

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- आवश्यक Google Cloud APIs सक्षम करें।

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- सर्विस अकाउंट बनाएं।

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- डाटाबेस और Kubernetes क्लस्टर के बीच peering सक्षम करें, जो अगले चरण में बनाया जाएगा।

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- न्यूनतम Terraform कॉन्फ़िगरेशन फ़ाइल बनाएँ (आवश्यकतानुसार अपडेट करें)।

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database password>"
EOF
```

#### टेराफॉर्म का उपयोग करके इंफ्रास्ट्रक्चर बनाएं

[variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) फ़ाइल को पढ़ने के बाद, इस डायरेक्टरी में terraform.tfvars नाम की एक फ़ाइल बनाएँ (या पिछली स्टेप में बनाई गई फ़ाइल को संशोधित करें)। प्रत्येक वेरिएबल के लिए, जहाँ आप डिफ़ॉल्ट मान को ओवरराइड करना चाहते हैं या जहाँ आपको कोई मान सेट करने की आवश्यकता है, terraform.tfvars में एक सेटिंग दर्ज करें।

- इन्फ्रास्ट्रक्चर बनाने के लिए निम्नलिखित कमांड चलाएँ।

```sh
#आवश्यक प्लगइन इंस्टॉल करें
terraform init

#बनने वाले संसाधनों की योजना देखें
terraform plan

#संसाधनों का निर्माण करें (इसे पूरा होने में 30 मिनट तक लग सकते हैं)
terraform apply
```

नई क्लस्टर के लिए क्रेडेंशियल्स को ~/.kube/config में डाउनलोड करें और इसे अपने डिफ़ॉल्ट संदर्भ के रूप में सेट करें।

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Indexer के लिए Kubernetes घटकों का निर्माण

- डायरेक्टरी `k8s/overlays` को एक नई डायरेक्टरी `$dir` में कॉपी करें, और `$dir/kustomization.yaml` में `bases` एंट्री को इस तरह समायोजित करें कि यह `k8s/base` डायरेक्टरी की ओर इशारा करे।

- सभी फ़ाइलों को `$dir` में पढ़ें और टिप्पणियों में दिए गए निर्देशों के अनुसार किसी भी मान को समायोजित करें।

सभी संसाधनों को `kubectl apply -k $dir` के साथ परिनियोजित करें।

### Graph Node

[Graph Node](https://github.com/graphprotocol/graph-node) एक ओपन सोर्स Rust इम्प्लीमेंटेशन है जो Ethereum ब्लॉकचेन को इवेंट सोर्स करके एक डेटा स्टोर को डिटर्मिनिस्टिक तरीके से अपडेट करता है, जिसे GraphQL एंडपॉइंट के जरिए क्वेरी किया जा सकता है। डेवलपर्स सबग्राफ का उपयोग करके अपनी स्कीमा को परिभाषित करते हैं और ब्लॉकचेन से सोर्स किए गए डेटा को ट्रांसफॉर्म करने के लिए एक सेट ऑफ मैपिंग्स बनाते हैं, और Graph Node पूरी चेन को सिंक करने, नए ब्लॉक्स की मॉनिटरिंग करने और इसे एक GraphQL एंडपॉइंट के जरिए सर्व करने का काम संभालता है।

#### सोर्स से शुरू करना

#### आवश्यक पूर्वापेक्षाएँ स्थापित करें

- **Rust**

- **PostgreSQL**

- **IPFS**

- **उबंटू उपयोगकर्ताओं के लिए अतिरिक्त आवश्यकताएँ** - उबंटू पर एक ग्राफ-नोड चलाने के लिए कुछ अतिरिक्त पैकेजों की आवश्यकता हो सकती है।

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### सेटअप

1. PostgreSQL डेटाबेस सर्वर शुरू करें

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. [Graph Node](https://github.com/graphprotocol/graph-node) रिपॉजिटरी को क्लोन करें और सोर्स को बिल्ड करने के लिए `cargo build` कमांड चलाएँ।

3. अब जब सभी dependencies सेटअप हो गई हैं, तो Graph Node शुरू करें:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.thegraph.com
```

#### Docker का उपयोग शुरू करना

#### आवश्यक शर्तें

- **Ethereum नोड** -डिफ़ॉल्ट रूप से, Docker Compose सेटअप मुख्य नेटवर्क (mainnet) का उपयोग करेगा:[http://host.docker.internal:8545](http://host.docker.internal:8545) आपके होस्ट मशीन पर Ethereum node से कनेक्ट करने के लिए। आप `docker-compose.yaml` को अपडेट करके इस नेटवर्क नाम और URL को बदल सकते हैं।

#### सेटअप

1. Clone Graph Node और Docker डायरेक्टरी पर नेविगेट करें:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. सिर्फ़ Linux उपयोगकर्ताओं के लिए - `docker-compose.yaml` में `host.docker.internal` की जगह होस्ट IP एड्रेस का उपयोग करें, दिए गए स्क्रिप्ट का उपयोग करके:

```sh
./setup.sh
```

3. एक लोकल Graph Node शुरू करें जो आपके Ethereum endpoint से कनेक्ट होगा:

```sh
docker-compose up
```

### Indexer घटक

नेटवर्क में सफलतापूर्वक भाग लेने के लिए लगभग निरंतर निगरानी और इंटरैक्शन की आवश्यकता होती है, इसलिए हमने एक TypeScript application का एक सूट बनाया है जो Indexers नेटवर्क भागीदारी को सुगम बनाता है। तीन Indexer घटक हैं:

- **Indexer agent** - यह एजेंट नेटवर्क और Indexer's स्वयं के बुनियादी ढांचे की निगरानी करता है और ऑनचेन पर कौन-कौन से सबग्राफ डिप्लॉयमेंट को इंडेक्स और आवंटित किया जाएगा, तथा प्रत्येक के लिए कितना आवंटित किया जाएगा, इसका प्रबंधन करता है।

- **Indexer सेवा** - यह एकमात्र घटक है जिसे बाहरी रूप से एक्सपोज़ करने की आवश्यकता होती है। यह सेवा सबग्राफ क्वेरीज़ को The Graph नोड तक पहुंचाती है, क्वेरी भुगतान के लिए स्टेट चैनल प्रबंधित करती है, और गेटवे जैसे क्लाइंट्स को महत्वपूर्ण निर्णय लेने की जानकारी साझा करती है।

- **Indexer CLI** - कमांड लाइन इंटरफ़ेस जो Indexer एजेंट को प्रबंधित करने के लिए उपयोग किया जाता है। यह Indexers को लागत मॉडल, मैनुअल अलोकेशन, एक्शन कतार, और Indexing नियमों को प्रबंधित करने की अनुमति देता है।

#### शुरू करना

Indexer agent और Indexer service को आपके Graph Node इंफ्रास्ट्रक्चर के साथ ही रखना चाहिए। आपके Indexer components के लिए वर्चुअल execution environments सेटअप करने के कई तरीके हैं; यहाँ हम बताएंगे कि उन्हें baremetal पर NPM पैकेज या source से कैसे चलाया जाए, या फिर Kubernetes और Docker के ज़रिए Google Cloud Kubernetes Engine पर कैसे रन किया जाए। अगर ये सेटअप उदाहरण आपके इंफ्रास्ट्रक्चर के लिए उपयुक्त नहीं हैं, तो संभवतः कोई कम्युनिटी गाइड उपलब्ध होगी, हमें [Discord](https://discord.gg/graphprotocol) पर आकर हैलो कहें! शुरू करने से पहले [protocol में stake करें!](/indexing/overview/#stake-in-the-protocol)

#### NPM पैकेजों से -

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### स्रोत से

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Docker का उपयोग

- रजिस्ट्र्री से इमेजेस प्राप्त करें

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

या स्रोत से स्थानीय रूप से छवियाँ बनाएं

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- कंपोनेंट्स चलाएं

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**नोट**: कंटेनर शुरू करने के बाद, Indexer सेवा [http://localhost:7600](http://localhost:7600) पर उपलब्ध होगी और Indexer एजेंट [http://localhost:18000/](http://localhost:18000/) पर Indexer प्रबंधन API को एक्सपोज़ करेगा।

#### कुबेरनेट्स (K8s) और टेराफॉर्म का उपयोग

देखें [Google Cloud पर Terraform का उपयोग करके सर्वर इंफ्रास्ट्रक्चर सेटअप करें अनुभाग](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud)

#### उपयोग

> नोट: सभी रनटाइम कॉन्फ़िगरेशन वेरिएबल्स या तो कमांड पर स्टार्टअप के समय पैरामीटर्स के रूप में लागू किए जा सकते हैं या फिर `COMPONENT_NAME_VARIABLE_NAME` प्रारूप में एनवायरनमेंट वेरिएबल्स के रूप में उपयोग किए जा सकते हैं (उदाहरण: `INDEXER_AGENT_ETHEREUM`)।

#### Indexer एजेंट

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer सेवा

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexer CLI

The Indexer CLI @graphprotocol/graph-clihttps://www.npmjs.com/package/@graphprotocol/graph-cli के लिए एक प्लगइन है, जिसे टर्मिनल में `graph indexer` कमांड के माध्यम से एक्सेस किया जा सकता है।

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Indexer प्रबंधन Indexer CLI का उपयोग करके

**Indexer Management API** के साथ इंटरैक्ट करने के लिए सुझाया गया टूल **Indexer CLI** है, जो कि **Graph CLI** का एक एक्सटेंशन है। Indexer agent को एक Indexer से इनपुट की आवश्यकता होती है ताकि वह Indexer की ओर से नेटवर्क के साथ स्वायत्त रूप से इंटरैक्ट कर सके। Indexer agent व्यवहार को परिभाषित करने के लिए **allocation management** मोड और **indexing rules** का उपयोग किया जाता है। Auto mode में, एक Indexer **indexing rules** का उपयोग करके यह तय कर सकता है कि वह किन को इंडेक्स और क्वेरी के लिए सर्व करेगा। इन नियमों को GraphQL API के माध्यम से प्रबंधित किया जाता है, जिसे agent द्वारा सर्व किया जाता है और यह Indexer Management API के रूप में जाना जाता है। Manual mode में, एक Indexer **actions queue** का उपयोग करके allocation actions बना सकता है और उन्हें निष्पादित करने से पहले स्पष्ट रूप से अनुमोदित कर सकता है। Oversight mode में, **indexing rules** का उपयोग **actions queue** को भरने के लिए किया जाता है और इन्हें निष्पादित करने से पहले भी स्पष्ट अनुमोदन की आवश्यकता होती है।

#### उपयोग

**Indexer CLI** Indexer agent से कनेक्ट होता है, आमतौर पर पोर्ट-फॉरवर्डिंग के माध्यम से, जिससे CLI को वही सर्वर या क्लस्टर पर चलाने की जरूरत नहीं होती है। शुरुआत करने के लिए और कुछ संदर्भ देने के लिए, यहां CLI का संक्षिप्त विवरण दिया जाएगा।

- `graph indexer connect <url>` - Indexer प्रबंधन API से कनेक्ट करें। आमतौर पर, सर्वर से कनेक्शन पोर्ट फॉरवर्डिंग के माध्यम से खोला जाता है, जिससे CLI को आसानी से रिमोटली ऑपरेट किया जा सकता है। (उदाहरण: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - एक या अधिक इंडेक्सिंग नियम प्राप्त करें,`<deployment-id>`के रूप में `all` का उपयोग करके सभी नियम प्राप्त करें, या global का उपयोग करके वैश्विक डिफॉल्ट प्राप्त करें। एक अतिरिक्त आर्ग्यूमेंट --merged का उपयोग किया जा सकता है, जो यह निर्दिष्ट करता है कि डिप्लॉयमेंट-विशिष्ट नियम वैश्विक नियम के साथ मर्ज किए गए हैं। यह उसी तरह लागू होते हैं जैसे वे Indexer agent में होते हैं।

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ... `- एक या अधिक indexing नियम सेट करें।

- `graph indexer rules start [options] <deployment-id>` - यदि उपलब्ध हो तो किसी सबग्राफ डिप्लॉयमेंट का Indexing शुरू करें और इसका `decisionBasis` को `always` पर सेट करें, ताकि Indexer एजेंट इसे हमेशा Index करने के लिए चुने। यदि ग्लोबल नियम always पर सेट है, तो नेटवर्क पर उपलब्ध सभी सबग्राफ को Index किया जाएगा।

- `graph indexer rules stop [options] <deployment-id>` - किसी डिप्लॉयमेंट की इंडेक्सिंग को रोकें और इसका `decisionBasis` को कभी नहीं पर सेट करें, जिससे यह डिप्लॉयमेंट को इंडेक्स करने के निर्णय में छोड़ देगा।

- `graph indexer rules maybe [options] <deployment-id>` — किसी deployment के लिए `decisionBasis` को `rules` पर सेट करें, ताकि Indexer agent यह तय करने के लिए indexing rules का उपयोग करे कि इस deployment को index करना है या नहीं।

- `graph indexer actions get [options] <action-id>` - एक या अधिक कार्यों को प्राप्त करें `all` का उपयोग करके या सभी कार्य प्राप्त करने के लिए `action-id` को खाली छोड़ दें। एक अतिरिक्त आर्गुमेंट --status का उपयोग एक निश्चित स्थिति वाले सभी कार्यों को प्रदर्शित करने के लिए किया जा सकता है।

- `graph indexer एक्शन कतार आवंटित <deployment-id> <allocation-amount>` - आवंटन क्रिया को कतारबद्ध करें

- `graph indexer एक्शन कतार पुनः आवंटित<deployment-id> <allocation-id> <allocationAmount>` - पुनः आवंटन क्रिया को कतारबद्ध करें

- `graph indexer एक्शन कतार अनआवंटित <deployment-id> <allocation-id>` - अनविन्यास क्रिया को कतारबद्ध करें

- `graph indexer actions cancel [<action-id> ...]` - यदि ID निर्दिष्ट नहीं है, तो कतार में सभी कार्रवाइयों को रद्द करें, अन्यथा स्पेस से अलग की गई आईडी की सूची को रद्द करें।

- `graph indexer actions approve [<action-id> ...]` - कई क्रियाओं को निष्पादन के लिए अनुमोदित करें

- `graph indexer actions execute approve` - कार्यकर्ता को स्वीकृत क्रियाओं को तुरंत निष्पादित करने के लिए बाध्य करें

सभी कमांड जो आउटपुट में नियम दिखाते हैं, वे -output आर्गुमेंट का उपयोग करके समर्थित `-otuput` फ़ॉर्मेट (`table,` `yaml`, और `json`) में से किसी एक को चुन सकते हैं।

#### indexing नियम

Indexing नियमों को या तो वैश्विक डिफ़ॉल्ट के रूप में या विशिष्ट सबग्राफ डिप्लॉयमेंट्स के लिए उनकी IDs का उपयोग करके लागू किया जा सकता है। `deployment` और `decisionBasis` फ़ील्ड अनिवार्य हैं, जबकि सभी अन्य फ़ील्ड वैकल्पिक हैं। जब किसी Indexing नियम में `rules` को `decisionBasis` के रूप में सेट किया जाता है, तो Indexer एजेंट उस नियम पर दिए गए गैर-शून्य थ्रेशोल्ड मानों की तुलना नेटवर्क से प्राप्त मानों से संबंधित डिप्लॉयमेंट के लिए करेगा। यदि सबग्राफ डिप्लॉयमेंट के मान किसी भी थ्रेशोल्ड से ऊपर (या नीचे) होते हैं, तो इसे Indexing के लिए चुना जाएगा।

For example, अगर global rule का `minStake` **5** (GRT) है, तो कोई भी सबग्राफ deployment जिसमें 5 (GRT) से ज्यादा stake allocated है, उसे index किया जाएगा। Threshold rules में शामिल हैं `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, और `minAverageQueryFees`।

डेटा मॉडल:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

indexing नियम का उदाहरण उपयोग:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### कार्य सूची CLI

Indexer-cli एक `actions` मॉड्यूल प्रदान करता है जो मैन्युअल रूप से एक्शन कतार के साथ काम करने के लिए उपयोग किया जाता है। यह **Graphql API**, जो कि indexer management server द्वारा होस्ट की गई है, का उपयोग एक्शन कतार के साथ इंटरैक्ट करने के लिए करता है।

एक्शन एक्सीक्यूशन वर्कर केवल तभी कतार से आइटम उठाकर निष्पादित करेगा जब उनका `ActionStatus = approved` होगा। अनुशंसित मार्ग में, एक्शन को कतार में ActionStatus = queued के साथ जोड़ा जाता है, इसलिए उन्हें ऑनचेन निष्पादित होने के लिए अनुमोदित किया जाना चाहिए। सामान्य प्रवाह इस प्रकार होगा:

- 3rd party ऑप्टिमाइज़र टूल या indexer-cli उपयोगकर्ता द्वारा कतार में क्रिया जोड़ी गई है
- Indexer `indexer-cli` का उपयोग करके सभी कतारबद्ध क्रियाओं को देख सकता है।
- Indexer (या अन्य सॉफ़्टवेयर) `indexer-cli` का उपयोग करके कतार में क्रियाओं को मंजूरी या रद्द कर सकता है। मंजूरी और रद्द करने वाले आदेश एक्शन आईडीज़ के एक एरे को इनपुट के रूप में लेते हैं।
- निर्वाचन कार्यकर्ता नियमित रूप से क्यू से अनुमोदित क्रियाओं के लिए पोल करता है। यह क्यू से `approved` क्रियाओं को प्राप्त करेगा, उन्हें निष्पादित करने का प्रयास करेगा, और निष्पादन की स्थिति के आधार पर डाटाबेस में मानों को `success` या `failed` के रूप में अपडेट करेगा।
- अगर कोई क्रिया सफल होती है तो कर्मचारी यह सुनिश्चित करेगा कि एक indexing नियम मौजूद हो जो एजेंट को यह बताए कि आगे बढ़ते हुए आवंटन को कैसे प्रबंधित करना है, यह उस स्थिति में उपयोगी होता है जब एजेंट `auto` या `oversight` मोड में हो और मैन्युअल क्रियाएं ली जा रही हों।
- Indexer एक्शन कतार की निगरानी कर सकता है ताकि एक्शन निष्पादन के इतिहास को देखा जा सके और यदि आवश्यक हो, तो असफल निष्पादन वाले एक्शन आइटम्स को पुनः अनुमोदित और अपडेट किया जा सके। एक्शन कतार उन सभी एक्शनों का इतिहास प्रदान करती है जो कतारबद्ध और लिए गए हैं।

डेटा मॉडल:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

स्रोत से उदाहरण उपयोग:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Supported action types के लिए आवंटन प्रबंधन की विभिन्न इनपुट आवश्यकताएँ होती हैं:

- Allocate - किसी विशिष्ट सबग्राफ डिप्लॉयमेंट के लिए स्टेक आवंटित करें

  - आवश्यक क्रिया पैरामीटर्स:
    - deploymentID
    - राशि

- `अनुदेश हटाएं` - आवंटन बंद करें, जिससे दांव को मुक्त किया जा सके और इसे कहीं और पुनः आवंटित किया जा सके।

  - आवश्यक क्रिया पैरामीटर्स:
    - allocationID
    - deploymentID
  - वैकल्पिक क्रिया पैरामीटर:
    - poi
    - बल प्रयोग करें (दिए गए POI का उपयोग तब भी करें यदि यह ग्राफ-नोड द्वारा प्रदान किए गए से मेल नहीं खाता)

- `पुनः आवंटित करें` - परमाणु रूप से आवंटन को बंद करें और उसी Subgraph परिनियोजन के लिए एक नया आवंटन खोलें

  - आवश्यक क्रिया पैरामीटर:
    - allocationID
    - deploymentID
    - राशि
  - वैकल्पिक क्रिया पैरामीटर्स:
    - poi
    - बल (दिए गए POI का उपयोग करने के लिए मजबूर करता है, भले ही वह ग्राफ-नोड द्वारा प्रदान किए गए डेटा से मेल न खाए)

#### लागत मॉडल

कॉस्ट मॉडल बाज़ार और क्वेरी विशेषताओं के आधार पर क्वेरी के लिए डायनामिक मूल्य निर्धारण प्रदान करते हैं। Indexer Service प्रत्येक सबग्राफ के लिए गेटवे के साथ एक कॉस्ट मॉडल साझा करता है, जिसके लिए वे क्वेरी का जवाब देने का इरादा रखते हैं। बदले में, गेटवे इस कॉस्ट मॉडल का उपयोग प्रति क्वेरी Indexer चयन निर्णय लेने और चुने गए Indexers के साथ भुगतान पर बातचीत करने के लिए करते हैं।

#### Agora

Agora भाषा क्वेरी के लिए लागत मॉडल घोषित करने के लिए एक लचीला प्रारूप प्रदान करती है। एक Agora मूल्य मॉडल बयानों का एक क्रम होता है जो प्रत्येक शीर्ष-स्तरीय GraphQL क्वेरी के लिए क्रम में निष्पादित होता है। प्रत्येक शीर्ष-स्तरीय क्वेरी के लिए, पहला कथन जो उससे मेल खाता है, उस क्वेरी के लिए मूल्य निर्धारित करता है।

एक कथन में एक ​predicate​ होता है, जिसका उपयोग GraphQL queries से मिलान करने के लिए किया जाता है, और एक cost expression होता है, जो मूल्यांकन किए जाने पर दशमलव GRT में एक लागत आउटपुट करता है। किसी क्वेरी में नामित आर्गुमेंट स्थिति के मानों को predicate में कैप्चर किया जा सकता है और expression में उपयोग किया जा सकता है। Globals भी सेट किए जा सकते हैं और expression में प्लेसहोल्डर्स के लिए प्रतिस्थापित किए जा सकते हैं।

उदाहरण लागत मॉडल:

```
#यह कथन skip मान को प्राप्त करता है,
#शर्त में एक बूलियन अभिव्यक्ति का उपयोग करता है ताकि skip का उपयोग करने वाले विशिष्ट क्वेरीज़ का मिलान किया जा सके,
#और skip मान और SYSTEM_LOAD ग्लोबल के आधार पर लागत की गणना करने के लिए लागत अभिव्यक्ति का उपयोग करता है।
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

#यह डिफ़ॉल्ट किसी भी GraphQL अभिव्यक्ति से मेल खाएगा।
#यह ग्लोबल का उपयोग करके लागत की गणना करने के लिए अभिव्यक्ति में प्रतिस्थापित करता है।
default => 0.1 * $SYSTEM_LOAD;
```

उपरोक्त मॉडल का उपयोग करके उदाहरण क्वेरी लागत:

| Query                                                                        | कीमत    |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### लागत मॉडल लागू करना

कास्ट मॉडल को Indexer CLI के माध्यम से लागू किया जाता है, जो उन्हें Indexer एजेंट के Indexer Management API को पास करता है ताकि उन्हें डेटाबेस में संग्रहीत किया जा सके। इसके बाद, Indexer Service उन्हें लेगी और जब भी गेटवे इसकी मांग करेंगे, तो उन्हें कास्ट मॉडल प्रदान करेगी।

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## नेटवर्क के साथ इंटरैक्ट करना

### प्रोटोकॉल में staking

पहले कदम नेटवर्क में एक Indexer के रूप में भाग लेने के लिए प्रोटोकॉल को अनुमोदित करना, धन को स्टेक करना, और (वैकल्पिक रूप से) दिन-प्रतिदिन की प्रोटोकॉल इंटरैक्शन के लिए एक ऑपरेटर पता सेट करना शामिल हैं।

> नोट: contract इंटरैक्शन के लिए इन निर्देशों में Remix का उपयोग किया जाएगा, लेकिन आप अपनी पसंद के किसी भी टूल का उपयोग कर सकते हैं ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), और [MyCrypto](https://www.mycrypto.com/account) कुछ अन्य ज्ञात टूल हैं)।

Once an Indexer ने प्रोटोकॉल में GRT को स्टेक कर दिया है, तो [Indexer components](/indexing/overview/#indexer-components) को शुरू किया जा सकता है और वे नेटवर्क के साथ अपनी इंटरैक्शन शुरू कर सकते हैं।

#### स्वीकृत करें टोकन

1. ओपन द [Remix app](https://remix.ethereum.org/) एक ब्राउज़र में

2. `File Explorer` में **GraphToken.abi** नामक फ़ाइल बनाएं जिसमें [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json) हो।

3. `GraphToken.abi` चयनित और संपादक में खुला होने पर, Remix इंटरफ़ेस में `Deploy and run transactions` अनुभाग पर स्विच करें।

4. पर्यावरण के अंतर्गत `Injected Web3` चुनें और `Account` के अंतर्गत अपना Indexer पता चुनें।

5. GraphToken contract एड्रेस सेट करें - `At Address` के बगल में GraphToken कॉन्ट्रैक्ट एड्रेस (0xc944E90C64B2c07662A292be6244BDf05Cda44a7) पेस्ट करें और लागू करने के लिए `At address` बटन पर क्लिक करें।

6. `approve(spender, amount)` फ़ंक्शन को कॉल करके Staking कॉन्ट्रैक्ट को अप्रूव करें। spender को Staking contract एड्रेस (0xF55041E37E12cD407ad00CE2910B8269B01263b9) से भरें और amount में स्टेक किए जाने वाले टोकन (wei में) डालें।

#### Staking टोकन

1. [Remix app](https://remix.ethereum.org/) को ब्राउज़र में खोलें

2. File Explorer में **Staking.abi** नाम की एक फ़ाइल बनाएं जिसमें स्टेकिंग ABI हो।

3. `Staking.abi` को संपादक में चयनित और खुला रखने के साथ, Remix इंटरफ़ेस में `Deploy and run transactions` अनुभाग पर स्विच करें।

4. पर्यावरण के अंतर्गत `Injected Web3` चुनें और `Account` के अंतर्गत अपना Indexer पता चुनें।

5. Staking कॉन्ट्रैक्ट एड्रेस सेट करें - `At Address` के पास Staking contract एड्रेस (0xF55041E37E12cD407ad00CE2910B8269B01263b9) पेस्ट करें और इसे लागू करने के लिए `At address` बटन पर क्लिक करें।

6. `stake()` को कॉल करें ताकि प्रोटोकॉल में GRT को स्टेक किया जा सके।

7. (Optional) Indexers दूसरे पते को अपने Indexer इंफ्रास्ट्रक्चर के लिए ऑपरेटर के रूप में अनुमोदित कर सकते हैं ताकि उन कुंजियों को अलग किया जा सके जो धन को नियंत्रित करती हैं और जो दिन-प्रतिदिन की क्रियाएँ जैसे सबग्राफ पर आवंटन करना और (भुगतान किए गए) क्वेरीज़ की सेवा करना कर रही हैं। ऑपरेटर सेट करने के लिए, `setOperator()` को ऑपरेटर पते के साथ कॉल करें।

8. (Optional) पुरस्कारों के वितरण को नियंत्रित करने और रणनीतिक रूप से Delegators को आकर्षित करने के लिए, Indexers अपने delegation पैरामीटर्स को अपडेट कर सकते हैं। इसके लिए वे indexingRewardCut (parts per million), queryFeeCut (parts per million), और cooldownBlocks (ब्लॉक्स की संख्या) को अपडेट कर सकते हैं। ऐसा करने के लिए, setDelegationParameters() को कॉल करें। निम्नलिखित उदाहरण में queryFeeCut को सेट किया गया है ताकि 95% क्वेरी रिबेट्स Indexer को और 5% Delegators को वितरित किए जाएं, indexingRewardCut को सेट किया गया है ताकि 60% Indexing पुरस्कार Indexer को और 40% Delegators को वितरित किए जाएं, और cooldownBlocks अवधि को 500 ब्लॉक्स पर सेट किया गया है।

```
setDelegationParameters(950000, 600000, 500)
```

### delegation मानक सेट करना

`setDelegationParameters()` फ़ंक्शन [staking contract](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) में आवश्यक है, जो Indexers को उन मापदंडों को सेट करने की अनुमति देता है जो उनके Delegators के साथ इंटरैक्शन को परिभाषित करते हैं, जिससे उनके इनाम साझा करने और delegation क्षमता को प्रभावित किया जाता है।

### delegation मापदंड सेट करने का तरीका

Graph Explorer इंटरफेस का उपयोग करके delegation पैरामीटर सेट करने के लिए, इन चरणों का पालन करें:

1. [Graph Explorer](https://thegraph.com/explorer/)को नेविगेट करें
2. अपने वॉलेट को कनेक्ट करें। मल्टीसिग (जैसे Gnosis Safe) चुनें और फिर मुख्य नेटवर्क (mainnet) का चयन करें। ध्यान दें: आपको इस प्रक्रिया को Arbitrum One के लिए दोहराने की आवश्यकता होगी।
3. अपने वॉलेट को एक साइनर के रूप में कनेक्ट करें।
4. `सेटिंग्स` अनुभाग पर जाएं और `delegation पैरामीटर्स` का चयन करें। इन पैरामीटर्स को वांछित सीमा के भीतर प्रभावी कट प्राप्त करने के लिए कॉन्फ़िगर किया जाना चाहिए। प्रदान किए गए इनपुट फ़ील्ड में मान दर्ज करने पर, इंटरफ़ेस स्वचालित रूप से प्रभावी कट की गणना करेगा। वांछित प्रभावी कट प्रतिशत प्राप्त करने के लिए इन मानों को आवश्यकतानुसार समायोजित करें।
5. लेन-लेन-देन(transaction) को नेटवर्क पर जमा करें।

> नोट: इस लेन-देन(transaction) की पुष्टि मल्टीसिग वॉलेट साइनर्स द्वारा की जानी होगी।

### एक आवंटन का जीवन

एक Indexer द्वारा बनाए जाने के बाद, एक स्वस्थ आवंटन दो अवस्थाओं से गुजरता है।

- **सक्रिय** - एक बार जब ऑनचेन पर आवंटन बनाया जाता है ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)), तो इसे सक्रिय माना जाता है। Indexer के स्वयं के और/या प्रत्यायोजित स्टेक का एक हिस्सा किसी सबग्राफ परिनियोजन की ओर आवंटित किया जाता है, जो उन्हें उस सबग्राफ परिनियोजन के लिए इंडेक्सिंग पुरस्कारों का दावा करने और क्वेरीज़ को सर्व करने की अनुमति देता है। Indexer एजेंट, Indexer नियमों के आधार पर आवंटन बनाने का प्रबंधन करता है।

- **बंद** - एक Indexer एक आवंटन को बंद करने के लिए स्वतंत्र होता है जब 1 युग (epoch) बीत चुका हो ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335) या उनका Indexer एजेंट **maxAllocationEpochs** (वर्तमान में 28 दिन) के बाद स्वचालित रूप से आवंटन बंद कर देगा। जब कोई आवंटन एक वैध प्रूफ ऑफ indexing (POI) के साथ बंद किया जाता है, तो उनके indexing पुरस्कार Indexer और उसके Delegators को वितरित किए जाते हैं ([अधिक जानें])(/indexing/overview/#how-are-indexing-rewards-distributed)।

Indexers को अनुशंसा दी जाती है कि वे onchain पर allocation बनाने से पहले सबग्राफ deployments को chainhead तक sync करने के लिए offchain syncing सुविधा का उपयोग करें। यह सुविधा विशेष रूप से उन सबग्राफ के लिए उपयोगी है जिन्हें sync होने में 28 epochs से अधिक समय लग सकता है या जिनके अनिश्चित रूप से विफल होने की संभावना हो सकती है।
