---
title: Indexing का अवलोकन
sidebarTitle: Overview
---

Indexers, The Graph Network में node operators होते हैं जो Graph Tokens (GRT) stake करके indexing और query processing services प्रदान करते हैं। वे अपनी सेवाओं के लिए query fees और indexing rewards अर्जित करते हैं। इसके अलावा, उन्हें query fees भी मिलती हैं, जो एक exponential rebate function के अनुसार rebate की जाती हैं।

जीआरटी जो प्रोटोकॉल में दांव पर लगा है, विगलन अवधि के अधीन है और यदि अनुक्रमणिका दुर्भावनापूर्ण हैं और अनुप्रयोगों को गलत डेटा प्रदान करते हैं या यदि वे गलत तरीके से अनुक्रमणित करते हैं तो इसे घटाया जा सकता है। इंडेक्सर्स नेटवर्क में योगदान करने के लिए डेलीगेटर्स से प्रत्यायोजित हिस्सेदारी के लिए पुरस्कार भी अर्जित करते हैं।

Indexers किसी सबग्राफ के curation signal के आधार पर उसे चुनते हैं, जहाँ Curators GRT को स्टेक करते हैं ताकि यह संकेत दिया जा सके कि कौन से Subgraph उच्च-गुणवत्ता वाले हैं और प्राथमिकता दी जानी चाहिए। Consumers (जैसे कि applications) यह भी निर्धारित कर सकते हैं कि कौन से Indexers उनके सबग्राफ के लिए queries को प्रोसेस करें और query fee pricing के लिए अपनी प्राथमिकताएँ सेट कर सकते हैं।

## FAQ

### नेटवर्क पर Indexer बनने के लिए न्यूनतम स्टेक कितना आवश्यक है?

Indexer के लिए न्यूनतम स्टेक वर्तमान में 100K GRT निर्धारित है।

### एक Indexer के लिए राजस्व स्रोत क्या हैं?

**पूछताछ शुल्क rebates** - नेटवर्क पर क्वेरी सर्व करने के लिए किए गए भुगतान। ये भुगतान एक Indexer और एक गेटवे के बीच स्टेट चैनलों के माध्यम से संचालित होते हैं। गेटवे से प्रत्येक क्वेरी अनुरोध में एक भुगतान शामिल होता है और संबंधित प्रतिक्रिया में क्वेरी परिणाम की वैधता का प्रमाण होता है।

**indexing रिवार्ड्स** - 3% वार्षिक प्रोटोकॉल-वाइड मुद्रास्फीति के माध्यम से उत्पन्न, indexing रिवार्ड्स उन Indexers को वितरित किए जाते हैं जो नेटवर्क के लिए सबग्राफ डिप्लॉयमेंट को इंडेक्स कर रहे हैं।

### Indexing इनाम कैसे वितरित किए जाते हैं?

Indexing rewards प्रोटोकॉल मुद्रास्फीति से आते हैं, जो 3% वार्षिक जारी करने के लिए सेट किया गया है। इन्हें सभी सबग्राफ पर कुल क्यूरेशन सिग्नल के अनुपात के आधार पर वितरित किया जाता है, और फिर Indexers को उनके द्वारा उस सबग्राफ पर आवंटित स्टेक के अनुपात में वितरित किया जाता है। **एक आवंटन को मान्य प्रूफ ऑफ Indexing (POI) के साथ बंद किया जाना चाहिए, जो मध्यस्थता चार्टर द्वारा निर्धारित मानकों को पूरा करता हो, ताकि इसे पुरस्कारों के लिए योग्य माना जा सके।**

समुदाय द्वारा कई उपकरण बनाए गए हैं जो इनाम की गणना करने में मदद करते हैं; आपको इनका संग्रह [Community Guides collection](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c) में संगठित रूप में मिलेगा। आप #Delegators और #Indexers चैनलों में भी उपकरणों की एक अद्यतन सूची [Discord server](https://discord.gg/graphprotocol) पर पा सकते हैं। यहाँ हम एक [recommended allocation optimiser](https://github.com/graphprotocol/allocation-optimizer) को लिंक कर रहे हैं जो indexer software stack के साथ एकीकृत है।

### Indexing का प्रमाण (POI) क्या है?

POIs का उपयोग नेटवर्क में यह सत्यापित करने के लिए किया जाता है कि कोई Indexer उन सबग्राफ को Indexing कर रहा है जिन पर उन्होंने आवंटन किया है। जब किसी आवंटन को बंद किया जाता है, तो वर्तमान युग के पहले ब्लॉक के लिए एक POI प्रस्तुत करना आवश्यक होता है ताकि वह आवंटन Indexing पुरस्कारों के लिए पात्र हो सके। किसी ब्लॉक के लिए POI उस ब्लॉक तक और उसमें शामिल सभी entity store लेनदेन के लिए एक डाइजेस्ट होता है, जो एक विशिष्ट Subgraph परिनियोजन के लिए होता है।

### indexing पुरस्कार कब वितरित किए जाते हैं?

आवंटन सक्रिय रहते हुए और 28 युगों के भीतर आवंटित होने पर लगातार इनाम अर्जित करते रहते हैं। इनाम Indexers द्वारा एकत्र किए जाते हैं और तब वितरित किए जाते हैं जब उनके आवंटन बंद हो जाते हैं। यह या तो मैन्युअल रूप से होता है, जब भी Indexer उन्हें बलपूर्वक बंद करना चाहता है, या 28 युगों के बाद एक Delegator Indexer के लिए आवंटन बंद कर सकता है, लेकिन इससे कोई इनाम नहीं मिलता। 28 युग अधिकतम आवंटन अवधि है (फिलहाल, एक युग लगभग ~24 घंटे तक चलता है)।

### क्या लंबित indexing पुरस्कारों की निगरानी की जा सकती है?

RewardsManager contract में एक केवल-पढ़ने योग्य [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316) फ़ंक्शन है, जिसका उपयोग किसी विशिष्ट आवंटन के लिए लंबित इनाम की जाँच करने के लिए किया जा सकता है।

कई समुदाय द्वारा बनाए गए डैशबोर्ड में पेंडिंग रिवॉर्ड्स के मान होते हैं और इन्हें मैन्युअल रूप से निम्नलिखित कदमों का पालन करके आसानी से चेक किया जा सकता है:

1. [mainnet सबग्राफ](https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one) को क्वेरी करें ताकि सभी सक्रिय आवंटनों के लिए ID प्राप्त की जा सके।

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Etherscan का उपयोग करके `getRewards()` कॉल करें:

- [ईथरस्कैन इंटरफेस पर रिवॉर्ड्स contract](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract) पर जाएं।
- `getRewards()` को कॉल करने के लिए: 
  - **9. getRewards** ड्रॉपडाउन का विस्तार करें।
  - इनपुट में **allocationID** दर्ज करें।
  - कृपया **Query** बटन पर क्लिक करें।

### क्या होते हैं और मैं उन्हें कहाँ देख सकता हूँ?

Indexers की queries और आवंटन दोनों को The Graph में विवाद अवधि के दौरान विवादित किया जा सकता है। विवाद अवधि विवाद के प्रकार के अनुसार भिन्न होती है। Queries/अभिप्रमाणन के लिए 7 अवधियों को विवाद विंडो होती है, जबकि आवंटन के लिए 56 युगों की अवधि होती है। इन अवधियों के बीतने के बाद, आवंटन या queries के खिलाफ कोई विवाद नहीं खोला जा सकता। जब कोई विवाद खोला जाता है, तो Fishermen को न्यूनतम 10,000 GRT की जमा राशि की आवश्यकता होती है, जिसे विवाद के अंतिम निर्णय और समाधान दिए जाने तक लॉक कर दिया जाता है। Fishermen वे नेटवर्क प्रतिभागी होते हैं जो विवाद खोलते हैं।

विवादों के **तीन** संभावित परिणाम होते हैं, और मछुआरों की जमा राशि भी।

- यदि विवाद अस्वीकार कर दिया जाता है, तो फ़िशरमैन द्वारा जमा किया गया GRT नष्ट कर दिया जाएगा, और विवादित Indexer पर कोई दंड नहीं लगाया जाएगा।
- यदि विवाद ड्रा के रूप में निपटाया जाता है, तो मछुआरों की जमा राशि वापस कर दी जाएगी, और विवादित Indexer पर कोई दंड नहीं लगाया जाएगा।
- यदि विवाद स्वीकार कर लिया जाता है, तो मछुआरों द्वारा जमा किया गया GRT वापस कर दिया जाएगा, विवादित Indexer को दंडित किया जाएगा, और मछुआरों को दंडित किए गए GRT का 50% मिलेगा।

विवादों को UI में एक Indexer's प्रोफ़ाइल पृष्ठ पर Disputes टैब के अंतर्गत देखा जा सकता है।

### पूछताछ शुल्क रिबेट्स क्या हैं और वे कब वितरित किए जाते हैं?

पूछताछ शुल्क गेटवे द्वारा एकत्र किए जाते हैं और Indexers को घातांकीय छूट फ़ंक्शन के अनुसार वितरित किए जाते हैं (देखें GIP [यहाँ](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162))। घातांकीय छूट फ़ंक्शन को यह सुनिश्चित करने के तरीके के रूप में प्रस्तावित किया गया है कि Indexers queries की सही सेवा करके सर्वोत्तम परिणाम प्राप्त करें। यह Indexers को एक बड़ी मात्रा में स्टेक आवंटित करने के लिए प्रोत्साहित करके काम करता है (जो किसी queries की सेवा करते समय गलती करने पर स्लैश किया जा सकता है) जो वे एकत्र कर सकने वाली पूछताछ शुल्क की मात्रा के सापेक्ष होती है।

एक बार आवंटन बंद हो जाने के बाद, रिबेट्स को Indexer द्वारा क्लेम किया जा सकता है। क्लेम करने पर, पूछताछ शुल्क रिबेट्स को Indexer और उनके Delegators के बीच पूछताछ शुल्क कट और घातीय रिबेट फ़ंक्शन के आधार पर वितरित किया जाता है।

### पूछताछ शुल्क कटौती और indexing पुरस्कार कटौती क्या हैं?

`queryFeeCut` और `indexingRewardCut` मान delegation पैरामीटर हैं, जिन्हें Indexer cooldownBlocks के साथ सेट कर सकता है ताकि Indexer और उनके Delegators के बीच GRT के वितरण को नियंत्रित किया जा सके। Delegation पैरामीटर सेट करने के निर्देशों के लिए [Staking in the Protocol](/indexing/overview/#stake-in-the-protocol) के अंतिम चरण देखें।

- **queryFeeCut** - वह % जो पूछताछ शुल्क रिबेट्स में से Indexer को वितरित किया जाएगा। यदि इसे 95% पर सेट किया गया है, तो जब एक एलोकेशन बंद होगी, तो Indexer को अर्जित किए गए पूछताछ शुल्क का 95% प्राप्त होगा, और शेष 5% Delegators को जाएगा।

- **indexingRewardCut** - वह % जो Indexing पुरस्कारों में से Indexer को वितरित किया जाएगा। यदि इसे 95% पर सेट किया जाता है, तो जब कोई आवंटन बंद होता है, तो Indexer को Indexing पुरस्कारों का 95% प्राप्त होगा और Delegators शेष 5% को साझा करेंगे।

### Indexers को कैसे पता चलता है कि कौन से सबग्राफ को index करना है?

Indexers उन्नत तकनीकों को लागू करके सबग्राफ indexing निर्णय लेने में खुद को अलग कर सकते हैं, लेकिन सामान्य विचार देने के लिए, हम नेटवर्क में सबग्राफ का मूल्यांकन करने के लिए उपयोग की जाने वाली कुछ प्रमुख मीट्रिक्स पर चर्चा करेंगे:

- **Curation signal** - किसी विशेष Subgraph पर लागू किए गए नेटवर्क curation signal का अनुपात उस Subgraph में रुचि का एक अच्छा संकेतक होता है, विशेष रूप से प्रारंभिक चरण में जब क्वेरी वॉल्यूम बढ़ रहा होता है।

- **क्वेरी फीस संग्रहित **- किसी विशेष सबग्राफ के लिए संग्रहित क्वेरी फीस की ऐतिहासिक डेटा भविष्य की मांग का एक अच्छा संकेतक है।

- **राशि दांव पर लगी हुई** - अन्य Indexers के व्यवहार की निगरानी करना या कुल दांव का विशिष्ट सबग्राफ की ओर आवंटित अनुपात देखना, एक Indexer को सबग्राफ क्वेरी के लिए आपूर्ति पक्ष की निगरानी करने में मदद कर सकता है। इससे वे उन सबग्राफ की पहचान कर सकते हैं जिनमें नेटवर्क आत्मविश्वास दिखा रहा है या ऐसे सबग्राफ जिनमें अधिक आपूर्ति की आवश्यकता हो सकती है।

- **Subgraph जिनके लिए कोई indexing रिवार्ड नहीं है -**कुछ सबग्राफ को indexing इनाम नहीं मिलते हैं, मुख्य रूप से इसलिए क्योंकि वे असमर्थित सुविधाओं जैसे कि IPFS का उपयोग कर रहे हैं या वे मुख्य नेटवर्क के बाहर किसी अन्य नेटवर्क से क्वेरी कर रहे हैं। यदि कोई सबग्राफ indexing इनाम उत्पन्न नहीं कर रहा है, तो आपको उस पर एक संदेश दिखाई देगा।

### हार्डवेयर आवश्यकताएँ क्या हैं?

- **छोटा** - शुरुआत में कुछ सबग्राफ को index करने के लिए पर्याप्त, लेकिन संभवतः विस्तार करने की आवश्यकता होगी।
- **स्टैंडर्ड **- डिफ़ॉल्ट सेटअप, यह वही है जो उदाहरण k8s/terraform परिनियोजन मैनिफेस्ट में उपयोग किया जाता है।
- **मध्यम**- एक प्रोडक्शन Indexer जो 100 सबग्राफ को सपोर्ट करता है और 200-500 अनुरोध प्रति सेकंड प्रोसेस करता है।
- **बड़ा **- वर्तमान में उपयोग किए जा रहे सभी सबग्राफ को इंडेक्स करने और संबंधित ट्रैफ़िक के लिए अनुरोधों को सर्व करने के लिए तैयार।

| सेटअप | Postgres<br />(CPUs) | Postgres<br />(मेमोरी in GBs) | Postgres<br />(डिस्क in TBs) | VMs<br />(CPUs) | VMs<br />(मेमोरी in GBs) |
| ----- | :------------------: | :---------------------------: | :--------------------------: | :-------------: | :----------------------: |
| छोटा  |           4          |               8               |               1              |        4        |            16            |
| मानक  |           8          |               30              |               1              |        12       |            48            |
| मध्यम |          16          |               64              |               2              |        32       |            64            |
| बड़ा  |          72          |              468              |              3.5             |        48       |            184           |

### कोई Indexer को कौन-कौन सी बुनियादी सुरक्षा सावधानियाँ बरतनी चाहिए?

- **ऑपरेटर वॉलेट** - एक ऑपरेटर वॉलेट सेट अप करना एक महत्वपूर्ण एहतियात है क्योंकि यह एक Indexer को अपने उन कुंजियों के बीच अलगाव बनाए रखने की अनुमति देता है जो स्टेक को नियंत्रित करती हैं और वे जो दिन-प्रतिदिन के संचालन के नियंत्रण में होती हैं। निर्देशों के लिए (Stake in Protocol](/indexing/overview/#stake-in-the-protocol) देखें।

- **Firewall**- केवल Indexer सेवा को सार्वजनिक रूप से एक्सपोज़ किया जाना चाहिए और विशेष ध्यान एडमिन पोर्ट्स और डेटाबेस एक्सेस को लॉक करने पर दिया जाना चाहिए: Graph Node JSON-RPC एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 8030), Indexer प्रबंधन API एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 18000), और Postgres डेटाबेस एंडपॉइंट (डिफ़ॉल्ट पोर्ट: 5432) को एक्सपोज़ नहीं किया जाना चाहिए।

## इंफ्रास्ट्रक्चर

Indexer के इंफ्रास्ट्रक्चर के केंद्र में Graph Node होता है, जो इंडेक्स किए गए नेटवर्क की निगरानी करता है, डेटा को सबग्राफ परिभाषा के अनुसार निकालता और लोड करता है, और इसे एक [GraphQL API](/about/#how-the-graph-works) के रूप में सर्व करता है। Graph Node को प्रत्येक इंडेक्स किए गए नेटवर्क से डेटा एक्सपोज़ करने वाले एक एंडपॉइंट से कनेक्ट करने की आवश्यकता होती है; डेटा स्रोत करने के लिए एक IPFS नोड; अपने स्टोर के लिए एक PostgreSQL डेटाबेस; और Indexer घटकों से, जो इसे नेटवर्क के साथ इंटरैक्शन की सुविधा प्रदान करते हैं।

- **PostgreSQL डेटाबेस** - यह Graph Node के लिए मुख्य स्टोर है, जहाँ Subgraph डेटा संग्रहीत किया जाता है। Indexer सेवा और एजेंट भी इस डेटाबेस का उपयोग state channel डेटा, cost models, Indexing नियमों और allocation क्रियाओं को संग्रहीत करने के लिए करते हैं।

- **डेटा एंडपॉइंट** - EVM-संगत नेटवर्क्स के लिए, Graph Node को एक ऐसे एंडपॉइंट से कनेक्ट करने की आवश्यकता होती है जो EVM-संगत JSON-RPC API को एक्सपोज़ करता हो। यह एक सिंगल क्लाइंट के रूप में हो सकता है या यह एक अधिक जटिल सेटअप हो सकता है जो मल्टीपल क्लाइंट्स के बीच लोड बैलेंस करता हो। यह जानना महत्वपूर्ण है कि कुछ सबग्राफ को विशेष क्लाइंट क्षमताओं की आवश्यकता हो सकती है, जैसे कि आर्काइव मोड और/या पैरिटी ट्रेसिंग API।

- **IPFS node (संस्करण 5 से कम)** - सबग्राफ डिप्लॉयमेंट मेटाडेटा IPFS नेटवर्क पर स्टोर किया जाता है। The Graph Node मुख्य रूप से सबग्राफ डिप्लॉयमेंट के दौरान IPFS node तक पहुंचता है ताकि सबग्राफ मैनिफेस्ट और सभी लिंक की गई फ़ाइलों को प्राप्त किया जा सके। नेटवर्क Indexers को अपना स्वयं का IPFS node होस्ट करने की आवश्यकता नहीं है, नेटवर्क के लिए एक IPFS node होस्ट किया गया है: https://ipfs.network.thegraph.com.

- **Indexer सेवा** - आवश्यक बाहरी संचार को नेटवर्क के साथ संभालती है। लागत मॉडल और इंडेक्सिंग स्थितियों को साझा करती है, गेटवे से आने वाले क्वेरी अनुरोधों को एक Graph Node तक पहुंचाती है, और गेटवे के साथ स्टेट चैनलों के माध्यम से क्वेरी भुगतान को प्रबंधित करती है।

- **Indexer agent** - ऑनचेन पर Indexers की इंटरैक्शन को सुविधाजनक बनाता है, जिसमें नेटवर्क पर पंजीकरण करना, अपने ग्राफ-नोड पर सबग्राफ परिनियोजन का प्रबंधन करना और आवंटनों का प्रबंधन करना शामिल है।

- **Prometheus मेट्रिक्स सर्वर** - The Graph Node और Indexer घटक अपने मेट्रिक्स को मेट्रिक्स सर्वर में लॉग करते हैं।

कृपया ध्यान दें: चुस्त स्केलिंग का समर्थन करने के लिए, यह अनुशंसा की जाती है कि क्वेरी और indexing संबंधी चिंताओं को विभिन्न सेट के नोड्स के बीच विभाजित किया जाए: क्वेरी नोड्स और इंडेक्स नोड्स।

### पोर्ट्स का अवलोकन

> **महत्वपूर्ण**: पोर्ट्स को सार्वजनिक रूप से एक्सपोज़ करने में सावधानी बरतें - **प्रशासनिक पोर्ट्स** को सुरक्षित रखा जाना चाहिए। इसमें नीचे दिए गए Graph Node JSON-RPC और Indexer प्रबंधन एंडपॉइंट्स शामिल हैं।

#### ग्राफ-नोड

| पोर्ट | उद्देश्य                                        | रूट्स                                          | आर्गुमेंट्स        | पर्यावरण वेरिएबल्स |
| ----- | ----------------------------------------------- | ---------------------------------------------- | ------------------ | ------------------ |
| 8000  | GraphQL HTTP server<br />(for Subgraph queries) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port       | -                  |
| 8001  | GraphQL WS<br />(for Subgraph subscriptions)    | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port         | -                  |
| 8020  | JSON-RPC<br />(for managing deployments)        | /                                              | \--admin-port      | -                  |
| 8030  | Subgraph indexing status API                    | /graphql                                       | \--index-node-port | -                  |
| 8040  | Prometheus metrics                              | /metrics                                       | \--metrics-port    | -                  |

#### Indexer Service

| पोर्ट | उद्देश्य                                             | रूट्स                                                       | आर्गुमेंट्स     | पर्यावरण वेरिएबल्स     |
| ----- | ---------------------------------------------------- | ----------------------------------------------------------- | --------------- | ---------------------- |
| 7600  | GraphQL HTTP server<br />(for paid Subgraph queries) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port         | `INDEXER_SERVICE_PORT` |
| 7300  | Prometheus metrics                                   | /metrics                                                    | \--metrics-port | -                      |

#### Indexer Agent

| पोर्ट | Purpose                | रूट्स  | CLI Argument               | Environment Variable                    |
| ----- | ---------------------- | ------ | -------------------------- | --------------------------------------- |
| 8000  | Indexer management API | /      | \--indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Google Cloud पर Terraform का उपयोग करके सर्वर अवसंरचना सेटअप करें

> Indexers वैकल्पिक रूप से AWS, Microsoft Azure, या Alibaba का उपयोग कर सकते हैं।

#### आवश्यक पूर्वापेक्षाएँ स्थापित करें

- Google Cloud SDK
- Kubectl कमांड लाइन टूल
- Terraform

####  Google Cloud प्रोजेक्ट बनाएं

- Clone करें या [Indexer repository](https://github.com/graphprotocol/indexer) पर जाएं।

- `./terraform` डायरेक्टरी पर जाएं, यही वह स्थान है जहां सभी कमांड निष्पादित की जानी चाहिए।

```sh
cd terraform
```

- Google Cloud के साथ प्रमाणीकृत करें और एक नया प्रोजेक्ट बनाएं।

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Google Cloud Console के बिलिंग पेज का उपयोग करके नए प्रोजेक्ट के लिए बिलिंग सक्षम करें।

- Google Cloud कॉन्फ़िगरेशन बनाएँ।

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- आवश्यक Google Cloud APIs सक्षम करें।

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- सर्विस अकाउंट बनाएं।

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- डाटाबेस और Kubernetes क्लस्टर के बीच peering सक्षम करें, जो अगले चरण में बनाया जाएगा।

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- न्यूनतम Terraform कॉन्फ़िगरेशन फ़ाइल बनाएँ (आवश्यकतानुसार अपडेट करें)।

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database password>"
EOF
```

#### टेराफॉर्म का उपयोग करके इंफ्रास्ट्रक्चर बनाएं

[variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) फ़ाइल को पढ़ने के बाद, इस डायरेक्टरी में terraform.tfvars नाम की एक फ़ाइल बनाएँ (या पिछली स्टेप में बनाई गई फ़ाइल को संशोधित करें)। प्रत्येक वेरिएबल के लिए, जहाँ आप डिफ़ॉल्ट मान को ओवरराइड करना चाहते हैं या जहाँ आपको कोई मान सेट करने की आवश्यकता है, terraform.tfvars में एक सेटिंग दर्ज करें।

- इन्फ्रास्ट्रक्चर बनाने के लिए निम्नलिखित कमांड चलाएँ।

```sh
#आवश्यक प्लगइन इंस्टॉल करें
terraform init

#बनने वाले संसाधनों की योजना देखें
terraform plan

#संसाधनों का निर्माण करें (इसे पूरा होने में 30 मिनट तक लग सकते हैं)
terraform apply
```

नई क्लस्टर के लिए क्रेडेंशियल्स को ~/.kube/config में डाउनलोड करें और इसे अपने डिफ़ॉल्ट संदर्भ के रूप में सेट करें।

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Indexer के लिए Kubernetes घटकों का निर्माण

- डायरेक्टरी `k8s/overlays` को एक नई डायरेक्टरी `$dir` में कॉपी करें, और `$dir/kustomization.yaml` में `bases` एंट्री को इस तरह समायोजित करें कि यह `k8s/base` डायरेक्टरी की ओर इशारा करे।

- सभी फ़ाइलों को `$dir` में पढ़ें और टिप्पणियों में दिए गए निर्देशों के अनुसार किसी भी मान को समायोजित करें।

सभी संसाधनों को `kubectl apply -k $dir` के साथ परिनियोजित करें।

### ग्राफ-नोड

[Graph Node](https://github.com/graphprotocol/graph-node) एक ओपन सोर्स Rust इम्प्लीमेंटेशन है जो Ethereum ब्लॉकचेन को इवेंट सोर्स करके एक डेटा स्टोर को डिटर्मिनिस्टिक तरीके से अपडेट करता है, जिसे GraphQL एंडपॉइंट के जरिए क्वेरी किया जा सकता है। डेवलपर्स सबग्राफ का उपयोग करके अपनी स्कीमा को परिभाषित करते हैं और ब्लॉकचेन से सोर्स किए गए डेटा को ट्रांसफॉर्म करने के लिए एक सेट ऑफ मैपिंग्स बनाते हैं, और Graph Node पूरी चेन को सिंक करने, नए ब्लॉक्स की मॉनिटरिंग करने और इसे एक GraphQL एंडपॉइंट के जरिए सर्व करने का काम संभालता है।

#### सोर्स से शुरू करना

#### आवश्यक पूर्वापेक्षाएँ स्थापित करें

- **Rust**

- **PostgreSQL**

- **IPFS**

- **उबंटू उपयोगकर्ताओं के लिए अतिरिक्त आवश्यकताएँ** - उबंटू पर एक ग्राफ-नोड चलाने के लिए कुछ अतिरिक्त पैकेजों की आवश्यकता हो सकती है।

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### सेटअप

1. PostgreSQL डेटाबेस सर्वर शुरू करें

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. [Graph Node](https://github.com/graphprotocol/graph-node) रिपॉजिटरी को क्लोन करें और सोर्स को बिल्ड करने के लिए `cargo build` कमांड चलाएँ।

3. अब जब सभी dependencies सेटअप हो गई हैं, तो Graph Node शुरू करें:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Docker का उपयोग शुरू करना

#### आवश्यक शर्तें

- **Ethereum node** - By default, the docker compose setup will use mainnet: [http://host.docker.internal:8545](http://host.docker.internal:8545) to connect to the Ethereum node on your host machine. You can replace this network name and url by updating `docker-compose.yaml`.

#### सेटअप

1. Clone Graph Node and navigate to the Docker directory:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. For linux users only - Use the host IP address instead of `host.docker.internal` in the `docker-compose.yaml `using the included script:

```sh
./setup.sh
```

3. Start a local Graph Node that will connect to your Ethereum endpoint:

```sh
docker-compose up
```

### Indexer components

To successfully participate in the network requires almost constant monitoring and interaction, so we've built a suite of Typescript applications for facilitating an Indexers network participation. There are three Indexer components:

- **Indexer agent** - The agent monitors the network and the Indexer's own infrastructure and manages which Subgraph deployments are indexed and allocated towards onchain and how much is allocated towards each.

- **Indexer service** - The only component that needs to be exposed externally, the service passes on Subgraph queries to the graph node, manages state channels for query payments, shares important decision making information to clients like the gateways.

- **Indexer CLI** - The command line interface for managing the Indexer agent. It allows Indexers to manage cost models, manual allocations, actions queue, and indexing rules.

#### Getting started

The Indexer agent and Indexer service should be co-located with your Graph Node infrastructure. There are many ways to set up virtual execution environments for your Indexer components; here we'll explain how to run them on baremetal using NPM packages or source, or via kubernetes and docker on the Google Cloud Kubernetes Engine. If these setup examples do not translate well to your infrastructure there will likely be a community guide to reference, come say hi on [Discord](https://discord.gg/graphprotocol)! Remember to [stake in the protocol](/indexing/overview/#stake-in-the-protocol) before starting up your Indexer components!

#### From NPM packages

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### From source

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Using docker

- Pull images from the registry

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Or build images locally from source

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Run the components

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**NOTE**: After starting the containers, the Indexer service should be accessible at [http://localhost:7600](http://localhost:7600) and the Indexer agent should be exposing the Indexer management API at [http://localhost:18000/](http://localhost:18000/).

#### Using K8s and Terraform

See the [Setup Server Infrastructure Using Terraform on Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud) section

#### Usage

> **NOTE**: All runtime configuration variables may be applied either as parameters to the command on startup or using environment variables of the format `COMPONENT_NAME_VARIABLE_NAME`(ex. `INDEXER_AGENT_ETHEREUM`).

#### Indexer agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexer CLI

The Indexer CLI is a plugin for [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) accessible in the terminal at `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Indexer management using Indexer CLI

The suggested tool for interacting with the **Indexer Management API** is the **Indexer CLI**, an extension to the **Graph CLI**. The Indexer agent needs input from an Indexer in order to autonomously interact with the network on the behalf of the Indexer. The mechanism for defining Indexer agent behavior are **allocation management** mode and **indexing rules**. Under auto mode, an Indexer can use **indexing rules** to apply their specific strategy for picking Subgraphs to index and serve queries for. Rules are managed via a GraphQL API served by the agent and known as the Indexer Management API. Under manual mode, an Indexer can create allocation actions using **actions queue** and explicitly approve them before they get executed. Under oversight mode, **indexing rules** are used to populate **actions queue** and also require explicit approval for execution.

#### Usage

The **Indexer CLI** connects to the Indexer agent, typically through port-forwarding, so the CLI does not need to run on the same server or cluster. To help you get started, and to provide some context, the CLI will briefly be described here.

- `graph indexer connect <url>` - Connect to the Indexer management API. Typically the connection to the server is opened via port forwarding, so the CLI can be easily operated remotely. (Example: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Get one or more indexing rules using `all` as the `<deployment-id>` to get all rules, or `global` to get the global defaults. An additional argument `--merged` can be used to specify that deployment specific rules are merged with the global rule. This is how they are applied in the Indexer agent.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Set one or more indexing rules.

- `graph indexer rules start [options] <deployment-id>` - Start indexing a Subgraph deployment if available and set its `decisionBasis` to `always`, so the Indexer agent will always choose to index it. If the global rule is set to always then all available Subgraphs on the network will be indexed.

- `graph indexer rules stop [options] <deployment-id>` - Stop indexing a deployment and set its `decisionBasis` to never, so it will skip this deployment when deciding on deployments to index.

- `graph indexer rules maybe [options] <deployment-id>` — Set the `decisionBasis` for a deployment to `rules`, so that the Indexer agent will use indexing rules to decide whether to index this deployment.

- `graph indexer actions get [options] <action-id>` - Fetch one or more actions using `all` or leave `action-id` empty to get all actions. An additional argument `--status` can be used to print out all actions of a certain status.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Queue allocation action

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Queue reallocate action

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Queue unallocate action

- `graph indexer actions cancel [<action-id> ...]` - यदि ID निर्दिष्ट नहीं है, तो कतार में सभी कार्रवाइयों को रद्द करें, अन्यथा स्पेस से अलग की गई आईडी की सूची को रद्द करें।

- `graph indexer actions approve [<action-id> ...]` - कई क्रियाओं को निष्पादन के लिए अनुमोदित करें

- `graph indexer actions execute approve` - कार्यकर्ता को स्वीकृत क्रियाओं को तुरंत निष्पादित करने के लिए बाध्य करें

सभी कमांड जो आउटपुट में नियम दिखाते हैं, वे -output आर्गुमेंट का उपयोग करके समर्थित `-otuput` फ़ॉर्मेट (`table,` `yaml`, और `json`) में से किसी एक को चुन सकते हैं।

#### indexing नियम

Indexing नियमों को या तो वैश्विक डिफ़ॉल्ट के रूप में या विशिष्ट सबग्राफ डिप्लॉयमेंट्स के लिए उनकी IDs का उपयोग करके लागू किया जा सकता है। `deployment` और `decisionBasis` फ़ील्ड अनिवार्य हैं, जबकि सभी अन्य फ़ील्ड वैकल्पिक हैं। जब किसी Indexing नियम में `rules` को `decisionBasis` के रूप में सेट किया जाता है, तो Indexer एजेंट उस नियम पर दिए गए गैर-शून्य थ्रेशोल्ड मानों की तुलना नेटवर्क से प्राप्त मानों से संबंधित डिप्लॉयमेंट के लिए करेगा। यदि सबग्राफ डिप्लॉयमेंट के मान किसी भी थ्रेशोल्ड से ऊपर (या नीचे) होते हैं, तो इसे Indexing के लिए चुना जाएगा।

For example, अगर global rule का `minStake` **5** (GRT) है, तो कोई भी सबग्राफ deployment जिसमें 5 (GRT) से ज्यादा stake allocated है, उसे index किया जाएगा। Threshold rules में शामिल हैं `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, और `minAverageQueryFees`।

डेटा मॉडल:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

indexing नियम का उदाहरण उपयोग:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### कार्य सूची CLI

Indexer-cli एक `actions` मॉड्यूल प्रदान करता है जो मैन्युअल रूप से एक्शन कतार के साथ काम करने के लिए उपयोग किया जाता है। यह **Graphql API**, जो कि indexer management server द्वारा होस्ट की गई है, का उपयोग एक्शन कतार के साथ इंटरैक्ट करने के लिए करता है।

एक्शन एक्सीक्यूशन वर्कर केवल तभी कतार से आइटम उठाकर निष्पादित करेगा जब उनका `ActionStatus = approved` होगा। अनुशंसित मार्ग में, एक्शन को कतार में ActionStatus = queued के साथ जोड़ा जाता है, इसलिए उन्हें ऑनचेन निष्पादित होने के लिए अनुमोदित किया जाना चाहिए। सामान्य प्रवाह इस प्रकार होगा:

- 3rd party ऑप्टिमाइज़र टूल या indexer-cli उपयोगकर्ता द्वारा कतार में क्रिया जोड़ी गई है
- Indexer `indexer-cli` का उपयोग करके सभी कतारबद्ध क्रियाओं को देख सकता है।
- Indexer (या अन्य सॉफ़्टवेयर) `indexer-cli` का उपयोग करके कतार में क्रियाओं को मंजूरी या रद्द कर सकता है। मंजूरी और रद्द करने वाले आदेश एक्शन आईडीज़ के एक एरे को इनपुट के रूप में लेते हैं।
- निर्वाचन कार्यकर्ता नियमित रूप से क्यू से अनुमोदित क्रियाओं के लिए पोल करता है। यह क्यू से `approved` क्रियाओं को प्राप्त करेगा, उन्हें निष्पादित करने का प्रयास करेगा, और निष्पादन की स्थिति के आधार पर डाटाबेस में मानों को `success` या `failed` के रूप में अपडेट करेगा।
- अगर कोई क्रिया सफल होती है तो कर्मचारी यह सुनिश्चित करेगा कि एक indexing नियम मौजूद हो जो एजेंट को यह बताए कि आगे बढ़ते हुए आवंटन को कैसे प्रबंधित करना है, यह उस स्थिति में उपयोगी होता है जब एजेंट `auto` या `oversight` मोड में हो और मैन्युअल क्रियाएं ली जा रही हों।
- Indexer एक्शन कतार की निगरानी कर सकता है ताकि एक्शन निष्पादन के इतिहास को देखा जा सके और यदि आवश्यक हो, तो असफल निष्पादन वाले एक्शन आइटम्स को पुनः अनुमोदित और अपडेट किया जा सके। एक्शन कतार उन सभी एक्शनों का इतिहास प्रदान करती है जो कतारबद्ध और लिए गए हैं।

डेटा मॉडल:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

स्रोत से उदाहरण उपयोग:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Supported action types के लिए आवंटन प्रबंधन की विभिन्न इनपुट आवश्यकताएँ होती हैं:

- Allocate - किसी विशिष्ट सबग्राफ डिप्लॉयमेंट के लिए स्टेक आवंटित करें

  - आवश्यक क्रिया पैरामीटर्स:
    - deploymentID
    - राशि

- `अनुदेश हटाएं` - आवंटन बंद करें, जिससे दांव को मुक्त किया जा सके और इसे कहीं और पुनः आवंटित किया जा सके।

  - आवश्यक क्रिया पैरामीटर्स:
    - allocationID
    - deploymentID
  - वैकल्पिक क्रिया पैरामीटर:
    - poi
    - बल प्रयोग करें (दिए गए POI का उपयोग तब भी करें यदि यह ग्राफ-नोड द्वारा प्रदान किए गए से मेल नहीं खाता)

- `पुनः आवंटित करें` - परमाणु रूप से आवंटन को बंद करें और उसी Subgraph परिनियोजन के लिए एक नया आवंटन खोलें

  - आवश्यक क्रिया पैरामीटर:
    - allocationID
    - deploymentID
    - राशि
  - वैकल्पिक क्रिया पैरामीटर्स:
    - poi
    - बल (दिए गए POI का उपयोग करने के लिए मजबूर करता है, भले ही वह ग्राफ-नोड द्वारा प्रदान किए गए डेटा से मेल न खाए)

#### लागत मॉडल

कॉस्ट मॉडल बाज़ार और क्वेरी विशेषताओं के आधार पर क्वेरी के लिए डायनामिक मूल्य निर्धारण प्रदान करते हैं। Indexer Service प्रत्येक सबग्राफ के लिए गेटवे के साथ एक कॉस्ट मॉडल साझा करता है, जिसके लिए वे क्वेरी का जवाब देने का इरादा रखते हैं। बदले में, गेटवे इस कॉस्ट मॉडल का उपयोग प्रति क्वेरी Indexer चयन निर्णय लेने और चुने गए Indexers के साथ भुगतान पर बातचीत करने के लिए करते हैं।

#### Agora

Agora भाषा क्वेरी के लिए लागत मॉडल घोषित करने के लिए एक लचीला प्रारूप प्रदान करती है। एक Agora मूल्य मॉडल बयानों का एक क्रम होता है जो प्रत्येक शीर्ष-स्तरीय GraphQL क्वेरी के लिए क्रम में निष्पादित होता है। प्रत्येक शीर्ष-स्तरीय क्वेरी के लिए, पहला कथन जो उससे मेल खाता है, उस क्वेरी के लिए मूल्य निर्धारित करता है।

एक कथन में एक ​predicate​ होता है, जिसका उपयोग GraphQL queries से मिलान करने के लिए किया जाता है, और एक cost expression होता है, जो मूल्यांकन किए जाने पर दशमलव GRT में एक लागत आउटपुट करता है। किसी क्वेरी में नामित आर्गुमेंट स्थिति के मानों को predicate में कैप्चर किया जा सकता है और expression में उपयोग किया जा सकता है। Globals भी सेट किए जा सकते हैं और expression में प्लेसहोल्डर्स के लिए प्रतिस्थापित किए जा सकते हैं।

उदाहरण लागत मॉडल:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Example query costing using the above model:

| Query                                                                        | Price   |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### Applying the cost model

Cost models are applied via the Indexer CLI, which passes them to the Indexer Management API of the Indexer agent for storing in the database. The Indexer Service will then pick them up and serve the cost models to gateways whenever they ask for them.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interacting with the network

### Stake in the protocol

The first steps to participating in the network as an Indexer are to approve the protocol, stake funds, and (optionally) set up an operator address for day-to-day protocol interactions.

> Note: For the purposes of these instructions Remix will be used for contract interaction, but feel free to use your tool of choice ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), and [MyCrypto](https://www.mycrypto.com/account) are a few other known tools).

Once an Indexer has staked GRT in the protocol, the [Indexer components](/indexing/overview/#indexer-components) can be started up and begin their interactions with the network.

#### Approve tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **GraphToken.abi** with the [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. With `GraphToken.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the GraphToken contract address - Paste the GraphToken contract address (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) next to `At Address` and click the `At address` button to apply.

6. Call the `approve(spender, amount)` function to approve the Staking contract. Fill in `spender` with the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) and `amount` with the tokens to stake (in wei).

#### Stake tokens

1. Open the [Remix app](https://remix.ethereum.org/) in a browser

2. In the `File Explorer` create a file named **Staking.abi** with the staking ABI.

3. With `Staking.abi` selected and open in the editor, switch to the `Deploy and run transactions` section in the Remix interface.

4. Under environment select `Injected Web3` and under `Account` select your Indexer address.

5. Set the Staking contract address - Paste the Staking contract address (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) next to `At Address` and click the `At address` button to apply.

6. Call `stake()` to stake GRT in the protocol.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on Subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their `indexingRewardCut` (parts per million), `queryFeeCut` (parts per million), and `cooldownBlocks` (number of blocks). To do so call `setDelegationParameters()`. The following example sets the `queryFeeCut` to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the `indexingRewardCut` to distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set the `cooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### Setting delegation parameters

The `setDelegationParameters()` function in the [staking contract](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) is essential for Indexers, allowing them to set parameters that define their interactions with Delegators, influencing their reward sharing and delegation capacity.

### How to set delegation parameters

To set the delegation parameters using Graph Explorer interface, follow these steps:

1. Navigate to [Graph Explorer](https://thegraph.com/explorer/).
2. Connect your wallet. Choose multisig (such as Gnosis Safe) and then select mainnet. Note: You will need to repeat this process for Arbitrum One.
3. Connect the wallet you have as a signer.
4. Navigate to the 'Settings' section and select 'Delegation Parameters'. These parameters should be configured to achieve an effective cut within the desired range. Upon entering values in the provided input fields, the interface will automatically calculate the effective cut. Adjust these values as necessary to attain the desired effective cut percentage.
5. Submit the transaction to the network.

> Note: This transaction will need to be confirmed by the multisig wallet signers.

### The life of an allocation

After being created by an Indexer a healthy allocation goes through two states.

- **Active** - Once an allocation is created onchain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a Subgraph deployment, which allows them to claim indexing rewards and serve queries for that Subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - An Indexer is free to close an allocation once 1 epoch has passed ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) or their Indexer agent will automatically close the allocation after the **maxAllocationEpochs** (currently 28 days). When an allocation is closed with a valid proof of indexing (POI) their indexing rewards are distributed to the Indexer and its Delegators ([learn more](/indexing/overview/#how-are-indexing-rewards-distributed)).

Indexers are recommended to utilize offchain syncing functionality to sync Subgraph deployments to chainhead before creating the allocation onchain. This feature is especially useful for Subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
