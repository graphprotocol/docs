---
title: नई श्रृंखला एकीकरण
---

Chains can bring Subgraph support to their ecosystem by starting a new `graph-node` integration. Subgraphs are a powerful indexing tool opening a world of possibilities for developers. Graph Node already indexes data from the chains listed here. If you are interested in a new integration, there are 2 integration strategies:

1. EVM JSON-RPC
2. Firehose: सभी Firehose एकीकरण समाधान में Substreams शामिल हैं, जो Firehose पर आधारित एक बड़े पैमाने पर स्ट्रीमिंग इंजन है, जिसमें स्वदेशी `graph-node` समर्थन है, जो समानांतर रूपांतरण की अनुमति देता है।

> ध्यान दें कि जबकि अनुशंसित तरीका सभी नए चेन के लिए एक नया Firehose विकसित करना है, यह केवल गैर-EVM चेन के लिए आवश्यक है।

## एकीकरण रणनीतियाँ

### 1. EVM JSON-RPC

यदि ब्लॉकचेन EVM समान है और क्लाइंट/नोड मानक EVM JSON-RPC API को एक्सपोज़ करता है, तो Graph Node को नए चेन को इंडेक्स करने में सक्षम होना चाहिए।

#### Testing an EVM JSON-RPC

Graph Node को EVM चेन से डेटा इन्गेस्ट करने के लिए, RPC नोड को निम्नलिखित EVM JSON-RPC विधियों को एक्सपोज़ करना होगा:

- `eth_getLogs`
- eth_call (ऐतिहासिक ब्लॉक्स के लिए, EIP-1898 के साथ - आर्काइव नोड की आवश्यकता)
- `eth_getBlockByNumber`
- `eth_getBlockByHash`
- `net_version`
- `eth_getTransactionReceipt`, in a JSON-RPC batch request
- `trace_filter` _(सीमित ट्रेसिंग और विकल्पतः Graph Node के लिए आवश्यक)_

### 2. Firehose एकीकरण

[Firehose](https://firehose.streamingfast.io/firehose-setup/overview) एक अगली पीढ़ी की निष्कर्षण परत है। यह फ्लैट फ़ाइलों में इतिहास एकत्र करता है और वास्तविक समय में स्ट्रीम करता है। Firehose तकनीक उन पॉलिंग API कॉल्स को एक डेटा स्ट्रीम से बदल देती है, जो एक पुश मॉडल का उपयोग करती है, जिससे डेटा को इंडेक्सिंग नोड तक तेजी से भेजा जा सके। यह सिंकिंग और इंडेक्सिंग की गति बढ़ाने में मदद करता है।

> नोट: StreamingFast टीम द्वारा की गई सभी एकीकरणों में श्रृंखला के कोडबेस में Firehose प्रतिकृति प्रोटोकॉल के लिए रखरखाव शामिल है।StreamingFast किसी भी परिवर्तन को ट्रैक करता है और जब आप कोड बदलते हैं और जब StreamingFastकोड बदलता है, तो बाइनरी जारी करता है। इसमें प्रोटोकॉल के लिए Firehose/Substreamsबाइनरी जारी करना, श्रृंखला के ब्लॉक मॉडल के लिए Substreamsमॉड्यूल को बनाए रखना, और आवश्यकता होने पर ब्लॉकचेन नोड के लिए इंस्ट्रुमेंटेशन के साथ बाइनरी जारी करना शामिल है।

#### Integration for Non-EVM chains

फायरहोज़ को चेन में एकीकृत करने का प्राथमिक तरीका RPC पॉलिंग रणनीति का उपयोग करना है। हमारी पॉलिंग एल्गोरिदम नए ब्लॉक के आने का पूर्वानुमान लगाएगी और उस समय के करीब नए ब्लॉक के लिए जाँच करने की दर बढ़ा देगी, जिससे यह एक बहुत कम लेटेंसी और प्रभावी समाधान बन जाता है। फायरहोज़ के एकीकरण और रखरखाव में मदद के लिए, [स्ट्रीमिंगफास्ट टीम](https://www.streamingfast.io/firehose-integration-program) से संपर्क करें। नए चेन और उनके एकीकृतकर्ताओं को फायरहोज़ और सबस्ट्रीम द्वारा उनके पारिस्थितिकी तंत्र में लाए गए [फोर्क जागरूकता](https://substreams.streamingfast.io/documentation/consume/reliability-guarantees) और विशाल समानांतर इंडेक्सिंग क्षमताओं की सराहना होगी।

#### Specific Instrumentation for EVM (`geth`) chains

EVM चेन के लिए, एक गहरे स्तर के डेटा को प्राप्त करने के लिए `geth` [लाइव-ट्रेसर](https://github.com/ethereum/go-ethereum/releases/tag/v1.14.0) का उपयोग किया जाता है, जो गो-एथेरियम और स्ट्रीमिंगफास्ट के बीच सहयोग है, जो उच्च थ्रूपुट और समृद्ध लेनदेन ट्रेसिंग प्रणाली बनाने के लिए है। लाइव ट्रेसर सबसे व्यापक समाधान है, जो [विस्तारित](https://streamingfastio.medium.com/new-block-model-to-accelerate-chain-integration-9f65126e5425) ब्लॉक विवरण का परिणाम है। यह नए इंडेक्सिंग पैरेडाइम्स की अनुमति देता है, जैसे राज्य परिवर्तनों, कॉल्स, पैरेंट कॉल ट्रीज़ के आधार पर घटनाओं का पैटर्न मिलाना, या स्मार्ट कॉन्ट्रैक्ट में वास्तविक वेरिएबल्स में बदलाव के आधार पर घटनाओं को ट्रिगर करना।

![Base block vs Extended block](/img/extended-vs-base-substreams-blocks.png)

> नोट: Firehose में यह सुधार तब आवश्यक है जब चेन EVM इंजन `geth संस्करण 1.13.0` और उससे ऊपर का उपयोग करें।

## EVM विचार - JSON-RPC और Firehose के बीच का अंतर

While the JSON-RPC and Firehose are both suitable for Subgraphs, a Firehose is always required for developers wanting to build with [Substreams](https://substreams.streamingfast.io). Supporting Substreams allows developers to build [Substreams-powered Subgraphs](/subgraphs/cookbook/substreams-powered-subgraphs/) for the new chain, and has the potential to improve the performance of your Subgraphs. Additionally, Firehose — as a drop-in replacement for the JSON-RPC extraction layer of `graph-node` — reduces by 90% the number of RPC calls required for general indexing.

- All those `getLogs` calls and roundtrips get replaced by a single stream arriving into the heart of `graph-node`; a single block model for all Subgraphs it processes.

> NOTE: A Firehose-based integration for EVM chains will still require Indexers to run the chain's archive RPC node to properly index Subgraphs. This is due to the Firehose's inability to provide smart contract state typically accessible by the `eth_call` RPC method. (It's worth reminding that `eth_calls` are not a good practice for developers)

## Graph Node Configuration

Configuring Graph Node is as easy as preparing your local environment. Once your local environment is set, you can test the integration by locally deploying a Subgraph.

1. [Clone Graph Node](https://github.com/graphprotocol/graph-node)

2. Modify [this line](https://github.com/graphprotocol/graph-node/blob/master/docker/docker-compose.yml#L22) to include the new network name and the EVM JSON-RPC or Firehose compliant URL

   > कृपया पर्यावरण चर ethereum को खुद नाम में बदलें नहीं। यही रहना चाहिए, चाहे network का नाम भिन्न हो।

3. एक IPFS node चलाएं या उसे The Graph द्वारा उपयोग किया जाने वाले node का उपयोग करें: https://api.thegraph.com/ipfs/

## सबस्ट्रीम-संचालित सबग्राफ की सेवा

For StreamingFast-led Firehose/Substreams integrations, basic support for foundational Substreams modules (e.g. decoded transactions, logs and smart-contract events) and Substreams codegen tools are included. These tools enable the ability to enable [Substreams-powered Subgraphs](/substreams/sps/introduction/). Follow the [How-To Guide](https://substreams.streamingfast.io/documentation/how-to-guides/intro-your-first-application) and run `substreams codegen subgraph` to experience the codegen tools for yourself.
