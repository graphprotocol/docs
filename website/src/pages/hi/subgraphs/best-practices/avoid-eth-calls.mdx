---
title: सबग्राफ सर्वोत्तम प्रथा 4 - eth_calls से बचकर अनुक्रमण गति में सुधार करें
sidebarTitle: Avoiding eth_calls
---

## TLDR

`eth_calls` are calls that can be made from a Subgraph to an Ethereum node. These calls take a significant amount of time to return data, slowing down indexing. If possible, design smart contracts to emit all the data you need so you don’t need to use `eth_calls`.

## Eth_calls से बचना एक सर्वोत्तम अभ्यास क्यों है

Subgraphs are optimized to index event data emitted from smart contracts. A Subgraph can also index the data coming from an `eth_call`, however, this can significantly slow down Subgraph indexing as `eth_calls` require making external calls to smart contracts. The responsiveness of these calls relies not on the Subgraph but on the connectivity and responsiveness of the Ethereum node being queried. By minimizing or eliminating eth_calls in our Subgraphs, we can significantly improve our indexing speed.

### एक eth_call कैसा दिखता है?

`eth_calls` are often necessary when the data required for a Subgraph is not available through emitted events. For example, consider a scenario where a Subgraph needs to identify whether ERC20 tokens are part of a specific pool, but the contract only emits a basic `Transfer` event and does not emit an event that contains the data that we need:

```yaml
इवेंट Transfer(address indexed from, address indexed to, uint256 value);
```

मान लें कि टोकन्स की पूल सदस्यता एक state वेरिएबल getPoolInfo द्वारा निर्धारित होती है। इस मामले में, हमें इस डेटा को क्वेरी करने के लिए एक eth_call का उपयोग करना होगा:

```typescript
import { Address } from '@graphprotocol/graph-ts'
import { ERC20, Transfer } from '../generated/ERC20/ERC20'
import { TokenTransaction } from '../generated/schema'

export function handleTransfer(event: Transfer): void {
  let transaction = new TokenTransaction(event.transaction.hash.toHex())

  // दिए गए पते पर ERC20 कॉन्ट्रैक्ट इंस्टेंस को बाइंड करें:
  let instance = ERC20.bind(event.address)

  // eth_call के जरिए पूल जानकारी प्राप्त करें
  let poolInfo = instance.getPoolInfo(event.params.to)

  transaction.pool = poolInfo.toHexString()
  transaction.from = event.params.from.toHexString()
  transaction.to = event.params.to.toHexString()
  transaction.value = event.params.value

  transaction.save()
}
```

This is functional, however is not ideal as it slows down our Subgraph’s indexing.

## Eth_calls को कैसे समाप्त करें

आदर्श रूप से, स्मार्ट कॉन्ट्रैक्ट को सभी आवश्यक डेटा को इवेंट्स के भीतर प्रकट करने के लिए अपडेट किया जाना चाहिए। उदाहरण के लिए, स्मार्ट कॉन्ट्रैक्ट में इवेंट में पूल जानकारी शामिल करने के लिए संशोधन करने से eth_calls की आवश्यकता को समाप्त किया जा सकता है:

```
event TransferWithPool(address indexed from, address indexed to, uint256 value, bytes32 indexed poolInfo);
```

With this update, the Subgraph can directly index the required data without external calls:

```typescript
import { Address } from '@graphprotocol/graph-ts'
import { ERC20, TransferWithPool } from '../generated/ERC20/ERC20'
import { TokenTransaction } from '../generated/schema'

export function handleTransferWithPool(event: TransferWithPool): void {
  let transaction = new TokenTransaction(event.transaction.hash.toHex())

  transaction.pool = event.params.poolInfo.toHexString()
  transaction.from = event.params.from.toHexString()
  transaction.to = event.params.to.toHexString()
  transaction.value = event.params.value

  transaction.save()
}
```

यह बहुत अधिक प्रदर्शनकारी है क्योंकि इसने eth_calls की आवश्यकता को समाप्त कर दिया है।

## Eth_calls को ऑप्टिमाइज़ करने का तरीका

यदि स्मार्ट कॉन्ट्रैक्ट में परिवर्तन करना संभव नहीं है और eth_calls की आवश्यकता है, तो विभिन्न रणनीतियों को सीखने के लिए Improve Subgraph Indexing Performance Easily: Reduce eth_calls पढ़ें जो eth_calls को ऑप्टिमाइज़ करने के तरीके बताती है।

## Eth_calls के रनटाइम ओवरहेड को कम करना

जिन eth_calls को समाप्त नहीं किया जा सकता है, उनके द्वारा उत्पन्न रनटाइम ओवरहेड को मैनिफेस्ट में घोषित करके कम किया जा सकता है। जब graph-node एक ब्लॉक को प्रोसेस करता है, तो यह हैंडलर्स के चलने से पहले सभी घोषित eth_calls को समानांतर में प्रदर्शन करता है। जो कॉल घोषित नहीं हैं, वे हैंडलर्स के चलने के समय अनुक्रमिक रूप से निष्पादित होते हैं। रनटाइम में सुधार समानांतर में कॉल्स को करने से आता है, न कि अनुक्रमिक रूप से - यह कुल समय को कम करने में मदद करता है, लेकिन इसे पूरी तरह से समाप्त नहीं करता है।

वर्तमान में, eth_calls को केवल event handlers के लिए घोषित किया जा सकता है। मैनिफेस्ट में, लिखें

```yaml
इवेंट: TransferWithPool(address indexed, address indexed, uint256, bytes32 indexed)
हैंडलर: handleTransferWithPool
कॉल्स:
  ERC20.poolInfo: ERC20[event.address].getPoolInfo(event.params.to)
```

पीले रंग में हाइलाइट किया गया हिस्सा कॉल डिक्लेरेशन है। कॉल के पहले वाले हिस्से में जो टेक्स्ट लेबल है, वह केवल त्रुटि संदेशों के लिए उपयोग किया जाता है। कॉल के बाद वाला हिस्सा Contract[address].function(params) के रूप में होता है। address और params के लिए मान `event.address` और `event.params.<name>` अनुमेय हैं।

Handler स्वयं इस eth_call के परिणाम तक ठीक उसी तरह पहुंचता है जैसे पिछले अनुभाग में, अनुबंध से बाइंडिंग करके और कॉल करके। graph-node घोषित eth_calls के परिणामों को मेमोरी में कैश करता है और हैंडलर से कॉल इस मेमोरी कैश से परिणाम प्राप्त करेगा, बजाय इसके कि एक वास्तविक RPC कॉल की जाए।

Note: Declared eth_calls can only be made in Subgraphs with specVersion >= 1.2.0.

## निष्कर्ष

You can significantly improve indexing performance by minimizing or eliminating `eth_calls` in your Subgraphs.

## Subgraph Best Practices 1-6

1. [Improve Query Speed with Subgraph Pruning](/subgraphs/best-practices/pruning/)

2. [Improve Indexing and Query Responsiveness by Using @derivedFrom](/subgraphs/best-practices/derivedfrom/)

3. [Improve Indexing and Query Performance by Using Immutable Entities and Bytes as IDs](/subgraphs/best-practices/immutable-entities-bytes-as-ids/)

4. [Improve Indexing Speed by Avoiding `eth_calls`](/subgraphs/best-practices/avoid-eth-calls/)

5. [Simplify and Optimize with Timeseries and Aggregations](/subgraphs/best-practices/timeseries/)

6. [Use Grafting for Quick Hotfix Deployment](/subgraphs/best-practices/grafting-hotfix/)
