---
title: वितरित प्रणाली
---

ग्राफ़ एक वितरित प्रणाली के रूप में कार्यान्वित प्रोटोकॉल है।

कनेक्शन विफल। अनुरोध आदेश से बाहर आते हैं। आउट-ऑफ-सिंक घड़ियों वाले विभिन्न कंप्यूटर और राज्य संबंधित अनुरोधों को संसाधित करते हैं। सर्वर पुनरारंभ करें। अनुरोधों के बीच पुन: संगठन होते हैं। ये समस्याएँ सभी वितरित प्रणालियों में निहित हैं, लेकिन वैश्विक स्तर पर संचालित प्रणालियों में अधिक हैं।

इस उदाहरण पर विचार करें कि क्या हो सकता है यदि कोई ग्राहक किसी पुन: संगठन के दौरान नवीनतम डेटा के लिए एक अनुक्रमणिका का चुनाव करता है।

1. इंडेक्सर ब्लॉक 8 को निगलता है
2. क्लाइंट को ब्लॉक 8 के लिए अनुरोध दिया गया
3. इंडेक्सर ब्लॉक 9 को निगलता है
4. इंडेक्सर ब्लॉक 10A को निगलता है
5. ग्राहक को ब्लॉक 10A के लिए अनुरोध दिया गया
6. इंडेक्सर 10B पर रीऑर्ग का पता लगाता है और 10A को रोल बैक करता है
7. क्लाइंट को ब्लॉक 9 के लिए अनुरोध दिया गया
8. इंडेक्सर ब्लॉक 10बी लेता है
9. इंडेक्सर ब्लॉक 11 को निगलता है
10. ग्राहक को ब्लॉक 11 के लिए अनुरोध दिया गया

इंडेक्सर की दृष्टि से चीजें तार्किक रूप से आगे बढ़ रही हैं। समय आगे बढ़ रहा है, हालांकि हमें एक अंकल ब्लॉक को वापस रोल करना पड़ा और इसके शीर्ष पर आम सहमति के तहत ब्लॉक खेलना पड़ा। रास्ते में, इंडेक्सर उस समय के बारे में नवीनतम स्थिति का उपयोग करके अनुरोधों को पूरा करता है।

हालाँकि, क्लाइंट के दृष्टिकोण से, चीजें अव्यवस्थित दिखाई देती हैं। क्लाइंट देखता है कि प्रतिक्रियाएँ उसी क्रम में ब्लॉक 8, 10, 9 और 11 के लिए थीं। हम इसे "ब्लॉक वॉबल" समस्या कहते हैं। जब कोई क्लाइंट ब्लॉक डगमगाने का अनुभव करता है, तो डेटा समय के साथ विरोधाभासी प्रतीत हो सकता है। स्थिति तब और खराब हो जाती है जब हम यह मानते हैं कि सभी अनुक्रमणिकाएँ एक साथ नवीनतम ब्लॉकों को ग्रहण नहीं करती हैं, और आपके अनुरोध एकाधिक अनुक्रमणकों को भेजे जा सकते हैं।

उपयोगकर्ता को लगातार डेटा प्रदान करने के लिए एक साथ काम करना क्लाइंट और सर्वर की जिम्मेदारी है। वांछित स्थिरता के आधार पर विभिन्न दृष्टिकोणों का उपयोग किया जाना चाहिए क्योंकि हर समस्या के लिए कोई एक सही कार्यक्रम नहीं है।

वितरित सिस्टम के प्रभाव के माध्यम से तर्क करना कठिन है, लेकिन समाधान नहीं हो सकता है! हमने कुछ सामान्य उपयोग-मामलों को नेविगेट करने में आपकी सहायता के लिए API और पैटर्न स्थापित किए हैं। निम्नलिखित उदाहरण उन पैटर्नों को चित्रित करते हैं लेकिन फिर भी मुख्य विचारों को अस्पष्ट नहीं करने के लिए उत्पादन कोड (जैसे त्रुटि प्रबंधन और रद्दीकरण) द्वारा आवश्यक विवरणों को दूर करते हैं।

## अद्यतन डेटा के लिए मतदान

The Graph block: `{ number_gte: $minBlock }` API प्रदान करता है, जो यह सुनिश्चित करता है कि प्रतिक्रिया एक ही ब्लॉक के लिए होगी जो `$minBlock` के बराबर या उससे अधिक होगा। यदि अनुरोध `ग्राफ-नोड` instances पर किया जाता है और न्यूनतम ब्लॉक अभी तक सिंक नहीं हुआ है, तो graph-node एक त्रुटि लौटाएगा। यदि `ग्राफ-नोड` ने न्यूनतम ब्लॉक को सिंक कर लिया है, तो यह नवीनतम ब्लॉक के लिए प्रतिक्रिया चलाएगा। यदि अनुरोध Edge & Node Gateway को किया जाता है, तो Gateway उन Indexers को फ़िल्टर कर देगा जिन्होंने अभी तक न्यूनतम ब्लॉक को सिंक नहीं किया है और उस नवीनतम ब्लॉक के लिए अनुरोध करेगा जिसे Indexer ने सिंक किया है।

हम `number_gte` का उपयोग यह सुनिश्चित करने के लिए कर सकते हैं कि डेटा को लूप में पोल करते समय समय कभी पीछे न जाए। यहाँ एक उदाहरण है

````javascript
/// एक लूप में नवीनतम ज्ञात मान को लाने के लिए The Graph का उपयोग करके
/// protocol.paused वेरिएबल को अपडेट करता है।
async function updateProtocolPaused() {
  // minBlock को 0 से शुरू करना ठीक है। क्वेरी को
  // नवीनतम उपलब्ध ब्लॉक का उपयोग करके परोसा जाएगा। minBlock को 0 सेट करना
  // उसी के समान है जैसे इस आर्गुमेंट को छोड़ देना।
  let minBlock = 0

  for (;;) {
    // एक प्रॉमिस शेड्यूल करें जो तभी तैयार होगी जब
    // अगला Ethereum ब्लॉक उपलब्ध होने की संभावना होगी।
    const nextBlock = new Promise((f) => {
      setTimeout(f, 14000)
    })

    const query = `
        query GetProtocol($minBlock: Int!) {
            protocol(block: { number_gte: $minBlock }  id: "0") {
              paused
            }
            _meta {
                block {
                    number
                }
            }
        }`

    const variables = { minBlock }
    const response = await graphql(query, variables)
    minBlock = response._meta.block.number

    // TODO: यहाँ डेटा के साथ कुछ करें, केवल इसे लॉग करने के बजाय।
    console.log(response.protocol.paused)

    // अगले ब्लॉक की प्रतीक्षा करने के लिए स्लीप करें
    await nextBlock
  }
}
```
````

## संबंधित वस्तुओं का एक सेट लाया जा रहा है

एक अन्य उपयोग-मामला एक बड़े सेट को पुनः प्राप्त कर रहा है, या अधिक सामान्यतः, कई अनुरोधों में संबंधित वस्तुओं को पुनः प्राप्त कर रहा है। मतदान के मामले के विपरीत (जहां वांछित स्थिरता समय में आगे बढ़ने के लिए थी), वांछित स्थिरता समय में एक बिंदु के लिए है।

यहां हम सभी परिणामों को एक ही ब्लॉक पर पिन करने के लिए `block: { hash: $blockHash }` आर्गुमेंट का उपयोग करेंगे।

```javascript
/// पृष्ठांकन का उपयोग करके एकल ब्लॉक से डोमेन नामों की सूची प्राप्त करता है
async function getDomainNames() {
  // खींचे जाने वाले अधिकतम आइटम की एक सीमा निर्धारित करें।
  let pages = 5
  const perPage = 1000

  // पहली क्वेरी पहले पृष्ठ के परिणाम प्राप्त करेगी और ब्लॉक हैश भी प्राप्त करेगी
  // ताकि शेष क्वेरी पहले के अनुरूप हों।
  const listDomainsQuery = `
    query ListDomains($perPage: Int!) {
        domains(first: $perPage) {
            name
            id
        }
        _meta {
            block {
                hash
            }
        }
    }`

  let data = await graphql(listDomainsQuery, { perPage })
  let result = data.domains.map((d) => d.name)
  let blockHash = data._meta.block.hash

  let query
  // अतिरिक्त पृष्ठों को तब तक प्राप्त करना जारी रखें जब तक कि हम या तो 5 पृष्ठों की सीमा तक न पहुँच जाएँ
  // (ऊपर निर्दिष्ट) या हमें यह पता चल जाए कि हम अंतिम पृष्ठ तक पहुँच चुके हैं क्योंकि
  // पृष्ठ में पूर्ण पृष्ठ की तुलना में कम इकाइयाँ हैं।
  while (data.domains.length == perPage && --pages) {
    let lastID = data.domains[data.domains.length - 1].id
    query = `
        query ListDomains($perPage: Int!, $lastID: ID!, $blockHash: Bytes!) {
            domains(first: $perPage, where: { id_gt: $lastID }, block: { hash: $blockHash }) {
                name
                id
            }
        }`

    data = await graphql(query, { perPage, lastID, blockHash })

    // परिणाम में डोमेन नामों को संचित करें
    for (domain of data.domains) {
      result.push(domain.name)
    }
  }
  return result
}
```

ध्यान दें कि री-ऑर्गन के मामले में, क्लाइंट को ब्लॉक हैश को गैर-अंकल ब्लॉक में अपडेट करने के पहले अनुरोध से पुनः प्रयास करने की आवश्यकता होगी।
