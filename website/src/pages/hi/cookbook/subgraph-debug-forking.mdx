---
title: फोर्क्स का उपयोग करके त्वरित और आसान सबग्राफ डिबगिंग
---

बड़ी मात्रा में डेटा को संसाधित करने वाली कई प्रणालियों के साथ, ग्राफ़ के इंडेक्सर्स (ग्राफ़ नोड्स) को लक्ष्य ब्लॉकचेन के साथ आपके सबग्राफ़ को सिंक-अप करने में कुछ समय लग सकता है। डिबगिंग के उद्देश्य से त्वरित परिवर्तन और अनुक्रमण के लिए आवश्यक लंबे प्रतीक्षा समय के बीच विसंगति अत्यंत प्रतिकूल है और हम इसके बारे में अच्छी तरह से जानते हैं। यही कारण है कि हम [LimeChain](https://limechain.tech/) द्वारा विकसित **सबग्राफ फोर्किंग** की शुरुआत कर रहे हैं, और इस लेख में मैं आपको दिखाऊंगा कि कैसे इस सुविधा का उपयोग सबग्राफ डिबगिंग में तेजी लाने के लिए किया जा सकता है!

## ठीक है वो क्या है?

**सबग्राफ फोर्किंग** आलसी ढंग से _दूसरे_ सबग्राफ के स्टोर (आमतौर पर एक परोक्ष सबग्राफ) से इकाइयां को लाने की प्रक्रिया है।

डिबगिंग के संदर्भ में, **सबग्राफ फोर्किंग** आपको ब्लॉक*X* को सिंक-अप करने के लिए बिना प्रतीक्षा किए ब्लॉक _X_ पर अपने विफल सबग्राफ को डीबग करने की अनुमति देता है ।

## क्या?! कैसे?

जब आप अनुक्रमण के लिए एक दूरस्थ ग्राफ़ नोड पर एक सबग्राफ तैनात करते हैं और यह ब्लॉक _X_ करने में विफल रहता है, तो अच्छी खबर यह है कि ग्राफ़ नोड अभी भी अपने स्टोर का उपयोग करके ग्राफ़क्यूएल क्वेरी को सर्व करेगा, जो ब्लॉक*X* में सिंक-अप है। एक दम बढ़िया! इसका मतलब यह है कि ब्लॉक _X_ को अनुक्रमित करते समय उत्पन्न होने वाली बग को ठीक करने के लिए हम इस "अप-टू-डेट" स्टोर का लाभ उठा सकते हैं।

संक्षेप में, हम एक दूरस्थ ग्राफ नोड से _असफल सबग्राफ को फोर्क करने जा रहे हैं_ जो सबग्राफ को ब्लॉक _X_ तक अनुक्रमित होने की गारंटी देता है ताकि ब्लॉक _X_ पर डिबग किए जा रहे स्थानीय रूप से तैनात सबग्राफ को इंडेक्सिंग स्थिति का एक अप-टू-डेट दृश्य प्रदान हो सकें।

## कृपया मुझे कुछ कोड दिखाओ!

सबग्राफ डिबगिंग पर ध्यान केंद्रित करने के लिए, आइए चीजों को सरल रखें और एथेरियम ग्रेविटी स्मार्ट कॉन्ट्रैक्ट को इंडेक्स करने वाले [उदाहरण-सबग्राफ](https://github.com/graphprotocol/graph-tooling/tree/main/examples/ethereum-gravatar) के साथ चलें।

`Gravatar`s को अनुक्रमणित करने के लिए परिभाषित हैंडलर यहां दिए गए हैं, बिना किसी बग के:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

ओह, कितना दुर्भाग्यपूर्ण है, जब मैं [होस्टेड सेवा](https://thegraph.com/hosted-service/) पर अपना सटीक दिखने वाला सबग्राफ तैनात करता हूं, तो यह _"ग्रेवटार नहीं मिला!"_ त्रुटि के साथ विफल हो जाता है|

फिक्स का प्रयास करने का सामान्य तरीका है:

1. मैपिंग सोर्स में बदलाव करें, जो आपको लगता है कि समस्या का समाधान करेगा (जबकि मुझे पता है कि यह नहीं होगा)।
2. सबग्राफ को [होस्टेड सेवा](https://thegraph.com/hosted-service/) (या अन्य दूरस्थ ग्राफ़ नोड) में फिर से तैनात करें।
3. इसके सिंक-अप होने की प्रतीक्षा करें।
4. यदि यह फिर से टूट जाता है तो 1 पर वापस जाएँ, अन्यथा: हुर्रे!

यह वास्तव में एक सामान्य डिबग प्रक्रिया से काफी परिचित है, लेकिन एक कदम है जो प्रक्रिया को बहुत धीमा कर देता है: _3. इसके सिंक-अप होने की प्रतीक्षा करें।_

**सबग्राफ फोर्किंग** का उपयोग करके हम अनिवार्य रूप से इस चरण को समाप्त कर सकते हैं। यहाँ यह कैसा दिखता है:

0. **_उपयुक्त फ़ोर्क-बेस_** सेट के साथ स्थानीय ग्राफ़ नोड को स्पिन-अप करें।
1. मैपिंग सोर्स में परिवर्तन करें, जिसके बारे में आपको लगता है कि इससे समस्या हल हो जाएगी.
2. स्थानीय ग्राफ़ नोड में तैनात करें, **_असफल सबग्राफ़ को फोर्क करना_** और ** _समस्याग्रस्त ब्लॉक से शुरू_**।
3. यदि यह फिर से ब्रेक जाता है, तो 1 पर वापस जाएँ, अन्यथा: हुर्रे!

अब, आपके 2 प्रश्न हो सकते हैं:

1. फोर्क-बेस क्या???
2. फोर्किंग कौन?!

और मैं उत्तर देता हूं:

1. `fork-base` "आधार" URL है, जैसे कि जब _सबग्राफ आईडी_ जोड़ा जाता है तो परिणामी URL (`<fork-base>/<subgraph-id>`) सबग्राफ के स्टोर के लिए एक मान्य ग्राफ़क्यूएल एंडपॉइंट है।
2. फोर्किंग आसान है, पसीना बहाने की जरूरत नहीं:

```bash
$ graph deploy <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

साथ ही, सबग्राफ मेनिफ़ेस्ट में `dataSources.source.startBlock` फ़ील्ड को समस्याग्रस्त ब्लॉक की संख्या पर सेट करना न भूलें, ताकि आप अनावश्यक ब्लॉकों को इंडेक्सिंग करना छोड़ सकें और फोर्क का लाभ उठा सकें!

तो, यहाँ मैं क्या करता हूँ:

0. मैं एक स्थानीय ग्राफ नोड को स्पिन-अप करता हूं ([यह कैसे करना है](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) `fork-base` विकल्प के साथ: `https://api.thegraph.com/subgraphs/id/` पर सेट किया गया है, क्यों की मैं एक सबग्राफ को फोर्क करूंगा, जिस बग्गी को मैंने तैनात किया है पहले, [HostedService](https://thegraph.com/hosted-service/) से।

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

1. सावधानीपूर्वक निरीक्षण के बाद मैंने देखा कि मेरे दो हैंडलर में `Gravatar` को अनुक्रमित करते समय उपयोग किए जाने वाले `id` अभ्यावेदन में एक बेमेल है। जबकि `handleNewGravatar` इसे हेक्स (`event.params.id.toHex()`) में बदल देता है, `handleUpdatedGravatar` एक int32 (`event. params.id.toI32()`) जो "Gravatar नहीं मिला!" से घबराने के लिए `handleUpdatedGravatar` का कारण बनता है। मैं उन दोनों को `आईडी` को हेक्स में बदलने के लिए तैयार करता हूं।
2. परिवर्तन करने के बाद मैंने अपने सबग्राफ को स्थानीय ग्राफ़ नोड में तैनात किया, **_असफल सबग्राफ़ को फोर्क करना_** और `dataSources.source.startBlock` से `6190343` को `subgraph.yaml`में सेटिंग किया:

```bash
$ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

3. मैं स्थानीय ग्राफ़ नोड द्वारा निर्मित लॉग का निरीक्षण करता हूं और, हुर्रे!, सब कुछ काम करने लगता है।
4. मैं अपने अब बग-मुक्त सबग्राफ को एक दूरस्थ ग्राफ़ नोड पर तैनात करता हूं और हमेशा के बाद खुशी से रहता हूं! (कोई आलू नहीं)
5. समाप्त...
