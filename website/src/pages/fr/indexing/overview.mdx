---
title: Vue d’ensemble de l’indexation
sidebarTitle: Aperçu
---

Les indexeurs sont des opérateurs de nœuds dans The Graph Network qui mettent en jeu des jetons Graph (GRT) afin de fournir des services d'indexation et de traitement de requêtes. Les indexeurs perçoivent des frais de requête et des récompenses d'indexation pour leurs services. Ils perçoivent également des frais de requête qui sont réduits selon une fonction de remise exponentielle.

Le GRT intégré au protocole est soumis à une période de décongélation et peut être réduit si les indexeurs sont malveillants et fournissent des données incorrectes aux applications ou s'ils indexent de manière incorrecte. Les indexeurs gagnent également des récompenses pour la participation déléguée des délégués, afin de contribuer au réseau.

Indexers select Subgraphs to index based on the Subgraph’s curation signal, where Curators stake GRT in order to indicate which Subgraphs are high-quality and should be prioritized. Consumers (eg. applications) can also set parameters for which Indexers process queries for their Subgraphs and set preferences for query fee pricing.

## FAQ

### Quelle est le staking minimal requise pour être Indexeur sur le réseau ?

Le staking minimal pour un Indexeur est actuellement fixée à 100 000 GRT.

### Quelles sont les sources de revenus d'un Indexeur ?

**Rabais de frais de requête** - Paiements pour servir les requêtes sur le réseau. Ces paiements sont effectués par l'intermédiaire de canaux d'état entre un Indexeur et une passerelle. Chaque demande de requête provenant d'une passerelle contient un paiement et la réponse correspondante est une preuve de la validité du résultat de la requête.

**Indexing rewards** - Generated via a 3% annual protocol wide inflation, the indexing rewards are distributed to Indexers who are indexing Subgraph deployments for the network.

### Comment les récompenses d'indexation sont-elles distribuées ?

Indexing rewards come from protocol inflation which is set to 3% annual issuance. They are distributed across Subgraphs based on the proportion of all curation signal on each, then distributed proportionally to Indexers based on their allocated stake on that Subgraph. **An allocation must be closed with a valid proof of indexing (POI) that meets the standards set by the arbitration charter in order to be eligible for rewards.**

De nombreux outils ont été créés par la communauté pour calculer les récompenses ; vous en trouverez une collection organisée dans la [Collection des guides de la communauté](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). Vous pouvez également trouver une liste actualisée d'outils dans les canaux #Delegators et #Indexers sur le [serveur Discord](https://discord.gg/graphprotocol). Nous présentons ici un lien vers un [optimiseur d'allocation recommandé](https://github.com/graphprotocol/allocation-optimizer) intégré à la pile logicielle de l'Indexeur.

### Qu'est-ce qu'une preuve d'indexation (POI) ?

POIs are used in the network to verify that an Indexer is indexing the Subgraphs they have allocated on. A POI for the first block of the current epoch must be submitted when closing an allocation for that allocation to be eligible for indexing rewards. A POI for a block is a digest for all entity store transactions for a specific Subgraph deployment up to and including that block.

### Quand les récompenses d'indexation sont-elles distribuées ?

Les allocations accumulent continuellement des récompenses tant qu'elles sont actives et allouées dans un délai de 28 époques. Les récompenses sont collectées par les Indexeurs et distribuées lorsque leurs allocations sont fermées. Cela se fait soit manuellement, lorsque l'Indexeur veut forcer la fermeture, soit après 28 époques, un Déléguateur peut fermer l'allocation pour l'Indexeur, mais cela n'entraîne pas de récompenses. 28 époques est la durée de vie maximale d'une allocation (actuellement, une époque dure environ 24 heures).

### Les récompenses d'indexation en attente peuvent-elles être surveillées ?

Le contrat RewardsManager dispose d'une fonction en lecture seule [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316) qui peut être utilisée pour vérifier les récompenses en attente pour une allocation spécifique.

De nombreux tableaux de bord élaborés par la communauté comprennent des valeurs de récompenses en attente et il est facile de les vérifier manuellement en suivant les étapes suivantes :

1. Query the [mainnet Subgraph](https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one) to get the IDs for all active allocations:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Utilisez Etherscan pour appeler `getRewards()` :

- Naviguer vers [l'Interface Etherscan pour le contrat de récompenses] (https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)
- Pour appeler `getRewards()` :
  - Développez la liste déroulante **9. getRewards**.
  - Saisissez l'**allocationID** dans le champ de saisie.
  - Cliquez sur le bouton **Query**.

### Que sont les litiges et où puis-je les consulter ?

Les requêtes et les allocations des Indexeurs peuvent toutes deux être contestées sur The Graph pendant la période de contestation. La période de contestation varie en fonction du type de contestation. Les requêtes/attestations ont une fenêtre de contestation de 7 époques, tandis que les attributions ont une fenêtre de 56 époques. Une fois ces périodes écoulées, il n'est plus possible d'ouvrir un litige contre une allocation ou une requête. Lorsqu'un litige est ouvert, un dépôt d'un minimum de 10 000 GRT est exigé par les Fisherman, qui sera bloqué jusqu'à ce que le litige soit finalisé et qu'une résolution ait été donnée. Les Fisherman sont tous les participants au réseau qui ouvrent des litiges.

Les litiges ont **trois** issues possibles, tout comme le dépôt des Fishermen.

- Si le litige est rejeté, les GRT déposées par le Fishermen seront brûlées et l’Indexeur accusé n’est pas « slashed » (aucune pénalité).
- Si le litige se solde par un match nul, la caution du Fisherman sera restituée et l’Indexeur mis en cause n’est pas pénalisé.
- Si le litige est accepté, les GRT déposés par le Fisherman lui seront restitués, l’Indexeur mis en cause sera pénalisé (slashed) et le Fisherman recevra 50 % des GRT ainsi confisqués.

Les litiges peuvent être consultés dans l'interface utilisateur sur la page de profil d'un indexeur sous l'onglet `Disputes`.

### Que sont les query fee rebates et quand sont-ils distribués ?

Les frais de requête sont collectés par la passerelle et distribués aux Indexeurs selon la fonction de ristourne exponentielle (exponential rebate function, voir GIP à ce sujet [ici](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). Cette fonction est proposée comme un moyen de garantir que les Indexeurs obtiennent le meilleur résultat en répondant fidèlement aux requêtes. Elle incite les Indexeurs à allouer un montant élevé de staking (qui peut être réduit en cas d'erreur lors du service d'une requête) par rapport au montant des frais de requête qu'ils peuvent percevoir.

Une fois l’allocation clôturée, les ristournes peuvent être réclamées par l’Indexeur. Une fois réclamées, ces ristournes sur les frais de requête sont partagées entre l’Indexeur et ses Délégateurs, conformément au query fee cut et à la fonction de ristourne exponentielle.

### Que sont les query fee cut et l’indexing reward cut ?

Les valeurs `queryFeeCut` et `indexingRewardCut` sont des paramètres de délégation que l'Indexeur peut définir avec les cooldownBlocks pour contrôler la distribution des GRT entre l'Indexeur et ses Déléguateurs. Voir les dernières étapes de [Staking dans le Protocol](/indexing/overview/#stake-in-the-protocol) pour les instructions sur la définition des paramètres de délégation.

- **queryFeeCut** - le pourcentage des remises sur les frais de requête qui sera distribué à l'Indexeur. Si cette valeur est fixée à 95 %, l'indexeur recevra 95 % des frais de requête perçus lors de la clôture d'une allocation, les 5 % restants revenant aux Déléguateurs.

- **indexingRewardCut** - le pourcentage des récompenses d'indexation qui sera distribué à l'Indexeur. Si cette valeur est fixée à 95 %, l'Indexeur recevra 95 % des récompenses d'indexation lorsqu'une allocation est clôturée et les Déléguateurs se partageront les 5 % restants.

### How do Indexers know which Subgraphs to index?

Indexers may differentiate themselves by applying advanced techniques for making Subgraph indexing decisions but to give a general idea we'll discuss several key metrics used to evaluate Subgraphs in the network:

- **Curation signal** - The proportion of network curation signal applied to a particular Subgraph is a good indicator of the interest in that Subgraph, especially during the bootstrap phase when query volume is ramping up.

- **Query fees collected** - The historical data for volume of query fees collected for a specific Subgraph is a good indicator of future demand.

- **Amount staked** - Monitoring the behavior of other Indexers or looking at proportions of total stake allocated towards specific Subgraphs can allow an Indexer to monitor the supply side for Subgraph queries to identify Subgraphs that the network is showing confidence in or Subgraphs that may show a need for more supply.

- **Subgraphs with no indexing rewards** - Some Subgraphs do not generate indexing rewards mainly because they are using unsupported features like IPFS or because they are querying another network outside of mainnet. You will see a message on a Subgraph if it is not generating indexing rewards.

### Quelles sont les exigences en matière de matériel ?

- **Small** - Enough to get started indexing several Subgraphs, will likely need to be expanded.
- **Standard** - Configuration par défaut, c'est ce qui est utilisé dans les manifestes de déploiement de l'exemple k8s/terraform.
- **Medium** - Production Indexer supporting 100 Subgraphs and 200-500 requests per second.
- **Large** - Prepared to index all currently used Subgraphs and serve requests for the related traffic.

| Configuration | Postgres<br />(CPUs) | Postgres<br />(mémoire en Go) | Postgres<br />(disque en To) | VMs<br />(CPUs) | VMs<br />(mémoire en Go) |
| --- | :-: | :-: | :-: | :-: | :-: |
| Petit | 4 | 8 | 1 | 4 | 16 |
| Standard | 8 | 30 | 1 | 12 | 48 |
| Moyen | 16 | 64 | 2 | 32 | 64 |
| Grand | 72 | 468 | 3.5 | 48 | 184 |

### Quelles sont les précautions de sécurité de base qu'un Indexeur doit prendre ?

- **Portefeuille de l'opérateur** - La mise en place d'un portefeuille de l'opérateur est une précaution importante car elle permet à un Indexeur de maintenir une séparation entre les clés qui contrôlent le stajing et celles qui contrôlent les opérations quotidiennes. Voir [Staking dans le Protocol](/indexing/overview/#stake-in-the-protocol) pour les instructions.

- **Firewall** - Seul le service de l'Indexeur doit être exposé publiquement et une attention particulière doit être portée au verrouillage des ports d'administration et de l'accès à la base de données : l'endpoint JSON-RPC de Graph Node (port par défaut : 8030), l'endpoint de l'API de gestion de l'Indexeur (port par défaut : 18000), et l'enpoint de la base de données Postgres (port par défaut : 5432) ne doivent pas être exposés.

## Infrastructure

At the center of an Indexer's infrastructure is the Graph Node which monitors the indexed networks, extracts and loads data per a Subgraph definition and serves it as a [GraphQL API](/about/#how-the-graph-works). The Graph Node needs to be connected to an endpoint exposing data from each indexed network; an IPFS node for sourcing data; a PostgreSQL database for its store; and Indexer components which facilitate its interactions with the network.

- **PostgreSQL database** - The main store for the Graph Node, this is where Subgraph data is stored. The Indexer service and agent also use the database to store state channel data, cost models, indexing rules, and allocation actions.

- **Data endpoint** - For EVM-compatible networks, Graph Node needs to be connected to an endpoint that exposes an EVM-compatible JSON-RPC API. This may take the form of a single client or it could be a more complex setup that load balances across multiple. It's important to be aware that certain Subgraphs will require particular client capabilities such as archive mode and/or the parity tracing API.

- **IPFS node (version less than 5)** - Subgraph deployment metadata is stored on the IPFS network. The Graph Node primarily accesses the IPFS node during Subgraph deployment to fetch the Subgraph manifest and all linked files. Network Indexers do not need to host their own IPFS node, an IPFS node for the network is hosted at https://ipfs.network.thegraph.com.

- **Service de l'Indexeur** - Gère toutes les communications externes requises avec le réseau. Il partage les modèles de coûts et les états d'indexation, transmet les requêtes des passerelles à un Graph Node et gère les paiements des requêtes via des canaux d'état avec la passerelle.

- **Indexer agent** - Facilitates the Indexers interactions onchain including registering on the network, managing Subgraph deployments to its Graph Node/s, and managing allocations.

- **Serveur de métriques Prometheus** - Les composants Graph Node et Indexeur enregistrent leurs métriques sur le serveur de métriques.

Remarque : pour permettre une mise à l'échelle souple, il est recommandé de séparer les préoccupations de requête et d'indexation soient séparés différents ensembles de nœuds : les nœuds de requête et les nœuds d'indexation.

### Vue d'ensemble des ports

> **Important** : Attention à ne pas exposer les ports publiquement - les **ports d'administration** doivent être verrouillés. Cela inclut les endpoints JSON-RPC de Graph Node et les endpoints de gestion de l'Indexeur détaillés ci-dessous.

#### Nœud de The Graph

| Port | Objectif | Routes | Argument CLI | Variable d'Environment |
| --- | --- | --- | --- | --- |
| 8000 | GraphQL HTTP server<br />(for Subgraph queries) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port | - |
| 8001 | GraphQL WS<br />(for Subgraph subscriptions) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port | - |
| 8020 | JSON-RPC<br />(pour gérer les déploiements) | / | \--admin-port | - |
| 8030 | API du statut de l'indexation des subgraphs | /graphql | \--index-node-port | - |
| 8040 | Métriques Prometheus | /metrics | \--metrics-port | - |

#### Service d'Indexeur

| Port | Objectif | Routes | Argument CLI | Variable D'environment |
| --- | --- | --- | --- | --- |
| 7600 | GraphQL HTTP server<br />(for paid Subgraph queries) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port | `INDEXER_SERVICE_PORT` |
| 7300 | Métriques Prometheus | /metrics | \--metrics-port | - |

#### Indexer Agent

| Port | Objectif                     | Routes | Argument CLI               | Variable D'environment                  |
| ---- | ---------------------------- | ------ | -------------------------- | --------------------------------------- |
| 8000 | API de gestion des Indexeurs | /      | \--indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Mise en place d'une infrastructure de serveurs à l'aide de Terraform sur Google Cloud

> Remarque : les indexeurs peuvent également utiliser AWS, Microsoft Azure ou Alibaba.

#### Installer les prérequis

- SDK Google Cloud
- Outil en ligne de commande Kubectl
- Terraform

#### Créer un projet Google Cloud

- Cloner ou naviguer vers la [repo de l'Indexeur](https://github.com/graphprotocol/indexer).

- Naviguez jusqu'au répertoire `./terraform`, c'est là que toutes les commandes doivent être exécutées.

```sh
cd terraform
```

- Authentifiez-vous auprès de Google Cloud et créez un nouveau projet.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Utilisez la page de facturation de la Google Cloud Console pour activer la facturation du nouveau projet.

- Créez une configuration Google Cloud.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Activer les API Google Cloud requises.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Créer un compte de service.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Obtenir l'email du compte de service à partir de la liste
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Activer le peering entre la base de données et le cluster Kubernetes qui sera créé à l'étape suivante.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Créer un fichier de configuration minimal pour terraform (mettre à jour si nécessaire).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database password>"
EOF
```

#### Utiliser Terraform pour créer une infrastructure

Avant de lancer une commande, lisez [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) et créez un fichier `terraform.tfvars` dans ce répertoire (ou modifiez celui que nous avons créé à la dernière étape). Pour chaque variable pour laquelle vous voulez remplacer la valeur par défaut, ou pour laquelle vous avez besoin de définir une valeur, entrez un paramètre dans `terraform.tfvars`.

- Exécutez les commandes suivantes pour créer l'infrastructure.

```sh
# Installer les plugins nécessaires
terraform init

# Visualiser le plan des ressources à créer
terraform plan

# Créer les ressources (cela peut prendre jusqu'à 30 minutes)
terraform apply
```

Téléchargez les informations d'identification du nouveau cluster dans `~/.kube/config` et définissez-le comme contexte par défaut.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Création des composants Kubernetes pour l'Indexeur

- Copiez le répertoire `k8s/overlays` dans un nouveau répertoire `$dir,` et ajustez l'entrée `bases` dans `$dir/kustomization.yaml` pour qu'elle pointe vers le répertoire `k8s/base`.

- Lisez tous les fichiers de `$dir` et ajustez les valeurs indiquées dans les commentaires.

Déployer toutes les ressources avec `kubectl apply -k $dir`.

### Nœud de The Graph

[Graph Node](https://github.com/graphprotocol/graph-node) is an open source Rust implementation that event sources the Ethereum blockchain to deterministically update a data store that can be queried via the GraphQL endpoint. Developers use Subgraphs to define their schema, and a set of mappings for transforming the data sourced from the blockchain and the Graph Node handles syncing the entire chain, monitoring for new blocks, and serving it via a GraphQL endpoint.

#### Démarrer à partir des sources

#### Installer les prérequis

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Exigences supplémentaires pour les utilisateurs d'Ubuntu** - Pour faire fonctionner un Graph Node sur Ubuntu, quelques packages supplémentaires peuvent être nécessaires.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Configuration

1. Démarrer un serveur de base de données PostgreSQL

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Clonez la repo [Graph Node](https://github.com/graphprotocol/graph-node) et compilez les sources en lançant `cargo build`

3. Maintenant que toutes les dépendances sont installées, démarrez Graph Node :

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Commencer à utiliser Docker

#### Prérequis

- **Nœud Ethereum** - Par défaut, l'installation de docker compose utilisera mainnet : [http://host.docker.internal:8545](http://host.docker.internal:8545) pour se connecter au nœud Ethereum sur votre machine hôte. Vous pouvez remplacer ce nom de réseau et cette url en mettant à jour `docker-compose.yaml`.

#### Configuration

1. Clonez Graph Node et accédez au répertoire Docker :

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Pour les utilisateurs linux uniquement - Utilisez l'adresse IP de l'hôte au lieu de `host.docker.internal` dans le `docker-compose.yaml ` en utilisant le script inclus :

```sh
./setup.sh
```

3. Démarrez un Graph Node local qui se connectera à votre endpoint Ethereum :

```sh
docker-compose up
```

### Indexer components

Pour participer avec succès au réseau, il faut une surveillance et une interaction presque constantes. C'est pourquoi nous avons créé une suite d'applications Typescript pour faciliter la participation d'un Indexeur au réseau. Il y a trois Indexer components :

- **Indexer agent** - The agent monitors the network and the Indexer's own infrastructure and manages which Subgraph deployments are indexed and allocated towards onchain and how much is allocated towards each.

- **Indexer service** - The only component that needs to be exposed externally, the service passes on Subgraph queries to the graph node, manages state channels for query payments, shares important decision making information to clients like the gateways.

- **Indexer CLI** - L'interface en ligne de commande pour la gestion de l'agent Indexer. Elle permet aux Indexeurs de gérer les modèles de coûts, les allocations manuelles, la file d'attente des actions et les règles d'indexation.

#### Pour commencer

L'Indexer agent et l'Indexer service doivent être situés au même endroit que votre infrastructure Graph Node. Il existe de nombreuses façons de mettre en place des environnements d'exécution virtuels pour vos Indexer components; nous expliquerons ici comment les exécuter sur baremetal en utilisant les packages NPM ou les sources, ou via kubernetes et docker sur Google Cloud Kubernetes Engine. Si ces exemples de configuration ne s'appliquent pas à votre infrastructure, il y aura probablement un guide communautaire à consulter, venez nous dire bonjour sur [Discord](https://discord.gg/graphprotocol) ! N'oubliez pas de [staker sur le protocole](/indexing/overview/#stake-in-the-protocol) avant de démarrer vos Indexer components !

#### A partir des packages NPM

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI est un plugin pour Graph CLI, les deux doivent donc être installés :
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Transférer le port de votre pod agent si vous utilisez Kubernetes.
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### Depuis la source

```sh
# Depuis le répertoire racine de Repo
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Utilisation de Docker

- Extraire des images du registre

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Ou construire des images localement à partir des sources

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Exécuter les composants

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**NOTE** : Après le démarrage des conteneurs, le service Indexer doit être accessible à l'adresse [http://localhost:7600](http://localhost:7600) et l'agent Indexer doit exposer l'API de gestion de l'Indexeur à l'adresse [http://localhost:18000/](http://localhost:18000/).

#### En utilisant K8s et Terraform

Voir la section [Configuration de l'infrastructure du serveur à l'aide de Terraform sur Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Usage

> **NOTE** : Toutes les variables de configuration d'exécution peuvent être appliquées soit en tant que paramètres de la commande au démarrage, soit en utilisant des variables d'environnement du format `COMPONENT_NAME_VARIABLE_NAME` (ex. `INDEXER_AGENT_ETHEREUM`).

#### Indexer agent

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Indexer service

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### Indexer CLI

L'Indexer CLI est un plugin pour [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) accessible dans le terminal à `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Gestion de l'Indexeur à l'aide de l'Indexer CLI

The suggested tool for interacting with the **Indexer Management API** is the **Indexer CLI**, an extension to the **Graph CLI**. The Indexer agent needs input from an Indexer in order to autonomously interact with the network on the behalf of the Indexer. The mechanism for defining Indexer agent behavior are **allocation management** mode and **indexing rules**. Under auto mode, an Indexer can use **indexing rules** to apply their specific strategy for picking Subgraphs to index and serve queries for. Rules are managed via a GraphQL API served by the agent and known as the Indexer Management API. Under manual mode, an Indexer can create allocation actions using **actions queue** and explicitly approve them before they get executed. Under oversight mode, **indexing rules** are used to populate **actions queue** and also require explicit approval for execution.

#### Usage

L'**Indexer CLI** se connecte à l'Indexer agent, généralement par le biais d'une redirection de port, de sorte que le CLI n'a pas besoin d'être exécuté sur le même serveur ou cluster. Pour vous aider à démarrer, et pour vous donner un peu de contexte, nous allons décrire brièvement le CLI.

- `graph indexer connect <url>` - Se connecter à l'API de gestion de l'Indexeur. Généralement, la connexion au serveur est ouverte via une redirection de port, afin que le CLI puisse être facilement utilisé à distance. (Exemple : `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - Obtenir une ou plusieurs règles d'indexation en utilisant `all` comme `<deployment-id>` pour obtenir toutes les règles, ou `global` pour obtenir les valeurs par défaut globales. Un argument supplémentaire `--merged` peut être utilisé pour spécifier que les règles spécifiques au déploiement sont fusionnées avec la règle globale. C'est ainsi qu'elles sont appliquées dans l'Indexer agent.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Définir une ou plusieurs règles d'indexation.

- `graph indexer rules start [options] <deployment-id>` - Start indexing a Subgraph deployment if available and set its `decisionBasis` to `always`, so the Indexer agent will always choose to index it. If the global rule is set to always then all available Subgraphs on the network will be indexed.

- `graph indexer rules stop [options] <deployment-id>` - Arrête l'indexation d'un déploiement et met sa `decisionBasis` à never, de sorte qu'il ignorera ce déploiement lorsqu'il décidera des déploiements à indexer.

- `graph indexer rules maybe [options] <deployment-id>` — Définit la `decisionBasis` pour un déploiement à `rules`, afin que l'agent d'Indexeur utilise les règles d'indexation pour décider d'indexer ou non ce déploiement.

- `graph indexer actions get [options] <action-id>` - Récupère une ou plusieurs actions en utilisant `all` ou laisse `action-id` vide pour obtenir toutes les actions. Un argument supplémentaire `--status` peut être utilisé pour afficher toutes les actions d'un certain statut.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` - Action d'allocation de la file d'attente

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` - Action de réallocation de la file d'attente

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` - Action de désallocation de la file d'attente

- `graph indexer actions cancel [<action-id> ...]` - Annule toutes les actions de la file d'attente si id n'est pas spécifié, sinon annule un tableau d'id avec un espace comme séparateur

- `graph indexer actions approve [<action-id> ...]` - Approuver l'exécution de plusieurs actions

- `graph indexer actions execute approve` - Force le worker à exécuter immédiatement les actions approuvées

Toutes les commandes qui affichent des règles dans la sortie peuvent choisir entre les formats de sortie supportés (`table`, `yaml`, et `json`) en utilisant l'argument `-output`.

#### Règles d'indexation

Indexing rules can either be applied as global defaults or for specific Subgraph deployments using their IDs. The `deployment` and `decisionBasis` fields are mandatory, while all other fields are optional. When an indexing rule has `rules` as the `decisionBasis`, then the Indexer agent will compare non-null threshold values on that rule with values fetched from the network for the corresponding deployment. If the Subgraph deployment has values above (or below) any of the thresholds it will be chosen for indexing.

For example, if the global rule has a `minStake` of **5** (GRT), any Subgraph deployment which has more than 5 (GRT) of stake allocated to it will be indexed. Threshold rules include `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake`, and `minAverageQueryFees`.

Modèle de données :

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Exemple d'utilisation de la règle d'indexation :

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### File d'attente d'actions CLI

L'indexer-cli fournit un module `actions` pour travailler manuellement avec la file d'attente des actions. Il utilise l' **API Graphql** hébergée par le serveur de gestion de l'Indexeur pour interagir avec la file d'attente des actions.

L'agent d'exécution des actions ne récupère les éléments de la file d'attente pour les exécuter que s'ils ont un `ActionStatus = approved`. Dans le chemin recommandé, les actions sont ajoutées à la file d'attente avec ActionStatus = queued, de ce fait elles doivent donc être approuvées pour être exécutées onchain. Le flux général se présente comme suit :

- Action ajoutée à la file d'attente par l'outil d'optimisation tiers ou l'utilisateur d'indexer-cli
- L'Indexeur peut utiliser `indexer-cli` pour visualiser toutes les actions en attente
- L'Indexeur (ou un autre logiciel) peut approuver ou annuler des actions dans la file d'attente en utilisant l'`indexer-cli`. Les commandes approve et cancel prennent en entrée un tableau d'identifiants d'actions.
- L'agent d'exécution interroge régulièrement la file d'attente pour les actions approuvées. Il récupère les actions `approuvées` de la file d'attente, tente de les exécuter, et met à jour les valeurs dans la base de données en fonction du statut de l'exécution, `success` ou `failed`.
- Si une action est réussie, le worker s'assurera qu'il y a une règle d'indexation présente qui indique à l'agent comment gérer l'allocation à l'avenir, ce qui est utile pour prendre des actions manuelles lorsque l'agent est en mode `auto` ou `oversight`.
- L'indexeur peut surveiller la file d'attente des actions pour voir l'historique de l'exécution des actions et, si nécessaire, réapprouver et mettre à jour les éléments d'action dont l'exécution a échoué. La file d'attente des actions fournit un historique de toutes les actions mises en attente et exécutées.

Modèle de données :

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Exemple d'utilisation de la source :

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Notez que les types d'action pris en charge pour la gestion de l'allocation ont des exigences différentes en matière de données d'entrée :

- `Allocate` - allocate stake to a specific Subgraph deployment

  - paramètres d'action requis :
    - deploymentID
    - amount

- `Unallocate` - ferme l'allocation, libérant le staking pour le réallouer ailleurs

  - paramètres d'action requis :
    - allocationID
    - deploymentID
  - paramètres d'action optionnels :
    - poi
    - force (force à utiliser le POI fourni même s'il ne correspond pas à ce que graph-node fournit)

- `Reallocate` - atomically close allocation and open a fresh allocation for the same Subgraph deployment

  - paramètres d'action requis :
    - allocationID
    - deploymentID
    - amount
  - paramètres d'action optionnels :
    - poi
    - force (force à utiliser le POI fourni même s'il ne correspond pas à ce que graph-node fournit)

#### Modèles de coûts

Cost models provide dynamic pricing for queries based on market and query attributes. The Indexer Service shares a cost model with the gateways for each Subgraph for which they intend to respond to queries. The gateways, in turn, use the cost model to make Indexer selection decisions per query and to negotiate payment with chosen Indexers.

#### Agora

Le langage Agora fournit un format flexible pour déclarer des modèles de coûts pour les requêtes. Un modèle de prix Agora est une séquence d'instructions qui s'exécutent dans l'ordre pour chaque requête de niveau supérieur dans une requête GraphQL. Pour chaque requête de niveau supérieur, la première instruction qui lui correspond détermine le prix de cette requête.

Une déclaration est composée d'un prédicat, qui est utilisé pour faire correspondre les requêtes GraphQL, et d'une expression de coût qui, lorsqu'elle est évaluée, produit un coût en GRT décimal. Les valeurs de l'argument nommé d'une requête peuvent être capturées dans le prédicat et utilisées dans l'expression. Les globaux peuvent également être définis et remplacés par des espaces réservés dans une expression.

Exemple de modèle de coût :

```
# Cette instruction capture la valeur du saut,
# utilise une expression booléenne dans le prédicat pour faire correspondre les requêtes spécifiques qui utilisent `skip`
# et une expression de coût pour calculer le coût en fonction de la valeur `skip` et de la valeur globale SYSTEM_LOAD
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# Cette valeur par défaut correspondra à n'importe quelle expression GraphQL.
# Il utilise un Global substitué dans l'expression pour calculer le coût.
default => 0.1 * $SYSTEM_LOAD;
```

Exemple de calcul des coûts d'une requête à l'aide du modèle ci-dessus :

| Requête                                                                      | Prix    |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### Application du modèle de coût

Les modèles de coûts sont appliqués via l'Indexer CLI, qui les transmet à l'API de gestion de l'Indexer agent pour qu'ils soient stockés dans la base de données. L'Indexer Service les récupère ensuite et fournit les modèles de coûts aux passerelles chaque fois qu'elles le demandent.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interaction avec le réseau

### Staker dans le protocol

Les premières étapes de la participation au réseau en tant qu'Indexeur consistent à approuver le protocole, à staker des fonds et (éventuellement) à créer une adresse d'opérateur pour les interactions quotidiennes avec le protocole.

> Note : Dans le cadre de ces instructions, Remix sera utilisé pour l'interaction contractuelle, mais vous pouvez utiliser l'outil de votre choix ([OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/), et [MyCrypto](https://www.mycrypto.com/account) sont d'autres outils connus).

Une fois qu'un Indexeur a staké des GRT dans le protocole, les [composants de l'Indexeur](/indexing/overview/#indexer-components) peuvent être démarrés et commencer leurs interactions avec le réseau.

#### Approuver les jetons

1. Ouvrir l'[application Remix](https://remix.ethereum.org/) dans un navigateur

2. Dans l'explorateur de fichiers, créez un fichier nommé **GraphToken.abi** avec le [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. Avec `GraphToken.abi` sélectionné et ouvert dans l'éditeur, passez à la section `Deploy and run transactions` dans l'interface Remix.

4. Sous environnement, sélectionnez `Injected Web3` et sous `Account` sélectionnez votre adresse d'Indexeur.

5. Définir l'adresse du contrat GraphToken - Collez l'adresse du contrat GraphToken (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) à côté de `At Address` et cliquez sur le bouton `At Address` pour l'appliquer.

6. Appeler la fonction `approve(spender, amount)` pour approuver le contrat de Staking. Remplissez `spender` avec l'adresse du contrat de staking (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) et `amount` avec les jetons à staker (en wei).

#### Staker les jetons

1. Ouvrir l'[application Remix](https://remix.ethereum.org/) dans un navigateur

2. Dans l'explorateur de fichiers, créez un fichier nommé **Staking.abi** avec l'ABI de staking.

3. Avec `Staking.abi` sélectionné et ouvert dans l'éditeur, passez à la section `Deploy and run transactions` dans l'interface Remix.

4. Sous environnement, sélectionnez `Injected Web3` et sous `Account` sélectionnez votre adresse d'Indexeur.

5. Définir l'adresse du contrat de staking - Collez l'adresse du contrat de staking (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) à côté de `At Address` et cliquez sur le bouton `At address` pour l'appliquer.

6. Appeler `stake()` pour staker les GRT dans le protocole.

7. (Optional) Indexers may approve another address to be the operator for their Indexer infrastructure in order to separate the keys that control the funds from those that are performing day to day actions such as allocating on Subgraphs and serving (paid) queries. In order to set the operator call `setOperator()` with the operator address.

8. (Optional) In order to control the distribution of rewards and strategically attract Delegators Indexers can update their delegation parameters by updating their `indexingRewardCut` (parts per million), `queryFeeCut` (parts per million), and `cooldownBlocks` (number of blocks). To do so call `setDelegationParameters()`. The following example sets the `queryFeeCut` to distribute 95% of query rebates to the Indexer and 5% to Delegators, set the `indexingRewardCut` to distribute 60% of indexing rewards to the Indexer and 40% to Delegators, and set the `cooldownBlocks` period to 500 blocks.

```
setDelegationParameters(950000, 600000, 500)
```

### Définition des paramètres de délégation

La fonction `setDelegationParameters()` du [contrat de staking](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) est essentielle pour les Indexeurs, car elle leur permet de définir les paramètres qui définissent leurs interactions avec les Déléguateurs, en influençant le partage des récompenses et la capacité de délégation.

### Comment définir les paramètres de délégation

Pour définir les paramètres de délégation à l'aide de l'interface Graph Explorer, procédez comme suit :

1. Naviguez jusqu'à [Graph Explorer](https://thegraph.com/explorer/).
2. Connectez votre portefeuille. Choisissez multisig (comme Gnosis Safe) et sélectionnez ensuite mainnet. Note : Vous devrez répéter ce processus pour Arbitrum One.
3. Connectez le portefeuille que vous avez en tant que signataire.
4. Accédez à la section 'Paramètres' et sélectionnez 'Paramètres de délégation'. Ces paramètres doivent être configurés de manière à obtenir une réduction effective dans la fourchette souhaitée. En saisissant des valeurs dans les champs de saisie prévus à cet effet, l'interface calculera automatiquement la réduction effective. Ajustez ces valeurs si nécessaire pour obtenir le pourcentage de réduction effective souhaité.
5. Soumettre la transaction au réseau.

> Remarque : cette transaction devra être confirmée par les signataires du portefeuille multisig.

### La durée de vie d'une allocation

Après avoir été créée par un Indexeur, une allocation saine passe par deux états.

- **Active** - Once an allocation is created onchain ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)) it is considered **active**. A portion of the Indexer's own and/or delegated stake is allocated towards a Subgraph deployment, which allows them to claim indexing rewards and serve queries for that Subgraph deployment. The Indexer agent manages creating allocations based on the Indexer rules.

- **Closed** - Un indexeur est libre de clôturer une allocation une fois qu'une époque s'est écoulée ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)) ou son agent d'Indexeur clôturera automatiquement l'allocation après le **maxAllocationEpochs** (actuellement 28 jours). Lorsqu'une allocation est clôturée avec une preuve d'indexation (POI) valide, les récompenses d'indexation sont distribuées à l'Indexeur et à ses délégués ([en savoir plus](/indexing/overview/#how-are-indexing-rewards-distributed)).

Indexers are recommended to utilize offchain syncing functionality to sync Subgraph deployments to chainhead before creating the allocation onchain. This feature is especially useful for Subgraphs that may take longer than 28 epochs to sync or have some chances of failing undeterministically.
