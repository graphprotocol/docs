---
title: API GraphQL
---

Explore the GraphQL Query API for interacting with Subgraphs on The Graph Network.

[GraphQL](https://graphql.org/learn/) is a query language for APIs and a runtime for executing those queries with existing data.

The Graph uses GraphQL to query Subgraphs.

## Core Concepts

### Entities

- **What they are**: Persistent data objects defined with `@entity` in your schema
- **Key requirement**: Must contain `id: ID!` as primary identifier
- **Usage**: Foundation for all query operations

### Schema

- **Purpose**: Blueprint defining the data structure and relationships using GraphQL [IDL](https://facebook.github.io/graphql/draft/#sec-Type-System)
- **Key characteristics**:
  - Auto-generates query endpoints
  - Read-only operations (no mutations)
  - Defines entity interfaces and derived fields

## Query Structure

GraphQL queries in The Graph target entities defined in the Subgraph schema. Each `Entity` type generates corresponding `entity` and `entities` fields on the root `Query` type.

> Note: The `query` keyword is not required at the top level of GraphQL queries.

### Single Entity Queries Example

Query for a single `Token` entity:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> Note: Single entity queries require the `id` parameter as a string.

### Collection Queries Example

Query format for all `Token` entities:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Sorting Example

Collection queries support the following sort parameters:

- `orderBy`: Specifies the attribute for sorting
- `orderDirection`: Accepts `asc` (ascending) or `desc` (descending)

#### Standard Sorting Example

```graphql
{
  tokens(orderBy : price, orderDirection : asc) {
    id
    propriétaire
  }
}
```

#### Nested Entity Sorting Example

```graphql
{
   jetons (orderBy : propriétaire__nom, orderDirection : asc) {
     identifiant
     propriétaire {
       {
      name
    }
     }
   }
}
```

> Note: Nested sorting supports one-level-deep `String` or `ID` types on `@entity` and `@derivedFrom` fields.

### Pagination Example

When querying a collection, it is best to:

- Utilisez le paramètre `first` pour paginer à partir du début de la collection.
  - L'ordre de tri par défaut est le tri par `ID` dans l'ordre alphanumérique croissant, **non** par heure de création.
- Utilisez le paramètre `skip` pour sauter des entités et paginer. Par exemple, `first:100` affiche les 100 premières entités et `first:100, skip:100` affiche les 100 entités suivantes.
- Évitez d'utiliser les valeurs `skip` dans les requêtes car elles sont généralement peu performantes. Pour récupérer un grand nombre d'éléments, il est préférable de parcourir les entités en fonction d'un attribut, comme indiqué dans l'exemple précédent.

#### Standard Pagination Example

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

#### Offset Pagination Example

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Cursor-based Pagination Example

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

### Filtration

The `where` parameter filters entities based on specified conditions.

#### Basic Filtering Example

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Numeric Comparison Example

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Block-based Filtering Example

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### Nested Entity Filtering Example

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Logical Operators

##### AND Operations Example

L'exemple suivant filtre les défis avec `outcome` `succeeded` et `number` supérieur ou égal à `100`.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

**Syntactic sugar:** You can simplify the above query by removing the `and` operator and by passing a sub-expression separated by commas.

```graphql
{
  challenges(where: { number_gte: 100, outcome: "succeeded" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

##### OR Operations Example

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Global filter parameter:

```graphql
_change_block(numéro_gte : Int)
```

### Time-travel Queries Example

Queries support historical state retrieval using the `block` parameter:

- `number`: Integer block number
- `hash`: String block hash

> Remarque : l'implémentation actuelle est encore sujette à certaines limitations qui pourraient violer ces garanties. L'implémentation ne permet pas toujours de déterminer si un bloc donné n'est pas du tout sur la chaîne principale ou si le résultat d'une requête par bloc pour un bloc qui n'est pas encore considéré comme final peut être influencé par une réorganisation du bloc qui a lieu en même temps que la requête. Elles n'affectent pas les résultats des requêtes par hash de bloc lorsque le bloc est final et que l'on sait qu'il se trouve sur la chaîne principale. [Ce numéro](https://github.com/graphprotocol/graph-node/issues/1405) explique ces limitations en détail.

#### Block Number Query Example

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Block Hash Query Example

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

### Full-Text Search Example

Full-text search query fields provide an expressive text search API that can be added to the Subgraph schema and customized. Refer to [Defining Full-text Search Fields](/developing/creating-a-subgraph/#defining-fulltext-search-fields) to add full-text search to your Subgraph.

Full-text search queries have one required field, `text`, for supplying search terms. Several special full-text operators are available to be used in this `text` search field.

Full-text search fields use the required `text` parameter with the following operators:

| Operator  | Symbole | Description                                                     |
| --------- | ------- | --------------------------------------------------------------- |
| And       | `&`     | Matches entities containing all terms                           |
| Or        | `\|`    | Return all entities with a match from any of the provided terms |
| Follow by | `<->`   | Matches terms with specified distance                           |
| Prefix    | `:*`    | Matches word prefixes (minimum 2 characters)                    |

#### Search Examples

OR operator:

```
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

“Follow” by operator:

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combined operators:

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Définition de schéma

Entity types require:

- GraphQL Interface Definition Language (IDL) format
- `@entity` directive
- `ID` field

### Subgraph Metadata Example

The `_Meta_` object provides subgraph metadata:

```graphql
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

Metadata fields:

- `deployment`: IPFS CID of the subgraph.yaml
- `block`: Latest block information
- `hasIndexingErrors`: Boolean indicating past indexing errors

> Note: When writing queries, it is important to consider the performance impact of using the `or` operator. While `or` can be a useful tool for broadening search results, it can also have significant costs. One of the main issues with `or` is that it can cause queries to slow down. This is because `or` requires the database to scan through multiple indexes, which can be a time-consuming process. To avoid these issues, it is recommended that developers use `and` operators instead of `or` whenever possible. This allows for more precise filtering and can lead to faster, more accurate queries.

### GraphQL Filter Operators Reference

This table explains each filter operator available in The Graph's GraphQL API. These operators are used as suffixes to field names when filtering data using the `where` parameter.

| Opérateur                 | Description                                                       | Exemple                                              |
| ------------------------- | ----------------------------------------------------------------- | ---------------------------------------------------- |
| `_`                       | Matches entities where the specified field equals another entity  | `{ where: { owner_: { name: "Alice" } } }`           |
| `_not`                    | Negates the specified condition                                   | `{ where: { active_not: true } }`                    |
| `_gt`                     | Greater than (>)                                                  | `{ where: { price_gt: "100" } }`                     |
| `_lt`                     | Less than (`\<`)                                                  | `{ where: { price_lt: "100" } }`                     |
| `_gte`                    | Greater than or equal to (>=)                                     | `{ where: { price_gte: "100" } }`                    |
| `_lte`                    | Less than or equal to (`\<=`)                                     | `{ where: { price_lte: "100" } }`                    |
| `_in`                     | Value is in the specified array                                   | `{ where: { category_in: ["Art", "Music"] } }`       |
| `_not_in`                 | Value is not in the specified array                               | `{ where: { category_not_in: ["Art", "Music"] } }`   |
| `_contains`               | Field contains the specified string (case-sensitive)              | `{ where: { name_contains: "token" } }`              |
| `_contains_nocase`        | Field contains the specified string (case-insensitive)            | `{ where: { name_contains_nocase: "token" } }`       |
| `_not_contains`           | Field does not contain the specified string (case-sensitive)      | `{ where: { name_not_contains: "test" } }`           |
| `_not_contains_nocase`    | Field does not contain the specified string (case-insensitive)    | `{ where: { name_not_contains_nocase: "test" } }`    |
| `_starts_with`            | Field starts with the specified string (case-sensitive)           | `{ where: { name_starts_with: "Crypto" } }`          |
| `_starts_with_nocase`     | Field starts with the specified string (case-insensitive)         | `{ where: { name_starts_with_nocase: "crypto" } }`   |
| `_ends_with`              | Field ends with the specified string (case-sensitive)             | `{ where: { name_ends_with: "Token" } }`             |
| `_ends_with_nocase`       | Field ends with the specified string (case-insensitive)           | `{ where: { name_ends_with_nocase: "token" } }`      |
| `_not_starts_with`        | Field does not start with the specified string (case-sensitive)   | `{ where: { name_not_starts_with: "Test" } }`        |
| `_not_starts_with_nocase` | Field does not start with the specified string (case-insensitive) | `{ where: { name_not_starts_with_nocase: "test" } }` |
| `_not_ends_with`          | Field does not end with the specified string (case-sensitive)     | `{ where: { name_not_ends_with: "Test" } }`          |
| `_not_ends_with_nocase`   | Field does not end with the specified string (case-insensitive)   | `{ where: { name_not_ends_with_nocase: "test" } }`   |

#### Notes

- Type support varies by operator. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`.
- The `_` operator is only available for object and interface types.
- String comparison operators are especially useful for text fields.
- Numeric comparison operators work with both number and string-encoded number fields.
- Use these operators in combination with logical operators (`and`, `or`) for complex filtering.

### Validation

Graph Node met en œuvre une validation [basée sur les spécifications](https://spec.graphql.org/October2021/#sec-Validation) des requêtes GraphQL qu'il reçoit à l'aide de [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), qui est basée sur l'implémentation de référence [graphql-js](https://github.com/graphql/graphql-js/tree/main/src/validation). Les requêtes qui échouent à une règle de validation sont accompagnées d'une erreur standard - consultez les [spécifications GraphQL](https://spec.graphql.org/October2021/#sec-Validation) pour en savoir plus.
