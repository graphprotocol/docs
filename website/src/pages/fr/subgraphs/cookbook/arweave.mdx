---
title: Construction de subgraphs pour Arweave
---

> Arweave support in Graph Node and on Subgraph Studio is in beta: please reach us on [Discord](https://discord.gg/graphprotocol) with any questions about building Arweave Subgraphs!

Dans ce guide, vous apprendrez comment créer et déployer des subgraphs pour indexer la blockchain Arweave.

## Qu’est-ce qu’Arweave ?

Arweave est un protocole qui permet aux développeurs de stocker des données de façon permanente. C'est cette caractéristique qui constitue la principale différence entre Arweave et IPFS. En effet, IPFS n'a pas la caractéristique de permanence, et les fichiers stockés sur Arweave ne peuvent pas être modifiés ou supprimés.

Arweave a déjà construit de nombreuses bibliothèques pour intégrer le protocole dans plusieurs langages de programmation différents. Pour plus d'informations, vous pouvez consulter :

- [Arwiki](https://arwiki.wiki/#/en/main)
- [Ressources Arweave](https://www.arweave.org/build)

## À quoi servent les subgraphs d'Arweave ?

The Graph vous permet de créer des API ouvertes personnalisées appelées "Subgraphs". Les subgraphs sont utilisés pour indiquer aux Indexeurs (opérateurs de serveur) quelles données indexer sur une blockchain et enregistrer sur leurs serveurs afin que vous puissiez les interroger à tout moment à l'aide de [GraphQL](https://graphql.org/).

[Graph Node](https://github.com/graphprotocol/graph-node) est désormais capable d'indexer les données sur le protocole Arweave. L'intégration actuelle indexe uniquement Arweave en tant que blockchain (blocs et transactions), elle n'indexe pas encore les fichiers stockés.

## Construire un subgraph Arweave

Pour pouvoir créer et déployer des Arweave Subgraphs, vous avez besoin de deux packages :

1. `@graphprotocol/graph-cli` above version 0.30.2 - This is a command-line tool for building and deploying Subgraphs. [Click here](https://www.npmjs.com/package/@graphprotocol/graph-cli) to download using `npm`.
2. `@graphprotocol/graph-ts` above version 0.27.0 - This is library of Subgraph-specific types. [Click here](https://www.npmjs.com/package/@graphprotocol/graph-ts) to download using `npm`.

## Caractéristique des subgraphs

There are three components of a Subgraph:

### 1. Le Manifest - `subgraph.yaml`

Définit les sources de données intéressantes et la manière dont elles doivent être traitées. Arweave est un nouveau type de source de données.

### 2. Schéma - `schema.graphql`

Vous définissez ici les données que vous souhaitez pouvoir interroger après avoir indexé votre subgraph à l'aide de GraphQL. Ceci est en fait similaire à un modèle pour une API, où le modèle définit la structure d'un corps de requête.

The requirements for Arweave Subgraphs are covered by the [existing documentation](/developing/creating-a-subgraph/#the-graphql-schema).

### 3. Mappages en AssemblyScript - `mapping.ts`

Il s'agit de la logique qui détermine comment les données doivent être récupérées et stockées lorsqu'une personne interagit avec les sources de données que vous interrogez. Les données sont traduites et stockées sur la base du schema que vous avez répertorié.

During Subgraph development there are two key commands:

```
$ graph codegen # generates types from the schema file identified in the manifest
$ graph build # generates Web Assembly from the AssemblyScript files, and prepares all the Subgraph files in a /build folder
```

## Définition du manifeste du subgraph

The Subgraph manifest `subgraph.yaml` identifies the data sources for the Subgraph, the triggers of interest, and the functions that should be run in response to those triggers. See below for an example Subgraph manifest for an Arweave Subgraph:

```yaml
specVersion: 0.0.5
description: Arweave Blocks Indexing
schema:
  file: ./schema.graphql # lien vers le fichier de schéma
dataSources:
  - kind: arweave
    name: arweave-blocks
    network: arweave-mainnet # The Graph ne supporte que le Arweave Mainnet
    source:
      owner: 'ID-OF-AN-OWNER' # La clé publique d'un porte-monnaie Arweave
      startBlock: 0 # mettez cette valeur à 0 pour commencer l'indexation à partir de la genèse de la chaîne.
    mapping:
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/blocks.ts # lien vers le fichier contenant les mappages d'Assemblyscript
      entities:
        - Block
        - Transaction
      blockHandlers:
        - handler: handleBlock # le nom de la fonction dans le fichier de mapping
      transactionHandlers:
        - handler: handleTx # le nom de la fonction dans le fichier de mapping
```

- Arweave Subgraphs introduce a new kind of data source (`arweave`)
- Le réseau doit correspondre à un réseau sur le Graph Node hôte. Dans Subgraph Studio, le réseau principal d'Arweave est `arweave-mainnet`
- Les sources de données Arweave introduisent un champ source.owner facultatif, qui est la clé publique d'un portefeuille Arweave

Les sources de données Arweave prennent en charge deux types de gestionnaires :

- `blockHandlers` - Exécuté sur chaque nouveau bloc Arweave. Aucun source.owner n'est requis.
- `transactionHandlers` - Exécute chaque transaction dont le propriétaire est `source.owner` de la source de données. Actuellement, un propriétaire est requis pour `transactionHandlers`, si les utilisateurs veulent traiter toutes les transactions, ils doivent fournir "" comme `source.owner`

> Source.owner peut être l’adresse du propriétaire ou sa clé publique.
>
> Les transactions sont les éléments constitutifs du permaweb Arweave et ce sont des objets créés par les utilisateurs finaux.
>
> Note : Les transactions [Irys (anciennement Bundlr)](https://irys.xyz/) ne sont pas encore prises en charge.

## Définition de schéma

Schema definition describes the structure of the resulting Subgraph database and the relationships between entities. This is agnostic of the original data source. There are more details on the Subgraph schema definition [here](/developing/creating-a-subgraph/#the-graphql-schema).

## Cartographies AssemblyScript

Les gestionnaires d'événements sont écrits en [AssemblyScript](https://www.assemblyscript.org/).

L'indexation Arweave introduit des types de données spécifiques à Arweave dans l'[API AssemblyScript](/subgraphs/developing/creating/graph-ts/api/).

```tsx
class Block {
  timestamp: u64
  lastRetarget: u64
  height: u64
  indepHash: Bytes
  nonce: Bytes
  previousBlock: Bytes
  diff: Bytes
  hash: Bytes
  txRoot: Bytes
  txs: Bytes[]
  walletList: Bytes
  rewardAddr: Bytes
  tags: Tag[]
  rewardPool: Bytes
  weaveSize: Bytes
  blockSize: Bytes
  cumulativeDiff: Bytes
  hashListMerkle: Bytes
  poa: ProofOfAccess
}

class Transaction {
  format: u32
  id: Bytes
  lastTx: Bytes
  owner: Bytes
  tags: Tag[]
  target: Bytes
  quantity: Bytes
  data: Bytes
  dataSize: Bytes
  dataRoot: Bytes
  signature: Bytes
  reward: Bytes
}
```

Les gestionnaires de blocs reçoivent un `Block`, tandis que les transactions reçoivent un `Transaction`.

L'écriture des mappages d'un subgraph Arweave est très similaire à l'écriture des mappages d'un subgraph Ethereum. Pour plus d'informations, cliquez [ici](/developing/creating-a-subgraph/#writing-mappings).

## Déploiement d'un subgraph Arweave dans Subgraph Studio

Once your Subgraph has been created on your Subgraph Studio dashboard, you can deploy by using the `graph deploy` CLI command.

```bash
graph deploy --access-token <votre-token-d-acces>
```

## Interroger un subgraph d'Arweave

The GraphQL endpoint for Arweave Subgraphs is determined by the schema definition, with the existing API interface. Please visit the [GraphQL API documentation](/subgraphs/querying/graphql-api/) for more information.

## Exemples de subgraphs

Here is an example Subgraph for reference:

- [Example Subgraph for Arweave](https://github.com/graphprotocol/graph-tooling/tree/main/examples/arweave-blocks-transactions)

## FAQ

### Can a Subgraph index Arweave and other chains?

No, a Subgraph can only support data sources from one chain/network.

### Puis-je indexer les fichiers enregistrés sur Arweave ?

Actuellement, The Graph n'indexe Arweave qu'en tant que blockchain (ses blocs et ses transactions).

### Can I identify Bundlr bundles in my Subgraph?

Cette fonction n'est pas prise en charge actuellement.

### Comment puis-je filtrer les transactions sur un compte spécifique ?

La source.owner peut être la clé publique de l'utilisateur ou l'adresse de son compte.

### Quel est le format de chiffrement actuel ?

Data is generally passed into the mappings as Bytes, which if stored directly is returned in the Subgraph in a `hex` format (ex. block and transaction hashes). You may want to convert to a `base64` or `base64 URL`-safe format in your mappings, in order to match what is displayed in block explorers like [Arweave Explorer](https://viewblock.io/arweave/).

La fonction d'assistant `bytesToBase64(bytes : Uint8Array, urlSafe : boolean) : string` suivante peut être utilisée, et sera ajoutée à `graph-ts` :

```
const base64Alphabet = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64UrlAlphabet = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
];

function bytesToBase64(bytes: Uint8Array, urlSafe: boolean): string {
	let alphabet = urlSafe? base64UrlAlphabet : base64Alphabet;

	let result = '', i: i32, l = bytes.length;
	for (i = 2; i < l; i += 3) {
		result += alphabet[bytes[i - 2] >> 2];
		result += alphabet[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += alphabet[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
		result += alphabet[bytes[i] & 0x3F];
	}
	if (i === l + 1) { // 1 octet à écrire
		result += alphabet[bytes[i - 2] >> 2];
		result += alphabet[(bytes[i - 2] & 0x03) << 4];
		if (!urlSafe) {
			result += "==";
		}
	}
	if (!urlSafe && i === l) { // 2 octets à écrire
		result += alphabet[bytes[i - 2] >> 2];
		result += alphabet[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += alphabet[(bytes[i - 1] & 0x0F) << 2];
		if (!urlSafe) {
			result += "=";
		}
	}
	return result;
}
```
