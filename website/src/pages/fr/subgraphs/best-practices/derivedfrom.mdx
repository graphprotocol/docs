---
title: Bonne pratique pour les subgraphs 2 - Améliorer la Réactivité de l'Indexation et des Requêtes en Utilisant @derivedFrom
sidebarTitle: Arrays with @derivedFrom
---

## TLDR

Arrays in your schema can really slow down a Subgraph's performance as they grow beyond thousands of entries. If possible, the `@derivedFrom` directive should be used when using arrays as it prevents large arrays from forming, simplifies handlers, and reduces the size of individual entities, improving indexing speed and query performance significantly.

## Comment Utiliser la Directive `@derivedFrom`

Il vous suffit d'ajouter une directive `@derivedFrom` après votre tableau dans votre schéma. Comme ceci :

```graphql
comments: [Comment!]! @derivedFrom(field: "post")
```

`@derivedFrom` creates efficient one-to-many relationships, enabling an entity to dynamically associate with multiple related entities based on a field in the related entity. This approach removes the need for both sides of the relationship to store duplicate data, making the Subgraph more efficient.

### Exemple de cas d'utilisation de `@derivedFrom`

Un exemple de tableau à croissance dynamique est une plateforme de blogs où un "Post" peut avoir de nombreux "Comments"(Commentaires).

Commençons avec nos deux entités, `Post` et `Comment`

Sans optimisation, vous pourriez implémenter cela avec un tableau :

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]!
}

type Comment @entity {
  id: Bytes!
  content: String!
}
```

Les tableaux comme ceux-ci stockeront effectivement des données supplémentaires de Comments du côté Post de la relation.

Voici à quoi ressemble une version optimisée utilisant `@derivedFrom`:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]! @derivedFrom(field: "post")
}

type Comment @entity {
  id: Bytes!
  content: String!
  post: Post!
}
```

En ajoutant simplement la directive `@derivedFrom`, ce schéma ne stockera les "Comments" que du côté "Comments" de la relation et non du côté "Post" de la relation. Les tableaux sont stockés sur des lignes individuelles, ce qui leur permet de s'étendre de manière significative. Cela peut entraîner des tailles particulièrement grandes si leur croissance est illimitée.

This will not only make our Subgraph more efficient, but it will also unlock three features:

1. Nous pouvons interroger le `Post` et voir tous ses commentaires.

2. Nous pouvons faire une recherche inverse et interroger n'importe quel Commentaire et voir de quel post il provient.

3. We can use [Derived Field Loaders](/subgraphs/developing/creating/graph-ts/api/#looking-up-derived-entities) to unlock the ability to directly access and manipulate data from virtual relationships in our Subgraph mappings.

## Conclusion

Use the `@derivedFrom` directive in Subgraphs to effectively manage dynamically growing arrays, enhancing indexing efficiency and data retrieval.

Pour une explication plus détaillée des stratégies permettant d'éviter les tableaux volumineux, consultez le blog de Kevin Jones : [Bonnes pratiques en matière de développement de subgraphs : éviter les tableaux volumineux](https://thegraph.com/blog/improve-subgraph-performance-avoiding-large-arrays/).

## Bonnes pratiques pour les subgraphs 1-6

1. [Improve Query Speed with Subgraph Pruning](/subgraphs/best-practices/pruning/)

2. [Improve Indexing and Query Responsiveness by Using @derivedFrom](/subgraphs/best-practices/derivedfrom/)

3. [Improve Indexing and Query Performance by Using Immutable Entities and Bytes as IDs](/subgraphs/best-practices/immutable-entities-bytes-as-ids/)

4. [Improve Indexing Speed by Avoiding `eth_calls`](/subgraphs/best-practices/avoid-eth-calls/)

5. [Simplify and Optimize with Timeseries and Aggregations](/subgraphs/best-practices/timeseries/)

6. [Use Grafting for Quick Hotfix Deployment](/subgraphs/best-practices/grafting-hotfix/)
