---
title: Meilleure pratique pour les subgraphs 6 - Utiliser le greffage pour un déploiement rapide des correctifs
sidebarTitle: Grafting and Hotfixing
---

## TLDR

La greffe est une fonctionnalité puissante dans le développement de subgraphs qui vous permet de construire et de déployer de nouveaux subgraphs tout en réutilisant les données indexées des subgraphs existants.

### Aperçu

Cette fonction permet de déployer rapidement des correctifs pour les problèmes critiques, ce qui évite de devoir réindexer l'ensemble du subgraph à partir de zéro. En préservant les données historiques, la greffe minimise les temps d'arrêt et assure la continuité des services de données.

## Avantages du greffage pour les correctifs

1. **Déploiement rapide**

   - **Minimiser les temps d'arrêt** : Lorsqu'un subgraph rencontre une erreur critique et cesse d'être indexé, la greffe vous permet de déployer immédiatement un correctif sans attendre la réindexation.
   - **Rétablissement immédiat** : Le nouveau subgraph continue à partir du dernier bloc indexé, ce qui garantit que les services de données restent ininterrompus.

2. **Préservation des données**

   - **Réutilisation des données historiques** : Le greffage copie les données existantes du subgraph de base, de sorte que vous ne perdez pas de précieux enregistrements historiques.
   - **Consistance** : Maintient la continuité des données, ce qui est crucial pour les applications qui s'appuient sur des données historiques cohérentes.

3. **Efficacité**
   - **Économie de temps et de ressources** : Évite surcoût de calcul lié à la réindexation de grands ensembles de données.
   - **Focalisation sur les corrections** : Permet aux développeurs de se concentrer sur la résolution des problèmes plutôt que sur la gestion de la récupération des données.

## Meilleures pratiques lors de l'utilisation du greffage pour les correctifs

1. **Déploiement initial sans greffage**

   - **Démarrez proprement** : Déployez toujours votre subgraph initial sans greffage pour vous assurer qu'il est stable et qu'il fonctionne comme prévu.
   - **Testez minutieusement** : Validez les performances du subgraph afin de minimiser les besoins en correctifs futurs.

2. **Mise en œuvre du correctif par greffage**

   - **Identifier le problème** : Lorsqu'une erreur critique se produit, déterminez le numéro de bloc du dernier événement indexé avec succès.
   - **Créer un nouveau subgraph** : Développez un nouveau subgraph qui inclut le correctif.
   - **Configurer le greffage** : Utiliser le greffage pour copier les données jusqu'au numéro de bloc identifié à partir du subgraph défaillant.
   - **Déploiement rapide** : Publier le subgraph greffé pour rétablir le service dès que possible.

3. **Actions post-correctif**

   - **Surveillez les performances** : Assurez-vous que le subgraph greffé est indexé correctement et que le correctif résout le problème.
   - **Républier sans greffage** : Une fois stable, déployer une nouvelle version du subgraph sans greffage pour une maintenance à long terme.
     > Remarque : il n'est pas recommandé de s'appuyer indéfiniment sur le greffage, car cela peut compliquer les mises à jour et la maintenance futures.
   - **Mettre à jour les références** : Rediriger tous les services ou applications pour qu'ils utilisent le nouveau subgraph non greffé.

4. **Considérations importantes**
   - **Sélection minutieuse des blocs** : Choisissez soigneusement le numéro du bloc de greffage pour éviter toute perte de données.
   - **Conseil** : Utilisez le numéro de bloc du dernier événement correctement traité.
   - **Utiliser l'ID de déploiement** : Assurez-vous que vous faites référence à l'ID de déploiement du subgraph de base, et non à l'ID du subgraph.
   - **Note** : L'ID de déploiement est l'identifiant unique d'un déploiement de subgraph spécifique.
   - **Déclaration de caractéristiques** : N'oubliez pas de déclarer le greffage dans le manifeste du subgraph sous la section features.

## Exemple : Déploiement d'un correctif par greffage

Supposons que vous ayez un subgraph qui suit un contrat intelligent qui a cessé d'être indexé en raison d'une erreur critique. Voici comment vous pouvez utiliser le greffage pour déployer un correctif.

1. **Manifeste du subgraph échoué (subgraph.yaml)**

   ```yaml
   specVersion: 1.0.0
   schema:
     file: ./schema.graphql
   dataSources:
     - kind: ethereum/contract
       name: OldSmartContract
       network: sepolia
       source:
         address: '0xOldContractAddress'
         abi: Lock
         startBlock: 5000000
       mapping:
         kind: ethereum/events
         apiVersion: 0.0.7
         language: wasm/assemblyscript
         entities:
           - Withdrawal
         abis:
           - name: Lock
             file: ./abis/OldLock.json
         eventHandlers:
           - event: Withdrawal(uint256,uint256)
             handler: handleOldWithdrawal
         file: ./src/old-lock.ts
   ```

2. **Nouveau manifeste de subgraph greffé (subgraph.yaml)**
   ```yaml
   specVersion: 1.0.0
   schema:
     file: ./schema.graphql
   dataSources:
     - kind: ethereum/contract
       name: NewSmartContract
       network: sepolia
       source:
         address: '0xNewContractAddress'
         abi: Lock
         startBlock: 6000001 # Bloc suivant le dernier bloc indexé
       mapping:
         kind: ethereum/events
         apiVersion: 0.0.7
         language: wasm/assemblyscript
         entities:
           - Withdrawal
         abis:
           - name: Lock
             file: ./abis/Lock.json
         eventHandlers:
           - event: Withdrawal(uint256,uint256)
             handler: handleWithdrawal
         file: ./src/lock.ts
   features:
     - grafting
   graft:
     base: QmBaseDeploymentID # ID de déploiement du subgraph ayant échoué
     block: 6000000 # Dernier bloc indexé avec succès
   ```

**Explication:**

- **Mise à jour de la source de données** : Le nouveau subgraph pointe vers 0xNewContractAddress, qui peut être une version corrigée du smart contract.
- **Bloc de départ** : Fixé à un bloc après le dernier bloc indexé avec succès afin d'éviter de retraiter l'erreur.
- **Configuration du greffage** :
  - **base** : ID de déploiement du subgraph défaillant.
  - **bloc** : Numéro du bloc où le greffage doit commencer.

3. **Étapes de déploiement**

   - **Mise à jour du code** : Implémentez le correctif dans vos scripts de mappage (par exemple, handleWithdrawal).
   - **Ajuster le manifeste** : Comme indiqué ci-dessus, mettez à jour le fichier `subgraph.yaml` avec les configurations de greffage.
   - **Déployer le subgraph** :
     - S'authentifier à l'aide de l'interface de Graph CLI.
     - Déployer le nouveau subgraph en utilisant `graph deploy`.

4. **Post-Déploiement**
   - **Vérifier l'indexation** : Vérifier que le subgraph est correctement indexé à partir du point de greffage.
   - **Surveiller les données** : S'assurer que les nouvelles données sont capturées et que le correctif est efficace.
   - **Planifier la republication** : Planifier le déploiement d'une version non greffée pour une stabilité à long terme.

## Avertissements et précautions

Bien que le greffage soit un outil puissant pour déployer rapidement des correctifs, il existe des scénarios spécifiques dans lesquels il doit être évité afin de préserver l'intégrité des données et d'assurer des performances optimales.

- **Modifications de schéma incompatibles** : Si votre correctif nécessite de modifier le type des champs existants ou de supprimer des champs de votre schéma, le greffage n'est pas approprié. La greffe attend que le schéma du nouveau subgraph soit compatible avec celui du subgraph de base. Des modifications incompatibles peuvent entraîner des incohérences et des erreurs dans les données, car les données existantes ne sont pas alignées sur le nouveau schéma.
- **Révisions importantes de la logique de mappage** : Lorsque le correctif implique des modifications substantielles de votre logique de mappage, telles que la modification du traitement des événements ou des fonctions de gestion, le greffage risque de ne pas fonctionner correctement. La nouvelle logique peut ne pas être compatible avec les données traitées dans le cadre de l'ancienne logique, ce qui entraîne des données incorrectes ou un échec de l'indexation.
- **Déploiements sur The Graph Network** : Le greffage n'est pas recommandé pour les subgraphs destinés au réseau décentralisé de The Graph (réseau principal). Elle peut compliquer l'indexation et peut ne pas être entièrement prise en charge par tous les Indexeurs, ce qui peut entraîner un comportement inattendu ou une augmentation des coûts. Pour les déploiements sur le réseau principal, il est plus sûr de réindexer le subgraph à partir de zéro pour garantir une compatibilité et une fiabilité totales.

### Gestion des risques

- **Intégrité des données** : Des numéros de blocs incorrects peuvent entraîner la perte ou la duplication de données.
- **Test** : Testez toujours le greffage dans un environnement de développement avant de la déployer en production.

## Conclusion

Le greffage est une stratégie efficace pour déployer des correctifs lors du développement de subgraphs, vous permettant de:

- **Rétablissement rapide** sans besoin de réindexation après des erreurs critiques.
- **Préserver les données historiques**, en maintenant la continuité pour les applications et les utilisateurs.
- **Assurer la disponibilité du service** en minimisant les temps d'arrêt lors des corrections critiques.

Toutefois, il est important d'utiliser le greffage de manière judicieuse et de suivre les meilleures pratiques pour limiter les risques. Après avoir stabilisé votre subgraph à l'aide du correctif, prévoyez de déployer une version non greffée afin de garantir la maintenabilité à long terme.

## Ressources supplémentaires

- **[Documentation sur le greffage](/subgraphs/cookbook/grafting/)** : Remplacer un contrat et conserver son historique avec le greffage
- **[Comprendre les ID de déploiement](/subgraphs/querying/subgraph-id-vs-deployment-id/)** : Apprenez la différence entre l'ID de déploiement et l'ID de subgraph.

En intégrant le greffage dans votre flux de travail de développement de subgraphs, vous pouvez améliorer votre capacité à répondre rapidement aux problèmes, en veillant à ce que vos services de données restent robustes et fiables.

## Bonnes pratiques pour les subgraphs 1-6

1. [Improve Query Speed with Subgraph Pruning](/subgraphs/best-practices/pruning/)

2. [Improve Indexing and Query Responsiveness by Using @derivedFrom](/subgraphs/best-practices/derivedfrom/)

3. [Improve Indexing and Query Performance by Using Immutable Entities and Bytes as IDs](/subgraphs/best-practices/immutable-entities-bytes-as-ids/)

4. [Improve Indexing Speed by Avoiding `eth_calls`](/subgraphs/best-practices/avoid-eth-calls/)

5. [Simplify and Optimize with Timeseries and Aggregations](/subgraphs/best-practices/timeseries/)

6. [Use Grafting for Quick Hotfix Deployment](/subgraphs/best-practices/grafting-hotfix/)
