---
title: Meilleure pratique pour les subgraphs 6 - Utiliser le greffage pour un déploiement rapide des correctifs
sidebarTitle: Grafting and Hotfixing
---

## TLDR

Grafting is a powerful feature in Subgraph development that allows you to build and deploy new Subgraphs while reusing the indexed data from existing ones.

### Aperçu

This feature enables quick deployment of hotfixes for critical issues, eliminating the need to re-index the entire Subgraph from scratch. By preserving historical data, grafting minimizes downtime and ensures continuity in data services.

## Avantages du greffage pour les correctifs

1. **Déploiement rapide**

   - **Minimize Downtime**: When a Subgraph encounters a critical error and stops indexing, grafting enables you to deploy a fix immediately without waiting for re-indexing.
   - **Immediate Recovery**: The new Subgraph continues from the last indexed block, ensuring that data services remain uninterrupted.

2. **Préservation des données**

   - **Reuse Historical Data**: Grafting copies the existing data from the base Subgraph, so you don’t lose valuable historical records.
   - **Consistance** : Maintient la continuité des données, ce qui est crucial pour les applications qui s'appuient sur des données historiques cohérentes.

3. **Efficacité**
   - **Économie de temps et de ressources** : Évite surcoût de calcul lié à la réindexation de grands ensembles de données.
   - **Focalisation sur les corrections** : Permet aux développeurs de se concentrer sur la résolution des problèmes plutôt que sur la gestion de la récupération des données.

## Meilleures pratiques lors de l'utilisation du greffage pour les correctifs

1. **Déploiement initial sans greffage**

   - **Start Clean**: Always deploy your initial Subgraph without grafting to ensure that it’s stable and functions as expected.
   - **Test Thoroughly**: Validate the Subgraph’s performance to minimize the need for future hotfixes.

2. **Mise en œuvre du correctif par greffage**

   - **Identifier le problème** : Lorsqu'une erreur critique se produit, déterminez le numéro de bloc du dernier événement indexé avec succès.
   - **Create a New Subgraph**: Develop a new Subgraph that includes the hotfix.
   - **Configure Grafting**: Use grafting to copy data up to the identified block number from the failed Subgraph.
   - **Deploy Quickly**: Publish the grafted Subgraph to restore service as soon as possible.

3. **Actions post-correctif**

   - **Monitor Performance**: Ensure the grafted Subgraph is indexing correctly and the hotfix resolves the issue.
   - **Republish Without Grafting**: Once stable, deploy a new version of the Subgraph without grafting for long-term maintenance.
     > Remarque : il n'est pas recommandé de s'appuyer indéfiniment sur le greffage, car cela peut compliquer les mises à jour et la maintenance futures.
   - **Update References**: Redirect any services or applications to use the new, non-grafted Subgraph.

4. **Considérations importantes**
   - **Sélection minutieuse des blocs** : Choisissez soigneusement le numéro du bloc de greffage pour éviter toute perte de données.
   - **Conseil** : Utilisez le numéro de bloc du dernier événement correctement traité.
   - **Use Deployment ID**: Ensure you reference the Deployment ID of the base Subgraph, not the Subgraph ID.
   - **Note**: The Deployment ID is the unique identifier for a specific Subgraph deployment.
   - **Feature Declaration**: Remember to declare grafting in the Subgraph manifest under features.

## Exemple : Déploiement d'un correctif par greffage

Suppose you have a Subgraph tracking a smart contract that has stopped indexing due to a critical error. Here’s how you can use grafting to deploy a hotfix.

1. **Manifeste du subgraph échoué (subgraph.yaml)**

   ```yaml
   specVersion: 1.0.0
   schema:
     file: ./schema.graphql
   dataSources:
     - kind: ethereum/contract
       name: OldSmartContract
       network: sepolia
       source:
         address: '0xOldContractAddress'
         abi: Lock
         startBlock: 5000000
       mapping:
         kind: ethereum/events
         apiVersion: 0.0.7
         language: wasm/assemblyscript
         entities:
           - Withdrawal
         abis:
           - name: Lock
             file: ./abis/OldLock.json
         eventHandlers:
           - event: Withdrawal(uint256,uint256)
             handler: handleOldWithdrawal
         file: ./src/old-lock.ts
   ```

2. **Nouveau manifeste de subgraph greffé (subgraph.yaml)**
   ```yaml
   specVersion: 1.0.0
   schema:
     file: ./schema.graphql
   dataSources:
     - kind: ethereum/contract
       name: NewSmartContract
       network: sepolia
       source:
         address: '0xNewContractAddress'
         abi: Lock
         startBlock: 6000001 # Block after the last indexed block
       mapping:
         kind: ethereum/events
         apiVersion: 0.0.7
         language: wasm/assemblyscript
         entities:
           - Withdrawal
         abis:
           - name: Lock
             file: ./abis/Lock.json
         eventHandlers:
           - event: Withdrawal(uint256,uint256)
             handler: handleWithdrawal
         file: ./src/lock.ts
   features:
     - grafting
   graft:
     base: QmBaseDeploymentID # Deployment ID of the failed Subgraph
     block: 6000000 # Last successfully indexed block
   ```

**Explication:**

- **Data Source Update**: The new Subgraph points to 0xNewContractAddress, which may be a fixed version of the smart contract.
- **Bloc de départ** : Fixé à un bloc après le dernier bloc indexé avec succès afin d'éviter de retraiter l'erreur.
- **Configuration du greffage** :
  - **base**: Deployment ID of the failed Subgraph.
  - **bloc** : Numéro du bloc où le greffage doit commencer.

3. **Étapes de déploiement**

   - **Mise à jour du code** : Implémentez le correctif dans vos scripts de mappage (par exemple, handleWithdrawal).
   - **Ajuster le manifeste** : Comme indiqué ci-dessus, mettez à jour le fichier `subgraph.yaml` avec les configurations de greffage.
   - **Déployer le subgraph** :
     - S'authentifier à l'aide de l'interface de Graph CLI.
     - Deploy the new Subgraph using `graph deploy`.

4. **Post-Déploiement**
   - **Verify Indexing**: Check that the Subgraph is indexing correctly from the graft point.
   - **Surveiller les données** : S'assurer que les nouvelles données sont capturées et que le correctif est efficace.
   - **Planifier la republication** : Planifier le déploiement d'une version non greffée pour une stabilité à long terme.

## Avertissements et précautions

Bien que le greffage soit un outil puissant pour déployer rapidement des correctifs, il existe des scénarios spécifiques dans lesquels il doit être évité afin de préserver l'intégrité des données et d'assurer des performances optimales.

- **Incompatible Schema Changes**: If your hotfix requires altering the type of existing fields or removing fields from your schema, grafting is not suitable. Grafting expects the new Subgraph’s schema to be compatible with the base Subgraph’s schema. Incompatible changes can lead to data inconsistencies and errors because the existing data won’t align with the new schema.
- **Révisions importantes de la logique de mappage** : Lorsque le correctif implique des modifications substantielles de votre logique de mappage, telles que la modification du traitement des événements ou des fonctions de gestion, le greffage risque de ne pas fonctionner correctement. La nouvelle logique peut ne pas être compatible avec les données traitées dans le cadre de l'ancienne logique, ce qui entraîne des données incorrectes ou un échec de l'indexation.
- **Deployments to The Graph Network**: Grafting is not recommended for Subgraphs intended for The Graph’s decentralized network (mainnet). It can complicate indexing and may not be fully supported by all Indexers, potentially causing unexpected behavior or increased costs. For mainnet deployments, it’s safer to re-index the Subgraph from scratch to ensure full compatibility and reliability.

### Gestion des risques

- **Intégrité des données** : Des numéros de blocs incorrects peuvent entraîner la perte ou la duplication de données.
- **Test** : Testez toujours le greffage dans un environnement de développement avant de la déployer en production.

## Conclusion

Grafting is an effective strategy for deploying hotfixes in Subgraph development, enabling you to:

- **Rétablissement rapide** sans besoin de réindexation après des erreurs critiques.
- **Préserver les données historiques**, en maintenant la continuité pour les applications et les utilisateurs.
- **Assurer la disponibilité du service** en minimisant les temps d'arrêt lors des corrections critiques.

However, it’s important to use grafting judiciously and follow best practices to mitigate risks. After stabilizing your Subgraph with the hotfix, plan to deploy a non-grafted version to ensure long-term maintainability.

## Ressources supplémentaires

- **[Documentation sur le greffage](/subgraphs/cookbook/grafting/)** : Remplacer un contrat et conserver son historique avec le greffage
- **[Comprendre les ID de déploiement](/subgraphs/querying/subgraph-id-vs-deployment-id/)** : Apprenez la différence entre l'ID de déploiement et l'ID de subgraph.

By incorporating grafting into your Subgraph development workflow, you can enhance your ability to respond to issues swiftly, ensuring that your data services remain robust and reliable.

## Bonnes pratiques pour les subgraphs 1-6

1. [Improve Query Speed with Subgraph Pruning](/subgraphs/best-practices/pruning/)

2. [Improve Indexing and Query Responsiveness by Using @derivedFrom](/subgraphs/best-practices/derivedfrom/)

3. [Improve Indexing and Query Performance by Using Immutable Entities and Bytes as IDs](/subgraphs/best-practices/immutable-entities-bytes-as-ids/)

4. [Improve Indexing Speed by Avoiding `eth_calls`](/subgraphs/best-practices/avoid-eth-calls/)

5. [Simplify and Optimize with Timeseries and Aggregations](/subgraphs/best-practices/timeseries/)

6. [Use Grafting for Quick Hotfix Deployment](/subgraphs/best-practices/grafting-hotfix/)
