---
title: Meilleure Pratique Subgraph 1 - Améliorer la Vitesse des Requêtes avec le Pruning de Subgraph
sidebarTitle: Pruning with indexerHints
---

## TLDR

[Le pruning](/developing/creating-a-subgraph/#prune) (élagage) retire les entités archivées de la base de données des subgraphs jusqu'à un bloc donné, et retirer les entités inutilisées de la base de données d'un subgraph améliorera souvent de manière spectaculaire les performances de requête d'un subgraph. L'utilisation de `indexerHints` est un moyen simple de réaliser le pruning d'un subgraph.

## Comment effectuer le Pruning d'un subgraph avec `indexerHints`

Ajoutez une section appelée `indexerHints` dans le manifest.

`indexerHints` dispose de trois options de `prune` :

- `prune: auto`: Conserve l'historique minimum nécessaire tel que défini par l'Indexeur, optimisant ainsi les performances des requêtes. C'est le paramètre généralement recommandé et celui par défaut pour tous les subgraphs créés par `graph-cli` >= 0.66.0.
- `prune: <Nombre de blocs à conserver>`: Définit une limite personnalisée sur le nombre de blocs historiques à conserver.
- `prune : never` : Pas d'élagage des données historiques ; conserve l'historique complet et est la valeur par défaut s'il n'y a pas de section `indexerHints`. `prune : never` devrait être sélectionné si [Les requetes Chronologiques](/subgraphs/querying/graphql-api/#time-travel-queries) sont désirées.

Nous pouvons ajouter `indexerHints` à nos subgraphs en mettant à jour notre `subgraph.yaml`:

```yaml
specVersion: 1.0.0
schema:
  file: ./schema.graphql
indexerHints:
  prune: auto
dataSources:
  - kind: ethereum/contract
    name: Contract
    network: mainnet
```

## Points Importants

- Si les [requêtes chronologiques](/subgraphs/querying/graphql-api/#time-travel-queries) sont souhaitées en plus de l'élagage, l'élagage doit être effectué avec précision pour conserver la fonctionnalité des requêtes chronologiques. Pour cette raison, il n'est généralement pas recommandé d'utiliser `indexerHints : prune : auto` avec les requêtes chronologiques. Au lieu de cela, élaguez en utilisant `indexerHints : prune : <Nombre de blocs à conserver>` pour élaguer précisément à une hauteur de bloc qui préserve les données historiques requises par les requêtes chronologiques, ou utilisez `prune : never` pour conserver toutes les données.

- Il n'est pas possible de [greffer](/subgraphs/cookbook/grafting/) à une hauteur de bloc qui a été élaguée. Si le greffage est effectué de manière routinière et que l'élagage est souhaité, il est recommandé d'utiliser `indexerHints : prune : <Nombre de blocs à conserver>` qui conservera avec précision un nombre défini de blocs (par exemple, suffisamment pour six mois).

## Conclusion

L'élagage en utilisant `indexerHints` est une meilleure bonne pour le développement de subgraphs, offrant des améliorations significatives des performances des requêtes.

## Bonnes pratiques pour les subgraphs 1-6

1. [Improve Query Speed with Subgraph Pruning](/subgraphs/best-practices/pruning/)

2. [Improve Indexing and Query Responsiveness by Using @derivedFrom](/subgraphs/best-practices/derivedfrom/)

3. [Improve Indexing and Query Performance by Using Immutable Entities and Bytes as IDs](/subgraphs/best-practices/immutable-entities-bytes-as-ids/)

4. [Improve Indexing Speed by Avoiding `eth_calls`](/subgraphs/best-practices/avoid-eth-calls/)

5. [Simplify and Optimize with Timeseries and Aggregations](/subgraphs/best-practices/timeseries/)

6. [Use Grafting for Quick Hotfix Deployment](/subgraphs/best-practices/grafting-hotfix/)
