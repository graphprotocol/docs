---
title: Déploiement d'un subgraph sur plusieurs réseaux
sidebarTitle: Deploying to Multiple Networks
---

This page explains how to deploy a Subgraph to multiple networks. To deploy a Subgraph you need to first install the [Graph CLI](https://github.com/graphprotocol/graph-tooling/tree/main/packages/cli). If you have not created a Subgraph already, see [Creating a Subgraph](/developing/creating-a-subgraph/).

## Deploying the Subgraph to multiple networks

In some cases, you will want to deploy the same Subgraph to multiple networks without duplicating all of its code. The main challenge that comes with this is that the contract addresses on these networks are different.

### En utilisant `graph-cli`

Les commandes `graph build` (depuis la version `v0.29.0`) et `graph deploy` (depuis la version `v0.32.0`) acceptent deux nouvelles options:

```sh
Options:

      --network <nom>          Configuration du réseau à utiliser à partir du fichier de configuration des réseaux
      --network-file <chemin>  Chemin du fichier de configuration des réseaux (par défaut : "./networks.json")
```

You can use the `--network` option to specify a network configuration from a `json` standard file (defaults to `networks.json`) to easily update your Subgraph during development.

> Note : La commande `init` générera désormais automatiquement un fichier networks.json en se basant sur les informations fournies. Vous pourrez ensuite mettre à jour les réseaux existants ou en ajouter de nouveaux.

Si vous n'avez pas de fichier `networks.json`, vous devrez en créer un manuellement avec la structure suivante :

```json
{
    "network1": { // le nom du réseau
        "dataSource1": { // le nom de la source de données
            "address": "0xabc...", // l'adresse du contrat (facultatif)
            "startBlock": 123456 // le bloc de départ (facultatif)
        },
        "dataSource2": {
            "address": "0x123...",
            "startBlock": 123444
        }
    },
    "network2": {
        "dataSource1": {
            "address": "0x987...",
            "startBlock": 123
        },
        "dataSource2": {
            "address": "0xxyz..",
            "startBlock": 456
        }
    },
    ...
}
```

> Note : Vous n'avez besoin de spécifier aucun des `templates` (si vous en avez) dans le fichier de configuration, uniquement les `dataSources`. Si des `templates` sont déclarés dans le fichier `subgraph.yaml`, leur réseau sera automatiquement mis à jour vers celui spécifié avec l'option `--network`.

Now, let's assume you want to be able to deploy your Subgraph to the `mainnet` and `sepolia` networks, and this is your `subgraph.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x123...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

Voici à quoi devrait ressembler votre fichier de configuration réseau :

```json
{
  "mainnet": {
    "Gravity": {
      "address": "0x123..."
    }
  },
  "sepolia": {
    "Gravity": {
      "address": "0xabc..."
    }
  }
}
```

Nous pouvons maintenant exécuter l'une des commandes suivantes :

```sh
# En utilisant le fichier networks.json par défaut
yarn build --network sepolia

 # En utilisant un fichier personnalisé
yarn build --network sepolia --network-file chemin/à/configurer
```

The `build` command will update your `subgraph.yaml` with the `sepolia` configuration and then re-compile the Subgraph. Your `subgraph.yaml` file now should look like this:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: sepolia
    source:
      address: '0xabc...'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

Vous êtes maintenant prêt à utiliser la commande `yarn deploy`.

> Note : Comme mentionné précédemment, depuis `graph-cli 0.32.0`, vous pouvez directement exécuter `yarn deploy` avec l'option `--network`:

```sh
# En utilisant le fichier networks.json par défaut
yarn deploy --network sepolia

 # En utilisant un fichier personnalisé
yarn deploy --network sepolia --network-file chemin/à/configurer
```

### Utilisation du modèle subgraph.yaml

Une façon de paramétrer des aspects tels que les adresses de contrat en utilisant des versions plus anciennes de `graph-cli` est de générer des parties de celui-ci avec un système de creation de modèle comme [Mustache](https://mustache.github.io/) ou [Handlebars](https://handlebarsjs.com/).

To illustrate this approach, let's assume a Subgraph should be deployed to mainnet and Sepolia using different contract addresses. You could then define two config files providing the addresses for each network:

```json
{
  "network": "mainnet",
  "address": "0x123..."
}
```

et

```json
{
  "network": "sepolia",
  "address": "0xabc..."
}
```

Avec ceci, vous remplacerez le nom du réseau et les adresses dans le manifeste par des variables de type `{{network}}` et `{{address}}` et renommer le manifeste par exemple `subgraph.template.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

Pour générer un manifeste pour l'un ou l'autre réseau, vous pourriez ajouter deux commandes supplémentaires au fichier `package.json` ainsi qu'une dépendance à `mustache` :

```json
{
  ...
  "scripts": {
    ...
    "prepare:mainnet": "mustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
    "prepare:sepolia": "mustache config/sepolia.json subgraph.template.yaml > subgraph.yaml"
  },
  "devDependencies": {
    ...
    "mustache": "^3.1.0"
  }
}
```

To deploy this Subgraph for mainnet or Sepolia you would now simply run one of the two following commands:

```sh
# Mainnet:
yarn prepare:mainnet && yarn deploy

# Sepolia:
yarn prepare:sepolia && yarn deploy
```

Un exemple fonctionnel de ceci peut être trouvé [ici](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759).

Note : Cette approche peut également être appliquée à des situations plus complexes, dans lesquelles il est nécessaire de remplacer plus que les adresses des contrats et les noms de réseau ou où il est nécessaire de générer des mappages ou alors des ABI à partir de modèles également.

This will give you the `chainHeadBlock` which you can compare with the `latestBlock` on your Subgraph to check if it is running behind. `synced` informs if the Subgraph has ever caught up to the chain. `health` can currently take the values of `healthy` if no errors occurred, or `failed` if there was an error which halted the progress of the Subgraph. In this case, you can check the `fatalError` field for details on this error.

## Subgraph Studio Subgraph archive policy

A Subgraph version in Studio is archived if and only if it meets the following criteria:

- La version n'est pas publiée sur le réseau (ou en attente de publication)
- La version a été créée il y a 45 jours ou plus
- The Subgraph hasn't been queried in 30 days

In addition, when a new version is deployed, if the Subgraph has not been published, then the N-2 version of the Subgraph is archived.

Every Subgraph affected with this policy has an option to bring the version in question back.

## Checking Subgraph health

If a Subgraph syncs successfully, that is a good sign that it will continue to run well forever. However, new triggers on the network might cause your Subgraph to hit an untested error condition or it may start to fall behind due to performance issues or issues with the node operators.

Graph Node exposes a GraphQL endpoint which you can query to check the status of your Subgraph. On the hosted service, it is available at `https://api.thegraph.com/index-node/graphql`. On a local node, it is available on port `8030/graphql` by default. The full schema for this endpoint can be found [here](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql). Here is an example query that checks the status of the current version of a Subgraph:

```graphql
{
  indexingStatusForCurrentVersion(subgraphName: "org/subgraph") {
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      chainHeadBlock {
        number
      }
      latestBlock {
        number
      }
    }
  }
}
```

This will give you the `chainHeadBlock` which you can compare with the `latestBlock` on your Subgraph to check if it is running behind. `synced` informs if the Subgraph has ever caught up to the chain. `health` can currently take the values of `healthy` if no errors occurred, or `failed` if there was an error which halted the progress of the Subgraph. In this case, you can check the `fatalError` field for details on this error.
