---
title: Manifeste de Subgraph
---

## Aperçu

The Subgraph manifest, `subgraph.yaml`, defines the smart contracts & network your Subgraph will index, the events from these contracts to pay attention to, and how to map event data to entities that Graph Node stores and allows to query.

The **Subgraph definition** consists of the following files:

- `subgraph.yaml`: Contains the Subgraph manifest

- `schema.graphql`: A GraphQL schema defining the data stored for your Subgraph and how to query it via GraphQL

- `mapping.ts` : [Mappage AssemblyScript](https://github.com/AssemblyScript/assemblyscript) code qui traduit les données d'événements en entités définies dans votre schéma (par exemple `mapping.ts` dans ce guide)

### Capacités des subgraphs

A single Subgraph can:

- Indexer les données de plusieurs contrats intelligents (mais pas de plusieurs réseaux).

- Indexer des données de fichiers IPFS en utilisant des File Data Sources.

- Ajouter une entrée pour chaque contrat nécessitant une indexation dans le tableau `dataSources`.

The full specification for Subgraph manifests can be found [here](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

For the example Subgraph listed above, `subgraph.yaml` is:

```yaml
version spec : 0.0.4
description : Gravatar pour Ethereum
référentiel : https://github.com/graphprotocol/graph-tooling
schéma:
   fichier : ./schema.graphql
indexeurConseils :
   tailler : automatique
les sources de données:
   - genre : ethereum/contrat
     nom: Gravité
     réseau : réseau principal
     source:
       adresse : '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
       abi : Gravité
       bloc de démarrage : 6175244
       bloc de fin : 7175245
     contexte:
       foo :
         tapez : Booléen
         données : vrai
       bar:
         tapez : chaîne
         données : 'barre'
     cartographie :
       genre : ethereum/événements
       Version api : 0.0.6
       langage : wasm/assemblyscript
       entités :
         -Gravatar
       abis :
         - nom : Gravité
           fichier : ./abis/Gravity.json
       Gestionnaires d'événements :
         - événement : NewGravatar(uint256,adresse,chaîne,chaîne)
           gestionnaire : handleNewGravatar
         - événement : UpdatedGravatar (uint256, adresse, chaîne, chaîne)
           gestionnaire : handleUpdatedGravatar
       Gestionnaires d'appels :
         - fonction : createGravatar(string,string)
           gestionnaire : handleCreateGravatar
       gestionnaires de blocs :
         - gestionnaire : handleBlock
         - gestionnaire : handleBlockWithCall
           filtre:
             genre : appeler
       fichier : ./src/mapping.ts
```

## Entrées de subgraphs

> Important Note: Be sure you populate your Subgraph manifest with all handlers and [entities](/subgraphs/developing/creating/ql-schema/).

Les entrées importantes à mettre à jour pour le manifeste sont :

- `specVersion`: a semver version that identifies the supported manifest structure and functionality for the Subgraph. The latest version is `1.2.0`. See [specVersion releases](#specversion-releases) section to see more details on features & releases.

- `description`: a human-readable description of what the Subgraph is. This description is displayed in Graph Explorer when the Subgraph is deployed to Subgraph Studio.

- `repository`: the URL of the repository where the Subgraph manifest can be found. This is also displayed in Graph Explorer.

- `features` : une liste de tous les noms de [fonctionnalités](#experimental-features) utilisés.

- `indexerHints.prune`: Defines the retention of historical block data for a Subgraph. See [prune](#prune) in [indexerHints](#indexer-hints) section.

- `dataSources.source`: the address of the smart contract the Subgraph sources, and the ABI of the smart contract to use. The address is optional; omitting it allows to index matching events from all contracts.

- `dataSources.source.startBlock` : le numéro optionnel du bloc à partir duquel la source de données commence l'indexation. Dans la plupart des cas, nous suggérons d'utiliser le bloc dans lequel le contrat a été créé.

- `dataSources.source.endBlock` : Le numéro optionnel du bloc sur lequel la source de données arrête l'indexation, y compris ce bloc. Version minimale de la spécification requise : `0.0.9`.

- `dataSources.context`: key-value pairs that can be used within Subgraph mappings. Supports various data types like `Bool`, `String`, `Int`, `Int8`, `BigDecimal`, `Bytes`, `List`, and `BigInt`. Each variable needs to specify its `type` and `data`. These context variables are then accessible in the mapping files, offering more configurable options for Subgraph development.

- `dataSources.mapping.entities` : les entités que la source de données écrit dans le store. Le schéma de chaque entité est défini dans le fichier schema.graphql.

- `dataSources.mapping.abis` : un ou plusieurs fichiers ABI nommés pour le contrat source ainsi que pour tous les autres contrats intelligents avec lesquels vous interagissez à partir des mappages.

- `dataSources.mapping.eventHandlers`: lists the smart contract events this Subgraph reacts to and the handlers in the mapping—./src/mapping.ts in the example—that transform these events into entities in the store.

- `dataSources.mapping.callHandlers`: lists the smart contract functions this Subgraph reacts to and handlers in the mapping that transform the inputs and outputs to function calls into entities in the store.

- `dataSources.mapping.blockHandlers`: lists the blocks this Subgraph reacts to and handlers in the mapping to run when a block is appended to the chain. Without a filter, the block handler will be run every block. An optional call-filter can be provided by adding a `filter` field with `kind: call` to the handler. This will only run the handler if the block contains at least one call to the data source contract.

A single Subgraph can index data from multiple smart contracts. Add an entry for each contract from which data needs to be indexed to the `dataSources` array.

## Gestionnaires d'événements

Event handlers in a Subgraph react to specific events emitted by smart contracts on the blockchain and trigger handlers defined in the Subgraph's manifest. This enables Subgraphs to process and store event data according to defined logic.

### Définition d'un gestionnaire d'événements

An event handler is declared within a data source in the Subgraph's YAML configuration. It specifies which events to listen for and the corresponding function to execute when those events are detected.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: Approval(address,address,uint256)
          handler: handleApproval
        - event: Transfer(address,address,uint256)
          handler: handleTransfer
          topic1: ['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', '0xc8dA6BF26964aF9D7eEd9e03E53415D37aA96325'] # Filtre de rubrique optionnel qui filtre uniquement les événements avec la rubrique spécifiée.
```

## Gestionnaires d'appels

While events provide an effective way to collect relevant changes to the state of a contract, many contracts avoid generating logs to optimize gas costs. In these cases, a Subgraph can subscribe to calls made to the data source contract. This is achieved by defining call handlers referencing the function signature and the mapping handler that will process calls to this function. To process these calls, the mapping handler will receive an `ethereum.Call` as an argument with the typed inputs to and outputs from the call. Calls made at any depth in a transaction's call chain will trigger the mapping, allowing activity with the data source contract through proxy contracts to be captured.

Les gestionnaires d'appels ne se déclencheront que dans l'un des deux cas suivants : lorsque la fonction spécifiée est appelée par un compte autre que le contrat lui-même ou lorsqu'elle est marquée comme externe dans Solidity et appelée dans le cadre d'une autre fonction du même contrat.

> **Note:** Call handlers currently depend on the Parity tracing API. Certain networks, such as BNB chain and Arbitrum, does not support this API. If a Subgraph indexing one of these networks contain one or more call handlers, it will not start syncing. Subgraph developers should instead use event handlers. These are far more performant than call handlers, and are supported on every evm network.

### Définir un gestionnaire d'appels

Pour définir un gestionnaire d'appel dans votre manifeste, ajoutez simplement un tableau `callHandlers` sous la source de données à laquelle vous souhaitez vous abonner.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

La propriété `function` est la signature de la fonction normalisée pour filtrer les appels. La propriété `handler` est le nom de la fonction dans votre mappage que vous souhaitez exécuter lorsque la fonction cible est appelée dans le contrat de la source de données.

### Fonction de cartographie

Each call handler takes a single parameter that has a type corresponding to the name of the called function. In the example Subgraph above, the mapping contains a handler for when the `createGravatar` function is called and receives a `CreateGravatarCall` parameter as an argument:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

La fonction `handleCreateGravatar` prend un nouveau `CreateGravatarCall` qui est une sous-classe de `ethereum.Call`, fournie par `@graphprotocol/graph-ts`, qui inclut les entrées et sorties typées de l'appel. Le type `CreateGravatarCall` est généré pour vous lorsque vous lancez `graph codegen`.

## Block Handlers

In addition to subscribing to contract events or function calls, a Subgraph may want to update its data as new blocks are appended to the chain. To achieve this a Subgraph can run a function after every block or after blocks that match a pre-defined filter.

### Filtres pris en charge

#### Filtre d'appel

```yaml
filter:
  kind: call
```

_Le gestionnaire défini sera appelé une fois pour chaque bloc qui contient un appel au contrat (source de données) sous lequel le gestionnaire est défini._

> **Note:** The `call` filter currently depend on the Parity tracing API. Certain networks, such as BNB chain and Arbitrum, does not support this API. If a Subgraph indexing one of these networks contain one or more block handlers with a `call` filter, it will not start syncing.

L'absence de filtre pour un gestionnaire de bloc garantira que le gestionnaire est appelé à chaque bloc. Une source de données ne peut contenir qu'un seul gestionnaire de bloc pour chaque type de filtre.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

#### Filtre d'interrogation

> **Nécessite `specVersion` >= 0.0.8**
>
> **Note:** Les filtres d'interrogation ne sont disponibles que sur les dataSources de `kind : ethereum`.

```yaml
blockHandlers:
  - handler: handleBlock
    filter:
      kind: polling
      every: 10
```

The defined handler will be called once for every `n` blocks, where `n` is the value provided in the `every` field. This configuration allows the Subgraph to perform specific operations at regular block intervals.

#### Le filtre Once

> **Nécessite `specVersion` >= 0.0.8**
>
> **Note:** Les filtres Once ne sont disponibles que sur les dataSources de `kind : ethereum`.

```yaml
blockHandlers:
  - handler: handleOnce
    filter:
      kind: once
```

The defined handler with the once filter will be called only once before all other handlers run. This configuration allows the Subgraph to use the handler as an initialization handler, performing specific tasks at the start of indexing.

```ts
export function handleOnce(block: ethereum.Block): void {
  let data = new InitialData(Bytes.fromUTF8('initial'))
  data.data = 'Setup data here'
  data.save()
}
```

### Fonction de cartographie

The mapping function will receive an `ethereum.Block` as its only argument. Like mapping functions for events, this function can access existing Subgraph entities in the store, call smart contracts and create or update entities.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash
  let entity = new Block(id)
  entity.save()
}
```

## Événements anonymes

Si vous devez traiter des événements anonymes dans Solidity, cela peut être réalisé en fournissant le sujet 0 de l'événement, comme dans l'exemple :

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0x644843f351d3fba4abcd60109eaff9f54bac8fb8ccf0bab941009c21df21cf31'
    handler: handleGive
```

Un événement ne sera déclenché que si la signature et le sujet 0 correspondent. Par défaut, `topic0` est égal au hash de la signature de l'événement.

## Reçus de transaction dans les gestionnaires d'événements

A partir de `specVersion` `0.0.5` et `apiVersion` `0.0.7`, les gestionnaires d'événements peuvent avoir accès au reçu de la transaction qui les a émis.

To do so, event handlers must be declared in the Subgraph manifest with the new `receipt: true` key, which is optional and defaults to false.

```yaml
eventHandlers:
  - event: NewGravatar(uint256,address,string,string)
    handler: handleNewGravatar
    receipt: true
```

Dans la fonction handler, le reçu peut être accédé dans le champ `Event.receipt`. Si la clé `receipt` est fixée à `false` ou omise dans le manifeste, une valeur `null` sera renvoyée à la place.

## Ordre de déclenchement des gestionnaires

Les déclencheurs d'une source de données au sein d'un bloc sont classés à l'aide du processus suivant :

1. Les déclencheurs d'événements et d'appels sont d'abord classés par index de transaction au sein du bloc.
2. Les déclencheurs d'événements et d'appels au sein d'une même transaction sont classés selon une convention : les déclencheurs d'événements d'abord, puis les déclencheurs d'appel, chaque type respectant l'ordre dans lequel ils sont définis dans le manifeste.
3. Les déclencheurs de bloc sont exécutés après les déclencheurs d'événement et d'appel, dans l'ordre dans lequel ils sont définis dans le manifeste.

Ces règles de commande sont susceptibles de changer.

> **Note:** Lorsque de nouvelles [sources de données dynamiques] (#data-source-templates-for-dynamically-created-contracts) sont créées, les gestionnaires définis pour les sources de données dynamiques ne commenceront à être traités qu'une fois que tous les gestionnaires de sources de données existants auront été traités, et se répéteront dans la même séquence chaque fois qu'ils seront déclenchés.

## Modèles de sources de données

Un modèle courant dans les contrats intelligents compatibles EVM est l'utilisation de contrats de registre ou d'usine, dans lesquels un contrat crée, gère ou référence un nombre arbitraire d'autres contrats qui ont chacun leur propre état et leurs propres événements.

Les adresses de ces sous-contrats peuvent ou non être connues à l'avance et nombre de ces contrats peuvent être créés et/ou ajoutés au fil du temps. C'est pourquoi, dans de tels cas, la définition d'une source de données unique ou d'un nombre fixe de sources de données est impossible et une approche plus dynamique est nécessaire : les _modèles de sources de données_.

### Source de données pour le contrat principal

Tout d'abord, vous devez définir une source de données régulière pour le contrat principal. L'extrait ci-dessous montre un exemple simplifié de source de données pour le contrat factory de l'exchange [Uniswap](https://uniswap.org). Notez le gestionnaire d'événement `NewExchange(address,address)`. Il est émis lorsqu'un nouveau contrat d'exchange est créé onchain par le contrat factory.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Modèles de source de données pour les contrats créés dynamiquement

Ensuite, vous ajoutez des _modèles de sources de données_ au manifeste. Ceux-ci sont identiques aux sources de données classiques, sauf qu'ils n'ont pas d'adresse de contrat prédéfinie sous `source`. Typiquement, vous devriez définir un modèle pour chaque type de sous-contrat géré ou référencé par le contrat parent.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Instanciation d'un modèle de source de données

Dans la dernière étape, vous mettez à jour votre mappage du contrat principal pour créer une instance de source de données dynamique à partir de l'un des modèles. Dans cet exemple, vous modifiez le mappage du contrat principal pour importer le modèle `Exchange` et appeler la méthode `Exchange.create(address)` pour commencer à indexer le nouveau contrat d'exchange.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Commence à indexer l'échange ; `event.params.exchange` est le
  // adresse du nouveau contrat d'échange
  Exchange.create(event.params.exchange)
}
```

> **Note:** Une nouvelle source de données ne traitera que les appels et les événements du bloc dans lequel elle a été créée et de tous les blocs suivants, mais ne traitera pas les données historiques, c'est-à-dire les données contenues dans les blocs précédents.
>
> Si les blocs précédents contiennent des données pertinentes pour la nouvelle source de données, il est préférable d'indexer ces données en lisant l'état actuel du contrat et en créant des entités représentant cet état au moment de la création de la nouvelle source de données.

### Data Source Context

Les contextes de source de données permettent de passer une configuration supplémentaire lors de l'instanciation d'un modèle. Dans notre exemple, disons que les éxchanges sont associés à une paire de trading particulière, qui est incluse dans l'événement `NewExchange`. Cette information peut être passée dans la source de données instanciée, comme suit :

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

A l'intérieur d'un mappage du modèle `Exchange`, il est possible d'accéder au contexte :

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Il existe des setters et getters comme `setString` et `getString` pour tous les types de valeurs.

## Blocs de démarrage

The `startBlock` is an optional setting that allows you to define from which block in the chain the data source will start indexing. Setting the start block allows the data source to skip potentially millions of blocks that are irrelevant. Typically, a Subgraph developer will set `startBlock` to the block in which the smart contract of the data source was created.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Note:** Le bloc de création du contrat peut être consulté rapidement sur Etherscan :
>
> 1. Recherchez le contrat en saisissant son adresse dans la barre de recherche.
> 2. Cliquez sur le hash de la transaction de création dans la section `Contract Creator`.
> 3. Chargez la page des détails de la transaction où vous trouverez le bloc de départ de ce contrat.

## Conseils pour l'indexeur

The `indexerHints` setting in a Subgraph's manifest provides directives for indexers on processing and managing a Subgraph. It influences operational decisions across data handling, indexing strategies, and optimizations. Presently, it features the `prune` option for managing historical data retention or pruning.

> Cette fonctionnalité est disponible à partir de `specVersion : 1.0.0`

### Prune

`indexerHints.prune`: Defines the retention of historical block data for a Subgraph. Options include:

1. `"never"`: Aucune suppression des données historiques ; conserve l'ensemble de l'historique.
2. `"auto"`: Conserve l'historique minimum nécessaire tel que défini par l'Indexeur, optimisant ainsi les performances de la requête.
3. Un nombre spécifique : Fixe une limite personnalisée au nombre de blocs historiques à conserver.

```
 indexerHints:
  prune: auto
```

> The term "history" in this context of Subgraphs is about storing data that reflects the old states of mutable entities.

L'historique à partir d'un bloc donné est requis pour :

- [Time travel queries](/subgraphs/querying/graphql-api/#time-travel-queries), which enable querying the past states of these entities at specific blocks throughout the Subgraph's history
- Using the Subgraph as a [graft base](/developing/creating-a-subgraph/#grafting-onto-existing-subgraphs) in another Subgraph, at that block
- Rewinding the Subgraph back to that block

Si les données historiques à partir du bloc ont été purgées, les capacités ci-dessus ne seront pas disponibles.

> L'utilisation de `"auto"` est généralement recommandée car elle maximise les performances des requêtes et est suffisante pour la plupart des utilisateurs qui n'ont pas besoin d'accéder à des données historiques étendues.

For Subgraphs leveraging [time travel queries](/subgraphs/querying/graphql-api/#time-travel-queries), it's advisable to either set a specific number of blocks for historical data retention or use `prune: never` to keep all historical entity states. Below are examples of how to configure both options in your Subgraph's settings:

Pour conserver une quantité spécifique de données historiques :

```
 indexerHints:
  prune: 1000 # Remplacez 1000 par le nombre de blocs souhaité à conserver
```

Préserver l'histoire complète des États de l'entité :

```
indexerHints:
  prune: never
```

## SpecVersion Releases

| Version | Notes de version                                                                                                                                                         |
| :-----: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|  1.2.0  | Added support for [Indexed Argument Filtering](/#indexed-argument-filters--topic-filters) & declared `eth_call`                                                          |
|  1.1.0  | Supports [Timeseries & Aggregations](#timeseries-and-aggregations). Added support for type `Int8` for `id`.                                                              |
|  1.0.0  | Supports [`indexerHints`](/developing/creating-a-subgraph/#indexer-hints) feature to prune Subgraphs                                                                     |
|  0.0.9  | Supports `endBlock` feature                                                                                                                                              |
|  0.0.8  | Added support for polling [Block Handlers](/developing/creating-a-subgraph/#polling-filter) and [Initialisation Handlers](/developing/creating-a-subgraph/#once-filter). |
|  0.0.7  | Added support for [File Data Sources](/developing/creating-a-subgraph/#file-data-sources).                                                                               |
|  0.0.6  | Supports fast [Proof of Indexing](/indexing/overview/#what-is-a-proof-of-indexing-poi) calculation variant.                                                              |
|  0.0.5  | Added support for event handlers having access to transaction receipts.                                                                                                  |
|  0.0.4  | Added support for managing subgraph features.                                                                                                                            |
