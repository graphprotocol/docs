---
title: Cadre pour les tests unitaires
---

Apprenez √† utiliser Matchstick, un cadre de test unitaire d√©velopp√© par [LimeChain](https://limechain.tech/). Matchstick permet aux d√©veloppeurs de subgraphs de tester leur logique de mappages dans un environnement sandbox et de d√©ployer avec succ√®s leurs subgraphs.

## Avantages de l'utilisation de Matchstick

- Il est √©crit en Rust et optimis√© pour des hautes performances.
- Il vous donne acc√®s √† des fonctions de d√©veloppement, notamment la possibilit√© de simuler des appels de contrat, de faire des assertions sur l'√©tat du store, de surveiller les √©checs du subgraph, de v√©rifier les performances des tests, et bien d'autres choses encore.

## Introduction

### Installation des d√©pendances

Pour utiliser les m√©thodes d'aide aux tests et ex√©cuter les tests, vous devez installer les d√©pendances suivantes :

```sh
yarn add --dev matchstick-as
```

### Installer PostgreSQL

`graph-node` d√©pend de PostgreSQL, donc si vous ne l'avez pas d√©j√†, vous devrez l'installer.

> Remarque : Il est fortement recommand√© d'utiliser les commandes ci-dessous pour √©viter les erreurs inattendues.

#### En utilisant MacOS

Commande d'installation :

```sh
brew install postgresql
```

Cr√©ez un lien symbolique vers la derni√®re version de libpq.5.lib _Vous devrez peut-√™tre cr√©er ce r√©pertoire d'abord_ `/usr/local/opt/postgresql/lib/`

```sh
ln -sf /usr/local/opt/postgresql@14/lib/postgresql@14/libpq.5.dylib /usr/local/opt/postgresql/lib/libpq.5.dylib
```

#### En utilisant Linux

Commande d'installation (d√©pend de votre distribution) :

```sh
sudo apt installer postgresql
```

### En utilisant WSL (Windows Subsystem for Linux)

Vous pouvez utiliser Matchstick sur WSL en utilisant √† la fois l'approche Docker et l'approche binaire. Comme WSL peut √™tre un peu d√©licat, voici quelques conseils au cas o√π vous rencontreriez des probl√®mes tels que

```
static BYTES = Symbol("Bytes") SyntaxError: Unexpected token =
```

ou bien

```
<PROJECT_PATH>/node_modules/gluegun/build/index.js:13 throw up;
```

Veuillez vous assurer que vous √™tes sur une version plus r√©cente de Node.js graph-cli ne prend plus en charge **v10.19.0**, et c'est toujours la version par d√©faut pour les nouvelles images Ubuntu sur le WSL. Par exemple, il est confirm√© que Matchstick fonctionne sur WSL avec **v18.1.0**, vous pouvez passer √† cette version via **nvm** ou si vous mettez √† jour votre Node.js global. N'oubliez pas de supprimer `node_modules` et de relancer `npm install` apr√®s avoir mis √† jour votre nodejs ! Ensuite, assurez-vous que **libpq** est install√©, vous pouvez le faire en ex√©cutant

```
sudo apt-get install libpq-dev
```

Et enfin, n'utilisez pas `graph test` (qui utilise votre installation globale de graph-cli et pour une raison quelconque, il semble qu'il soit cass√© sur WSL actuellement), utilisez plut√¥t `yarn test` ou `npm run test` (qui utilisera l'instance locale, au niveau du projet, de graph-cli, ce qui fonctionne comme un charme). Pour cela, vous devez bien s√ªr avoir un script `" test "` dans votre fichier `package.json` qui peut √™tre quelque chose d'aussi simple que

```json
{
  "name": "demo-subgraph",
  "version": "0.1.0",
  "scripts": {
    "test": "graph test",
    ...
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "^0.56.0",
    "@graphprotocol/graph-ts": "^0.31.0",
    "matchstick-as": "^0.6.0"
  }
}
```

### En utilisant Matchstick

Pour utiliser **Matchstick** dans votre projet Subgraph, ouvrez simplement un terminal, naviguez jusqu'au dossier racine de votre projet et lancez simplement `graph test [options] <datasource>` - il t√©l√©charge le dernier binaire **Matchstick** et ex√©cute le test sp√©cifi√© ou tous les tests dans un dossier de test (ou tous les tests existants si aucun flag de source de donn√©es n'est sp√©cifi√©).

### CLI options

Cette op√©ration permet d'ex√©cuter tous les tests contenus dans le dossier test :

```sh
graph test
```

Ceci lancera un test nomm√© gravity.test.ts et/ou tous les tests √† l'int√©rieur d'un dossier nomm√© gravity :

```sh
gravity graph test
```

Ce fichier de test sera le seul √† √™tre ex√©cut√© :

```sh
graph test path/to/file.test.ts
```

**Options:**

```sh
-c, --coverage                Ex√©cute les tests en mode couverture
-d, --docker                  Ex√©cute les tests dans un conteneur Docker (Note : Ex√©cute √† partir du dossier racine du subgraph).
-f, --force                   Binaire : Red√©charge le binaire. Docker : Red√©charge le fichier Docker et reconstruit l'image Docker.
-h, --help                    Affiche les informations sur l'utilisation
-l, --logs                    Enregistre dans la console des informations sur le syst√®me d'exploitation, le mod√®le de processeur et l'adresse de t√©l√©chargement (√† des fins de d√©bogage).
-r, --recompile               Oblige √† recompiler les tests
-v, --version <tag>           Choisi la version du binaire rust que vous souhaitez t√©l√©charger/utiliser
```

### Docker

Depuis `graph-cli 0.25.2`, la commande `graph test` supporte l'ex√©cution de `matchstick` dans un conteneur docker avec l'option `-d`. L'impl√©mentation de docker utilise [bind mount](https://docs.docker.com/storage/bind-mounts/) pour ne pas avoir √† reconstruire l'image de docker √† chaque fois que la commande `graph test -d` est ex√©cut√©e. Vous pouvez √©galement suivre les instructions du d√©p√¥t [matchstick](https://github.com/LimeChain/matchstick#docker-) pour ex√©cuter docker manuellement.

‚ùó `graph test -d` force `docker run` √† s'ex√©cuter avec le flag `-t`. Ceci doit √™tre supprim√© pour fonctionner dans des environnements non-interactifs (comme GitHub CI).

‚ùó Si vous avez pr√©c√©demment ex√©cut√© `graph test`, vous pouvez rencontrer l'erreur suivante lors du build de docker :

```sh
  error from sender: failed to xattr node_modules/binary-install-raw/bin/binary-<platform>: permission denied
```

Dans ce cas, cr√©ez un `.dockerignore` dans le dossier racine et ajoutez `node_modules/binary-install-raw/bin`

### La Configuration

Matchstick peut √™tre configur√© pour utiliser un chemin personnalis√© pour les tests, les librairies et les manifestes via le fichier de configuration `matchstick.yaml` :

```yaml
testsFolder: path/to/tests
libsFolder: path/to/libs
manifestPath: path/to/subgraph.yaml
```

### Subgraph Demo

Vous pouvez essayer et jouer avec les exemples de ce guide en clonant le [d√©p√¥t du Demo Subgraph.](https://github.com/LimeChain/demo-subgraph)

### Tutoriels vid√©os

Vous pouvez √©galement consulter la s√©rie de vid√©os sur ["Comment utiliser Matchstick pour √©crire des tests unitaires pour vos subgraphs" ](https://www.youtube.com/playlist?list=PLTqyKgxaGF3SNakGQwczpSGVjS_xvOv3h)

## Structure des tests

_**IMPORTANT : La structure de test d√©crite ci-dessous d√©pend de la version de `matchstick-as` >=0.5.0**_

### d√©crivez()

`describe(name : String , () => {})` - D√©finit un groupe de test.

**_Notes:_**

- _Les descriptions ne sont pas obligatoires. Vous pouvez toujours utiliser test() √† l'ancienne, en dehors des blocs describe()_

L'exemple:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Il faut cr√©er une nouvelle entit√© Gravatar", () => {
    ...
  })
})
```

Exemple imbriqu√© de `describe()` :

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar } from "../../src/gravity"

describe("handleUpdatedGravatar()", () => {
  describe("Lorsque l'entit√© existe", () => {
    test("met √† jour l'entit√©", () => {
      ...
    })
  })

  describe("Lorsque l'entit√© n'existe pas", () => {
    test("il cr√©e une nouvelle entit√©", () => {
      ...
    })
  })
})
```

---

### tester ()

`test(name : String, () =>, should_fail : bool)` - D√©finit un cas de test. Vous pouvez utiliser test() √† l'int√©rieur des blocs describe() ou ind√©pendamment.

L'exemple:

```typescript
import { describe, test } from "matchstick-as/assembly/index"
import { handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar()", () => {
  test("Doit cr√©er une nouvelle entit√©", () => {
    ...
  })
})
```

ou bien

```typescript
test("handleNewGravatar() devrait cr√©er une nouvelle entit√©", () => {
  ...
})


```

---

### avantTout()

Ex√©cute un bloc de code avant tous les tests du fichier. Si `beforeAll` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il s'ex√©cute au d√©but de ce bloc `describe`.

Les Exemples:

Le code contenu dans `beforeAll` s'ex√©cutera une fois avant _tous_ les tests du fichier.

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

beforeAll(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
  ...
})

describe("Lorsque l'entit√© n'existe pas", () => {
  test("il devrait cr√©er un nouveau Gravatar avec l'identifiant 0x1", () => {
    ...
  })
})

describe("Lorsque l'entit√© existe d√©j√†", () => {
  test("il devrait mettre √† jour le Gravatar avec l'identifiant 0x0", () => {
    ...
  })
})
```

Le code contenu dans `beforeAll` sera ex√©cut√© une fois avant tous les tests du premier bloc de description

```typescript
import { describe, test, beforeAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { Gravatar } from "../../generated/schema"

describe("handleUpdatedGravatar()", () => {
  beforeAll(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
    gravatar.save()
    ...
  })

  test("met √† jour le Gravatar avec l'identifiant 0x0", () => {
    ...
  })

  test("cr√©e un nouveau Gravatar avec l'identifiant 0x1", () => {
    ...
  })
})
```

---

### afterAll()

Ex√©cute un bloc de code apr√®s tous les tests du fichier. Si `afterAll` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il s'ex√©cute √† la fin de ce bloc `describe`.

L'exemple:

Le code contenu dans `afterAll` sera ex√©cut√© une fois apr√®s _tous_ les tests du fichier.

```typescript
import { describe, test, afterAll } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"
import { store } from "@graphprotocol/graph-ts"

afterAll(() => {
  store.remove("Gravatar", "0x0")
  ...
})

describe("handleNewGravatar, () => {
  test("creates Gravatar with id 0x0", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

Le code contenu dans `afterAll` sera ex√©cut√© une fois apr√®s tous les tests du premier bloc de description

```typescript
import { describe, test, afterAll, clearStore } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
	afterAll(() => {
    store.remove("Gravatar", "0x1")
    ...
	})

  test("Il cr√©e une nouvelle entit√© avec l'identifiant 0x0.", () => {
    ...
  })

  test("Il cr√©e une nouvelle entit√© avec l'identifiant 0x1", () => {
    ...
  })
})

describe("handleUpdatedGravatar", () => {
  test("updates Gravatar with id 0x0", () => {
    ...
  })
})
```

---

### beforeEach()

Ex√©cute un bloc de code avant chaque test. Si `beforeEach` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il s'ex√©cute avant chaque test dans ce bloc `describe`.

Exemples : Le code contenu dans `beforeEach` sera ex√©cut√© avant chaque test.

```typescript
import { describe, test, beforeEach, clearStore } from "matchstick-as/assembly/index"
import { handleNewGravatars } from "./utils"

beforeEach(() => {
  clearStore() // <-- nettoye le store avant chaque test dans le fichier
})

describe("handleNewGravatars, () => {
  test("Un test qui n√©cessite un store propre", () => {
    ...
  })

  test("Second, qui n√©cessite un store propre", () => {
    ...
  })
})

 ...
```

Le code contenu dans `beforeEach` ne s'ex√©cutera qu'avant chaque test de la description

```typescript
import { describe, test, beforeEach } from 'matchstick-as/assembly/index'
import { handleUpdatedGravatar, handleNewGravatar } from '../../src/gravity'

describe('handleUpdatedGravatars', () => {
  beforeEach(() => {
    let gravatar = new Gravatar('0x0')
    gravatar.displayName = 'First Gravatar'
    gravatar.imageUrl = ''
    gravatar.save()
  })

  test('Met √† jour le nom d'affichage (displayName)', () => {
    assert.fieldEquals('Gravatar', '0x0', 'displayName', 'First Gravatar')

    // code qui devrait mettre √† jour le nom d'affichage (displayName) pour le 1er Gravatar

    assert.fieldEquals('Gravatar', '0x0', 'displayName', '1st Gravatar')
    store.remove('Gravatar', '0x0')
  })

  test('Met √† jour l'imageUrl', () => {
    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', '')

    // code qui devrait changer l'imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals('Gravatar', '0x0', 'imageUrl', 'https://www.gravatar.com/avatar/0x0')
    store.remove('Gravatar', '0x0')
  })
})
```

---

### afterEach()

Ex√©cute un bloc de code apr√®s chaque test. Si `afterEach` est d√©clar√© √† l'int√©rieur d'un bloc `describe`, il s'ex√©cute apr√®s chaque test dans ce bloc `describe`.

Les Exemples:

Le code contenu dans `afterEach` sera ex√©cut√© apr√®s chaque test.

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

beforeEach(() => {
  let gravatar = new Gravatar("0x0")
  gravatar.displayName = ‚ÄúFirst Gravatar‚Äù
  gravatar.save()
})

afterEach(() => {
  store.remove("Gravatar", "0x0")
})

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  test("Met √† jour le nom d'affichage (displayName)", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code qui devrait mettre √† jour le nom d'affichage (displayName) pour le 1er Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Met √† jour l'imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code qui devrait changer l'imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

Le code contenu dans `afterEach` sera ex√©cut√© apr√®s chaque test de cette description

```typescript
import { describe, test, beforeEach, afterEach } from "matchstick-as/assembly/index"
import { handleUpdatedGravatar, handleNewGravatar } from "../../src/gravity"

describe("handleNewGravatar", () => {
  ...
})

describe("handleUpdatedGravatar", () => {
  beforeEach(() => {
    let gravatar = new Gravatar("0x0")
    gravatar.displayName = "First Gravatar"
    gravatar.imageUrl = ""
    gravatar.save()
  })

  afterEach(() => {
    store.remove("Gravatar", "0x0")
  })

  test("Met √† jour le nom d'affichage (displayName)", () => {
     assert.fieldEquals("Gravatar", "0x0", "displayName", "First Gravatar")

    // code qui devrait mettre √† jour le nom d'affichage (displayName) pour le 1er Gravatar

    assert.fieldEquals("Gravatar", "0x0", "displayName", "1st Gravatar")
  })

  test("Met √† jour l'imageUrl", () => {
    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "")

    // code qui devrait changer l'imageUrl en https://www.gravatar.com/avatar/0x0

    assert.fieldEquals("Gravatar", "0x0", "imageUrl", "https://www.gravatar.com/avatar/0x0")
  })
})
```

## Assertions

```typescript
fieldEquals(entityType: string, id: string, fieldName: string, expectedVal: string)

equals(expected: ethereum.Value, actual: ethereum.Value)

notInStore(entityType: string, id: string)

addressEquals(address1: Address, address2: Address)

bytesEquals(bytes1: Bytes, bytes2: Bytes)

i32Equals(number1: i32, number2: i32)

bigIntEquals(bigInt1: BigInt, bigInt2: BigInt)

booleanEquals(bool1: boolean, bool2: boolean)

stringEquals(string1: string, string2: string)

arrayEquals(array1: Array<ethereum.Value>, array2: Array<ethereum.Value>)

tupleEquals(tuple1: ethereum.Tuple, tuple2: ethereum.Tuple)

assertTrue(value: boolean)

assertNull<T>(value: T)

assertNotNull<T>(value: T)

entityCount(entityType: string, expectedCount: i32)
```

√Ä partir de la version 0.6.0, les assertions supportent √©galement les messages d'erreur personnalis√©s

```typescript
assert.fieldEquals('Gravatar', '0x123', 'id', '0x123', 'Id doit √™tre 0x123')
assert.equals(ethereum.Value.fromI32(1), ethereum.Value.fromI32(1), 'La valeur doit √™tre √©gale √† 1')
assert.notInStore('Gravatar', '0x124', 'Gravatar ne devrait pas √™tre dans le store')
assert.addressEquals(Address.zero(), Address.zero(), 'L'adresse doit √™tre z√©ro')
assert.bytesEquals(Bytes.fromUTF8('0x123'), Bytes.fromUTF8('0x123'), 'Les Bytes doivent √™tre √©gaux')
assert.i32Equals(2, 2, 'I32 doit √™tre √©gal √† 2')
assert.bigIntEquals(BigInt.fromI32(1), BigInt.fromI32(1), 'BigInt doit √™tre √©gal √† 1')
assert.booleanEquals(true, true, 'Le bool√©en doit √™tre vrai')
assert.stringEquals('1', '1', 'La Cha√Æne de caract√®re doit √™tre √©gale √† 1')
assert.arrayEquals([ethereum.Value.fromI32(1)], [ethereum.Value.fromI32(1)], 'Les tableaux doivent √™tre √©gaux')
assert.tupleEquals(
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  changetype<ethereum.Tuple>([ethereum.Value.fromI32(1)]),
  'Les tuples doivent √™tre √©gaux',
)
assert.assertTrue(true, 'Devrait √™tre vrai')
assert.assertNull(null, 'Devrait √™tre null')
assert.assertNotNull('not null', 'Doit √™tre non null')
assert.entityCount('Gravatar', 1, 'Il devrait y avoir 2 gravatars')
assert.dataSourceCount('GraphTokenLockWallet', 1, 'Le mod√®le GraphTokenLockWallet doit avoir une source de donn√©es')
assert.dataSourceExists(
  'GraphTokenLockWallet',
  Adresse.zero().toHexString(),
  'GraphTokenLockWallet doit avoir une source de donn√©es pour z√©ro adresse',
)
```

## √âcrire un test unitaire

Voyons √† quoi ressemblerait un test unitaire simple en utilisant les exemples de Gravatar dans le [Subgraph de D√©mo](https://github.com/LimeChain/demo-subgraph/blob/main/src/gravity.ts).

En supposant que nous disposions de la fonction de traitement suivante (ainsi que de deux fonctions d'aide pour nous faciliter la vie) :

```typescript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string,
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters,
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownerAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress)),
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Nous devons tout d'abord cr√©er un fichier de test dans notre projet. Voici un exemple de ce √† quoi cela pourrait ressembler :

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Possibilit√© d'appeler des mappages avec des √©v√©nements personnalis√©s', () => {
  // Cr√©er une entit√© de test et la sauvegarder dans le store en tant qu'√©tat initial (optionnel)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Cr√©er des √©v√©nements fictifs
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Appeler les fonctions de mappage en passant par les √©v√©nements que nous venons de cr√©er
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Affirmer l'√©tat du store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Effacer le store afin de commencer le prochain test sur une ardoise propre
  clearStore()
})

test('Next test', () => {
  //...
})
```

Cela fait beaucoup √† d√©cortiquer ! Tout d'abord, une chose importante √† noter est que nous importons des choses √† partir de `matchstick-as`, notre biblioth√®que d'aide AssemblyScript (distribu√©e comme un module npm). Vous pouvez trouver le d√©p√¥t [ici](https://github.com/LimeChain/matchstick-as). `matchstick-as` nous fournit des m√©thodes de test utiles et d√©finit √©galement la fonction `test()` que nous utiliserons pour construire nos blocs de test. Le reste est assez simple - voici ce qui se passe :

- Mettons en place notre √©tat initial et ajoutons une entit√© Gravatar personnalis√©e ;
- Nous d√©finissons deux objets d'√©v√©nement `NewGravatar` avec leurs donn√©es, en utilisant la fonction `createNewGravatarEvent()` ;
- Nous appelons les m√©thodes de gestion de ces √©v√©nements - `handleNewGravatars()` et nous passons la liste de nos √©v√©nements personnalis√©s ;
- Affirmons l'√©tat du magasin. Comment cela fonctionne-t-il ? - Nous passons une combinaison unique de type d'entit√© et d'identifiant. Ensuite, nous v√©rifions un champ sp√©cifique de cette entit√© et affirmons qu'il a la valeur que nous attendons. Nous faisons cela √† la fois pour l'entit√© Gravatar initiale que nous avons ajout√©e au magasin, ainsi que pour les deux entit√©s Gravatar qui sont ajout√©es lorsque la fonction de gestion est appel√©e ;
- Enfin, nous nettoyons le store en utilisant `clearStore()` afin que notre prochain test puisse commencer avec un objet de store frais et vide. Nous pouvons d√©finir autant de blocs de test que nous le souhaitons.

Et voil√†, nous avons formul√© notre premier test ! üëè

Maintenant, pour ex√©cuter nos tests, il vous suffit d'ex√©cuter ce qui suit dans le dossier racine de Subgraph :

`graph test Gravity`

Et si tout se passe bien, vous devriez √™tre accueilli par ce qui suit¬†:

![Matchstick avec le message ‚ÄúTous les tests sont r√©ussis!‚Äù](/img/matchstick-tests-passed.png)

## Sc√©narios de tests actuels

### L'Hydratation du magasin avec un certain √©tat

Les utilisateurs peuvent hydrater le magasin avec un ensemble connu d'entit√©s. Voici un exemple pour initialiser la boutique avec une entit√© Gravatar¬†:

```typescript
laissez gravatar = new Gravatar('entryId')
gravatar.save()
```

### Appel d'une fonction de cartographie avec un √©v√©nement

Un utilisateur peut cr√©er un √©v√©nement personnalis√© et le transmettre √† une fonction de cartographie li√©e au magasin¬†:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Appel de tous les mappages avec des projecteurs d'√©v√©nements

Les utilisateurs peuvent appeler les mappages avec des dispositifs de test.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Appels de contrat moqueurs

Les utilisateurs peuvent simuler des appels de contrat¬†:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Comme d√©montr√©, afin de se moquer d'un appel de contrat et d'obtenir une valeur de retour, l'utilisateur doit fournir une adresse de contrat, un nom de fonction, une signature de fonction, un tableau d'arguments et bien s√ªr ‚Äì la valeur de retour.

Utilisateurs peuvent √©galement simuler des annulations de fonctions :

```typescript
laissez contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
   .withArgs([ethereum.Value.fromAddress(contractAddress)])
   .reverts()
```

### Se moquer des fichiers IPFS (√† partir de Matchstick 0.4.1)

Les utilisateurs peuvent simuler des fichiers IPFS en utilisant la fonction `mockIpfsFile(hash, filePath)`. La fonction accepte deux arguments, le premier √©tant le hash/chemin du fichier IPFS et le second le chemin d'un fichier local.

NOTE : Lorsque l'on teste `ipfs.map/ipfs.mapJSON`, la fonction callback doit √™tre export√©e depuis le fichier de test afin que matchtick la d√©tecte, comme la fonction `processGravatar()` dans l'exemple de test ci-dessous :

Ficher `.test.ts` :

```typescript
import { assert, test, mockIpfsFile } from 'matchstick-as/assembly/index'
import { ipfs } from '@graphprotocol/graph-ts'
import { gravatarFromIpfs } from './utils'

// Exporter le callback ipfs.map() pour qu'il soit d√©tect√© par matchstick
export { processGravatar } from './utils'

test('ipfs.cat', () => {
  mockIpfsFile('ipfsCatfileHash', 'tests/ipfs/cat.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  gravatarFromIpfs()

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 1)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'imageUrl', 'https://i.ytimg.com/vi/MELP46s8Cic/maxresdefault.jpg')

  clearStore()
})

test('ipfs.map', () => {
  mockIpfsFile('ipfsMapfileHash', 'tests/ipfs/map.json')

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 0)

  ipfs.map('ipfsMapfileHash', 'processGravatar', Value.fromString('Gravatar'), ['json'])

  assert.entityCount(GRAVATAR_ENTITY_TYPE, 3)
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '1', 'displayName', 'Gravatar1')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '2', 'displayName', 'Gravatar2')
  assert.fieldEquals(GRAVATAR_ENTITY_TYPE, '3', 'displayName', 'Gravatar3')
})
```

Fichier `utils.ts` :

```typescript
import { Address, ethereum, JSONValue, Value, ipfs, json, Bytes } from "@graphprotocol/graph-ts"
import { Gravatar } from "../../generated/schema"

...

// rappel ipfs.map
export function processGravatar(value: JSONValue, userData: Value): void {
  // Consultez la documentation de JSONValue pour plus de d√©tails sur la fa√ßon de traiter les donn√©es.
  // avec JSON values
  let obj = value.toObject()
  let id = obj.get('id')

  if (!id) {
    return
  }

  // Des entit√©s de rappel peuvent √©galement √™tre cr√©√©es
  let gravatar = new Gravatar(id.toString())
  gravatar.displayName = userData.toString() + id.toString()
  gravatar.save()
}

// fonction qui appelle ipfs.cat
export function gravatarFromIpfs(): void {
  let rawData = ipfs.cat("ipfsCatfileHash")

  if (!rawData) {
    return
  }

  let jsonData = json.fromBytes(rawData as Bytes).toObject()

  let id = jsonData.get('id')
  let url = jsonData.get("imageUrl")

  if (!id || !url) {
    return
  }

  let gravatar = new Gravatar(id.toString())
  gravatar.imageUrl = url.toString()
  gravatar.save()
}
```

### Affirmation de l'√©tat du magasin

Les utilisateurs sont en mesure d'affirmer l'√©tat final (ou interm√©diaire) du magasin via des entit√©s d'affirmation. Pour ce faire, l'utilisateur doit fournir un type d'entit√©, l'ID sp√©cifique d'une entit√©, le nom d'un champ sur cette entit√© et la valeur attendue du champ. Voici un exemple rapide:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

L'ex√©cution de la fonction assert.fieldEquals() permet de v√©rifier l'√©galit√© du champ donn√© par rapport √† la valeur attendue donn√©e. Le test √©chouera et un message d'erreur sera affich√© si les valeurs **NE SONT PAS** √©gales. Dans le cas contraire, le test passera avec succ√®s.

### Interagir avec les m√©tadonn√©es d'√©v√©nement

Les utilisateurs peuvent utiliser les m√©tadonn√©es de transaction par d√©faut, qui peuvent √™tre reenvoy√©es comme un ethereum.Event en utilisant la fonction `newMockEvent()`. L'exemple suivant montre comment vous pouvez lire/√©crire dans ces champs de l'objet Event :

```typescript
// Lisez
let logType = newGravatarEvent.logType

// √âcrivez
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Affirmation de l'√©galit√© des variables

```typescript
assert.equals(ethereum.Value.fromString("bonjour"); ethereum.Value.fromString("bonjour"));
```

### Affirmer qu'une entit√© n'est **PAS** dans le store

Les utilisateurs peuvent affirmer qu'une entit√© n'existe pas dans le magasin. La fonction prend un type d'entit√© et un identifiant. Si l'entit√© se trouve effectivement dans le magasin, le test √©chouera avec un message d'erreur pertinent. Voici un exemple rapide de la fa√ßon d'utiliser cette fonctionnalit√©¬†:

```typescript
assert.notInStore('Gravatar', '23')
```

### Affichage de tout le magasin ou d'entit√©s individuelles (√† des fins de d√©bogage)

Vous pouvez imprimer l'int√©gralit√© du magasin sur la console √† l'aide de cette fonction d'assistance:

```typescript
import { logStore } from 'matchstick-as/assembly/store'

logStore()
```

Depuis la version 0.6.0, `logStore` n'affiche plus les champs d√©riv√©s, au lieu de cel√† les utilisateurs peuvent utiliser la nouvelle fonction `logEntity`. Bien s√ªr, `logEntity` peut √™tre utilis√©e pour afficher n'importe quelle entit√©, pas seulement celles qui ont des champs d√©riv√©s. `logEntity` prend le type d'entit√©, l'identifiant de l'entit√© et un flag `showRelated` pour indiquer si les utilisateurs veulent afficher les entit√©s d√©riv√©es associ√©es.

```
import { logEntity } from 'matchstick-as/assembly/store'


logEntity("Gravatar", 23, true)
```

### √âchec pr√©vu

Les utilisateurs peuvent s'attendre √† des √©checs de test, en utilisant l'indicateur ShouldFail sur les fonctions test()¬†:

```typescript
test(
  'Devrait g√©n√©rer une erreur',
  () => {
    throw new Error()
  },
  true,
)
```

Si le test est marqu√© avec ShouldFail = true mais n'√©choue PAS, cela appara√Ætra comme une erreur dans les journaux et le bloc de test √©chouera. De plus, s'il est marqu√© avec ShouldFail = false (l'√©tat par d√©faut), l'ex√©cuteur de test plantera.

### Journal de bord

Avoir des journaux personnalis√©s dans les tests unitaires √©quivaut exactement √† la journalisation des mappages. La diff√©rence est que l'objet journal doit √™tre import√© depuis matchstick-as plut√¥t que graph-ts. Voici un exemple simple avec tous les types de journaux non critiques¬†:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Succ√®s!". []);
});
test("Error", () => {
    log.error("Erreur :( ", []);
});
test("Debug", () => {
    log.debug("Deboggage...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Avertissement!", []);
});
```

Les utilisateurs peuvent √©galement simuler une panne critique, comme ceci¬†:

```typescript
test('Tout faire exploser', () => {
  log.critical('Boom!')
})
```

La journalisation des erreurs critiques arr√™tera l‚Äôex√©cution des tests et fera tout exploser. Apr√®s tout, nous voulons nous assurer que votre code ne contient pas de journaux critiques lors du d√©ploiement, et vous devriez le remarquer imm√©diatement si cela devait se produire.

### Tests d√©riv√©s

Tester les champs d√©riv√©s est une fonctionnalit√© qui permet aux utilisateurs de d√©finir un champ sur une certaine entit√© et de faire en sorte qu'une autre entit√© soit automatiquement mise √† jour si elle d√©rive l'un de ses champs de la premi√®re entit√©.

Avant la version `0.6.0`, il √©tait possible d'obtenir les entit√©s d√©riv√©es en y acc√©dant en tant que champs/propri√©t√©s d'entit√©, comme suit :

```typescript
let entity = ExampleEntity.load('id')
let derivedEntity = entity.derived_entity
```

A partir de la version `0.6.0`, ceci est fait en utilisant la fonction `loadRelated` de graph-node, les entit√©s d√©riv√©es peuvent √™tre acc√©d√©es de la m√™me mani√®re que dans les gestionnaires.

```typescript
test('Derived fields example test', () => {
  let mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  let operatedAccount = GraphAccount.load('1')!
  operatedAccount.operators = [mainAccount.id]
  operatedAccount.save()

  mockNameSignalTransaction('1234', mainAccount.id)
  mockNameSignalTransaction('2', mainAccount.id)

  mainAccount = GraphAccount.load('12')!

  assert.assertNull(mainAccount.get('nameSignalTransactions'))
  assert.assertNull(mainAccount.get('operatorOf'))

  const nameSignalTransactions = mainAccount.nameSignalTransactions.load()
  const operatorsOfMainAccount = mainAccount.operatorOf.load()

  assert.i32Equals(2, nameSignalTransactions.length)
  assert.i32Equals(1, operatorsOfMainAccount.length)

  assert.stringEquals('1', operatorsOfMainAccount[0].id)

  mockNameSignalTransaction('2345', mainAccount.id)

  let nst = NameSignalTransaction.load('1234')!
  nst.signer = '11'
  nst.save()

  store.remove('NameSignalTransaction', '2')

  mainAccount = GraphAccount.load('12')!
  assert.i32Equals(1, mainAccount.nameSignalTransactions.load().length)
})
```

### Test de `loadInBlock`

Depuis la version `0.6.0`, les utilisateurs peuvent tester `loadInBlock` en utilisant le `mockInBlockStore`, qui permet de simuler des entit√©s dans le cache du bloc.

```typescript
import { afterAll, beforeAll, describe, mockInBlockStore, test } from 'matchstick-as'
import { Gravatar } from '../../generated/schema'

describe('loadInBlock', () => {
  beforeAll(() => {
    mockInBlockStore('Gravatar', 'gravatarId0', gravatar)
  })

  afterAll(() => {
    clearInBlockStore()
  })

  test('Peut utiliser entity.loadInBlock() pour r√©cup√©rer l'entit√© dans le sore du cache du bloc actuel', () => {
    let retrievedGravatar = Gravatar.loadInBlock('gravatarId0')
    assert.stringEquals('gravatarId0', retrievedGravatar!.get('id')!.toString())
  })

  test("Renvoit null lors de l'appel √† entity.loadInBlock() si une entit√© n'existe pas dans le bloc actuel", () => {
    let retrievedGravatar = Gravatar.loadInBlock('IDoNotExist')
    assert.assertNull(retrievedGravatar)
  })
})
```

### Tester les sources de donn√©es dynamiques

Le test des sources de donn√©es dynamiques peut √™tre effectu√© en simulant la valeur de retour des fonctions `context()`, `address()` et `network()` du namespace dataSource. Ces fonctions renvoient actuellement les valeurs suivantes `context()` - renvoit une entit√© vide (DataSourceContext), `address()` - renvoit `0x00000000000000000000000000000000`, `network()` - renvoit `mainnet`. Les fonctions `create(...)` et `createWithContext(...)` sont simul√©es pour ne rien faire, donc elles n'ont pas besoin d'√™tre appel√©es dans les tests. Les modifications des valeurs de retour peuvent √™tre faites √† travers les fonctions du namespace`dataSourceMock` dans `matchstick-as` (version 0.3.0+).

L'exemple ci-dessous :

Nous avons d‚Äôabord le gestionnaire d‚Äô√©v√©nements suivant (qui a √©t√© intentionnellement r√©utilis√© pour pr√©senter la moquerie de la source de donn√©es)¬†:

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == 'rinkeby') {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get('contextVal')!.toI32() > 0) {
    tokenLockWallet.setBigInt('tokensReleased', BigInt.fromI32(context.get('contextVal')!.toI32()))
  }
  tokenLockWallet.save()
}
```

Et puis nous avons le test utilisant l'une des m√©thodes de l'espace de noms dataSourceMock pour d√©finir une nouvelle valeur de retour pour toutes les fonctions dataSource¬†:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from 'matchstick-as/assembly/index'
import { BigInt, DataSourceContext, Value } from '@graphprotocol/graph-ts'

import { handleApproveTokenDestinations } from '../../src/token-lock-wallet'
import { ApproveTokenDestinations } from '../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet'
import { TokenLockWallet } from '../../generated/schema'

test('Source de donn√©es : simple exemple de simulation ', () => {
  let addressString = '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'
  let address = Address.fromString(addressString)

  let wallet = new TokenLockWallet(address.toHexString())
  wallet.save()
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))
  dataSourceMock.setReturnValues(addressString, 'rinkeby', context)
  let event = changetype<ApproveTokenDestinations>(newMockEvent())

  assert.assertTrue(!wallet.tokenDestinationsApproved)

  handleApproveTokenDestinations(event)

  wallet = TokenLockWallet.load(address.toHexString())!
  assert.assertTrue(wallet.tokenDestinationsApproved)
  assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

  dataSourceMock.resetValues()
})
```

Notez que dataSourceMock.resetValues() est appel√© √† la fin. C'est parce que les valeurs sont m√©moris√©es lorsqu'elles sont modifi√©es et doivent √™tre r√©initialis√©es si vous voulez revenir aux valeurs par d√©faut.

### Test de la cr√©ation dynamique de sources de donn√©es

Depuis la version `0.6.0`, il est possible de tester si une nouvelle source de donn√©es a √©t√© cr√©√©e √† partir d'un mod√®le. Cette fonctionnalit√© prend en charge √† la fois les mod√®les ethereum/contract et file/ipfs. Il y a quatre fonctions pour cela :

- `assert.dataSourceCount(templateName, expectedCount)` peut √™tre utilis√© pour affirmer le nombre attendu de sources de donn√©es √† partir du mod√®le sp√©cifi√©
- `assert.dataSourceExists(templateName, address/ipfsHash)` affirme qu'une source de donn√©es avec l'identifiant sp√©cifi√© (qui peut √™tre une adresse de contrat ou un hash de fichier IPFS) a √©t√© cr√©√©e √† partir d'un mod√®le sp√©cifi√©
- `logDataSources(templateName)` affiche toutes les sources de donn√©es du mod√®le sp√©cifi√© sur la console √† des fins de d√©bogage
- `readFile(path)` lit un fichier JSON qui repr√©sente un fichier IPFS et renvoie le contenu sous forme d'octets

#### Test des mod√®les `ethereum/contrat`

```typescript
test('ethereum/contract dataSource creation example', () => {
  // Affirmer qu'il n'y a pas de dataSources cr√©√©es √† partir du mod√®le GraphTokenLockWallet
  assert.dataSourceCount('GraphTokenLockWallet', 0)

  // Cr√©er une nouvelle source de donn√©es GraphTokenLockWallet avec l'adresse 0xA16081F360e3847006dB660bae1c6d1b2e17eC2A
  GraphTokenLockWallet.create(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2A'))

  // Affirmer que la source de donn√©es a √©t√© cr√©√©e
  assert.dataSourceCount('GraphTokenLockWallet', 1)

  // Ajouter une deuxi√®me source de donn√©es avec le contexte
  let context = new DataSourceContext()
  context.set('contextVal', Value.fromI32(325))

  GraphTokenLockWallet.createWithContext(Address.fromString('0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'), context)

  // Affirmer qu'il y a maintenant 2 sources de donn√©es
  assert.dataSourceCount('GraphTokenLockWallet', 2)

  // Affirme qu'une source de donn√©es avec l'adresse "0xA16081F360e3847006dB660bae1c6d1b2e17eC2B" a √©t√© cr√©√©e.
  // Gardez √† l'esprit que le type `Address` est transform√© en minuscules lorsqu'il est d√©cod√©, vous devez donc passer l'adresse en minuscules lorsque vous affirmez qu'elle existe.
  assert.dataSourceExists('GraphTokenLockWallet', '0xA16081F360e3847006dB660bae1c6d1b2e17eC2B'.toLowerCase())

  logDataSources('GraphTokenLockWallet')
})
```

##### Exemple de sortie `logDataSource`

```bash
üõ†  {
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2a": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2a",
    "context": null
  },
  "0xa16081f360e3847006db660bae1c6d1b2e17ec2b": {
    "kind": "ethereum/contract",
    "name": "GraphTokenLockWallet",
    "address": "0xa16081f360e3847006db660bae1c6d1b2e17ec2b",
    "context": {
      "contextVal": {
        "type": "Int",
        "data": 325
      }
    }
  }
```

#### Test des mod√®les `file/ipfs`

De m√™me que pour les sources de donn√©es dynamiques de contrat, les utilisateurs peuvent tester les fichiers sources de donn√©es et leurs gestionnaires

##### Exemple `subgraph.yaml`

```yaml
...
templates:
 - kind: file/ipfs
    name: GraphTokenLockMetadata
    network: mainnet
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      file: ./src/token-lock-wallet.ts
      handler: handleMetadata
      entities:
        - TokenLockMetadata
      abis:
        - name: GraphTokenLockWallet
          file: ./abis/GraphTokenLockWallet.json
```

##### Exemple `schema.graphql`

```graphql
"""
Portefeuilles de verrouillage de jetons qui contiennent des GRT verrouill√©s
"""
type TokenLockMetadata @entity {
  "L'adresse du portefeuille de blocage des jetons"
  id: ID!
  "Heure de d√©but du calendrier de sortie"
  startTime: BigInt!
  "Heure de fin du calendrier de sortie""
  endTime: BigInt!
  "Nombre de p√©riodes entre l'heure de d√©but et l'heure de fin"
  periods: BigInt!
  "Heure √† laquelle commence la sortie"
  releaseStartTime: BigInt!
}
```

##### Exemple `metadata.json`

```json
{
  "startTime": 1,
  "endTime": 1,
  "periods": 1,
  "releaseStartTime": 1
}
```

##### Exemple de gestionnaire

```typescript
export function handleMetadata(content : Bytes) : void {
  // dataSource.stringParams() renvoie le CID du fichier de la source de donn√©es 
  // stringParam() sera simul√© dans le test du gestionnaire
  // pour plus d'informations https://thegraph.com/docs/en/developing/creating-a-subgraph/#create-a-new-handler-to-process-files
  let tokenMetadata = new TokenLockMetadata(dataSource.stringParam())
  const value = json.fromBytes(content).toObject()

  if (value) {
    const startTime = value.get('startTime')
    const endTime = value.get('endTime')
    const periods = value.get('periods')
    const releaseStartTime = value.get('releaseStartTime')

    if (startTime && endTime && periods && releaseStartTime) {
      tokenMetadata.startTime = startTime.toBigInt()
      tokenMetadata.endTime = endTime.toBigInt()
      tokenMetadata.periods = periods.toBigInt()
      tokenMetadata.releaseStartTime = releaseStartTime.toBigInt()
    }

    tokenMetadata.save()
  }
}
```

##### Exemple de test

```typescript
import { assert, test, dataSourceMock, readFile } from 'matchstick-as'
import { Address, BigInt, Bytes, DataSourceContext, ipfs, json, store, Value } from '@graphprotocol/graph-ts'

import { handleMetadata } from '../../src/token-lock-wallet'
import { TokenLockMetadata } from '../../generated/schema'
import { GraphTokenLockMetadata } from '../../generated/templates'

test('exemple de cr√©ation d'une dataSource file/ipfs', () => {
  // G√©n√©rer le CID de la source de donn√©es √† partir du fichier ipfsHash + chemin ipfs
  // Par exemple QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm/example.json
  const ipfshash = 'QmaXzZhcYnsisuue5WRdQDH6FDvqkLQX1NckLqBYeYYEfm'
  const CID = `${ipfshash}/example.json`

  // Cr√©er une nouvelle dataSource en utilisant le CID g√©n√©r√©
  GraphTokenLockMetadata.create(CID)

  // Affirmer que la dataSource a √©t√© cr√©√©e
  assert.dataSourceCount('GraphTokenLockMetadata', 1)
  assert.dataSourceExists('GraphTokenLockMetadata', CID)
  logDataSources('GraphTokenLockMetadata')

  // Nous devons maintenant simuler les m√©tadonn√©es de la dataSource et plus particuli√®rement dataSource.stringParam()
  // dataSource.stringParams utilise en fait la valeur de dataSource.address(), nous allons donc simuler l'adresse en utilisant dataSourceMock de matchstick-as
  // Nous allons d'abord r√©initialiser les valeurs, puis utiliser dataSourceMock.setAddress() pour d√©finir le CID.
  dataSourceMock.resetValues()
  dataSourceMock.setAddress(CID)


  // Nous devons maintenant g√©n√©rer les octets √† transmettre au gestionnaire de la dataSource.
  // Pour ce cas, nous avons introduit une nouvelle fonction readFile, qui lit un json local et renvoie le contenu sous forme d'octets
  const content = readFile(`path/to/metadata.json`)
  handleMetadata(content)

  // Maintenant nous allons tester si un TokenLockMetadata a √©t√© cr√©√©
  const metadata = TokenLockMetadata.load(CID)

  assert.bigIntEquals(metadata !.endTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata !.periods, BigInt.fromI32(1))
  assert.bigIntEquals(metadata !.releaseStartTime, BigInt.fromI32(1))
  assert.bigIntEquals(metadata !.startTime, BigInt.fromI32(1))
})
```

## Couverture de test

En utilisant **Matchstick**, les d√©veloppeurs de Subgraph peuvent ex√©cuter un script qui calculera la couverture des tests unitaires √©crits.

L'outil de couverture des tests prend les binaires de test compil√©s `wasm` et les convertit en fichiers `wat`, qui peuvent alors √™tre facilement inspect√©s pour voir si les gestionnaires d√©finis dans `subgraph.yaml` ont √©t√© appel√©s ou non. Comme la couverture du code (et les tests dans leur ensemble) n'en est qu'√† ses d√©buts en AssemblyScript et WebAssembly, **Matchstick** ne peut pas v√©rifier la couverture des branches. Au lieu de cela, nous nous appuyons sur l'affirmation que si un gestionnaire donn√© a √©t√© appel√©, l'√©v√©nement/la fonction correspondant(e) a √©t√© correctement simul√©(e).

### Pr√©requis

Pour utiliser la fonctionnalit√© de couverture des tests fournie dans **Matchstick**, il y a quelques √©l√©ments √† pr√©parer √† l'avance :

#### Exportez vos gestionnaires

Pour que **Matchstick** puisse v√©rifier quels handlers sont ex√©cut√©s, ces handlers doivent √™tre export√©s depuis le **fichier de test**. Ainsi, dans notre exemple, dans notre fichier gravity.test.ts, nous avons import√© le gestionnaire suivant :

```typescript
importez { handleNewGravatar } from '../../src/gravity'
```

Pour que cette fonction soit visible (pour qu'elle soit incluse dans le fichier `wat` **par nom**), nous devons √©galement l'exporter, comme ceci :

```typescript
exportez { handleNewGravatar }
```

### Usage

Une fois tout configur√©, pour ex√©cuter l'outil de couverture de test, ex√©cutez simplement¬†:

```sh
graph test -- -c
```

Vous pouvez √©galement ajouter une commande `coverage` personnalis√©e √† votre fichier `package.json`, comme ceci :

```typescript
 "scripts": {
    /.../
    "coverage": "graph test -- -c"
  },
```

Cela ex√©cutera l'outil de couverture et vous devriez voir quelque chose comme ceci dans le terminal¬†:

```sh
$ graph test -c
Skipping download/install step because binary already exists at /Users/petko/work/demo-subgraph/node_modules/binary-install-raw/bin/0.4.0

___  ___      _       _         _   _      _
|  \/  |     | |     | |       | | (_)    | |
| .  . | __ _| |_ ___| |__  ___| |_ _  ___| | __
| |\/| |/ _` | __/ __| '_ \/ __| __| |/ __| |/ /
| |  | | (_| | || (__| | | \__ \ |_| | (__|   <
\_|  |_/\__,_|\__\___|_| |_|___/\__|_|\___|_|\_\

Compiling...

Running in coverage report mode.
 Ô∏è
Reading generated test modules... üîéÔ∏è

Generating coverage report üìù

Handlers for source 'Gravity':
Handler 'handleNewGravatar' is tested.
Handler 'handleUpdatedGravatar' is not tested.
Handler 'handleCreateGravatar' is tested.
Test coverage: 66.7% (2/3 handlers).

Handlers for source 'GraphTokenLockWallet':
Handler 'handleTokensReleased' is not tested.
Handler 'handleTokensWithdrawn' is not tested.
Handler 'handleTokensRevoked' is not tested.
Handler 'handleManagerUpdated' is not tested.
Handler 'handleApproveTokenDestinations' is not tested.
Handler 'handleRevokeTokenDestinations' is not tested.
Test coverage: 0.0% (0/6 handlers).

Global test coverage: 22.2% (2/9 handlers).
```

### Dur√©e d'ex√©cution du test dans la sortie du journal

La sortie du journal inclut la dur√©e de l‚Äôex√©cution du test. Voici un exemple¬†:

`[Thu, 31 Mar 2022 13:54:54 +0300] Program executed in: 42.270ms.`

## Erreurs de compilation courantes

> Critique¬†: impossible de cr√©er WasmInstance √† partir d'un module valide avec un contexte¬†: importation inconnue¬†: wasi_snapshot_preview1::fd_write n'a pas √©t√© d√©fini

Ceci signifie que vous avez utilis√© `console.log` dans votre code, qui n'est pas pris en charge par AssemblyScript. Veuillez consid√©rer l'utilisation de [Logging API](/subgraphs/developing/creating/graph-ts/api/#logging-api)

> ERREUR TS2554¬†: attendu¬†? arguments, mais j'ai eu ?.
>
> renvoyer le nouveau ethereum.Block (defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultAddress, defaultAddressBytes, defaultAddressBytes, defaultAddressBytes, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt, defaultBigInt) ;
>
> dans ~lib/matchstick-as/assembly/defaults.ts(18,12)
>
> ERREUR TS2554¬†: attendu¬†? arguments, mais j'ai eu ?.
>
> renvoyer un nouveau ethereum.Transaction (defaultAddressBytes, defaultBigInt, defaultAddress, defaultAddress, defaultBigInt, defaultBigInt, defaultBigInt, defaultAddressBytes, defaultBigInt) ;
>
> dans ~lib/matchstick-as/assembly/defaults.ts(24,12)

La non-concordance des arguments est caus√©e par la non-concordance de `graph-ts` et de `matchstick-as`. La meilleure fa√ßon de r√©soudre des probl√®mes comme celui-ci est de tout mettre √† jour vers la derni√®re version publi√©e.

## Ressources suppl√©mentaires

Pour toute aide suppl√©mentaire, consultez cette [d√©mo Subgraph repo utilisant Matchstick](https://github.com/LimeChain/demo-subgraph#readme_).

## R√©action

Si vous avez des questions, des commentaires, des demandes de fonctionnalit√©s ou si vous souhaitez simplement nous contacter, le meilleur endroit serait The Graph Discord o√π nous avons une cha√Æne d√©di√©e √† Matchstick, appel√©e üî•| tests unitaires.
