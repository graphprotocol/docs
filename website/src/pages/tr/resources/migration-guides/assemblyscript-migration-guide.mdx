---
title: AssemblyScript GeÃ§iÅŸ Rehberi
---

Up until now, Subgraphs have been using one of the [first versions of AssemblyScript](https://github.com/AssemblyScript/assemblyscript/tree/v0.6) (v0.6). Finally we've added support for the [newest one available](https://github.com/AssemblyScript/assemblyscript/tree/v0.19.10) (v0.19.10)! ğŸ‰

That will enable Subgraph developers to use newer features of the AS language and standard library.

Bu rehber, `graph-cli`/`graph-ts` araÃ§larÄ±nÄ±n `0.22.0` ve Ã¶ncesi versiyonlarÄ±nÄ± kullanan herkes iÃ§in geÃ§erlidir. EÄŸer halihazÄ±rda bu versiyonun Ã¼stÃ¼nde (veya ona eÅŸit) bir versiyon kullanÄ±yorsanÄ±z, zaten AssemblyScript'in `0.19.10` versiyonunu kullanÄ±yorsunuz demektir ğŸ™‚

> Note: As of `0.24.0`, `graph-node` can support both versions, depending on the `apiVersion` specified in the Subgraph manifest.

## Ã–zellikler

### Yeni iÅŸlevsellik

- `TypedArray`'ler artÄ±k [`wrap` isimli yeni statik metot](https://www.assemblyscript.org/stdlib/typedarray.html#static-members) ([v0.8.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.8.1)) kullanÄ±larak `ArrayBuffer`'lardan oluÅŸturulabilir
- Yeni standart kÃ¼tÃ¼phane fonksiyonlarÄ±: `String#toUpperCase`, `String#toLowerCase`, `String#localeCompare` ve `TypedArray#set` ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- GenericClass'in bir Ã¶rneÄŸini doÄŸrulamak iÃ§in x instanceof GenericClass desteÄŸi eklendi ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Daha verimli bir dizi Ã§eÅŸidi olan `StaticArray<T>` eklendi, ([v0.9.3](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.3))
- `Array<T>#flat` eklendi ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- `Number#toString` fonksiyonunda `radix` argÃ¼manÄ± desteklenmeye baÅŸlandÄ± ([v0.10.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.1))
- Kayan nokta literallerinde ayÄ±rÄ±cÄ±lar iÃ§in destek eklendi ([v0.13.7](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.13.7))
- Ä°lk sÄ±nÄ±f fonksiyonlar iÃ§in destek eklendi ([v0.14.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.0))
- YerleÅŸikler eklendi: `i32/i64/f32/f64.add/sub/mul` ([v0.14.13](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.13))
- `Array/TypedArray/String#at`' fonksiyonu geliÅŸtirildi ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))
- Åablon literal dizeleri iÃ§in destek eklendi ([v0.18.17](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.17))
- `encodeURI(Component)` ve `decodeURI(Component)` eklendi ([v0.18.27](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.27))
- `toString`, `toDateString` ve `toTimeString` metodlarÄ± `Date`'e eklendi ([v0.18.29](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.29))
- `Date` iÃ§in `toUTCString` eklendi ([v0.18.30](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.30))
- `nonnull/NonNullable` yerleÅŸik tÃ¼rÃ¼ eklendi ([v0.19.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.19.2))

### Optimizasyonlar

- `Math` fonksiyonlarÄ± olan `exp`, `exp2`, `log`, `log2` ve `pow`, daha hÄ±zlÄ± varyantlarla deÄŸiÅŸtirildi ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- `Math.mod`' fonksiyonu biraz optimize edildi ([v0.17.1](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.1))
- std Map ve Set'te daha fazla alan eriÅŸiminin Ã¶nbelleÄŸe alÄ±nmasÄ± saÄŸlandÄ± ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
- Ä°kinin katlarÄ± iÃ§in `ipow32/64` optimizasyonu ([v0.18.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.18.2))

### DiÄŸer

- Bir dizi literalinin tÃ¼rÃ¼ artÄ±k iÃ§eriÄŸinden Ã§Ä±karsanabilir ([v0.9.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.0))
- stdlib Unicode 13.0.0'a gÃ¼ncellendi ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))

## NasÄ±l yÃ¼kseltilir?

1. Change your mappings `apiVersion` in `subgraph.yaml` to `0.0.9`:

```yaml
...
dataSources:
  ...
    mapping:
      ...
      apiVersion: 0.0.9
      ...
```

2. Kullanmakta olduÄŸunuz `graph-cli`yi `latest` (en son) sÃ¼rÃ¼me gÃ¼ncellemek iÃ§in ÅŸu komutu Ã§alÄ±ÅŸtÄ±rÄ±n:

```bash
# EÄŸer `graph-cli` global olarak yÃ¼klÃ¼yse
npm install --global @graphprotocol/graph-cli@latest

# veya `subgraph` iÃ§inde bir geliÅŸtirme gereksinimi olarak yÃ¼klÃ¼yse
npm install --save-dev @graphprotocol/graph-cli@latest
```

3. AynÄ±sÄ±nÄ± `graph-ts` iÃ§in de yapÄ±n, ancak global olarak kurmak yerine ana gereksinimlerinizde kaydedin:

```bash
npm install --save @graphprotocol/graph-ts@latest
```

4. Dildeki uyumsuzluk sorunlarÄ±nÄ± dÃ¼zeltmek iÃ§in rehberin geri kalanÄ±nÄ± takip edin.
5. `codegen` ve `deploy` komutlarÄ±nÄ± tekrar Ã§alÄ±ÅŸtÄ±rÄ±n.

## Uyumsuz deÄŸiÅŸiklikler

### Null olabilme durumu

AssemblyScript'in eski bir sÃ¼rÃ¼mÃ¼nde ÅŸu ÅŸekilde kod oluÅŸturabilirdiniz:

```typescript
function load(): Value | null { ... }

let maybeValue = load();
maybeValue.aMethod();
```

Ancak, daha yeni sÃ¼rÃ¼mde deÄŸer null olabildiÄŸi iÃ§in bunu kontrol etmenizi gerektirir, aÅŸaÄŸÄ±daki gibi:

```typescript
let maybeValue = load()

if (maybeValue) {
  maybeValue.aMethod() // `maybeValue` artÄ±k null deÄŸil
}
```

Veya bunu ÅŸu ÅŸekilde zorlayÄ±n:

```typescript
let maybeValue = load()! // DeÄŸer null ise Ã§alÄ±ÅŸtÄ±rma esnasÄ±nda hata verir

maybeValue.aMethod()
```

If you are unsure which to choose, we recommend always using the safe version. If the value doesn't exist you might want to just do an early if statement with a return in you Subgraph handler.

### DeÄŸiÅŸken GÃ¶lgeleme

Daha Ã¶nce [deÄŸiÅŸken gÃ¶lgeleme](https://en.wikipedia.org/wiki/Variable_shadowing) yapabiliyordunuz ve aÅŸaÄŸÄ±daki gibi bir kod Ã§alÄ±ÅŸÄ±yordu:

```typescript
let a = 10
let b = 20
let a = a + b
```

Ancak bu artÄ±k mÃ¼mkÃ¼n deÄŸil ve bu kodu derlemeye Ã§alÄ±ÅŸÄ±rsanÄ±z derleyici ÅŸu hatayÄ± verir:

```typescript
ERROR TS2451: Cannot redeclare block-scoped variable 'a'

 let a = a + b;
 ~~~~~~~~~~~~~
in assembly/index.ts(4,3)
```

EÄŸer deÄŸiÅŸken gÃ¶lgeleme yapÄ±yorsanÄ±z, yinelenen deÄŸiÅŸkenlerinizi yeniden adlandÄ±rmanÄ±z gerekecek.

### Null KarÅŸÄ±laÅŸtÄ±rmalarÄ±

By doing the upgrade on your Subgraph, sometimes you might get errors like these:

```typescript
ERROR TS2322: Type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt | null' is not assignable to type '~lib/@graphprotocol/graph-ts/common/numbers/BigInt'.
     if (decimals == null) {
                     ~~~~
 in src/mappings/file.ts(41,21)
```

Bu hatayÄ± Ã§Ã¶zmek iÃ§in `if` ifadesini ÅŸu ÅŸekilde deÄŸiÅŸtirebilirsiniz:

```typescript
  if (!decimals) {

  // veya

  if (decimals === null) {
```

AynÄ±sÄ± == yerine != kullandÄ±ÄŸÄ±nÄ±zda da geÃ§erlidir.

### DÃ¶nÃ¼ÅŸtÃ¼rme

Ã–nceden dÃ¶nÃ¼ÅŸtÃ¼rme yapmanÄ±n yaygÄ±n yolu, `as` kelimesini ÅŸÃ¶yle kullanmaktÄ±:

```typescript
let byteArray = new ByteArray(10)
let uint8Array = byteArray as Uint8Array // equivalent to: <Uint8Array>byteArray
```

Ancak bu sadece iki senaryoda Ã§alÄ±ÅŸÄ±r:

- Temel tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ (`u8`, `i32`, `bool` gibi veri tÃ¼rleri arasÄ±nda; Ã¶rneÄŸin: `let b: isize = 10; b as usize`);
- SÄ±nÄ±f kalÄ±tÄ±mÄ±nda yukarÄ± doÄŸru dÃ¶nÃ¼ÅŸÃ¼m (alt sÄ±nÄ±f â†’ Ã¼st sÄ±nÄ±f)

Ã–rnekler:

```typescript
// temel tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼
let a: usize = 10
let b: isize = 5
let c: usize = a + (b as usize)
```

```typescript
// sÄ±nÄ±f kalÄ±tÄ±mÄ±nda yukarÄ± doÄŸru dÃ¶nÃ¼ÅŸÃ¼m
class Bytes extends Uint8Array {}

let bytes = new Bytes(2)
// <Uint8Array>bytes // // aynÄ± ÅŸÃ¶yle: bytes as Uint8Array
```

`as`/`<T>var` kullanmanÄ±n **gÃ¼venli olmadÄ±ÄŸÄ±** iki dÃ¶nÃ¼ÅŸÃ¼m senaryosu vardÄ±r:

- SÄ±nÄ±f kalÄ±tÄ±mÄ±nda aÅŸaÄŸÄ± doÄŸru dÃ¶nÃ¼ÅŸÃ¼m (Ã¼st sÄ±nÄ±f â†’ alt sÄ±nÄ±f)
- Ortak bir Ã¼st sÄ±nÄ±fa sahip iki tÃ¼r arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m

```typescript
// sÄ±nÄ±f kalÄ±tÄ±mÄ±nda aÅŸaÄŸÄ± doÄŸru dÃ¶nÃ¼ÅŸÃ¼m
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
// <Bytes>uint8Array // Ã§alÄ±ÅŸtÄ±rma esnasÄ±nda kÄ±rÄ±lÄ±r :(
```

```typescript
// aynÄ± Ã¼st sÄ±nÄ±fÄ± paylaÅŸan iki tÃ¼r arasÄ±nda
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
// <ByteArray>bytes // Ã§alÄ±ÅŸtÄ±rma esnasÄ±nda kÄ±rÄ±lÄ±r :(
```

Bu durumlar iÃ§in `changetype<T>` fonksiyonunu kullanabilirsiniz:

```typescript
// sÄ±nÄ±f kalÄ±tÄ±mÄ±nda aÅŸaÄŸÄ± doÄŸru dÃ¶nÃ¼ÅŸÃ¼m
class Bytes extends Uint8Array {}

let uint8Array = new Uint8Array(2)
changetype<Bytes>(uint8Array) // Ã§alÄ±ÅŸÄ±r :)
```

```typescript
// AynÄ± Ã¼st sÄ±nÄ±fÄ± paylaÅŸan iki tÃ¼r arasÄ±nda
class Bytes extends Uint8Array {}
class ByteArray extends Uint8Array {}

let bytes = new Bytes(2)
changetype<ByteArray>(bytes) // Ã§alÄ±ÅŸÄ±r :)
```

Sadece null olabilmeyi kaldÄ±rmak istiyorsanÄ±z, `as` operatÃ¶rÃ¼nÃ¼ (veya `<T>variable`) kullanmaya devam edebilirsiniz. Ancak deÄŸerin null olamayacaÄŸÄ±nÄ± bilmeniz gerekir. Aksi halde bu sorun yaratÄ±r.

```typescript
// null olabilmeyi kaldÄ±rma
let previousBalance = AccountBalance.load(balanceId) // AccountBalance | null

if (previousBalance != null) {
  return previousBalance as AccountBalance // gÃ¼venli null kaldÄ±rma
}

let newBalance = new AccountBalance(balanceId)
```

Null olabilme durumu iÃ§in [null olabilme kontrolÃ¼ Ã¶zelliÄŸine](https://www.assemblyscript.org/basics.html#nullability-checks) gÃ¶z atmanÄ±zÄ± Ã¶neririz. Bu Ã¶zellikleri uygulamak, kodunuzu daha temiz hale getirecektir ğŸ™‚

AyrÄ±ca, dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemlerini kolaylaÅŸtÄ±rmak iÃ§in bazÄ± tÃ¼rlere birkaÃ§ statik metot daha ekledik, bunlar:

- Bytes.fromByteArray
- Bytes.fromUint8Array
- BigInt.fromByteArray
- ByteArray.fromBigInt

### Ã–zellik eriÅŸimi ile null olabilme kontrolÃ¼

[Null kontrolÃ¼ Ã¶zelliÄŸini](https://www.assemblyscript.org/basics.html#nullability-checks) kullanmak iÃ§in, `if` ifadelerini veya Ã¼Ã§lÃ¼ operatÃ¶rÃ¼nÃ¼ (`?` ve `:`) ÅŸu ÅŸekilde kullanabilirsiniz:

```typescript
let something: string | null = 'data'

let somethingOrElse = something ? something : 'else'

// veya

let somethingOrElse

if (something) {
  somethingOrElse = something
} else {
  somethingOrElse = 'else'
}
```

Ancak bu yalnÄ±zca bir deÄŸiÅŸken Ã¼zerinde `if` / Ã¼Ã§lÃ¼ operatÃ¶r kullandÄ±ÄŸÄ±nÄ±zda Ã§alÄ±ÅŸÄ±r, bir Ã¶zellik eriÅŸiminde deÄŸil:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let somethingOrElse: string = container.data ? container.data : 'else' // derlemede hata verir
```

Bu hata Ã§Ä±ktÄ±sÄ±nÄ± verir:

```typescript
ERROR TS2322: Type '~lib/string/String | null' is not assignable to type '~lib/string/String'.

   let somethingOrElse: string = container.data ? container.data : "else";
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Bu hatayÄ± Ã§Ã¶zmek iÃ§in, Ã¶zellik eriÅŸimini bir deÄŸiÅŸkene atayarak derleyicinin null kontrolÃ¼nÃ¼ yapabilmesini saÄŸlayabilirsiniz:

```typescript
class Container {
  data: string | null
}

let container = new Container()
container.data = 'data'

let data = container.data

let somethingOrElse: string = data ? data : 'else' // sorunsuz bir ÅŸekilde derlenir :)
```

### Ã–zellik eriÅŸimi ile operatÃ¶r aÅŸÄ±rÄ± yÃ¼kleme

Bir Ã¶zelliÄŸe eriÅŸimden gelen bir null deÄŸere izin veren bir tÃ¼rÃ¼, null olmayan bir tÃ¼rle toplamaya Ã§alÄ±ÅŸÄ±rsanÄ±z AssemblyScript derleyicisi, bu deÄŸerlerden birinin null deÄŸere izin verdiÄŸi konusunda derleme zamanÄ± uyarÄ±sÄ± vermez. Bunun yerine, sadece sessiz bir ÅŸekilde derlemeye devam eder ve Ã§alÄ±ÅŸma sÄ±rasÄ±nda kodun kÄ±rÄ±lmasÄ±na yol aÃ§ar.

```typescript
class BigInt extends Uint8Array {
  @operator('+')
  plus(other: BigInt): BigInt {
    // ...
  }
}

class Wrapper {
  public constructor(public n: BigInt | null) {}
}

let x = BigInt.fromI32(2)
let y: BigInt | null = null

x + y // null deÄŸer alabilme hakkÄ±nda derleme hatasÄ± verir

let wrapper = new Wrapper(y)

wrapper.n = wrapper.n + x // olmasÄ± gerektiÄŸi gibi derleme hatasÄ± vermez
```

We've opened a issue on the AssemblyScript compiler for this, but for now if you do these kind of operations in your Subgraph mappings, you should change them to do a null check before it.

```typescript
let wrapper = new Wrapper(y)

if (!wrapper.n) {
  wrapper.n = BigInt.fromI32(0)
}

wrapper.n = wrapper.n + x // ÅŸimdi `n`'nin bir BigInt olduÄŸu garanti edilmiÅŸtir
```

### DeÄŸer ilklendirme

Bunun gibi bir koda sahipseniz:

```typescript
var value: Type // null
value.x = 10
value.y = 'content'
```

It will compile but break at runtime, that happens because the value hasn't been initialized, so make sure your Subgraph has initialized their values, like this:

```typescript
var value = new Type() // ilklendirme
value.x = 10
value.y = 'content'
```

AyrÄ±ca, bir GraphQL varlÄ±ÄŸÄ±nda ÅŸunun gibi null olabilen Ã¶zellikleriniz varsa:

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt
}
```

Ve bu koda benzer bir koda sahipseniz:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
}

total.amount = total.amount + BigInt.fromI32(1)
```

`total.amount` deÄŸerini ilklendirdiÄŸinizden emin olmanÄ±z gerekecek, Ã§Ã¼nkÃ¼ toplama iÅŸlemi iÃ§in son satÄ±rda eriÅŸmeye Ã§alÄ±ÅŸÄ±rsanÄ±z, uygulama Ã§Ã¶ker. Bu yÃ¼zden ya Ã¶nce ilklendirin:

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest')
  total.amount = BigInt.fromI32(0)
}

total.tokens = total.tokens + BigInt.fromI32(1)
```

Ya da GraphQL ÅŸemanÄ±zÄ± bu Ã¶zellik iÃ§in null olabilen bir tÃ¼r kullanmayacak ÅŸekilde deÄŸiÅŸtirin. BÃ¶ylece `codegen` adÄ±mÄ±nda bu deÄŸer sÄ±fÄ±r olarak ilklendirilir ğŸ˜‰

```graphql
type Total @entity {
  id: Bytes!
  amount: BigInt!
}
```

```typescript
let total = Total.load('latest')

if (total === null) {
  total = new Total('latest') // null olamayan Ã¶zellikleri ilklendirir
}

total.amount = total.amount + BigInt.fromI32(1)
```

### SÄ±nÄ±f Ã¶zelliÄŸi ilklendirme

EÄŸer (kendi tarafÄ±nÄ±zdan veya standart kÃ¼tÃ¼phane tarafÄ±ndan bildirilen) baÅŸka sÄ±nÄ±flarÄ± iÃ§eren Ã¶zelliklere sahip sÄ±nÄ±flarÄ± ÅŸu ÅŸekilde dÄ±ÅŸa aktarÄ±rsanÄ±z:

```typescript
class Thing {}

export class Something {
  value: Thing
}
```

Derleyici hata verecektir Ã§Ã¼nkÃ¼ sÄ±nÄ±f olan Ã¶zellikler iÃ§in ya bir ilklendirici eklemeniz ya da `!` operatÃ¶rÃ¼nÃ¼ eklemeniz gerekmektedir:

```typescript
export class Something {
  constructor(public value: Thing) {}
}

// veya

export class Something {
  value: Thing

  constructor(value: Thing) {
    this.value = value
  }
}

// veya

export class Something {
  value!: Thing
}
```

### Dizi ilklendirmesi

`Array` sÄ±nÄ±fÄ±, listenin uzunluÄŸunu ilklendirmek iÃ§in bir sayÄ± kabul etmeye devam eder. Ancak `.push` gibi iÅŸlemler baÅŸlangÄ±ca eklemek yerine boyutu gerÃ§ekten artÄ±racaÄŸÄ± iÃ§in dikkatli olmalÄ±sÄ±nÄ±z, Ã¶rneÄŸin:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr.push('something') // ["", "", "", "", "", "something"] // uzunluk 6 :(
```

KullandÄ±ÄŸÄ±nÄ±z tiplere baÄŸlÄ± olarak -mesela null olabilen deÄŸerler kullanÄ±yorsunuz- ve bu tiplere eriÅŸim ÅŸeklinize gÃ¶re, aÅŸaÄŸÄ±daki gibi bir Ã§alÄ±ÅŸtÄ±rma hatasÄ±yla karÅŸÄ±laÅŸabilirsiniz:

```
ERRO Handler skipped due to execution failure, error: Mapping aborted at ~lib/array.ts, line 110, column 40, with message: Element type must be nullable if array is holey  wasm backtrace:     0: 0x19c4 - <unknown>!~lib/@graphprotocol/graph-ts/index/format         1: 0x1e75 - <unknown>!~lib/@graphprotocol/graph-ts/common/collections/Entity#constructor        2: 0x30b9 - <unknown>!node_modules/@graphprotocol/graph-ts/global/global/id_of_type
```

Listenin baÅŸÄ±na "push" yapabilmek iÃ§in, `Array`'i ya ÅŸu ÅŸekilde sÄ±fÄ±r boyutla ilklendirmelisiniz:

```typescript
let arr = new Array<string>(0) // []

arr.push('something') // ["something"]
```

Ya da dizin kullanarak deÄŸiÅŸtirmelisiniz:

```typescript
let arr = new Array<string>(5) // ["", "", "", "", ""]

arr[0] = 'something' // ["something", "", "", "", ""]
```

### GraphQL ÅŸemasÄ±

Bu doÄŸrudan bir AssemblyScript deÄŸiÅŸikliÄŸi deÄŸildir. Ancak `schema.graphql` dosyanÄ±zÄ± gÃ¼ncellemeniz gerekebilir.

ArtÄ±k tÃ¼rlerinizde Non-Nullable Lists (BoÅŸ Olamayan Listeler) olarak alanlar tanÄ±mlayamazsÄ±nÄ±z. EÄŸer bÃ¶yle bir ÅŸemanÄ±z varsa:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something]! # artÄ±k geÃ§erli deÄŸil
}
```

Listenin tÃ¼r Ã¼yesine ÅŸu ÅŸekilde `!` eklemeniz gerekecek:

```graphql
type Something @entity {
  id: Bytes!
}

type MyEntity @entity {
  id: Bytes!
  invalidField: [Something!]! # geÃ§erli
}
```

Bu deÄŸiÅŸiklik, AssemblyScript sÃ¼rÃ¼mleri arasÄ±ndaki null olabilme farklÄ±lÄ±klarÄ±ndan dolayÄ± oldu. Ve bu deÄŸiÅŸiklik `src/generated/schema.ts` dosyasÄ±yla ilgilidir (varsayÄ±lan yol, bunu deÄŸiÅŸtirmiÅŸ olabilirsiniz).

### DiÄŸer

- `Map#set` ve `Set#add` Ã¶gelerini, `this` dÃ¶ndÃ¼recek ÅŸekilde spesifikasyonla uyumlu hale getirdik ([v0.9.2](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.9.2))
- Diziler artÄ±k ArrayBufferView'den gelmek yerine artÄ±k farklÄ± ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0)) sÃ¼rÃ¼mÃ¼nden geliyorlar
- Nesne literalinden baÅŸlatÄ±lan sÄ±nÄ±flar artÄ±k yapÄ±cÄ± bir metot tanÄ±mlayamaz ([v0.10.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.10.0))
- Bir `**` ikili iÅŸleminin sonucu artÄ±k her iki iÅŸlenen de tamsayÄ± ise ortak payda tamsayÄ±sÄ±dÄ±r. Ã–nceden, sonuÃ§ `Math/f.pow` Ã§aÄŸrÄ±lmÄ±ÅŸ gibi bir float'tÄ± ([v0.11.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.11.0))
- `bool` dÃ¶nÃ¼ÅŸÃ¼mÃ¼nde `NaN`' deÄŸeri `false` deÄŸerine zorla dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r ([v0.14.9](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.14.9))
- `i8`/`u8` ya da `i16`/`u16` tipindeki kÃ¼Ã§Ã¼k tamsayÄ± deÄŸerlerini kaydÄ±rÄ±rken, RHS deÄŸerinin yalnÄ±zca sÄ±rasÄ±yla en dÃ¼ÅŸÃ¼k 3 ve 4 anlamlÄ± biti sonucu etkiler. Bu, bir `i32.shl` sonucu yalnÄ±zca RHS deÄŸerinin 5 en dÃ¼ÅŸÃ¼k anlamlÄ± bitinden etkilenmesine benzer. Ã–rnek: `someI8 << 8` Ã¶nceden `0` deÄŸerini Ã¼retirken, ÅŸimdi RHS'Ä±n `8 & 7 = 0` (3 bit) olarak maskelenmesinden dolayÄ± `someI8` deÄŸerini Ã¼retir ([v0.17.0](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.0))
- Boyutlar farklÄ± olduÄŸunda iliÅŸkisel dize karÅŸÄ±laÅŸtÄ±rmalarÄ±nda olan hatanÄ±n dÃ¼zeltmesi ([v0.17.8](https://github.com/AssemblyScript/assemblyscript/releases/tag/v0.17.8))
