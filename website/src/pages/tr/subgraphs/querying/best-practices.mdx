---
title: Sorgulama - Örnek Uygulamalar
---

The Graph, blokzincirlerinden veri sorgulamak için merkeziyetsiz bir yöntem sağlar. Verileri bir GraphQL API'si aracılığıyla sunulur ve bu da GraphQL diliyle sorgulamayı kolaylaştırır.

Subgraph'inizi optimize etmek için gerekli temel GraphQL dili kurallarını ve örnek uygulamaları öğrenin.

---

## Bir GraphQL API'sini sorgulama

### Bir GraphQL Sorgusunun Anatomisi

REST API'den farklı olarak, bir GraphQL API'si, hangi sorguların gerçekleştirilebileceğini tanımlayan bir Şema üzerine kuruludur.

Örneğin, `token` sorgusunu kullanarak bir token almak için yapılacak sorgu aşağıdaki gibi olacaktır:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

ve bu sorgu (doğru `$id` değişkeni geçirildiğinde) aşağıdaki öngörülebilir JSON yanıtını döndürecektir:

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQL sorguları, [bir spesifikasyon](https://spec.graphql.org/) temelinde tanımlanmış olan GraphQL dilini kullanır.

Yukarıdaki `GetToken` sorgusu, birden fazla dil bileşeninden oluşur (aşağıda `[...]` yer tutucularıyla gösterilmiştir):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

## GraphQL Sorgusu Yazmanın Kuralları

- Her bir `queryName`, işlem başına yalnızca bir kez kullanılmalıdır.
- Her bir `field`, bir seçim içinde yalnızca bir kez kullanılmalıdır (örneğin, `token` altında `id` alanını iki kez sorgulayamayız)
- Bazı `field`'lar veya sorgular (örneğin `tokens`), alt alan seçimi gerektiren karmaşık türler döndürür. Beklendiğinde alt alan seçimi yapmamak (ya da beklenmediğinde böyle bir seçim yapmak, örneğin `id` üzerinde) bir hata oluşturur. Bir alanın türünü öğrenmek için lütfen [Graph Gezgini](/subgraphs/explorer/) sayfasına bakın.
- Bir argümana atanan herhangi bir değişken, onun türüyle eşleşmelidir.
- Belirli bir değişken listesinde, her bir değişken özgün olmalıdır.
- Tanımlanan tüm değişkenler kullanılmalıdır.

> Not: Bu kurallara uyulmaması, The Graph API'sinin hata vermesi ile sonuçlanacaktır.

Kod örnekleriyle birlikte tam kurallar listesi için [GraphQL Doğrulamaları rehberine](/resources/migration-guides/graphql-validations-migration-guide/) göz atın.

### Bir GraphQL API'sine sorgu göndermek

GraphQL, HTTP üzerinden taşınan bir dil ve kurallar bütünüdür.

Bu, (yerel olarak veya `@whatwg-node/fetch` ya da `isomorphic-fetch` aracılığıyla) standart `fetch` kullanarak bir GraphQL API'sini sorgulayabileceğiniz anlamına gelir.

Ancak, ["Bir Uygulamadan Sorgulama"](/subgraphs/querying/from-an-application/) bölümünde belirtildiği gibi, aşağıdaki benzersiz özellikleri destekleyen `graph-client`ın kullanılması önerilir:

- Zincirler arası Subgraph İşleme: Tek bir sorguda birden fazla Subgraph'ten veri sorgulama
- [Otomatik Blok Takibi](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [Otomatik Sayfalama](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- Tamamen yazılmış sonuç

`graph-client` aracılığıyla The Graph sorgusu nasıl yapılır:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

Daha fazla GraphQL istemcisi alternatifi, ["Bir Uygulamadan Sorgulama"](/subgraphs/querying/from-an-application/) bölümünde ele alınmıştır.

---

## En İyi Uygulamalar

### Her zaman statik sorgular yazın

Yaygın (ve kötü) bir uygulama, sorgu dizelerini aşağıdaki gibi dinamik olarak oluşturmaktır:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Sorguyu çalıştır...
```

Yukarıdaki kod parçası geçerli bir GraphQL sorgusu üretse de, **birçok dezavantaja sahiptir**:

- sorguyu bir bütün olarak anlamayı **zorlaştırır**
- geliştiriciler, **dize enterpolasyonunun güvenliğini sağlamakla sorumludur**
- değişken değerlerinin istek parametreleriyle gönderilmemesi **sunucu tarafındaki önbellekleme olasılığını ortadan kaldırır**
- bu, **araçların sorguyu statik olarak analiz etmesini engeller** (örneğin: Linter veya tür üretim araçları)

Bu nedenle, sorguları her zaman statik dizeler olarak yazmanız önerilir:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

Doing so brings **many advantages**:

- **Easy to read and maintain** queries
- The GraphQL **server handles variables sanitization**
- **Variables can be cached** at server-level
- **Queries can be statically analyzed by tools** (more on this in the following sections)

### How to include fields conditionally in static queries

You might want to include the `owner` field only on a particular condition.

For this, you can leverage the `@include(if:...)` directive as follows:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

> Note: The opposite directive is `@skip(if: ...)`.

### Ask for what you want

GraphQL became famous for its "Ask for what you want" tagline.

For this reason, there is no way, in GraphQL, to get all available fields without having to list them individually.

- GraphQL API'leri sorgularken, her zaman sadece gerçekten kullanılacak alanları sorgulamayı düşünmelisiniz.
- Make sure queries only fetch as many entities as you actually need. By default, queries will fetch 100 entities in a collection, which is usually much more than what will actually be used, e.g., for display to the user. This applies not just to top-level collections in a query, but even more so to nested collections of entities.

For example, in the following query:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

The response could contain 100 transactions for each of the 100 tokens.

If the application only needs 10 transactions, the query should explicitly set `first: 10` on the transactions field.

### Use a single query to request multiple records

By default, Subgraphs have a singular entity for one record. For multiple records, use the plural entities and filter: `where: {id_in:[X,Y,Z]}` or `where: {volume_gt:100000}`

Example of inefficient querying:

```graphql
query SingleRecord {
  entity(id: X) {
    id
    name
  }
}
query SingleRecord {
  entity(id: Y) {
    id
    name
  }
}
```

Example of optimized querying:

```graphql
query ManyRecords {
  entities(where: { id_in: [X, Y] }) {
    id
    name
  }
}
```

### Combine multiple queries in a single request

Your application might require querying multiple types of data as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

While this implementation is totally valid, it will require two round trips with the GraphQL API.

Fortunately, it is also valid to send multiple queries in the same GraphQL request as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

This approach will **improve the overall performance** by reducing the time spent on the network (saves you a round trip to the API) and will provide a **more concise implementation**.

### Leverage GraphQL Fragments

A helpful feature to write GraphQL queries is GraphQL Fragment.

Looking at the following query, you will notice that some fields are repeated across multiple Selection-Sets (`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

Such repeated fields (`id`, `active`, `status`) bring many issues:

- More extensive queries become harder to read.
- When using tools that generate TypeScript types based on queries (_more on that in the last section_), `newDelegate` and `oldDelegate` will result in two distinct inline interfaces.

A refactored version of the query would be the following:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

Using GraphQL `fragment` will improve readability (especially at scale) and result in better TypeScript types generation.

When using the types generation tool, the above query will generate a proper `DelegateItemFragment` type (_see last "Tools" section_).

### GraphQL Fragment do's and don'ts

### Fragment tabanı bir tip olmalıdır

A Fragment cannot be based on a non-applicable type, in short, **on type not having fields**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` is a **scalar** (native "plain" type) that cannot be used as a fragment's base.

#### Fragment Nasıl Yayılır

Fragments are defined on specific types and should be used accordingly in queries.

Örnek:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` and `oldDelegate` are of type `Transcoder`.

It is not possible to spread a fragment of type `Vote` here.

#### Fragment'ı atomik bir veri iş birimi olarak tanımlayın

GraphQL `Fragment`s must be defined based on their usage.

For most use-case, defining one fragment per type (in the case of repeated fields usage or type generation) is sufficient.

Here is a rule of thumb for using fragments:

- When fields of the same type are repeated in a query, group them in a `Fragment`.
- When similar but different fields are repeated, create multiple fragments, for instance:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The Essential Tools

### GraphQL web-based explorers

Iterating over queries by running them in your application can be cumbersome. For this reason, don't hesitate to use [Graph Explorer](https://thegraph.com/explorer) to test your queries before adding them to your application. Graph Explorer will provide you a preconfigured GraphQL playground to test your queries.

If you are looking for a more flexible way to debug/test your queries, other similar web-based tools are available such as [Altair](https://altairgraphql.dev/) and [GraphiQL](https://graphiql-online.com/graphiql).

### GraphQL Linting

In order to keep up with the mentioned above best practices and syntactic rules, it is highly recommended to use the following workflow and IDE tools.

**GraphQL ESLint**

[GraphQL ESLint](https://the-guild.dev/graphql/eslint/docs/getting-started) will help you stay on top of GraphQL best practices with zero effort.

[Setup the "operations-recommended"](https://the-guild.dev/graphql/eslint/docs/configs) config will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: should a given variable stay unused?
- and more!

This will allow you to **catch errors without even testing queries** on the playground or running them in production!

### IDE plugins

**VSCode and GraphQL**

The [GraphQL VSCode extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) is an excellent addition to your development workflow to get:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets
- Go to definition for fragments and input types

If you are using `graphql-eslint`, the [ESLint VSCode extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) is a must-have to visualize errors and warnings inlined in your code correctly.

**WebStorm/Intellij and GraphQL**

The [JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-graphql/) will significantly improve your experience while working with GraphQL by providing:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets

For more information on this topic, check out the [WebStorm article](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) which showcases all the plugin's main features.
