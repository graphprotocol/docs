---
title: GraphQL API'ı
---

Explore the GraphQL Query API for interacting with Subgraphs on The Graph Network.

## GraphQL Nedir?

[GraphQL] (https://graphql.org/learn/), API'lar için bir sorgu dili ve bu sorguları mevcut verileriniz üzerinde çalıştıran bir sorgu dilidir. The Graph, Subgraph'leri sorgulamak için GraphQL kullanır.

## Core Concepts

### Varlıklar

- **What they are**: Persistent data objects defined with `@entity` in your schema
- **Key requirement**: Must contain `id: ID!` as primary identifier
- **Usage**: Foundation for all query operations

### Şema

- **Purpose**: Blueprint defining the data structure and relationships using GraphQL [IDL](https://facebook.github.io/graphql/draft/#sec-Type-System)
- **Key characteristics**:
  - Auto-generates query endpoints
  - Read-only operations (no mutations)
  - Defines entity interfaces and derived fields

## GraphQL Sorguları

In the Subgraph schema, types called `Entities`. For each `Entity` type, `entity` and `entities` fields will be generated on the top-level `Query` type.

### Example Queries

> Not: The Graph'te, `graphql` sorgularının başına `query` (sorgu) ifadesinin eklenmesi gerekmez.

Şemanızda tanımlı tek bir `Token` varlığı için sorgu:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> Not: Tek bir varlık sorgulanırken `id` alanı zorunludur ve bir dize olarak yazılmalıdır.

Tüm `Token` varlıklarını sorgulama:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Sıralama

When querying a collection, you can:

- Belirli bir özniteliğe göre sıralama yapmak için `orderBy` parametresini kullanın.
- Sıralama yönünü belirtmek için `orderDirection` kullanın; artan sıralama için `asc`, azalan sıralama için `desc`.

#### Örnek

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### Example for Nested Entity Sorting

Graph Düğümü [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) sürümünden itibaren, varlıklar iç içe ve varlıklara göre sıralanabilir.

Aşağıdaki örnek, token'ların sahip adına göre nasıl sıralandığını gösteriyor:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> Şu anda, `@entity` ve `@derivedFrom` alanlarında bir seviye derinliğindeki `String` veya `ID` türlerine göre sıralama yapabilirsiniz. Ne yazık ki, [bir seviye derinliğindeki varlıklarda arayüzlere göre sıralama](https://github.com/graphprotocol/graph-node/pull/4058), alanı bir dizi ya da iç içe bir varlık olan ögelere göre sıralama henüz desteklenmemektedir.

### Sayfalandırma

Bir koleksiyon sorgularken aşağıdakileri uygulamanız önerilir:

- Koleksiyonun başından itibaren sayfalama yapmak için `first` parametresini kullanın.
  - Varsayılan sıralama düzeni, oluşturulma zamanına göre **değil**, artan alfasayısal sıraya göre `ID` alanına göre yapılır.
- Varlıkları atlamak ve sayfalama yapmak için `skip` parametresini kullanın. Örneğin, `first:100` ilk 100 varlığı gösterir. `first:100, skip:100` ise sonraki 100 varlığı gösterir.
- Sorgularda `skip` değerlerini kullanmaktan kaçının, çünkü genellikle düşük performans gösterirler. Çok sayıda ögeyi getirmek için, yukarıdaki örnekte gösterildiği gibi bir özniteliğe göre varlıklar arasında sayfalama yapmak en iyi yaklaşımdır.

#### Example Using `first`

İlk 10 tokeni sorgulayın:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

To query for groups of entities in the middle of a collection, the `skip` parameter can be used in conjunction with the `first` parameter to skip a specified number of entities starting at the beginning of the collection.

#### Example Using `first` and `skip`

Koleksiyonun başından itibaren 10 öge atlayarak 10 `Token` varlığı sorgulama:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Example Using `first` and `id_ge`

Bir istemcinin çok sayıda varlık alması gerektiğinde, sorguları bir öznitelik temelinde oluşturmak ve bu özniteliğe göre filtrelemek daha yüksek performans sağlar. Örneğin, bir istemci aşağıdaki sorguyu kullanarak çok sayıda token alabilir:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

İlk seferde `lastID = ""` ile sorgu gönderilecek ve sonraki istekler için `lastID` değeri önceki istekteki son varlığın `id` özelliğine göre ayarlanacaktır. Bu yaklaşım, artan `skip` değerlerini kullanmaktan önemli ölçüde daha iyi performans gösterir.

### Filtreleme

- `where` parametresini sorgularınızda farklı özellikleri filtrelemek için kullanabilirsiniz.
- Birden çok değeri `where` parametresi içinde filtreleyebilirsiniz.

#### Using `where` Filtering

Query challenges with `failed` outcome using 'where' filter:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

`_gt`, `_lte` gibi son ekleri değer karşılaştırması için kullanabilirsiniz:

#### Range Filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Block Filtering

Belirtilen bir blokta veya sonrasında güncellenen varlıkları, `_change_block(number_gte: Int)` ile de filtreleyebilirsiniz.

Bu, yalnızca değişen varlıkları getirmek istiyorsanız kullanışlı olabilir. Örneğin, son yoklamanızdan bu yana değişen varlıklar için. Ya da, subgraph'inizde varlıkların nasıl değiştiğini araştırmak veya hata ayıklamak için faydalı olabilir (bir blok filtresiyle beraber kullanıldığında, yalnızca belirli bir blokta değişen varlıkları izole edebilirsiniz).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### Nested Entity Filtering

İç içe varlıklara göre filtreleme, `_` son ekine sahip alanlarda mümkündür.

Bu, yalnızca alt düzey varlıkları sağlanan koşulları karşılayan varlıkları getirmek istiyorsanız yararlı olabilir.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

### Logical Operators

Graph Düğümü [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) sürümünden itibaren, birden fazla kritere dayalı sonuçları filtrelemek için aynı `where` argümanı içinde birden çok parametreyi `and` veya `or` operatörleriyle gruplayabilirsiniz.

#### Using `and` Operator

Aşağıdaki örnek, `outcome` değeri `succeeded` olan ve `number` alanı `100` veya daha büyük olan challenge'ları filtreler.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Sözdizimsel şeker:** Yukarıdaki sorguyu, virgülle ayrılmış bir alt ifade kullanıp `and` operatörünü kaldırarak sadeleştirebilirsiniz.
>
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

#### Using `or` Operator

Aşağıdaki örnek, `outcome` değeri `succeeded` olan veya `number` alanı `100` veya daha büyük olan challenge'ları filtreler.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Note**: When writing queries, it is important to consider the performance impact of using the `or` operator. While `or` can be a useful tool for broadening search results, it can also have significant costs. One of the main issues with `or` is that it can cause queries to slow down. This is because `or` requires the database to scan through multiple indexes, which can be a time-consuming process. To avoid these issues, it is recommended that developers use and operators instead of or whenever possible. This allows for more precise filtering and can lead to faster, more accurate queries.

#### Tüm Filtreler

Parametre eklerinin tam listesi:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Lütfen bazı son eklerin yalnızca belirli türler için desteklendiğini unutmayın. Örneğin, `Boolean` türü yalnızca `_not`, `_in` ve `_not_in` son eklerini destekler; ancak `_` soneki yalnızca nesne ve arayüz türleri için kullanılabilir.

Ayrıca, `where` argümanının bir parçası olarak aşağıdaki genel filtreler kullanılabilir:

```graphql
_change_block(number_gte: Int)
```

### Time-travel Queries

Varlıklarınızın durumunu en son blok için (varsayılan), ya da geçmişteki herhangi bir blok için sorgulayabilirsiniz. Sorgunun hangi blokta yapılacağını belirtmek için, üst seviye sorgu alanlarında `block` argümanı eklenerek ilgili blok numarası veya blok hash’i kullanılabilir.

Böyle bir sorgunun sonucu zamanla değişmez; yani, geçmişteki belirli bir blokta yapılan bir sorgu, ne zaman çalıştırılırsa çalıştırılsın aynı sonucu döndürür. Ancak, zincirin en ucuna (head) çok yakın bir blokta sorgulama yapılırsa, bu blok ana zincirde **yer almıyorsa** ve zincir yeniden düzenlenirse sonuç değişebilir. Bir blok artık kesin (final) olarak kabul edilebildiğinde, o blok için yapılan sorgunun sonucu değişmeyecektir.

> **Not:** Mevcut uygulama, bu güvenceleri ihlal edebilecek bazı sınırlamalara hâlâ tabidir. Uygulama, verilen bir blok hash’inin ana zincirde yer almadığını her zaman tespit edemez veya henüz kesin (final) olarak kabul edilmeyen bir blok için yapılan bir blok hash sorgusunun, sorgu ile eşzamanlı olarak gerçekleşen bir zincir yeniden düzenlemesinden etkilenip etkilenmeyeceğini öngöremez. Ancak bu sınırlamalar, blok kesinleşmiş ve ana zincirde yer aldığı biliniyorsa, blok hash ile yapılan sorguların sonuçlarını etkilemez. Bu sınırlamalar hakkında ayrıntılı bilgi için [bu GitHub issue'su](https://github.com/graphprotocol/graph-node/issues/1405) incelenebilir.

#### Example Time-travel Queries

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Bu sorgu, blok numarası 8.000.000 işlendiği andan hemen sonraki halleriyle `Challenge` varlıklarını ve bunlara bağlı `Application` varlıklarını döndürecektir.

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Bu sorgu, verilen hash’e sahip blok işlendiği andan hemen sonraki halleriyle `Challenge` varlıklarını ve bunlara bağlı `Application` varlıklarını döndürecektir.

### Full-text Search Queries

Full-text search query fields provide an expressive text search API that can be added to the Subgraph schema and customized. Refer to [Defining Full-text Search Fields](/developing/creating-a-subgraph/#defining-fulltext-search-fields) to add full-text search to your Subgraph.

Full-text search queries have one required field, `text`, for supplying search terms. Several special full-text operators are available to be used in this `text` search field.

Full-text search operators:

| Sembol | Operatör    | Tanım                                                                                                         |                                                                                                                                                  |
| ------ | ----------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| `&`    | `And`       | Sağlanan tüm arama terimlerini içeren varlıkları filtrelemek için birden fazla arama terimini birleştirir     |                                                                                                                                                  |
|        |             | `Or`                                                                                                          | Or (veya) operatörüyle ayrılmış birden fazla arama terimi içeren sorgular, sağlanan terimlerden herhangi biriyle eşleşen tüm varlıkları döndürür |
| `<->`  | `Follow by` | İki kelime arasındaki mesafeyi belirtmeyi sağlar.                                                             |                                                                                                                                                  |
| `:*`   | `Prefix`    | Ön eki (Prefix'i) eşleşen kelimeleri bulmak için ön ek arama terimini kullanın (en az 2 karakter gereklidir). |                                                                                                                                                  |

#### Full-text Query Examples

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their full-text fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies that two words must appear a specific distance apart in full-text documents.. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine full-text operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Validasyon

Graph Düğümü, [graphql-js referans uygulamasını](https://github.com/graphql/graphql-js/tree/main/src/validation) temel alan [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules)'yi kullanarak aldığı GraphQL sorgularının [spesifikasyon tabanlı](https://spec.graphql.org/October2021/#sec-Validation) doğrulamasını gerçekleştirir. Bir doğrulama kuralını geçemeyen sorgular standart bir hata ile sonuçlanır. Daha fazla bilgi için [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation)'i ziyaret edin.

### Subgraph Üst Verisi

Tüm Subgraph'lerde, Subgraph metadatasına erişim sağlayan otomatik olarak oluşturulmuş bir `_Meta_` nesnesi bulunur. Buna aşağıdaki şekilde sorgu yapabilirsiniz:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

Bir blok belirtilirse, metadata o bloğa ait durumu yansıtır; belirtilmezse en son endekslenmiş blok kullanılır. Belirtilen blok, Subgraph'in başlangıç bloğundan sonra ve en son endekslenmiş bloğa eşit ya da ondan küçük olmalıdır.

`deployment`, `subgraph.yaml` dosyasının IPFS CID’sine karşılık gelen özgün bir kimliktir.

`block`, `_meta`'ya iletilen herhangi bir blok kısıtlamasını dikkate alarak, en son blok hakkında bilgi sağlar:

- hash: bloğun hash değeri
- number: blok numarası
- timestamp: eğer mevcuts, blokun zaman damgası (bu şu anda yalnızca EVM ağlarını endeksleyen Subgraph'ler için kullanılabilir)

`hasIndexingErrors`, spesifik bir Subgraph'in geçmişteki bir blokta endeksleme hatalarıyla karşılaşıp karşılaşmadığını belirten bir boolean ifadedir
