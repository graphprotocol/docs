---
title: GraphQL API'ı
---

The Graph'te kullanılan GraphQL Sorgu API'ı hakkında bilgi edinin.

## GraphQL Nedir?

[GraphQL] (https://graphql.org/learn/), API'lar için bir sorgu dili ve bu sorguları mevcut verileriniz üzerinde çalıştıran bir sorgu dilidir. The Graph, Subgraph'leri sorgulamak için GraphQL kullanır.

GraphQL’in daha kapsamlı rolünü anlamak için [geliştirme](/subgraphs/developing/introduction/) ve [bir Subgraph oluşturma](/developing/creating-a-subgraph/) bölümlerini inceleyin.

## GraphQL Sorguları

Subgraph şemanızda, `Entities` (Varlıklar) olarak adlandırılan türleri tanımlarsınız. Her bir `Entity` (Varlık) türü için, üst düzey `Query` türü üzerinde `entity` ve `entities` alanları otomatik olarak oluşturulur.

> Not: The Graph'te, `graphql` sorgularının başına `query` (sorgu) ifadesinin eklenmesi gerekmez.

### Örnekler

Şemanızda tanımlı tek bir `Token` varlığı için sorgu:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> Not: Tek bir varlık sorgulanırken `id` alanı zorunludur ve bir dize olarak yazılmalıdır.

Tüm `Token` varlıklarını sorgulama:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Sıralama

Bir koleksiyon sorgularken şunları yapabilirsiniz:

- Belirli bir özniteliğe göre sıralama yapmak için `orderBy` parametresini kullanın.
- Sıralama yönünü belirtmek için `orderDirection` kullanın; artan sıralama için `asc`, azalan sıralama için `desc`.

#### Örnek

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### İç içe varlık sıralaması için örnek

Graph Düğümü [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) sürümünden itibaren, varlıklar iç içe ve varlıklara göre sıralanabilir.

Aşağıdaki örnek, token'ların sahip adına göre nasıl sıralandığını gösteriyor:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> Şu anda, `@entity` ve `@derivedFrom` alanlarında bir seviye derinliğindeki `String` veya `ID` türlerine göre sıralama yapabilirsiniz. Ne yazık ki, [bir seviye derinliğindeki varlıklarda arayüzlere göre sıralama](https://github.com/graphprotocol/graph-node/pull/4058), alanı bir dizi ya da iç içe bir varlık olan ögelere göre sıralama henüz desteklenmemektedir.

### Sayfalandırma

Bir koleksiyon sorgularken aşağıdakileri uygulamanız önerilir:

- Koleksiyonun başından itibaren sayfalama yapmak için `first` parametresini kullanın.
  - Varsayılan sıralama düzeni, oluşturulma zamanına göre **değil**, artan alfasayısal sıraya göre `ID` alanına göre yapılır.
- Varlıkları atlamak ve sayfalama yapmak için `skip` parametresini kullanın. Örneğin, `first:100` ilk 100 varlığı gösterir. `first:100, skip:100` ise sonraki 100 varlığı gösterir.
- Sorgularda `skip` değerlerini kullanmaktan kaçının, çünkü genellikle düşük performans gösterirler. Çok sayıda ögeyi getirmek için, yukarıdaki örnekte gösterildiği gibi bir özniteliğe göre varlıklar arasında sayfalama yapmak en iyi yaklaşımdır.

#### `first` kullanımına örnek

İlk 10 tokeni sorgulayın:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

Bir koleksiyonun ortasındaki varlık gruplarını sorgulamak için, `skip` parametresi `first` parametresiyle birlikte kullanılabilir. Bu, koleksiyonun başından itibaren belirli sayıda varlığı atlayarak sorgulama yapmanızı sağlar.

#### `first` ve `skip` kullanımına örnek

Koleksiyonun başından itibaren 10 öge atlayarak 10 `Token` varlığı sorgulama:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### `first` ve `id_ge` kullanımına örnek

Bir istemcinin çok sayıda varlık alması gerektiğinde, sorguları bir öznitelik temelinde oluşturmak ve bu özniteliğe göre filtrelemek daha yüksek performans sağlar. Örneğin, bir istemci aşağıdaki sorguyu kullanarak çok sayıda token alabilir:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

İlk seferde `lastID = ""` ile sorgu gönderilecek ve sonraki istekler için `lastID` değeri önceki istekteki son varlığın `id` özelliğine göre ayarlanacaktır. Bu yaklaşım, artan `skip` değerlerini kullanmaktan önemli ölçüde daha iyi performans gösterir.

### Filtreleme

- `where` parametresini sorgularınızda farklı özellikleri filtrelemek için kullanabilirsiniz.
- Birden çok değeri `where` parametresi içinde filtreleyebilirsiniz.

#### `where` kullanımına örnek

`outcome` değeri `failed` olan challenge'ları sorgulama:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

You can use suffixes like `_gt`, `_lte` for value comparison:

#### Aralık filtreleme için örnek

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Blok filtreleme için örnek

You can also filter entities that were updated in or after a specified block with `_change_block(number_gte: Int)`.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your Subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### İç içe varlık filtreleme örneği

Filtering on the basis of nested entities is possible in the fields with the `_` suffix.

Bu, yalnızca alt düzey varlıkları sağlanan koşulları karşılayan varlıkları getirmek istiyorsanız yararlı olabilir.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

#### Mantıksal operatörler

As of Graph Node [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0) you can group multiple parameters in the same `where` argument using the `and` or the `or` operators to filter results based on more than one criteria.

##### `AND` Operator

The following example filters for challenges with `outcome` `succeeded` and `number` greater than or equal to `100`.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Syntactic sugar:** You can simplify the above query by removing the `and` operator by passing a sub-expression separated by commas.
>
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

##### `OR` Operator

The following example filters for challenges with `outcome` `succeeded` or `number` greater than or equal to `100`.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Note**: When constructing queries, it is important to consider the performance impact of using the `or` operator. While `or` can be a useful tool for broadening search results, it can also have significant costs. One of the main issues with `or` is that it can cause queries to slow down. This is because `or` requires the database to scan through multiple indexes, which can be a time-consuming process. To avoid these issues, it is recommended that developers use and operators instead of or whenever possible. This allows for more precise filtering and can lead to faster, more accurate queries.

#### Tüm Filtreler

Parametre eklerinin tam listesi:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`, but `_` is available only for object and interface types.

In addition, the following global filters are available as part of `where` argument:

```graphql
_change_block(number_gte: Int)
```

### Zaman yolculuğu sorguları

You can query the state of your entities not just for the latest block, which is the default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the chain, the result might change if that block turns out to **not** be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

> Note: The current implementation is still subject to certain limitations that might violate these guarantees. The implementation can not always tell that a given block hash is not on the main chain at all, or if a query result by a block hash for a block that is not yet considered final could be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### Örnek

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### Örnek

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### Tam Metin Arama Sorguları

Fulltext search query fields provide an expressive text search API that can be added to the Subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developing/creating-a-subgraph/#defining-fulltext-search-fields) to add fulltext search to your Subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

Tam metin arama operatörleri:

| Symbol | Operator    | Tanım                                                                                                                                |
| ------ | ----------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `&`    | `And`       | For combining multiple search terms into a filter for entities that include all of the provided terms                                |
| &#x7c; | `Or`        | Queries with multiple search terms separated by the or operator will return all entities with a match from any of the provided terms |
| `<->`  | `Follow by` | Specify the distance between two words.                                                                                              |
| `:*`   | `Prefix`    | Use the prefix search term to find words whose prefix match (2 characters required.)                                                 |

#### Örnekler

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Daha karmaşık filtreler oluşturmak için tam metin operatörlerini birleştirin. Bu örnek sorgu, bir pretext arama işleci ile bir follow by işlecini birleştirerek "lou" ile başlayan ve ardından "music" ile devam eden sözcükleri içeren tüm blog varlıklarıyla eşleşecektir.

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Validasyon

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## Schema

The schema of your dataSources, i.e. the entity types, values, and relationships that are available to query, are defined through the [GraphQL Interface Definition Language (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your Subgraph is automatically generated from the GraphQL schema that's included in your [Subgraph manifest](/developing/creating-a-subgraph/#components-of-a-subgraph).

> Note: Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### Varlıklar

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.

### Subgraph Üst Verisi

All Subgraphs have an auto-generated `_Meta_` object, which provides access to Subgraph metadata. This can be queried as follows:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

If a block is provided, the metadata is as of that block, if not the latest indexed block is used. If provided, the block must be after the Subgraph's start block, and less than or equal to the most recently indexed block.

`deployment` is a unique ID, corresponding to the IPFS CID of the `subgraph.yaml` file.

`block` provides information about the latest block (taking into account any block constraints passed to `_meta`):

- hash: the hash of the block
- number: the block number
- timestamp: the timestamp of the block, if available (this is currently only available for Subgraphs indexing EVM networks)

`hasIndexingErrors` is a boolean identifying whether the Subgraph encountered indexing errors at some past block
