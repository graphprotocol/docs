---
title: About The Graph
---

> The Graph is a decentralized protocol for indexing and querying blockchain data. It enables efficient and secure access to onchain data via Subgraphs, Substreams, TokenAPI, and GraphQL, simplifying dapp development and improving performance.

This page summarizes the core concepts and basics of The Graph protocol.

## Explanation

### What is the Graph?

The Graph is a decentralized protocol for indexing and querying blockchain data, empowering developers to access onchain data via open APIs called [Subgraphs](https://thegraph.com/docs/en/subgraphs/developing/subgraphs/). Its suite includes The Graph Network, Subgraphs, [Substreams](https://thegraph.com/docs/en/substreams/introduction/), [Token API BETA](https://thegraph.com/docs/en/token-api/quick-start/), and tools like [Graph Explorer](https://thegraph.com/docs/en/subgraphs/explorer/) and [Subgraph Studio](https://thegraph.com/docs/en/subgraphs/developing/deploying/using-subgraph-studio/). The Graph supports multiple blockchains and enhances data access in the web3 ecosystem.

### Why is Blockchain Data hard to Query?

Reading onchain data from the blockchain (e.g., ownership history, metadata, relationships between assets) typically requires processing smart contract events, parsing metadata from IPFS, and aggregating data manually. This is very slow, complex, and resource-intensive.

## Solution

### How The Graph Solves This

The Graph uses open APIs called Subgraphs to index blockchain data. Each Subgraph defines:

- Which smart contracts to watch
- Which events to extract
- How to map event data into a queryable format using GraphQL

Indexing blockchain data is complex, but The Graph simplifies it through a global, decentralized network of Indexers. This infrastructure enables efficient, censorship-resistant query handling, allowing developers to build applications using blockchain data without the hassle of managing servers or custom indexing.

### Building a Subgraph

1. Define a **Subgraph Manifest** with the data sources and mappings
2. Use **Graph CLI** to deploy the manifest to IPFS
3. An **Indexer** picks it up and starts indexing Ethereum blocks
4. Data becomes queryable via a **GraphQL endpoint**

### Data Flow Overview

1. A dapp triggers a transaction on Ethereum by interacting with a smart contract.

2. As the transaction is processed, the smart contract emits one or more events.

3. Graph Node continuously scans the Ethereum blockchain for new blocks and filters for events relevant to a deployed Subgraph.

4. When a matching event is identified, the Graph Node executes the Subgraphâ€™s mapping logic, which is a WASM module that transforms event data into structured entities. These entities are subsequently stored and indexed.

5. The dapp queries the Graph Node via a [GraphQL API](https://graphql.org/learn/), retrieving indexed data to render in the UI. Users can then take actions that generate new transactions, continuing the cycle.

The diagram below provides more detailed information about the flow of data after a Subgraph manifest has been deployed with Ethereum transactions.

![A graphic explaining how The Graph uses Graph Node to serve queries to data consumers](/img/graph-dataflow.png)

## Next Steps

Explore [Graph Explorer](https://thegraph.com/explorer) to view and query existing Subgraphs.
