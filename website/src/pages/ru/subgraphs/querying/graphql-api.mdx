---
title: API GraphQL
---

Explore the GraphQL Query API for interacting with Subgraphs on The Graph Network.

## Что такое GraphQL?

[GraphQL](https://graphql.org/learn/) is a query language for APIs and a runtime for executing those queries with your existing data. The Graph uses GraphQL to query Subgraphs.

## Core Concepts

### Объекты

- **What they are**: Persistent data objects defined with `@entity` in your schema
- **Key requirement**: Must contain `id: ID!` as primary identifier
- **Usage**: Foundation for all query operations

### Схема

- **Purpose**: Blueprint defining the data structure and relationships using GraphQL [IDL](https://facebook.github.io/graphql/draft/#sec-Type-System)
- **Key characteristics**:
  - Auto-generates query endpoints
  - Read-only operations (no mutations)
  - Defines entity interfaces and derived fields

## Запросы с GraphQL

In the Subgraph schema, types called `Entities`. For each `Entity` type, `entity` and `entities` fields will be generated on the top-level `Query` type.

### Example Queries

> Примечание: `query` не нужно указывать в начале `graphql` запроса при использовании The Graph.

Запрос для одного объекта `Token`, определенного в Вашей схеме:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

> Примечание: При запросе одного объекта поле `id` является обязательным и должно быть записано как строка.

Запрос всех объектов `Token`:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Сортировка

When querying a collection, you can:

- Использовать параметр `orderBy` для сортировки по определенному атрибуту.
- Использовать параметр `orderDirection`, чтобы указать направление сортировки `asc` для возрастания или `desc` для убывания.

#### Пример

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

#### Example for Nested Entity Sorting

Начиная с Graph Node [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0), объекты можно сортировать на основе вложенных объектов.

В следующем примере мы сортируем токены по имени их владельца:

```graphql
{
  tokens(orderBy: owner__name, orderDirection: asc) {
    id
    owner {
      name
    }
  }
}
```

> В настоящее время сортировка возможна по одноуровневым полям типа `String` или `ID`, в полях `@entity` и `@derivedFrom`. К сожалению, [сортировка по интерфейсам в одноуровневых объектах](https://github.com/graphprotocol/graph-node/pull/4058), сортировка по полям-массивам и вложенным объектам пока не поддерживается.

### Пагинация

При запросе коллекции лучше всего:

- Использовать параметр `first` для пагинации данных с начала коллекции.
  - Стандартная сортировка выполняется по `ID` в возрастающем алфавитно-числовом порядке, **не** по времени создания.
- Использовать параметр `skip`, чтобы пропускать объекты и осуществлять пагинацию. Например, `first:100` покажет первые 100 объектов, а `first:100, skip:100` покажет следующие 100 объектов.
- Избегайте использования `skip` в запросах, так как это обычно приводит к низкой производительности. Для получения большого количества элементов лучше выполнять постраничную загрузку объектов на основе атрибута, как показано в предыдущем примере.

#### Example Using `first`

Запрос первых 10 токенов:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

To query for groups of entities in the middle of a collection, the `skip` parameter can be used in conjunction with the `first` parameter to skip a specified number of entities starting at the beginning of the collection.

#### Example Using `first` and `skip`

Запрос 10 объектов `Token`, смещенных на 10 позиций от начала коллекции:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Example Using `first` and `id_ge`

Если клиенту нужно получить большое количество объектов, эффективнее выполнять запросы на основе атрибута и фильтровать по этому атрибуту. Например, клиент может получить большое количество токенов с помощью следующего запроса:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

В первый раз запрос отправляется с `lastID = ""`, а в последующих запросах `lastID` устанавливается в значение атрибута `id` последнего объекта из предыдущего запроса. Этот подход значительно эффективнее, чем использование увеличивающихся значений `skip`.

### Фильтрация

- Вы можете использовать параметр `where` в запросах для фильтрации по различным свойствам.
- Вы можете фильтровать по нескольким значениям внутри параметра `where`.

#### Using `where` Filtering

Query challenges with `failed` outcome using 'where' filter:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Вы можете использовать такие суффиксы, как `_gt`, `_lte` для сравнения значений:

#### Range Filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Block Filtering

Вы также можете фильтровать объекты, которые были обновлены на указанном блоке или позже, с помощью `_change_block(number_gte: Int)`.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your Subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### Nested Entity Filtering

Фильтрация на основе вложенных объектов возможна в полях с суффиксом `_`.

Это может быть полезно, если Вы хотите получать только объекты, у которых объекты дочернего уровня удовлетворяют заданным условиям.

```graphql
{
  challenges(where: { application_: { id: 1 } }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

### Logical Operators

Начиная с Graph Node [`v0.30.0`](https://github.com/graphprotocol/graph-node/releases/tag/v0.30.0), Вы можете группировать несколько параметров в одном аргументе `where`, используя операторы `and` или `or` для фильтрации результатов по нескольким критериям.

#### Using `and` Operator

Следующий пример фильтрует задачи с `outcome` `succeeded` и `number` больше или равно `100`.

```graphql
{
  challenges(where: { and: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Синтаксический сахар:** Вы можете упростить приведенный выше запрос, убрав оператор `and` и передав подвыражение, разделенное запятыми.
>
> ```graphql
> {
>   challenges(where: { number_gte: 100, outcome: "succeeded" }) {
>     challenger
>     outcome
>     application {
>       id
>     }
>   }
> }
> ```

#### Using `or` Operator

Следующий пример фильтрует задачи с `outcome` `succeeded` или `number` больше или равно `100`.

```graphql
{
  challenges(where: { or: [{ number_gte: 100 }, { outcome: "succeeded" }] }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

> **Note**: When writing queries, it is important to consider the performance impact of using the `or` operator. While `or` can be a useful tool for broadening search results, it can also have significant costs. One of the main issues with `or` is that it can cause queries to slow down. This is because `or` requires the database to scan through multiple indexes, which can be a time-consuming process. To avoid these issues, it is recommended that developers use and operators instead of or whenever possible. This allows for more precise filtering and can lead to faster, more accurate queries.

#### Все фильтры

Полный список суффиксов параметров:

```
_
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Обратите внимание, что некоторые суффиксы поддерживаются только для определенных типов. Например, `Boolean` поддерживает только `_not`, `_in` и `_not_in`, тогда как `_` доступен только для объектных и интерфейсных типов.

Кроме того, в качестве части аргумента `where` доступны следующие глобальные фильтры:

```graphql
_change_block(number_gte: Int)
```

### Time-travel Queries

Вы можете запрашивать состояние своих объектов не только для последнего блока, который используется по умолчанию, но и для произвольного блока в прошлом. Блок, в котором должен выполняться запрос, можно указать либо по номеру блока, либо по его хэшу, включив аргумент `block` в поля верхнего уровня запросов.

Результат такого запроса не изменится со временем, то есть запрос на определенном прошедшем блоке вернет тот же результат, независимо от времени выполнения, за исключением случая, когда запрос выполняется на блоке, который находится очень близко к началу чейна. В этом случае результат может измениться, если этот блок окажется **не** на основном чейне, и чейн будет реорганизован. Как только блок можно будет считать окончательным, результат запроса больше не изменится.

> Примечание: Текущая реализация все еще подвержена определенным ограничениям, которые могут нарушить эти гарантии. Реализация не всегда может точно определить, что данный хэш блока вообще не находится на основном чейне, или что результат запроса по хэшу блока для блока, который еще не считается окончательным, может быть изменен из-за реорганизации блоков, происходящей одновременно с запросом. Эти ограничения не влияют на результаты запросов по хэшу блока, если блок окончателен и подтвержден на основном чейне. [Этот вопрос](https://github.com/graphprotocol/graph-node/issues/1405) подробно объясняет, в чем состоят эти ограничения.

#### Example Time-travel Queries

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Этот запрос вернет объекты `Challenge` и связанные с ними объекты `Application` в том виде, в каком они существовали сразу после обработки блока номер 8,000,000.

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Этот запрос вернет объекты `Challenge` и связанные с ними объекты `Application` в том виде, в каком они существовали сразу после обработки блока с заданным хешем.

### Full-text Search Queries

Full-text search query fields provide an expressive text search API that can be added to the Subgraph schema and customized. Refer to [Defining Full-text Search Fields](/developing/creating-a-subgraph/#defining-fulltext-search-fields) to add full-text search to your Subgraph.

Full-text search queries have one required field, `text`, for supplying search terms. Several special full-text operators are available to be used in this `text` search field.

Full-text search operators:

| Символ | Оператор    | Описание                                                                                                       |                                                                                                                                                |
| ------ | ----------- | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `&`    | `And`       | Для объединения нескольких условий поиска в фильтр для объектов, которые включают все указанные условия        |                                                                                                                                                |
|        |             | `Or`                                                                                                           | Запросы с несколькими условиями поиска, разделенные оператором or, вернут все объекты, которые соответствуют любому из предоставленных условий |
| `<->`  | `Follow by` | Укажите расстояние между двумя словами.                                                                        |                                                                                                                                                |
| `:*`   | `Prefix`    | Используйте поисковый запрос по префиксу, чтобы найти слова с соответствующим префиксом (необходимо 2 символа) |                                                                                                                                                |

#### Full-text Query Examples

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their full-text fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies that two words must appear a specific distance apart in full-text documents.. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine full-text operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Валидация

Graph Node реализует валидацию [на основе спецификации](https://spec.graphql.org/October2021/#sec-Validation) для получаемых GraphQL-запросов с использованием [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), которая основана на [референсной реализации graphql-js](https://github.com/graphql/graphql-js/tree/main/src/validation). Запросы, не прошедшие проверку валидации, завершаются стандартной ошибкой. Ознакомьтесь со [спецификацией GraphQL](https://spec.graphql.org/October2021/#sec-Validation), чтобы узнать больше.

### Метаданные субграфа

All Subgraphs have an auto-generated `_Meta_` object, which provides access to Subgraph metadata. This can be queried as follows:

```graphQL
{
  _meta(block: { number: 123987 }) {
    block {
      number
      hash
      timestamp
    }
    deployment
    hasIndexingErrors
  }
}
```

If a block is provided, the metadata is as of that block, if not the latest indexed block is used. If provided, the block must be after the Subgraph's start block, and less than or equal to the most recently indexed block.

`deployment` — это уникальный идентификатор, соответствующий IPFS CID файла `subgraph.yaml`.

`block` предоставляет информацию о последнем блоке (с учетом любых ограничений блоков, переданных в `_meta`):

- hash: хэш блока
- number: номер блока
- timestamp: the timestamp of the block, if available (this is currently only available for Subgraphs indexing EVM networks)

`hasIndexingErrors` is a boolean identifying whether the Subgraph encountered indexing errors at some past block
