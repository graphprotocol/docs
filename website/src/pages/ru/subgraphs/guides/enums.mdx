---
title: Категоризация маркетплейсов NFT с использованием Enums (перечислений)
---

Используйте Enums (перечисления), чтобы сделать Ваш код чище и уменьшить вероятность ошибок. Вот полный пример использования перечислений для маркетплейсов NFT.

## Что такое Enums (перечисления)?

Перечисления (или типы перечислений) — это особый тип данных, который позволяет определить набор конкретных допустимых значений.

### Пример использования Enums (перечислений) в Вашей схеме

Если вы создаете cубграф для отслеживания истории владения токенами на маркетплейсе, каждый токен может проходить через разные этапы владения, такие как `OriginalOwner`, `SecondOwner` и `ThirdOwner`. Используя перечисления (enums), вы можете определить эти конкретные этапы владения, обеспечив, что будут присваиваться только заранее определенные значения.

Вы можете определить перечисления (enums) в своей схеме, и после их определения Вы можете использовать строковое представление значений перечислений для установки значения поля перечисления в объекты.

Вот как может выглядеть определение перечисления (enum) в Вашей схеме, исходя из приведенного выше примера:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Это означает, что когда Вы используете тип `TokenStatus` в своей схеме, Вы ожидаете, что он будет иметь одно из заранее определенных значений: `OriginalOwner` (Первоначальный Владелец), `SecondOwner` (Второй Владелец) или `ThirdOwner` (Третий Владелец), что обеспечивает согласованность и корректность данных.

Чтобы узнать больше о перечислениях (Enums), ознакомьтесь с разделом [Создание субграфа](/developing/creating-a-subgraph/#enums) и с [документацией GraphQL](https://graphql.org/learn/schema/#enumeration-types).

## Преимущества использования перечислений (Enums)

- **Ясность:** Перечисления предоставляют значимые имена для значений, что делает данные более понятными.
- **Валидация:** Перечисления обеспечивают строгие определения значений, предотвращая ввод недопустимых данных.
- **Поддерживаемость:** Когда Вам нужно изменить или добавить новые категории, перечисления позволяют сделать это целенаправленно и удобно.

### Без перечислений (Enums)

Если Вы решите определить тип как строку вместо использования перечисления (Enum), Ваш код может выглядеть следующим образом:

```graphql
type Token @entity {
  id: ID!
  tokenId: BigInt!
  owner: Bytes! # Owner of the token
  tokenStatus: String! # String field to track token status
  timestamp: BigInt!
}
```

В этой схеме `TokenStatus` является простой строкой без конкретных и допустимых значений.

#### Почему это является проблемой?

- Нет никаких ограничений на значения `TokenStatus`, поэтому любое строковое значение может быть назначено случайно. Это усложняет обеспечение того, что устанавливаются только допустимые статусы, такие как `OriginalOwner` (Первоначальный Владелец), `SecondOwner` (Второй Владелец) или `ThirdOwner` (Третий Владелец).
- Легко допустить опечатку, например, `Orgnalowner` вместо `OriginalOwner`, что делает данные и потенциальные запросы ненадежными.

### С перечислениями (Enums)

Вместо присвоения строк произвольной формы Вы можете определить перечисление (Enum) для `TokenStatus` с конкретными значениями: `OriginalOwner`, `SecondOwner` или `ThirdOwner`. Использование перечисления гарантирует, что используются только допустимые значения.

Перечисления обеспечивают безопасность типов, минимизируют риск опечаток и гарантируют согласованные и надежные результаты.

## Определение перечислений (Enums) для Маркетплейсов NFT

> Примечание: Следующее руководство использует смарт-контракт NFT CryptoCoven.

Чтобы определить перечисления (enums) для различных маркетплейсов, где торгуются NFT, используйте следующее в вашей схеме cубграфа:

```gql
# Перечисление для маркетплейсов, с которыми взаимодействовал смарт-контракт CryptoCoven (вероятно, торговля или минт)
enum Marketplace {
  OpenSeaV1 # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе OpenSeaV1
  OpenSeaV2 # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе OpenSeaV2
  SeaPort # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе SeaPort
  LooksRare # Представляет случай, когда NFT CryptoCoven торгуется на маркетплейсе LooksRare
  # ...и другие рынки
}
```

## Использование перечислений (Enums) для Маркетплейсов NFT

После того как перечисления (enums) определены, их можно использовать по всему вашему cубграфу для категоризации транзакций или событий.

Например, при регистрации продаж NFT можно указать маркетплейс, на котором произошла сделка, используя перечисление.

### Реализация функции для маркетплейсов NFT

Вот как можно реализовать функцию для получения названия маркетплейса из перечисления (enum) в виде строки:

```ts
export function getMarketplaceName(marketplace: Marketplace): string {
  // Используем операторы if-else для сопоставления значения перечисления со строкой
  if (marketplace === Marketplace.OpenSeaV1) {
    return 'OpenSeaV1' // Если маркетплейс OpenSea, возвращаем его строковое представление
  } else if (marketplace === Marketplace.OpenSeaV2) {
    return 'OpenSeaV2'
  } else if (marketplace === Marketplace.SeaPort) {
    return 'SeaPort' // Если маркетплейс SeaPort, возвращаем его строковое представление
  } else if (marketplace === Marketplace.LooksRare) {
    return 'LooksRare' // Если маркетплейс LooksRare, возвращаем его строковое представление
    // ... и другие маркетплейсы
  }
}
```

## Лучшие практики использования перечислений (Enums)

- **Согласованность в наименованиях:** Используйте четкие, описательные названия для значений перечислений, чтобы улучшить читаемость кода.
- **Централизованное управление:** Храните перечисления в одном файле для обеспечения согласованности. Это облегчает обновление перечислений и гарантирует, что они являются единственным источником достоверной информации.
- **Документация:** Добавляйте комментарии к перечислениям, чтобы прояснить их назначение и использование.

## Использование перечислений (Enums) в запросах

Перечисления в запросах помогают улучшить качество данных и делают результаты более понятными. Они функционируют как фильтры и элементы ответа, обеспечивая согласованность и уменьшая ошибки в значениях маркетплейса.

**Особенности**

- **Фильтрация с помощью перечислений:** Перечисления предоставляют четкие фильтры, позволяя уверенно включать или исключать конкретные маркетплейсы.
- **Перечисления в ответах:** Перечисления гарантируют, что возвращаются только признанные названия маркетплейсов, делая результаты стандартизированными и точными.

### Пример запросов

#### Запрос 1: Аккаунт с наибольшим количеством взаимодействий на маркетплейсе NFT

Этот запрос выполняет следующие действия:

- Он находит аккаунт с наибольшим количеством уникальных взаимодействий с маркетплейсами NFT, что полезно для анализа активности на разных маркетплейсах.
- Поле маркетплейсов использует перечисление marketplace, что обеспечивает согласованность и валидацию значений маркетплейсов в ответе.

```gql
{
  accounts(first: 1, orderBy: uniqueMarketplacesCount, orderDirection: desc) {
    id
    sendCount
    receiveCount
    totalSpent
    uniqueMarketplacesCount
    marketplaces {
      marketplace # Это поле возвращает значение перечисления, представляющее маркетплейс
    }
  }
}
```

#### Результаты

Данный ответ включает информацию об аккаунте и перечень уникальных взаимодействий с маркетплейсом, где используются значения перечислений (enum) для обеспечения единообразной ясности:

```gql
{
  "data": {
    "accounts": [
      {
        "id": "0xb3abc96cb9a61576c03c955d75b703a890a14aa0",
        "sendCount": "44",
        "receiveCount": "44",
        "totalSpent": "1197500000000000000",
        "uniqueMarketplacesCount": "7",
        "marketplaces": [
          {
            "marketplace": "OpenSeaV1"
          },
          {
            "marketplace": "OpenSeaV2"
          },
          {
            "marketplace": "GenieSwap"
          },
          {
            "marketplace": "CryptoCoven"
          },
          {
            "marketplace": "Unknown"
          },
          {
            "marketplace": "LooksRare"
          },
          {
            "marketplace": "NFTX"
          }
        ]
      }
    ]
  }
}
```

#### Запрос 2: Наиболее активный маркетплейс для транзакций CryptoCoven

Этот запрос выполняет следующие действия:

- Он определяет маркетплейс с наибольшим объемом транзакций CryptoCoven.
- Он использует перечисление marketplace, чтобы гарантировать, что в ответе будут только допустимые типы маркетплейсов, что повышает надежность и согласованность ваших данных.

```gql
{
  marketplaceInteractions(first: 1, orderBy: transactionCount, orderDirection: desc) {
    marketplace
    transactionCount
  }
}
```

#### Результат 2

Ожидаемый ответ включает маркетплейс и соответствующее количество транзакций, используя перечисление для указания типа маркетплейса:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "Unknown",
        "transactionCount": "222"
      }
    ]
  }
}
```

#### Запрос 3: Взаимодействия на маркетплейсе с высоким количеством транзакций

Этот запрос выполняет следующие действия:

- Он извлекает четыре самых активных маркетплейса с более чем 100 транзакциями, исключая маркетплейсы с типом "Unknown".
- Он использует перечисления в качестве фильтров, чтобы гарантировать, что включены только допустимые типы маркетплейсов, что повышает точность выполнения запроса.

```gql
{
  marketplaceInteractions(
    first: 4
    orderBy: transactionCount
    orderDirection: desc
    where: { transactionCount_gt: "100", marketplace_not: "Unknown" }
  ) {
    marketplace
    transactionCount
  }
}
```

#### Результат 3

Ожидаемый вывод включает маркетплейсы, которые соответствуют критериям, каждый из которых представлен значением перечисления:

```gql
{
  "data": {
    "marketplaceInteractions": [
      {
        "marketplace": "NFTX",
        "transactionCount": "201"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "148"
      },
      {
        "marketplace": "CryptoCoven",
        "transactionCount": "117"
      },
      {
        "marketplace": "OpenSeaV1",
        "transactionCount": "111"
      }
    ]
  }
}
```

## Дополнительные ресурсы

Дополнительную информацию можно найти в [репозитории] этого руководства (https://github.com/chidubemokeke/Subgraph-Tutorial-Enums).
