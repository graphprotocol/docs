---
title: Схема GraphQL
---

## Обзор

Схема для вашего субграфа находится в файле `schema.graphql`. Схемы GraphQL определяются с использованием языка определения интерфейса GraphQL.

> Примечание: Если вы никогда не писали схему GraphQL, рекомендуется ознакомиться с этим введением в систему типов GraphQL. Справочную документацию по схемам GraphQL можно найти в разделе [GraphQL API](/subgraphs/querying/graphql-api/).

### Определение Объектов

Прежде чем определять объекты, важно сделать шаг назад и задуматься над тем, как структурированы и связаны Ваши данные.

- Все запросы будут выполняться против модели данных, определенной в схеме субграфа. Поэтому проектирование схемы субграфа должно основываться на запросах, которые ваше приложение будет выполнять.
- Может быть полезно представить объекты как «объекты, содержащие данные», а не как события или функции.
- Вы определяете типы объектов в файле `schema.graphql`, и Graph Node будет генерировать поля верхнего уровня для запроса отдельных экземпляров и коллекций этих типов объектов.
- Каждый тип, который должен быть объектом, должен быть аннотирован директивой `@entity`.
- По умолчанию объекты изменяемы, то есть мэппинги могут загружать существующие объекты, изменять и сохранять их новую версию.
  - Изменяемость имеет свою цену, поэтому для типов объектов, которые никогда не будут изменяться, например, содержащих данные, извлеченные дословно из чейна, рекомендуется пометить их как неизменяемые с помощью `@entity(immutable: true)`.
  - Если изменения происходят в том же блоке, в котором был создан объект, то мэппинги могут вносить изменения в неизменяемые объекты. Неизменяемые объекты гораздо быстрее записываются и запрашиваются, поэтому их следует использовать, когда это возможно.

#### Удачный пример

Следующий объект `Gravatar` структурирован вокруг объекта Gravatar и является хорошим примером того, как можно определить объект.

```graphql
type Gravatar @entity(immutable: true) {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

#### Неудачный пример

Следующий пример объектов `GravatarAccepted` и `GravatarDeclined` основан на событиях. Не рекомендуется сопоставлять события или вызовы функций 1:1 к объектам.

```graphql
type GravatarAccepted @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: Bytes!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

#### Дополнительные и обязательные поля

Поля объектов могут быть определены как обязательные или необязательные. Обязательные поля указываются с помощью `!` в схеме. Если поле является скалярным, вы получите ошибку при попытке сохранить объект. Если поле ссылается на другой объект, то вы получите следующую ошибку:

```
Null value resolved for non-null field 'name'
```

Каждый объект должен иметь поле `id`, которое должно быть типа `Bytes!` или `String!`. Обычно рекомендуется использовать `Bytes!`, если только `id` не содержит текст, читаемый человеком, поскольку объекты с `id` типа `Bytes!` будут быстрее записываться и запрашиваться, чем те, у которых `id` типа `String!`. Поле `id` служит основным ключом и должно быть уникальным среди всех объектов одного типа. По историческим причинам также принимается тип `ID!`, который является синонимом `String!`.

Для некоторых типов объектов `id` для `Bytes!` формируется из `id` двух других объектов. Это возможно с использованием функции `concat`, например, `let id = left.id.concat(right.id)`, чтобы сформировать `id` из `id` объектов `left` и `right`. Аналогично, чтобы сформировать `id` из `id` существующего объекта и счетчика `count`, можно использовать `let id = left.id.concatI32(count)`. Конкатенация гарантирует, что `id` будет уникальным, если длина `left.id` одинаковая для всех таких объектов, например, если `left.id` — это `Address`.

### Встроенные скалярные типы

#### Поддерживаемые GraphQL скаляры

В API GraphQL поддерживаются следующие скаляры:

| Тип | Описание |
| --- | --- |
| `Bytes` | Массив байтов, представленный в виде шестнадцатеричной строки. Обычно используется для хэшей и адресов Ethereum. |
| `String` | Скаляр для значений типа `string`. Нулевые символы не поддерживаются и автоматически удаляются. |
| `Boolean` | Скаляр для значений `boolean`. |
| `Int` | Спецификация GraphQL определяет тип `Int` как знаковое 32-битное целое число. |
| `Int8` | 8-байтовое целое число со знаком, также известное как 64-битное целое число со знаком, может хранить значения в диапазоне от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807. Рекомендуется использовать его для представления типа `i64` из ethereum. |
| `BigInt` | Большие целые числа. Используются для типов `uint32`, `int64`, `uint64`, ..., `uint256` из Ethereum. Примечание: все типы, меньше чем `uint32`, такие как `int32`, `uint24` или `int8`, представлены как `i32`. |
| `BigDecimal` | `BigDecimal` Высокоточные десятичные числа, представленные как мантисса и экспонента. Диапазон экспоненты от −6143 до +6144. Округляется до 34 значащих цифр. |
| `Timestamp` | Это значение типа `i64` в микросекундах. Обычно используется для полей `timestamp` в временных рядах и агрегациях. |

### Перечисления

Вы также можете создавать перечисления внутри схемы. Перечисления имеют следующий синтаксис:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Как только перечисление определено в схеме, вы можете использовать строковое представление значения перечисления для установки поля перечисления в объекте. Например, вы можете установить `tokenStatus` в значение `SecondOwner`, сначала определив ваш объект, а затем установив поле с помощью `entity.tokenStatus = "SecondOwner"`. Пример ниже демонстрирует, как будет выглядеть объект Token с полем перечисления:

Более подробную информацию о написании перечислений можно найти в [документации по GraphQL](https://graphql.org/learn/schema/).

### Связи объектов

Объект может иметь связь с одним или несколькими другими объектами в Вашей схеме. Эти связи могут быть использованы в Ваших запросах. Связи в The Graph являются однонаправленными. Можно смоделировать двунаправленные связи, определив однонаправленную связь на любом "конце" связи.

Связи определяются для объектов точно так же, как и для любого другого поля, за исключением того, что в качестве типа указывается тип другого объекта.

#### Связи "Один к одному"

Определите тип объекта `Transaction` с необязательной связью "один к одному" с типом объекта `TransactionReceipt`:

```graphql
type Transaction @entity(immutable: true) {
  id: Bytes!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity(immutable: true) {
  id: Bytes!
  transaction: Transaction
}
```

#### Связи "Один ко многим"

Определите тип объекта `TokenBalance` с обязательной связью "один ко многим" с типом объекта `Token`:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

### Обратные запросы

Обратные поисковые запросы можно определить в объекте с помощью поля `@derivedFrom`. Это создает виртуальное поле в объекте, которое может быть запрашиваемо, но не может быть установлено вручную через API отображений. Вместо этого оно вычисляется на основе связи, определенной в другом объекте. Для таких отношений редко имеет смысл хранить обе стороны связи, и как производительность индексирования, так и производительность запросов будут лучше, если хранится только одна сторона связи, а другая извлекается.

Для отношений «один ко многим» отношение всегда должно храниться на стороне «один», а сторона «многие» должна быть выведена. Хранение отношений таким образом, а не хранение массива объектов на стороне «многие», приведет к значительному улучшению производительности как при индексировании, так и при запросах к субграфу. В общем, хранение массивов объектов следует избегать, насколько это возможно на практике.

#### Пример

Мы можем сделать балансы для токена доступными из токена, создав поле `tokenBalances`:

```graphql
type Token @entity(immutable: true) {
  id: Bytes!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: Bytes!
  amount: Int!
  token: Token!
}
```

Вот пример того, как написать мэппинг для субграфа с обратными поисковыми запросами:

```typescript
let token = new Token(event.address) // Создание токена
token.save() // tokenBalances определяется автоматически

let tokenBalance = new TokenBalance(event.address)
tokenBalance.amount = BigInt.fromI32(0)
tokenBalance.token = token.id // Ссылка на токен сохраняется здесь
tokenBalance.save()
```

#### Связи "Многие ко многим"

Для связей "многие ко многим", таких, например, как пользователи, каждый из которых может принадлежать к любому числу организаций, наиболее простым, но, как правило, не самым производительным способом моделирования связей является создание массива в каждом из двух задействованных объектов. Если связь симметрична, то необходимо сохранить только одну сторону связи, а другая сторона может быть выведена.

#### Пример

Определите обратный поиск от объекта `User` к объекту `Organization`. В примере ниже это достигается через поиск атрибута `members` внутри объекта `Organization`. В запросах поле `organizations` на объекте `User` будет разрешаться путем поиска всех объектов `Organization`, которые включают идентификатор пользователя.

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [User!]!
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Более эффективный способ хранения этих отношений — это использование таблицы отображений, которая содержит одну запись для каждой пары `User` / `Organization` с такой схемой

```graphql
type Organization @entity {
  id: Bytes!
  name: String!
  members: [UserOrganization!]! @derivedFrom(field: "organization")
}

type User @entity {
  id: Bytes!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: Bytes! # Set to `user.id.concat(organization.id)`
  user: User!
  organization: Organization!
}
```

Этот подход требует, чтобы запросы опускались на один дополнительный уровень для получения, например, сведений об организациях для пользователей:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

Этот более сложный способ хранения отношений многие ко многим приведет к меньшему объему данных, хранимых для субграфа, что, в свою очередь, сделает субграф значительно быстрее как при индексировании, так и при запросах.

### Добавление комментариев к схеме

Согласно спецификации GraphQL, комментарии могут быть добавлены над атрибутами объектов схемы с использованием символа решетки `#`. Это показано в следующем примере:

```graphql
type MyFirstEntity @entity {
  #уникальный идентификатор и первичный ключ объекта
  id: Bytes!
  address: Bytes!
}
```

## Определение полей полнотекстового поиска

Полнотекстовые поисковые запросы фильтруют и ранжируют объекты на основе введенных данных текстового запроса. Полнотекстовые запросы способны возвращать совпадения по схожим словам путем обработки текста запроса в виде строк перед сравнением с индексированными текстовыми данными.

Определение полнотекстового запроса включает в себя название запроса, словарь языка, используемый для обработки текстовых полей, алгоритм ранжирования, используемый для упорядочивания результатов, и поля, включенные в поиск. Каждый полнотекстовый запрос может охватывать несколько полей, но все включенные поля должны относиться к одному типу объекта.

Чтобы добавить полнотекстовый запрос, включите тип `_Schema_` с директивой `fulltext` в схему GraphQL.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: Bytes!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

Пример поля `bandSearch` может быть использован в запросах для фильтрации объектов `Band` на основе текстовых документов в полях `name`, `description` и `bio`. Перейдите к [GraphQL API - Запросы](/subgraphs/querying/graphql-api/#queries) для описания API полнотекстового поиска и других примеров использования.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Управление функциями](#экспериментальные-функции):** Начиная с `specVersion` `0.0.4` и далее, `fullTextSearch` должен быть объявлен в разделе `features` манифеста субграфа.

## Поддерживаемые языки

Выбор другого языка окажет решающее, хотя иногда и неуловимое влияние на API полнотекстового поиска. Поля, охватываемые полем полнотекстового запроса, рассматриваются в контексте выбранного языка, поэтому лексемы, полученные в результате анализа и поисковых запросов, варьируются от языка к языку. Например: при использовании поддерживаемого турецкого словаря "token" переводится как "toke", в то время как, конечно, словарь английского языка переводит его в "token".

Поддерживаемые языковые словари:

| Код     | Словарь       |
| ------- | ------------- |
| простой | Общий         |
| da      | Датский       |
| nl      | Голландский   |
| en      | Английский    |
| fi      | Финский       |
| fr      | Французский   |
| de      | Немецкий      |
| hu      | Венгерский    |
| it      | Итальянский   |
| no      | Норвежский    |
| pt      | Португальский |
| ro      | Румынский     |
| ru      | Русский       |
| es      | Испанский     |
| sv      | Шведский      |
| tr      | Турецкий      |

### Алгоритмы ранжирования

Поддерживаемые алгоритмы для упорядочивания результатов:

| Алгоритм      | Описание                                                                                       |
| ------------- | ---------------------------------------------------------------------------------------------- |
| rank          | Используйте качество соответствия (0-1) полнотекстового запроса, чтобы упорядочить результаты. |
| proximityRank | Похоже на рейтинг, но также учитывает близость совпадений.                                     |
