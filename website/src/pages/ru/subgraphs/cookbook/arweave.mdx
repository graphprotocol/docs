---
title: Создание Субграфов на Arweave
---

> Arweave support in Graph Node and on Subgraph Studio is in beta: please reach us on [Discord](https://discord.gg/graphprotocol) with any questions about building Arweave Subgraphs!

Из этого руководства Вы узнаете, как создавать и развертывать субграфы для индексации блокчейна Arweave.

## Что такое Arweave?

Протокол Arweave позволяет разработчикам хранить данные на постоянной основе, и в этом основное различие между Arweave и IPFS, поскольку в IPFS отсутствует функция постоянства, а файлы, хранящиеся в Arweave, не могут быть изменены или удалены.

Arweave уже создала множество библиотек для интеграции протокола на нескольких различных языках программирования. С дополнительной информацией Вы можете ознакомиться:

- [Arwiki](https://arwiki.wiki/#/en/main)
- [Ресурсы Arweave](https://www.arweave.org/build)

## Что такое субграфы Arweave?

The Graph позволяет создавать собственные открытые API, называемые "Субграфами". Субграфы используются для указания индексаторам (операторам серверов), какие данные индексировать на блокчейне и сохранять на их серверах, чтобы Вы могли запрашивать эти данные в любое время используя [GraphQL](https://graphql.org/).

[Graph Node](https://github.com/graphprotocol/graph-node) теперь может индексировать данные на протоколе Arweave. Текущая интеграция индексирует только Arweave как блокчейн (блоки и транзакции), она еще не индексирует сохраненные файлы.

## Построение Субграфа на Arweave

Чтобы иметь возможность создавать и развертывать Субграфы на Arweave, Вам понадобятся два пакета:

1. `@graphprotocol/graph-cli` above version 0.30.2 - This is a command-line tool for building and deploying Subgraphs. [Click here](https://www.npmjs.com/package/@graphprotocol/graph-cli) to download using `npm`.
2. `@graphprotocol/graph-ts` above version 0.27.0 - This is library of Subgraph-specific types. [Click here](https://www.npmjs.com/package/@graphprotocol/graph-ts) to download using `npm`.

## Составляющие Субграфов

There are three components of a Subgraph:

### 1. Манифест - `subgraph.yaml`

Определяет источники данных, представляющие интерес, и то, как они должны обрабатываться. Arweave - это новый вид источника данных.

### 2. Схема - `schema.graphql`

Здесь Вы определяете, какие данные хотите иметь возможность запрашивать после индексации своего субграфа с помощью GraphQL. На самом деле это похоже на модель для API, где модель определяет структуру тела запроса.

The requirements for Arweave Subgraphs are covered by the [existing documentation](/developing/creating-a-subgraph/#the-graphql-schema).

### 3. Мэппинги на AssemblyScript - `mapping.ts`

Это логика, которая определяет, как данные должны извлекаться и храниться, когда кто-то взаимодействует с источниками данных, которые Вы отслеживаете. Данные переводятся и сохраняются в соответствии с указанной Вами схемой.

During Subgraph development there are two key commands:

```
$ graph codegen # generates types from the schema file identified in the manifest
$ graph build # generates Web Assembly from the AssemblyScript files, and prepares all the Subgraph files in a /build folder
```

## Определение манифеста субграфа

The Subgraph manifest `subgraph.yaml` identifies the data sources for the Subgraph, the triggers of interest, and the functions that should be run in response to those triggers. See below for an example Subgraph manifest for an Arweave Subgraph:

```yaml
specVersion: 1.3.0
description: Arweave Blocks Indexing
schema:
  file: ./schema.graphql # link to the schema file
dataSources:
  - kind: arweave
    name: arweave-blocks
    network: arweave-mainnet # The Graph only supports Arweave Mainnet
    source:
      owner: 'ID-OF-AN-OWNER' # The public key of an Arweave wallet
      startBlock: 0 # set this to 0 to start indexing from chain genesis
    mapping:
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      file: ./src/blocks.ts # link to the file with the Assemblyscript mappings
      entities:
        - Block
        - Transaction
      blockHandlers:
        - handler: handleBlock # the function name in the mapping file
      transactionHandlers:
        - handler: handleTx # the function name in the mapping file
```

- Arweave Subgraphs introduce a new kind of data source (`arweave`)
- Сеть должна соответствовать сети на размещенной Graph Node. В Subgraph Studio мейннет Arweave обозначается как `arweave-mainnet`
- Источники данных Arweave содержат необязательное поле source.owner, которое является открытым ключом кошелька Arweave

Источники данных Arweave поддерживают два типа обработчиков:

- `blockHandlers` — выполняется при каждом новом блоке Arweave. source.owner не требуется.
- `transactionHandlers` — выполняется при каждой транзакции, где `source.owner` является владельцем источника данных. На данный момент для `transactionHandlers` требуется указать владельца. Если пользователи хотят обрабатывать все транзакции, они должны указать `""` в качестве `source.owner`

> Source.owner может быть адресом владельца или его Публичным ключом.
>
> Транзакции являются строительными блоками Arweave permaweb, и они представляют собой объекты, созданные конечными пользователями.
>
> Примечание: транзакции [Irys (ранее Bundlr)](https://irys.xyz/) пока не поддерживаются.

## Определение схемы

Schema definition describes the structure of the resulting Subgraph database and the relationships between entities. This is agnostic of the original data source. There are more details on the Subgraph schema definition [here](/developing/creating-a-subgraph/#the-graphql-schema).

## Мэппинги AssemblyScript

Обработчики для обработки событий написаны на [AssemblyScript](https://www.assemblyscript.org/).

Индексирование Arweave вводит специфичные для Arweave типы данных в [API AssemblyScript](https://thegraph. com/docs/using-graph-ts).

```tsx
class Block {
  timestamp: u64
  lastRetarget: u64
  height: u64
  indepHash: Bytes
  nonce: Bytes
  previousBlock: Bytes
  diff: Bytes
  hash: Bytes
  txRoot: Bytes
  txs: Bytes[]
  walletList: Bytes
  rewardAddr: Bytes
  tags: Tag[]
  rewardPool: Bytes
  weaveSize: Bytes
  blockSize: Bytes
  cumulativeDiff: Bytes
  hashListMerkle: Bytes
  poa: ProofOfAccess
}

class Transaction {
  format: u32
  id: Bytes
  lastTx: Bytes
  owner: Bytes
  tags: Tag[]
  target: Bytes
  quantity: Bytes
  data: Bytes
  dataSize: Bytes
  dataRoot: Bytes
  signature: Bytes
  reward: Bytes
}
```

Обработчики блоков получают `Block`, в то время как обработчики транзакций получают `Transaction`.

Написание мэппингов для субграфа Arweave очень похоже на написание мэппингов для субграфа Ethereum. Для получения дополнительной информации нажмите [сюда](/developing/creating-a-subgraph/#writing-mappings).

## Развертывание субграфа Arweave в Subgraph Studio

Once your Subgraph has been created on your Subgraph Studio dashboard, you can deploy by using the `graph deploy` CLI command.

```bash
graph deploy --access-token <your-access-token>
```

## Запрос субграфа Arweave

The GraphQL endpoint for Arweave Subgraphs is determined by the schema definition, with the existing API interface. Please visit the [GraphQL API documentation](/subgraphs/querying/graphql-api/) for more information.

## Примеры субграфов

Here is an example Subgraph for reference:

- [Example Subgraph for Arweave](https://github.com/graphprotocol/graph-tooling/tree/main/examples/arweave-blocks-transactions)

## Часто задаваемые вопросы

### Can a Subgraph index Arweave and other chains?

No, a Subgraph can only support data sources from one chain/network.

### Могу ли я проиндексировать сохраненные файлы в Arweave?

В настоящее время The Graph индексирует Arweave только как блокчейн (его блоки и транзакции).

### Can I identify Bundlr bundles in my Subgraph?

В настоящее время это не поддерживается.

### Как я могу отфильтровать транзакции по определенному аккаунту?

Source.owner может быть открытым ключом пользователя или адресом учетной записи.

### Каков текущий формат шифрования?

Data is generally passed into the mappings as Bytes, which if stored directly is returned in the Subgraph in a `hex` format (ex. block and transaction hashes). You may want to convert to a `base64` or `base64 URL`-safe format in your mappings, in order to match what is displayed in block explorers like [Arweave Explorer](https://viewblock.io/arweave/).

Следующая вспомогательная функция `bytesToBase64(bytes: Uint8Array, urlSafe: boolean): string` может быть использована и будет добавлена в `graph-ts`:

```
const base64Alphabet = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64UrlAlphabet = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
];

function bytesToBase64(bytes: Uint8Array, urlSafe: boolean): string {
	let alphabet = urlSafe? base64UrlAlphabet : base64Alphabet;

	let result = '', i: i32, l = bytes.length;
	for (i = 2; i < l; i += 3) {
		result += alphabet[bytes[i - 2] >> 2];
		result += alphabet[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += alphabet[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
		result += alphabet[bytes[i] & 0x3F];
	}
	if (i === l + 1) { // 1 octet yet to write
		result += alphabet[bytes[i - 2] >> 2];
		result += alphabet[(bytes[i - 2] & 0x03) << 4];
		if (!urlSafe) {
			result += "==";
		}
	}
	if (!urlSafe && i === l) { // 2 octets yet to write
		result += alphabet[bytes[i - 2] >> 2];
		result += alphabet[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += alphabet[(bytes[i - 1] & 0x0F) << 2];
		if (!urlSafe) {
			result += "=";
		}
	}
	return result;
}
```
