---
title: Лучшая практика для субграфов 2 — улучшение индексирования и отклика на запросы с помощью @derivedFrom
sidebarTitle: 'Subgraph Best Practice 2: Arrays with @derivedFrom'
---

## Краткое содержание

Массивы в Вашей схеме могут значительно замедлить работу субграфа, когда их размер превышает тысячи элементов. Если возможно, следует использовать директиву @derivedFrom при работе с массивами, так как она предотвращает образование больших массивов, упрощает обработчики и уменьшает размер отдельных элементов, что значительно улучшает скорость индексирования и производительность запросов.

## Как использовать директиву @derivedFrom

Вам нужно просто добавить директиву @derivedFrom после массива в своей схеме. Например:

```graphql
comments: [Comment!]! @derivedFrom(field: "post")
```

@derivedFrom создает эффективные отношения "один ко многим", позволяя объекту динамически ассоциироваться с несколькими связанными объектами на основе поля в связанном объекте. Этот подход исключает необходимость хранения продублированных данных с обеих сторон отношений, что делает субграф более эффективным.

### Пример использования @derivedFrom

Пример динамически растущего массива — это платформа для блогов, где у "Поста" может быть много "Комментариев".

Начнем с наших двух объектов: `Post` и `Comment`

Без оптимизации Вы могли бы реализовать это следующим образом, используя массив:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]!
}

type Comment @entity {
  id: Bytes!
  content: String!
}
```

Подобные массивы будут эффективно хранить дополнительные данные о Comments на стороне отношения Post.

Вот как будет выглядеть оптимизированная версия с использованием @derivedFrom:

```graphql
type Post @entity {
  id: Bytes!
  title: String!
  content: String!
  comments: [Comment!]! @derivedFrom(field: "post")
}

type Comment @entity {
  id: Bytes!
  content: String!
  post: Post!
}
```

Именно при добавлении директивы `@derivedFrom`, эта схема будет хранить "Comments" только на стороне отношения "Comments", а не на стороне отношения "Post". Массивы хранятся в отдельных строках, что позволяет им значительно расширяться. Это может привести к очень большим объёмам, поскольку их рост не ограничен.

Это не только сделает наш субграф более эффективным, но и откроет три возможности:

1. Мы можем запрашивать `Post` и видеть все его комментарии.

2. Мы можем выполнить обратный поиск и запросить любой `Comment`, чтобы увидеть, от какого поста он пришел.

3. Мы можем использовать [Загрузчики производных полей](/subgraphs/developing/creating/graph-ts/api/#looking-up-derived-entities), чтобы получить возможность напрямую обращаться и манипулировать данными из виртуальных отношений в наших мэппингах субграфа.

## Заключение

Используйте директиву `@derivedFrom` в субграфах для эффективного управления динамически растущими массивами, улучшая эффективность индексирования и извлечения данных.

Для более подробного объяснения стратегий, которые помогут избежать использования больших массивов, ознакомьтесь с блогом Кевина Джонса: [Лучшие практики разработки субграфов: как избежать больших массивов](https://thegraph.com/blog/improve-subgraph-performance-avoiding-large-arrays/).

## Лучшие практики для субграфов 1-6

1. [Увеличение скорости запросов с помощью обрезки субграфов](/subgraphs/best-practices/pruning/)

2. [Улучшение индексирования и отклика запросов с использованием @derivedFrom](/subgraphs/best-practices/derivedfrom/)

3. [Улучшение индексирования и производительности запросов с использованием неизменяемых объектов и байтов в качестве идентификаторов](/subgraphs/best-practices/immutable-entities-bytes-as-ids/)

4. [Увеличение скорости индексирования путем избегания `eth_calls`](/subgraphs/best-practices/avoid-eth-calls/)

5. [Упрощение и оптимизация с помощью временных рядов и агрегаций](/subgraphs/best-practices/timeseries/)

6. [Использование переноса (графтинга) для быстрого развертывания исправлений](/subgraphs/best-practices/grafting-hotfix/)
