---
title: Обзор индексирования
sidebarTitle: Обзор
---

Индексаторы — это операторы нод в сети The Graph, которые стейкают токены Graph (GRT) для предоставления услуг индексирования и обработки запросов. Индексаторы получают оплату за запросы и вознаграждение за свои услуги индексирования. Они также получают комиссию за запросы, которая возвращаются в соответствии с экспоненциальной функцией возврата.

GRT, застейканные в протоколе, замораживаются на определённый период и могут быть уменьшены, если Индексаторы действуют недобросовестно и предоставляют приложениям неверные данные или неправильно выполняют индексирование. Кроме того, Индексаторы получают вознаграждения за стейк, который им передают Делегаторы, помогая тем самым поддерживать работу сети.

Индексаторы выбирают субграфы для индексирования на основе сигнала курирования субграфа, где Кураторы стейкают GRT, чтобы указать, какие субграфы являются качественными и должны быть в приоритете. Потребители (например, приложения) также могут задавать параметры для выбора Индексаторов, обрабатывающих запросы к их субграфам, и устанавливать предпочтения по стоимости запросов.

## Часто задаваемые вопросы

### Какова минимальная величина стейка, требуемая для того, чтобы быть Индексатором в сети?

Минимальный стейк для Индексатора в настоящее время составляет 100 000 GRT.

### Какие источники дохода у Индексатора?

**Возмещение комиссий за запросы** – выплаты за обработку запросов в сети. Эти платежи проходят через государственные каналы между Индексатором и шлюзом. Каждый запрос от шлюза содержит оплату, а соответствующий ответ — доказательство достоверности результата запроса.

**Награды за индексирование** – формируются за счет ежегодной инфляции протокола в размере 3% и распределяются между Индексаторами, которые индексируют развернутые субграфы для сети.

### Как распределяются награды за индексирование?

Награды за индексирование поступают из инфляции протокола, установленной на уровне 3% в год. Они распределяются между субграфами пропорционально общему сигналу кураторства на каждом из них, а затем пропорционально между Индексаторами в зависимости от их застейканного объема на данном субграфе. **Чтобы получить награду, распределение должно быть закрыто с действительным доказательством индексирования (POI), соответствующим стандартам, установленным арбитражной хартией.**

Сообщество создало множество инструментов для расчета наград; их собрание можно найти в [коллекции Гайдов Сообщества](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). Также актуальный список инструментов доступен в каналах #Delegators и #Indexers на [сервере Discord](https://discord.gg/graphprotocol). Здесь мы приводим ссылку на [рекомендованный оптимизатор распределения](https://github.com/graphprotocol/allocation-optimizer), интегрированный с программным стеком Индексатора.

### Что такое доказательство индексирования (POI)?

POI (доказательство индексирования) используется в сети для подтверждения того, что Индексатор действительно индексирует назначенные ему субграфы. При закрытии распределения необходимо предоставить POI для первого блока текущей эпохи, чтобы оно было квалифицировано для получения наград за индексирование. POI для блока представляет собой хеш всех транзакций хранилища объектов для конкретного развертывания субграфа вплоть до этого блока включительно.

### Когда распределяются награды за индексирование?

Аллокации постоянно накапливают награды, пока они активны и распределены в течение 28 эпох. Награды собираются Индексаторами и распределяются при закрытии их аллокаций. Это может происходить вручную, когда Индексатор сам решает их закрыть, или автоматически по истечении 28 эпох. Если после 28 эпох аллокацию закрывает Делегатор, награды не выплачиваются. В настоящее время одна эпоха длится примерно 24 часа.

### Можно ли отслеживать ожидаемые награды за индексирование?

Контракт RewardsManager имеет функцию только для чтения [getRewards](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/rewards/RewardsManager.sol#L316), которая позволяет проверить ожидаемые награды для конкретной аллокации.

Многие созданные сообществом панели отображают ожидаемые награды, и их можно легко проверить вручную, следуя этим шагам:

1. Выполните запрос к [основному субграфу](https://thegraph.com/explorer/subgraphs/9Co7EQe5PgW3ugCUJrJgRv4u9zdEuDJf8NvMWftNsBH8?view=Query&chain=arbitrum-one), чтобы получить идентификаторы всех активных аллокаций:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Используйте Etherscan для вызова `getRewards()`:

- Перейдите на [интерфейс Etherscan к контракту Rewards](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract).
- Чтобы вызвать `getRewards()`:
  - Разверните выпадающее меню **9. getRewards**.
  - Введите **allocationID** в поле ввода.
  - Нажмите кнопку **Query**.

### Что такое споры и где их можно посмотреть?

Запросы и аллокации Индексатора могут быть оспорены в The Graph в течение периода спора. Период спора варьируется в зависимости от типа спора. Запросы/аттестации имеют окно спора в 7 эпох, тогда как аллокации – 56 эпох. После истечения этих периодов споры против аллокаций или запросов больше не могут быть открыты. Когда спор открывается, Fishermen (участники сети, открывающие споры) должны внести депозит минимум 10 000 GRT, который будет заморожен до завершения спора и вынесения решения.

Споры могут иметь **три** возможных исхода, как и депозит Fishermen.

- Если спор отклонен, GRT, внесенные Fishermen в качестве депозита, будут сожжены, а оспариваемый Индексатор не понесет штраф.
- Если спор завершится вничью, депозит Fishermen будет возвращен, а оспариваемый Индексатор не понесет штраф.
- Если спор принят, депозит Fishermen будет возвращен, оспариваемый Индексатор понесет штраф, а Fishermen получит 50% от списанных GRT.

Споры можно просматривать в пользовательском интерфейсе на странице профиля Индексатора во вкладке `Disputes`.

### Что такое возврат комиссии за запросы и когда он распределяется?

Комиссии за запросы собираются шлюзом и распределяются индексаторам в соответствии с экспоненциальной функцией возврата (см. GIP [здесь](https://forum.thegraph.com/t/gip-0051-exponential-query-fee-rebates-for-indexers/4162)). Экспоненциальная функция возврата предлагается как способ гарантировать, что индексаторы добиваются наилучшего результата, добросовестно обслуживая запросы. Она работает, стимулируя Индексаторов выделять крупные объемы стейка (который может быть урезан в случае ошибки при обработке запроса) относительно суммы комиссий за запросы, которые они могут получить.

Как только аллокация закрывается, Индексатор может потребовать возврат комиссии. После запроса возврата, комиссии за запросы распределяются между Индексатором и его Делегаторами в соответствии с процентом комиссии за запросы и экспоненциальной функцией возврата.

### Что такое доля комиссии за запросы и доля вознаграждения за индексирование?

Параметры `queryFeeCut` и `indexingRewardCut` являются параметрами делегирования, которые Индексатор может настроить вместе с `cooldownBlocks`, чтобы контролировать распределение GRT между собой и Делегаторами. Инструкции по настройке параметров делегирования можно найти в последних шагах раздела [Стейкинг в протоколе](/indexing/overview/#stake-in-the-protocol).

- **queryFeeCut** – процент возврата комиссий за запросы, который будет распределяться в пользу Индексатора. Если установлено значение 95%, Индексатор получит 95% заработанных комиссий за запросы при закрытии аллокации, а оставшиеся 5% пойдут Делегаторам.

- **indexingRewardCut** – процент вознаграждений за индексирование, который будет распределяться в пользу Индексатора. Если установлено значение 95%, Индексатор получит 95% вознаграждений за индексирование при закрытии аллокации, а оставшиеся 5% будут распределены между Делегаторами.

### Как Индексаторы узнают, какие Субграфы индексировать?

Индексаторы могут отличаться, применяя продвинутые методы для принятия решений об индексировании Субграфов, но в общем случае они оценивают Субграфы на основе нескольких ключевых метрик:

- **Сигнал кураторства** — пропорция сигнала кураторства сети, применяемого к конкретному субграфу, является хорошим индикатором интереса к этому субграфу, особенно в фазе начальной загрузки, когда объем запросов постепенно увеличивается.

- **Собранные комиссии за запросы** – исторические данные о сумме комиссий за запросы, собранных для конкретного Субграфа, являются хорошим индикатором будущего спроса.

- **Объем стейка** – отслеживание поведения других Индексаторов или анализ доли общего стейка, выделенного на конкретные Субграфы, позволяет Индексатору оценивать предложение для запросов к Субграфам, что помогает выявлять Субграфы, которым сеть доверяет, или те, которые нуждаются в большем количестве ресурсов.

- **Субграфы без наград за индексирование** – некоторые Субграфы не приносят награды за индексирование, главным образом потому, что они используют неподдерживаемые функции, такие как IPFS, или делают запросы к другой сети за пределами основной сети. В интерфейсе будет отображаться сообщение, если Субграф не генерирует награды за индексирование.

### Каковы требования к аппаратному обеспечению?

- **Низкие** – достаточно для начала индексирования нескольких субграфов, но, вероятно, потребуется расширение.
- **Стандартные** – настройка по умолчанию, используется в примерах манифестов развертывания k8s/terraform.
- **Средние** – производительный Индексатор, поддерживающий 100 субграфов и 200–500 запросов в секунду.
- **Высокие** – готов индексировать все используемые субграфы и обрабатывать соответствующий трафик запросов.

| Настройка | Postgres<br />(ЦП) | Postgres<br />(память в ГБ) | Postgres<br />(диск в ТБ) | VMs<br />(ЦП) | VMs<br />(память в ГБ) |
| --- | :-: | :-: | :-: | :-: | :-: |
| Низкая | 4 | 8 | 1 | 4 | 16 |
| Стандартная | 8 | 30 | 1 | 12 | 48 |
| Средняя | 16 | 64 | 2 | 32 | 64 |
| Высокая | 72 | 468 | 3.5 | 48 | 184 |

### Какие основные меры безопасности следует предпринять Индексатору?

- **Кошелек оператора** - настройка кошелька оператора является важной мерой безопасности, поскольку она позволяет Индексатору поддерживать разделение между своими ключами, которые контролируют величину стейка, и теми, которые контролируют ежедневные операции. Инструкции см. в разделе [Стейкинг в протоколе](/indexing/overview/#stake-in-the-protocol).

- ** Firewall** – только сервис Индексатора должен быть доступен публично. Особое внимание следует уделить защите административных портов и доступа к базе данных: JSON-RPC-конечная точка Graph Node (порт по умолчанию: **8030**), конечная точка API управления Индексатором (порт по умолчанию: **18000**) и конечная точка базы данных Postgres (порт по умолчанию: **5432**) **не должны** быть открыты.

## Инфраструктура

В центре инфраструктуры Индексатора находится Graph Node, который отслеживает индексируемые сети, извлекает и загружает данные в соответствии с определением Субграфа и предоставляет их в виде [GraphQL API](/about/#how-the-graph-works). Graph Node должна быть подключена к конечной точке, предоставляющей данные из каждой индексируемой сети, к ноде IPFS для получения данных, к базе данных PostgreSQL для хранения информации, а также к компонентам Индексатора, которые обеспечивают его взаимодействие с сетью.

- **База данных PostgreSQL** – это основное хранилище для Graph Node, где хранятся данные Субграфа. Сервис и агент Индексатора также используют эту базу данных для хранения данных каналов состояния, моделей стоимости, правил индексирования и действий по распределению.

- **Конечная точка данных** – для сетей, совместимых с EVM, Graph Node должна быть подключена к конечной точке, предоставляющей JSON-RPC API, совместимый с EVM. Это может быть как один клиент, так и более сложная конфигурация с балансировкой нагрузки между несколькими клиентами. Важно учитывать, что некоторые Субграфы требуют определённых возможностей клиента, таких как архивный режим и/или API трассировки Parity.

- **IPFS-нода (версия ниже 5)** – метаданные развертывания Субграфа хранятся в сети IPFS. Graph Node в основном обращается к IPFS-ноде во время развертывания Субграфа, чтобы получить манифест Субграфа и все связанные файлы. Индексаторы сети не обязаны размещать свою собственную IPFS-ноду, так как для сети уже развернута IPFS-нода по адресу: [https://ipfs.thegraph.com](https://ipfs.thegraph.com).

- **Сервис Индексатора** – обрабатывает все необходимые внешние коммуникации с сетью. Делится моделями стоимости и статусами индексирования, передаёт запросы от шлюзов в Graph Node и управляет платежами за запросы через каналы состояния со шлюзом.

- **Агент Индексатора** – обеспечивает взаимодействие Индексатора в блокчейне, включая регистрацию в сети, управление развертыванием Субграфов в его Graph Node и управление распределением ресурсов.

- **Сервер метрик Prometheus** – Graph Node и компоненты Индексатора записывают свои метрики на сервер метрик.

Примечание: для поддержки гибкого масштабирования рекомендуется разделять обработку запросов и индексирование между разными наборами нод: нодами запросов и нодами индексирования.

### Обзор портов

> **Важно**: будьте осторожны при открытии портов в публичный доступ – **административные порты** должны быть закрыты. Это касается JSON-RPC Graph Node и управляющих конечных точек Индексатора, описанных ниже.

#### Graph Node

| Порт | Назначение | Маршруты | Аргумент CLI | Переменная среды |
| --- | --- | --- | --- | --- |
| 8000 | GraphQL HTTP-сервер<br />(для запросов к Субграфу) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--http-port | - |
| 8001 | GraphQL WS<br />(для подписок на Субграф) | /subgraphs/id/...<br />/subgraphs/name/.../... | \--ws-port | - |
| 8020 | JSON-RPC<br />(для управления развертываниями) | / | \--admin-port | - |
| 8030 | API статуса индексирования Субграфа | /graphql | \--index-node-port | - |
| 8040 | Метрики Prometheus | /metrics | \--metrics-port | - |

#### Сервис Индексатора

| Порт | Назначение | Маршруты | Аргумент CLI | Переменная среды |
| --- | --- | --- | --- | --- |
| 7600 | GraphQL HTTP-сервер<br />(для платных запросов к Субграфу) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | \--port | `INDEXER_SERVICE_PORT` |
| 7300 | Метрики Prometheus | /metrics | \--metrics-port | - |

#### Агент Индексатора

| Порт | Назначение                  | Маршруты | Аргумент CLI               | Переменная среды                        |
| ---- | --------------------------- | -------- | -------------------------- | --------------------------------------- |
| 8000 | API управления Индексатором | /        | \--indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Настройка серверной инфраструктуры с использованием Terraform в Google Cloud

> Примечание: Индексаторы могут также использовать AWS, Microsoft Azure или Alibaba.

#### Установка необходимых компонентов

- Google Cloud SDK
- Инструмент командной строки Kubectl
- Terraform

#### Создание проекта в Google Cloud

- Клонируйте или перейдите в [репозиторий Индексатора](https://github.com/graphprotocol/indexer).

- Перейдите в каталог `./terraform`, именно здесь должны быть выполнены все команды.

```sh
cd terraform
```

- Аутентифицируйтесь в Google Cloud и создайте новый проект.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Используйте страницу выставления счетов в Google Cloud Console, чтобы включить эту функцию для нового проекта.

- Создайте конфигурацию Google Cloud.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Включите необходимые API Google Cloud.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Создайте сервисный аккаунт.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Получить email учетной записи сервиса из списка
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Включите пиринг между базой данных и кластером Kubernetes, который будет создан на следующем шаге.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Создайте минимальный файл конфигурации Terraform (обновите при необходимости).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database password>"
EOF
```

#### Используйте Terraform для создания инфраструктуры

Прежде чем выполнять какие-либо команды, ознакомьтесь с файлом [variables.tf](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) и создайте файл `terraform.tfvars` в этом каталоге (или измените тот, который мы создали на предыдущем шаге). Для каждой переменной, значение которой вы хотите изменить по умолчанию или которую необходимо настроить, введите соответствующую настройку в `terraform.tfvars`.

- Выполните следующие команды для создания инфраструктуры.

```sh
# Установить необходимые плагины
terraform init

# Просмотреть план создаваемых ресурсов
terraform plan

# Создать ресурсы (может занять до 30 минут)
terraform apply
```

Скачайте учетные данные для нового кластера в файл `~/.kube/config` и установите его как ваш контекст по умолчанию.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Создание компонентов Kubernetes для Индексатора

- Скопируйте директорию `k8s/overlays` в новую директорию `$dir` и измените запись `bases` в файле `$dir/kustomization.yaml`, чтобы она указывала на директорию `k8s/base`.

- Прочитайте все файлы в директории `$dir` и скорректируйте значения в соответствии с комментариями.

Разверните все ресурсы с помощью команды `kubectl apply -k $dir`.

### Graph Node

[Graph Node](https://github.com/graphprotocol/graph-node) — это открытый источник на языке Rust, который отслеживает блокчейн Ethereum для детерминированного обновления хранилища данных, доступного для запросов через GraphQL API. Разработчики используют Субграфы для определения своей схемы и набора мэппингов, чтобы преобразовать информацию, полученную из блокчейна, а сама Graph Node синхронизирует весь блокчейн, отслеживает новые блоки и предоставляет данные через конечную точку GraphQL.

#### Начало работы с исходным кодом

#### Установка необходимых компонентов

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Дополнительные требования для пользователей Ubuntu** - для запуска Graph Node на Ubuntu может потребоваться установить несколько дополнительных пакетов.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Настройка

1. Запустите сервер базы данных PostgreSQL

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Клонируйте репозиторий [Graph Node](https://github.com/graphprotocol/graph-node) и соберите исходный код, выполнив команду `cargo build`.

3. Теперь, когда все зависимости настроены, запустите Graph Node:

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.thegraph.com
```

#### Начало работы с Docker

#### Предварительные требования

- **Нода Ethereum** — по умолчанию, настройка Docker Compose будет использовать основную сетевую ноду: [http://host.docker.internal:8545](http://host.docker.internal:8545) для подключения к ноде Ethereum на вашей хостинговой машине. Вы можете заменить это имя сети и URL, обновив файл `docker-compose.yaml`.

#### Настройка

1. Клонируйте Graph Node и перейдите в директорию Docker:

```sh
git clone https://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Только для пользователей Linux — используйте IP-адрес хоста вместо `host.docker.internal` в файле `docker-compose.yaml`, используя при этом включенный скрипт:

```sh
./setup.sh
```

3. Запустите локальную Graph Node, которая будет подключаться к Вашей конечной точке Ethereum:

```sh
docker-compose up
```

### Компоненты Индексатора

Для успешного участия в сети требуется почти постоянный мониторинг и взаимодействие, поэтому мы разработали набор приложений на TypeScript для упрощения участия Индексаторов в сети. Существует три компонента для Индексаторов:

- **Агент Индексатора** — агент мониторит сеть и инфраструктуру Индексатора, управляет тем, какие развертывания субграфов индексируются и распределяются по чейну, а также сколько ресурсов выделяется на каждый из них.

- **Сервис Индексатора** — единственный компонент, который необходимо открывать для внешнего доступа. Сервис передает запросы субграфов в граф-ноду, управляет каналами состояния для оплаты запросов, а также делится важной информацией для принятия решений с клиентами, такими как шлюзы.

- **CLI Индексатора** — интерфейс командной строки для управления агентом Индексатора. Он позволяет Индексаторам управлять моделями затрат, ручными распределениями, очередью действий и правилами индексирования.

#### Начало работы

Агент Индексатора и сервис Индексатора должны быть размещены рядом с Вашей инфраструктурой Graph Node. Существует множество способов настройки виртуальных исполнимых сред для компонентов Индексатора. Здесь мы объясним, как запустить их на физическом сервере, используя NPM пакеты или исходный код, а также через Kubernetes и Docker на Google Cloud Kubernetes Engine. Если эти примеры настроек не подходят для Вашей инфраструктуры, скорее всего, существует сообщество, которое может предоставить руководство. Присоединяйтесь к нам в [Discord](https://discord.gg/graphprotocol)! Не забудьте [застейкать GRT](https://thegraph.com/docs/indexing/overview/#stake-in-the-protocol) перед запуском компонентов Индексатора!

#### Из пакетов NPM

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# CLI Индексатора является плагином для Graph CLI, поэтому необходимо установить оба пакета:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Сервис Индексатора
graph-indexer-service start ...

# Агент Индексатора
graph-indexer-agent start ...

#CLI Индексатора
#Проброс порта Вашего pod-агента, если используется Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### Из исходного кода

```sh
# Из корневого каталога репозитория
yarn

# Сервис Индексатора
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Агент Индексатора
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# CLI Индексатора
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Использование docker

- Извлеките образы из реестра

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

Или создайте образы локально из исходного кода

```sh
# Сервис Индексатора
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Агент Индексатора
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Запустите компоненты

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

**ПРИМЕЧАНИЕ**: после запуска контейнеров сервис Индексатора должен быть доступен по адресу [http://localhost:7600](http://localhost:7600), а агент Индексатора должен предоставлять API управления Индексатором по адресу [http://localhost:18000/](http://localhost:18000/).

#### Использование K8s и Terraform

Посмотрите раздел [Настройка серверной инфраструктуры с использованием Terraform в Google Cloud](/indexing/overview/#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Применение

> **ПРИМЕЧАНИЕ**: все переменные конфигурации времени выполнения могут быть применены либо в качестве параметров команды при запуске, либо с использованием переменных среды в формате `COMPONENT_NAME_VARIABLE_NAME` (например, `INDEXER_AGENT_ETHEREUM`).

#### Агент Индексатора

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  --allocation-management auto \
  | pino-pretty
```

#### Сервис Индексатора

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint http://query-node-0:8000/subgraphs/id/QmUzRg2HHMpbgf6Q4VHKNDbtBEJnyp5JWCh2gUX9AV6jXv \
  | pino-pretty
```

#### CLI Индексатора

CLI Индексатора — это плагин для [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli), доступный в терминале через команду `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Управление Индексатором с помощью CLI Индексатора

Предлагаемым инструментом для взаимодействия с **API управления Индексатором** является **CLI Индексатора**, расширение для **Graph CLI**. Для того чтобы Индексатор мог автономно взаимодействовать с сетью от его имени, ему нужно предоставить входные данные. Механизм, который определяет поведение Индексатора, включает режимы **управления распределениями** и **правила индексирования**. В режиме **автоматического управления** Индексатор может использовать **правила индексирования**, чтобы применить свою стратегию для выбора субграфов, которые он будет индексировать и обслуживать запросы. Эти правила управляются через GraphQL API, которое предоставляется агентом и называется **API управления Индексатором**. В режиме **ручного управления** Индексатор может создавать действия для выделений, используя **очередь действий** и явно утверждать их перед выполнением. В режиме **контроля** **правила индексирования** используются для пополнения **очереди действий**, и для выполнения этих действий также требуется явное одобрение. Эти механизмы позволяют Индексатору выбирать стратегию для индексирования и обеспечения запросов в сети, а также контролировать их выполнение с различными уровнями автоматизации.

#### Применение

**CLI Индексатора** подключается к агенту Индексатора, обычно через порт-прокси, поэтому CLI не обязательно должен работать на том же сервере или кластере. Чтобы помочь вам начать работу и предоставить некоторый контекст, CLI будет кратко описан здесь.

- `graph indexer connect <url>` - подключение к API управления Индексатором. Обычно соединение с сервером устанавливается через порт-прокси, так что CLI можно легко использовать удаленно. (Пример: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id> [<key1> ...]` - получить одно или несколько правил индексирования, используя `all` в качестве `<deployment-id>`, чтобы получить все правила, или `global`, чтобы получить глобальные настройки по умолчанию. Дополнительный аргумент `--merged` можно использовать, чтобы указать, что правила, специфичные для развертывания, будут объединены с глобальным правилом. Именно так они применяются в агенте Индексатора.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - установить одно или несколько правил индексирования.

- `graph indexer rules start [options] <deployment-id>` - запустить индексирование развертывания субграфа, если оно доступно, и установить для него `decisionBasis` в значение `always`, чтобы агент Индексатора всегда выбирал его для индексирования. Если глобальное правило установлено на `always`, то все доступные субграфы в сети будут индексироваться.

- `graph indexer rules stop [options] <deployment-id>` - остановить индексирование развертывания и установить для него `decisionBasis` в значение `never`, чтобы агент Индексатора пропускал это развертывание при принятии решения о том, какие развертывания индексировать.

- `graph indexer rules maybe [options] <deployment-id>` — установить `decisionBasis` для развертывания в значение `rules`, чтобы агент Индексатора использовал правила индексирования для принятия решения о том, индексировать ли это развертывание.

- `graph indexer actions get [options] <action-id>` — получить одно или несколько действий, используя `all`, или оставить `action-id` пустым, чтобы получить все действия. Дополнительный аргумент `--status` можно использовать для вывода всех действий с определенным статусом.

- `graph indexer action queue allocate <deployment-id> <allocation-amount>` — добавить действие на распределение в очередь

- `graph indexer action queue reallocate <deployment-id> <allocation-id> <allocationAmount>` — добавить действие на перераспределение в виде очереди

- `graph indexer action queue unallocate <deployment-id> <allocation-id>` — добавить действие на отмену распределения в виде очереди

- `graph indexer actions cancel [<action-id> ...]` - отменить все действия в очереди, если идентификатор не указан, в противном случае отменить массив идентификаторов, разделенных пробелом

- `graph indexer actions approve [<action-id> ...]` - одобрить несколько действий для выполнения

- `graph indexer actions execute approve` - принудительно выполнить одобренные действия немедленно

Все команды, которые выводят правила, могут выбирать между поддерживаемыми форматами вывода (`table`, `yaml` и `json`) с помощью аргумента `-output`.

#### Правила индексирования

Правила индексирования могут быть применены как глобальные настройки по умолчанию или для конкретных развертываний субграфов с использованием их идентификаторов. Поля `deployment` и `decisionBasis` являются обязательными, в то время как все остальные поля — опциональными. Когда правило индексирования имеет значение `rules` в поле `decisionBasis`, агент Индексатора будет сравнивать ненулевые пороговые значения этого правила с значениями, полученными из сети для соответствующего развертывания. Если развертывание субграфа имеет значения, превышающие (или ниже) любой из пороговых величин, оно будет выбрано для индексирования.

Например, если глобальное правило имеет `minStake` равное **5** (GRT), любое развертывание субграфа, на которое выделено более 5 (GRT) стейка, будет проиндексировано. Пороговые правила включают `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake` и `minAverageQueryFees`.

Модель данных:

```graphql
type IndexingRule {
    identifier: string
    identifierType: IdentifierType
    decisionBasis: IndexingDecisionBasis!
    allocationAmount: number | null
    allocationLifetime: number | null
    autoRenewal: boolean
    parallelAllocations: number | null
    maxAllocationPercentage: number | null
    minSignal: string | null
    maxSignal: string | null
    minStake: string | null
    minAverageQueryFees: string | null
    custom: string | null
    requireSupported: boolean | null
  }

IdentifierType {
  deployment
  subgraph
  group
}

IndexingDecisionBasis {
  rules
  never
  always
  offchain
}
```

Пример применения правила индексирования:

```
graph indexer rules offchain QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules set QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK decisionBasis always allocationAmount 123321 allocationLifetime 14 autoRenewal false requireSupported false

graph indexer rules stop QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK

graph indexer rules delete QmZfeJYR86UARzp9HiXbURWunYgC9ywvPvoePNbuaATrEK
```

#### Очередь действий CLI

`indexer-cli` предоставляет модуль `actions` для ручной работы с очередью действий. Он использует **Graphql API**, размещенный на сервере управления Индексатором, для взаимодействия с очередью действий.

Рабочий процесс выполнения действий будет извлекать элементы из очереди для выполнения только в том случае, если у них статус `ActionStatus = approved`. В рекомендованном процессе действия добавляются в очередь с состоянием `ActionStatus = queued`, и затем они должны быть утверждены, чтобы быть выполненными на чейне. Общий процесс будет выглядеть следующим образом:

- Действие добавляется в очередь сторонним инструментом оптимизации или пользователем indexer-cli
- Индексатор может использовать `indexer-cli` для просмотра всех действий в очереди
- Индексатор (или другое программное обеспечение) может одобрять или отменять действия в очереди с помощью `indexer-cli`. Команды одобрения и отмены принимают массив идентификаторов действий в качестве входных данных.
- Исполнитель регулярно опрашивает очередь на наличие одобренных действий. Он извлекает одобренные действия из очереди, пытается выполнить их и обновляет значения в базе данных в зависимости от результата выполнения, присваивая статус `success` или `failed`.
- Если действие выполнено успешно, исполнитель убедится, что существует правило индексирования, которое указывает агенту, как управлять выделением ресурсов в дальнейшем. Это особенно полезно, когда выполняются ручные действия, в то время как агент находится в режиме `auto` или `oversight`.
- Индексатор может отслеживать очередь действий, чтобы увидеть историю выполнения действий и, если необходимо, повторно одобрить и обновить элементы действий, если они не были выполнены. Очередь действий предоставляет историю всех действий, которые были добавлены в очередь и выполнены.

Модель данных:

```graphql
Type ActionInput {
    status: ActionStatus
    type: ActionType
    deploymentID: string | null
    allocationID: string | null
    amount: string | null
    poi: string | null
    force: boolean | null
    source: string
    reason: string | null
    priority: number | null
}

ActionStatus {
  queued
  approved
  pending
  success
  failed
  canceled
}

ActionType {
  allocate
  unallocate
  reallocate
  collect
}
```

Пример использования из исходного кода:

```bash
graph indexer actions get all

graph indexer actions get --status queued

graph indexer actions queue allocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 5000

graph indexer actions queue reallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae5 55000

graph indexer actions queue unallocate QmeqJ6hsdyk9dVbo1tvRgAxWrVS3rkERiEMsxzPShKLco6 0x4a58d33e27d3acbaecc92c15101fbc82f47c2ae

graph indexer actions cancel

graph indexer actions approve 1 3 5

graph indexer actions execute approve
```

Обратите внимание, что поддерживаемые типы действий для управления аллокацией имеют различные требования к входным данным:

- `Allocate` - выделение стейка для конкретного развертывания субграфа

  - необходимые параметры действия:
    - deploymentID
    - amount

- `Unallocate` — закрыть аллокацию, освободив стейк для перераспределения в другое место

  - необходимые параметры действия:
    - allocationID
    - deploymentID
  - необязательные параметры действия:
    - poi
    - force (принудительно использует указанный POI, даже если он не совпадает с тем, что предоставляет graph-node)

- `Reallocate` - атомарно закрывает распределение и открывает новое распределение для того же развертывания субграфа

  - необходимые параметры действия:
    - allocationID
    - deploymentID
    - amount
  - необязательные параметры действия:
    - poi
    - force (принудительно использует указанный POI, даже если он не совпадает с тем, что предоставляет graph-node)

#### Модели стоимости

Модели стоимости обеспечивают динамическое ценообразование для запросов на основе рыночных условий и атрибутов запроса. Сервис Индексатора делится моделью стоимости с шлюзами для каждого субграфа, на который они планируют отвечать. Шлюзы, в свою очередь, используют модель стоимости для принятия решений о выборе Индексатора для каждого запроса и для ведения переговоров о плате с выбранными Индексаторами.

#### Agora

Язык Agora предоставляет гибкий формат для объявления моделей стоимости запросов. Модель стоимости Agora — это последовательность операторов, которые выполняются по порядку для каждого верхнего уровня запроса в GraphQL запросе. Для каждого верхнего уровня запроса первое условие, которое совпадает с ним, определяет цену для этого запроса.

Заявление состоит из предиката, который используется для сопоставления запросов GraphQL, и выражения стоимости, которое при вычислении выводит стоимость в десятичных долях GRT. Значения, находящиеся в позиции именованных аргументов запроса, могут быть захвачены в предикате и использованы в выражении. Глобальные переменные также могут быть установлены и подставлены в качестве заполнителей в выражении.

Пример модели стоимости:

```
# Это выражение захватывает значение skip,
# использует логическое выражение в предикате для соответствия конкретным запросам, использующим `skip`,
# и выражение для вычисления стоимости на основе значения `skip` и глобальной переменной SYSTEM_LOAD
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# Этот по умолчанию шаблон будет соответствовать любому выражению GraphQL.
# Он использует глобальную переменную, подставленную в выражение для вычисления стоимости
default => 0.1 * $SYSTEM_LOAD;
```

Пример вычисления запросов с использованием вышеуказанной модели:

| Запрос                                                                       | Цена    |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#125; tokens &#123; symbol &#125; &#125; | 0.6 GRT |

#### Применение модели стоимости

Модели стоимости применяются через CLI Индексатора, который передает их в API управления Индексатором для хранения в базе данных. После этого Индексатор-сервис будет получать эти модели стоимости и передавать их шлюзам, когда те запрашивают их.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Взаимодействие с сетью

### Стейкинг в протоколе

Первые шаги для участия в сети в качестве Индексатора заключаются в утверждении протокола, ставке средств и (по желанию) настройке адреса оператора для повседневных взаимодействий с протоколом.

> Примечание: В целях выполнения этих инструкций будет использоваться Remix для взаимодействия с контрактом, но Вы можете использовать любой инструмент по своему выбору (например, [OneClickDapp](https://oneclickdapp.com/), [ABItopic](https://abitopic.io/) и [MyCrypto](https://www.mycrypto.com/account) — несколько известных инструментов).

После того как Индексатор застейкает GRT в протокол, компоненты Индексатора могут быть запущены и начать взаимодействие с сетью.

#### Подтверждение токенов

1. Откройте [приложение Remix](https://remix.ethereum.org/) в браузере

2. В `File Explorer` создайте файл с именем **GraphToken.abi** с [токеном ABI](https://raw.githubusercontent.com/graphprotocol /contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. С выбранным и открытым в редакторе файлом `GraphToken.abi`, перейдите в раздел `Deploy and run transactions` в интерфейсе Remix.

4. В разделе Среды выберите `Injected Web3`, а в разделе `Account` выберите адрес своего Индексатора.

5. Установите адрес контракта GraphToken — вставьте адрес контракта GraphToken (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) рядом с полем `At Address` и нажмите кнопку `At address`, чтобы применить.

6. Вызовите функцию `approve(spender, amount)`, чтобы одобрить контракт стейкинга. В поле `spender` укажите адрес контракта стейкинга (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`), а в поле `amount` укажите количество токенов для стейкинга (в wei).

#### Стейкинг токенов

1. Откройте [приложение Remix](https://remix.ethereum.org/) в браузере

2. В `File Explorer` создайте файл с именем **Staking.abi** и добавьте в него ABI контракта для стейкинга.

3. С файлом `Staking.abi`, выбранным и открытым в редакторе, перейдите в раздел `Deploy and run transactions` в интерфейсе Remix.

4. В разделе Среды выберите `Injected Web3`, а в разделе `Account` выберите адрес своего Индексатора.

5. Установите адрес контракта стейкинга — вставьте адрес контракта стейкинга (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) рядом с полем `At Address` и нажмите кнопку `At address`, чтобы применить.

6. Вызовите функцию `stake()`, чтобы застейкать GRT в протокол.

7. (Необязательно) Индексаторы могут одобрить другой адрес в качестве оператора для своей инфраструктуры Индексатора, чтобы разделить ключи, которые контролируют средства, и те, которые выполняют повседневные действия, такие как выделение на субграфах и обслуживание (оплачиваемых) запросов. Чтобы установить оператора, вызовите функцию `setOperator()`, указав адрес оператора.

8. (Необязательно) Чтобы контролировать распределение вознаграждений и стратегически привлекать Делегаторов, Индексаторы могут обновить свои параметры делегирования, изменив `indexingRewardCut` (доли на миллион), `queryFeeCut` (доли на миллион) и `cooldownBlocks` (количество блоков). Для этого вызовите функцию `setDelegationParameters()`. Пример ниже устанавливает `queryFeeCut` так, чтобы 95% возмещений за запросы распределялись между Индексатором и 5% — между Делегаторами, устанавливает `indexingRewardCut` так, чтобы 60% вознаграждений за индексирование получал Индексатор, а 40% — Делегаторы, и устанавливает период `cooldownBlocks` на 500 блоков.

```
setDelegationParameters(950000, 600000, 500)
```

### Настройка параметров делегирования

Функция `setDelegationParameters()` в [стейкинг-контракте](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol) является важной для Индексаторов, позволяя им задавать параметры, определяющие их взаимодействие с Делегаторами, что влияет на распределение вознаграждений и способность к делегированию.

### Как настроить параметры делегирования

Чтобы установить параметры делегирования с помощью интерфейса Graph Explorer, выполните следующие шаги:

1. Перейдите в [Graph Explorer](https://thegraph.com/explorer/).
2. Подключите свой кошелек. Выберите мультиподпись (например, Gnosis Safe), затем выберите основную сеть. Примечание: вам нужно будет повторить этот процесс для сети Arbitrum One.
3. Подключите кошелек, который у Вас есть в качестве подписанта.
4. Перейдите в раздел 'Settings' и выберите 'Delegation Parameters'. Эти параметры должны быть настроены для достижения эффективного распределения в желаемом диапазоне. После ввода значений в предоставленные поля ввода интерфейс автоматически рассчитает эффективное распределение. При необходимости отрегулируйте эти значения, чтобы достичь желаемого процента эффективного распределения.
5. Отправьте транзакцию в сеть.

> Примечание: эта транзакция должна быть подтверждена подписантами кошелька с мультиподписью.

### Срок существования аллокации

После создания Индексатором работоспособная аллокация проходит через два состояния.

- **Активный** - как только распределение создается в блокчейне ([allocateFrom()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L316)), оно считается **активным**. Часть собственного залога Индексера и/или делегированного залога выделяется для развертывания субграфа, что позволяет им получать вознаграждения за индексирование и обслуживать запросы для этого развертывания субграфа. Агент Индексатора управляет созданием распределений в соответствии с правилами Индексатора.

- **Закрытый** - Индексатор может закрыть распределение, как только пройдет 1 эпоха ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/main/packages/contracts/contracts/staking/Staking.sol#L335)), или его агент Индексатора автоматически закроет распределение после **maxAllocationEpochs** (в настоящее время 28 дней). Когда распределение закрыто с действительным доказательством индексирования (POI), вознаграждения за индексирование распределяются между Индексатором и его делегаторами ([узнать больше](/indexing/overview/#how-are-indexing-rewards-distributed)).

Индексаторам рекомендуется использовать функциональность оффчейн-синхронизации для синхронизации развертываний субграфов до чейна перед созданием распределения в блокчейне. Эта функция особенно полезна для субграфов, которые могут занять более 28 эпох для синхронизации или которые имеют вероятность неустойчивых сбоев.
