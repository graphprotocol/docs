---
title: GraphQL API
---

Hướng dẫn này giải thích API truy vấn GraphQL được sử dụng cho Giao thức The Graph.

## Các truy vấn

Trong lược đồ subgraph của bạn, bạn xác định các loại được gọi là `Entities`. Với mỗi loại `Entity`, một trường `entity` và `entities` sẽ được tạo ở loại `Query` cấp cao nhất. Lưu ý là `query` không cần phải được bao gồm ở đầu truy vấn `graphql` khi sử dụng The Graph.

#### Các ví dụ

Truy vấn cho một thực thể `Token` được xác định trong lược đồ của bạn:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

**Lưu ý:** Khi truy vấn một thực thể, trường `id` là bắt buộc và nó phải là một chuỗi (string).

Truy vấn tất cả các thực thể `Token`:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### Sắp xếp

Khi truy vấn một tập hợp, tham số `orderBy` có thể được sử dụng để sắp xếp theo một thuộc tính cụ thể. Ngoài ra, `orderDirection` có thể được sử dụng để chỉ định hướng sắp xếp, `asc` tăng dần hoặc `desc` giảm dần.

#### Ví dụ

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

### Phân trang

Khi truy vấn một tập hợp, tham số `first` có thể được sử dụng để phân trang từ đầu tập hợp. Cần lưu ý rằng thứ tự sắp xếp mặc định là theo ID theo thứ tự chữ và số tăng dần, không phải theo thời gian tạo.

Hơn nữa, tham số `skip` có thể được sử dụng để bỏ qua các thực thể và phân trang. ví dụ. `first:100` hiển thị 100 thực thể đầu tiên và `first:100, skip: 100` hiển thị 100 thực thể tiếp theo.

Các truy vấn nên tránh sử dụng các giá trị `skip` rất lớn vì chúng thường hoạt động kém. Để truy xuất một số lượng lớn các mục, tốt hơn nhiều nên trang qua các thực thể dựa trên một thuộc tính như được hiển thị trong ví dụ vừa rồi.

#### Example using `first`

Truy vấn 10 token đầu tiên:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

Để truy vấn các nhóm thực thể ở giữa một tập hợp, tham số `skip` có thể được sử dụng cùng với tham số `first` để bỏ qua một số thực thể được chỉ định bắt đầu từ đầu của bộ sưu tập.

#### Example using `first` and `skip`

Truy vấn 10 thực thể `Token`, bù 10 vị trí từ đầu bộ sưu tập:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Example using `first` and `id_ge`

Nếu một máy khách cần truy xuất một số lượng lớn các thực thể, thì việc truy vấn cơ sở trên một thuộc tính và lọc theo thuộc tính đó sẽ hiệu quả hơn nhiều. Ví dụ: một máy khách sẽ truy xuất một số lượng lớn các token bằng cách sử dụng truy vấn này:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

Lần đầu tiên, nó sẽ gửi truy vấn với `lastID = ""`, và đối với các yêu cầu tiếp theo sẽ được thiết lập `lastID` đến thuộc tính `id` của thực thể cuối cùng trong yêu cầu trước đó. Cách tiếp cận này sẽ hoạt động tốt hơn đáng kể so với việc sử dụng giá trị `skip` ngày càng tăng.

### Lọc

Bạn có thể sử dụng tham số `where` trong các truy vấn của mình để lọc các thuộc tính khác nhau. Bạn có thể lọc theo nhiều giá trị trong tham số `where`.

#### Example using `where`

Các thử thách truy vấn với kết quả `failed`:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

Bạn có thể sử dụng các hậu tố như `_gt`, `_lte` để so sánh giá trị:

#### Example for range filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Example for block filtering

You can also filter entities by the `_change_block(number_gte: Int)` - this filters entities which were updated in or after the specified block.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 }}) {
    id
    whitelisted
    deposit
  }
}
```

#### All Filters

Full list of parameter suffixes:

```
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`.

In addition, the following global filters are available as part of `where` argument:

```gr
_change_block(number_gte: Int)
```


### Các truy vấn du hành thời gian

You can query the state of your entities not just for the latest block, which is the by default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the Ethereum chain, the result might change if that block turns out to not be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

Note that the current implementation is still subject to certain limitations that might violate these gurantees. The implementation can not always tell that a given block hash is not on the main chain at all, or that the result of a query by block hash for a block that can not be considered final yet might be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### Ví dụ

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### Ví dụ

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### Truy vấn Tìm kiếm Toàn văn bản

Fulltext search query fields provide an expressive text search API that can be added to the subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developer/create-subgraph-hosted#defining-fulltext-search-fields) to add fulltext search to your subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

Fulltext search operators:

| Biểu tượng  | Toán tử     | Miêu tả                                                                                                                                                  |
| ----------- | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `&`     | `And`       | Để kết hợp nhiều cụm từ tìm kiếm thành một bộ lọc cho các thực thể bao gồm tất cả các cụm từ được cung cấp                                               |
| &#x7c;      | `Or`        | Các truy vấn có nhiều cụm từ tìm kiếm được phân tách bằng toán tử hoặc sẽ trả về tất cả các thực thể có kết quả khớp với bất kỳ cụm từ nào được cung cấp |
| `<->` | `Follow by` | Chỉ định khoảng cách giữa hai từ.                                                                                                                        |
| `:*`        | `Prefix`    | Sử dụng cụm từ tìm kiếm tiền tố để tìm các từ có tiền tố khớp với nhau (yêu cầu 2 ký tự.)                                                                |

#### Các ví dụ

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### Các thực thể

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## Lược đồ

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your subgraph is automatically generated from the GraphQL schema that's included in your subgraph manifest.

> **Note:** Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### Các thực thể

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.
