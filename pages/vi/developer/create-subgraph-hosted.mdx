---
title: Tạo một Subgraph
---

Trước khi có thể sử dụng Graph CLI, bạn cần tạo subgraph của mình trong [Subgraph Studio](https://thegraph.com/studio). Sau đó, bạn sẽ có thể thiết lập dự án subgraph của mình và triển khai nó trên nền tảng bạn chọn. Lưu ý rằng ** subgraph không lập chỉ mục mạng chính Ethereum sẽ không được xuất bản lên Mạng The Graph**.

Lệnh `graph init` có thể được sử dụng để thiết lập một dự án subgraph mới, từ một hợp đồng hiện có trên bất kỳ mạng Ethereum công cộng nào hoặc từ một subgraph mẫu. Lệnh này có thể được sử dụng để tạo một subgraph trên Subgraph Studio bằng cách chuyển vào `graph init --product subgraph-studio`. Nếu bạn đã có một hợp đồng thông minh được triển khai cho Ethereum mainnet hoặc một trong các testnet, thì việc khởi động một subgraph mới từ hợp đồng đó có thể là một cách tốt để bắt đầu. Nhưng trước tiên, hãy giới thiệu một chút về các mạng mà Graph hỗ trợ.

## Mạng lưới được hỗ trợ

Mạng The Graph hỗ trợ lập chỉ mục các subgraph mạng chính Ethereum:

- `mainnet`

**Các mạng bổ sung được hỗ trợ trong phiên bản beta trên Dịch vụ được lưu trữ**:

- `mainnet`
- `kovan`
- `rinkeby`
- `ropsten`
- `goerli`
- `poa-core`
- `poa-sokol`
- `xdai`
- `near-mainnet`
- `near-testnet`
- `matic`
- `mumbai`
- `fantom`
- `bsc`
- `chapel`
- `clover`
- `avalanche`
- `fuji`
- `celo`
- `celo-alfajores`
- `fuse`
- `moonriver`
- `mbase`
- `arbitrum-one`
- `arbitrum-rinkeby`
- `optimism`
- `optimism-kovan`
- `aurora`
- `aurora-testnet`

Dịch vụ được lưu trữ của The Graph dựa trên sự ổn định và độ tin cậy của các công nghệ cơ bản, cụ thể là các điểm cuối JSON RPC được cung cấp. Các mạng mới hơn sẽ được đánh dấu là đang trong giai đoạn thử nghiệm cho đến khi mạng đó tự chứng minh được về độ ổn định, độ tin cậy và khả năng mở rộng. Trong giai đoạn beta này, có rủi ro về thời gian chết và hành vi không mong muốn.

Hãy nhớ rằng bạn sẽ **không thể** xuất bản một subgraph lập chỉ mục một mạng không phải mainnet lên Mạng The Graph phi tập trung trong [Subgraph Studio](/studio/subgraph-studio).

## Từ Một Hợp đồng Hiện có

Lệnh sau tạo một subgraph lập chỉ mục tất cả các sự kiện của một hợp đồng hiện có. Nó cố gắng lấy ABI hợp đồng từ Etherscan và quay trở lại yêu cầu đường dẫn tệp cục bộ. Nếu thiếu bất kỳ đối số tùy chọn nào, nó sẽ đưa bạn đến một biểu mẫu tương tác.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>` là ID của subgraph của bạn trong Subgraph Studio, bạn có thể tìm thấy mã này trên trang chi tiết subgraph của mình.

## Từ một Subgraph mẫu

Chế độ thứ hai mà `graph init` hỗ trợ là tạo một dự án mới từ một subgraph mẫu. Lệnh sau thực hiện điều này:

```
graph init --studio <SUBGRAPH_SLUG>
```

Subgraph mẫu dựa trên hợp đồng Gravity của Dani Grant quản lý hình đại diện của người dùng và phát ra các sự kiện `NewGravatar` hoặc `UpdateGravatar` bất cứ khi nào hình đại diện được tạo hoặc cập nhật. Subgraph xử lý các sự kiện này bằng cách ghi các thực thể `Gravatar` vào kho lưu trữ Graph Node và đảm bảo chúng được cập nhật theo sự kiện. Các phần sau sẽ xem xét các tệp tạo nên subgraph cho ví dụ này.

## Tệp kê khai Subgraph

Tệp kê khai subgraph `subgraph.yaml` xác định các hợp đồng thông minh lập chỉ mục subgraph của bạn, các sự kiện từ các hợp đồng này cần chú ý đến và cách ánh xạ dữ liệu sự kiện tới các thực thể mà Graph Node lưu trữ và cho phép truy vấn. Bạn có thể tìm thấy thông số kỹ thuật đầy đủ cho các tệp kê khai subgraph [tại đây](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

Đối với subgraph mẫu, `subgraph.yaml` là:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/example-subgraph
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - function: handleBlock
        - function: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

Các mục nhập quan trọng cần cập nhật cho tệp kê khai là:

- `description`: một mô tả mà con người có thể đọc được về nội dung của subgraph này. Mô tả này được Graph Explorer hiển thị khi subgraph được triển khai cho Dịch vụ được lưu trữ.

- `repository`: URL của kho lưu trữ nơi có thể tìm thấy tệp kê khai subgraph. Điều này cũng được hiển thị bởi Graph Explorer.

- `features`: một danh sách tất cả các tên [tính năng](#experimental-features) đã sử dụng.

- `dataSources.source`: địa chỉ của hợp đồng thông minh, các nguồn subgraph và abi của hợp đồng thông minh để sử dụng. Địa chỉ là tùy chọn; bỏ qua nó cho phép lập chỉ mục các sự kiện phù hợp từ tất cả các hợp đồng.

- `dataSources.source.startBlock`: số tùy chọn của khối mà nguồn dữ liệu bắt đầu lập chỉ mục. Trong hầu hết các trường hợp, chúng tôi khuyên bạn nên sử dụng khối mà hợp đồng đã được tạo.

- `dataSources.mapping.entities`: các thực thể mà nguồn dữ liệu ghi vào cửa hàng. Lược đồ cho mỗi thực thể được xác định trong tệp schema.graphql.

- `dataSources.mapping.abis`: một hoặc nhiều tệp ABI được đặt tên cho hợp đồng nguồn cũng như bất kỳ hợp đồng thông minh nào khác mà bạn tương tác từ bên trong ánh xạ.

- `dataSources.mapping.eventHandlers`: liệt kê các sự kiện hợp đồng thông minh mà subgraph này phản ứng và các trình xử lý trong ánh xạ—./src/mapping.ts trong ví dụ — biến những sự kiện này thành các thực thể trong cửa hàng.

- `dataSources.mapping.callHandlers`: liệt kê các chức năng của hợp đồng thông minh mà subgraph này phản ứng và xử lý trong ánh xạ chuyển đổi đầu vào và đầu ra cho các lệnh gọi hàm thành các thực thể trong cửa hàng.

- `dataSources.mapping.blockHandlers`: liệt kê các khối mà biểu đồ con này phản ứng và các trình xử lý trong ánh xạ để chạy khi một khối được nối vào chuỗi. Nếu không có bộ lọc, trình xử lý khối sẽ được chạy mỗi khối. Một bộ lọc tùy chọn có thể được cung cấp với các loại sau: call. call sẽ chạy trình xử lý nếu khối chứa ít nhất một lệnh gọi đến hợp đồng nguồn dữ liệu.

Một subgraph n có thể lập chỉ mục dữ liệu từ nhiều hợp đồng thông minh. Thêm mục nhập cho mỗi hợp đồng mà từ đó dữ liệu cần được lập chỉ mục vào mảng `dataSources`.

Các trình kích hoạt cho nguồn dữ liệu trong một khối được sắp xếp theo quy trình sau:

1. Trình kích hoạt sự kiện và cuộc gọi được sắp xếp đầu tiên theo chỉ mục giao dịch trong khối.
2. Trình kích hoạt sự kiện và cuộc gọi trong cùng một giao dịch được sắp xếp theo quy ước: trình kích hoạt sự kiện trước rồi đến trình kích hoạt cuộc gọi, mỗi loại tuân theo thứ tự mà chúng được xác định trong tệp kê khai.
3. Trình kích hoạt chặn được chạy sau trình kích hoạt sự kiện và cuộc gọi, theo thứ tự chúng được xác định trong tệp kê khai.

Các quy tắc đặt hàng này có thể thay đổi.

### Nhận các ABI

(Các) tệp ABI phải khớp với (các) hợp đồng của bạn. Có một số cách để lấy tệp ABI:

- Nếu bạn đang xây dựng dự án của riêng mình, bạn có thể sẽ có quyền truy cập vào các ABI mới nhất của mình.
- Nếu bạn đang xây dựng một subgraph cho một dự án công cộng, bạn có thể tải dự án đó xuống máy tính của mình và lấy ABI bằng cách sử dụng [`truffle compile`](https://truffleframework.com/docs/truffle/overview) hoặc sử dụng solc để biên dịch.
- Bạn cũng có thể tìm thấy ABI trên [Etherscan](https://etherscan.io/), nhưng điều này không phải lúc nào cũng đáng tin cậy, vì ABI được tải lên có thể đã lỗi thời. Đảm bảo rằng bạn có ABI phù hợp, nếu không việc chạy subgraph của bạn sẽ không thành công.

## Lược đồ GraphQL

Lược đồ cho subgraph của bạn nằm trong tệp `schema.graphql`. Các lược đồ GraphQL được định nghĩa bằng ngôn ngữ định nghĩa giao diện GraphQL. Nếu bạn chưa bao giờ viết lược đồ GraphQL, bạn nên xem phần sơ đồ này trên hệ thống loại GraphQL. Tài liệu tham khảo cho lược đồ GraphQL có thể được tìm thấy trong phần [GraphQL API](/developer/graphql-api).

## Xác định các Thực thể

Trước khi xác định các thực thể (entities), điều quan trọng là phải lùi lại một bước và suy nghĩ về cách dữ liệu của bạn được cấu trúc và liên kết. Tất cả các truy vấn sẽ được thực hiện dựa trên mô hình dữ liệu được xác định trong lược đồ subgraph và các thực thể được lập chỉ mục bởi subgraph. Bởi vì điều này, rất tốt để xác định lược đồ subgraph theo cách phù hợp với nhu cầu của dapp của bạn. Có thể hữu ích khi hình dung các thực thể là "đối tượng chứa dữ liệu", chứ không phải là các sự kiện hoặc chức năng.

Với The Graph, bạn chỉ cần xác định các loại thực thể trong `schema.graphql` và Graph Node sẽ tạo ra các trường cấp cao nhất để truy vấn các trường hợp và tập hợp đơn lẻ của loại thực thể đó. Mỗi loại phải là một thực thể bắt buộc phải được chú thích bằng chỉ thị `@entity`.

### Ví dụ tốt

Thực thể `Gravatar` bên dưới được cấu trúc xung quanh một đối tượng Gravatar và là một ví dụ điển hình về cách một thực thể có thể được xác định.

```graphql
type Gravatar @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Ví dụ tồi

Ví dụ về các thực thể `GravatarAccepted` và `GravatarDecline` bên dưới dựa trên các sự kiện. Không nên ánh xạ các sự kiện hoặc lệnh gọi hàm tới các thực thể 1: 1.

```graphql
type GravatarAccepted @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Các trường tùy chọn và bắt buộc

Các trường thực thể có thể được xác định theo yêu cầu hoặc tùy chọn. Các trường bắt buộc được biểu thị bằng `!` trong lược đồ. Nếu trường bắt buộc không được đặt trong ánh xạ, bạn sẽ nhận được lỗi này khi truy vấn trường:

```
Giá trị rỗng (null) được giải quyết cho trường không phải null 'name'
```

Mỗi thực thể phải có một trường `id`, thuộc loại `ID!` (string). Trường `id` đóng vai trò là khóa chính và cần phải là duy nhất giữa tất cả các thực thể cùng loại.

### Các loại vô hướng tích hợp

#### GraphQL Vô hướng được hỗ trợ

Chúng tôi hỗ trợ các đại lượng vô hướng sau trong API GraphQL của chúng tôi:

| Loại | Miêu tả |
| --- | --- |
| `Bytes` | Mảng byte, được biểu diễn dưới dạng chuỗi thập lục phân. Thường được sử dụng cho các mã băm và địa chỉ Ethereum. |
| `ID` | Được lưu trữ dưới dạng `string`. |
| `String` | Vô hướng cho các giá trị `string`. Các ký tự rỗng không được hỗ trợ và tự động bị xóa. |
| `Boolean` | Vô hướng cho các giá trị `boolean`. |
| `Int` | Thông số GraphQL xác định `Int` có kích thước 32 byte. |
| `BigInt` | Số nguyên lớn. Được sử dụng cho các loại `uint32`, `int64`, `uint64`, ..., `uint256` của Ethereum. Lưu ý: mọi thứ dưới `uint32`, như là `int32`, `uint24` or `int8` được đại diện như là `i32`. |
| `BigDecimal` | `BigDecimal` Các số thập phân có độ chính xác cao được biểu diễn dưới dạng dấu hiệu và số mũ. Phạm vi số mũ là từ −6143 đến +6144. Được làm tròn đến 34 chữ số có nghĩa. |

#### Enums

Bạn cũng có thể tạo enums trong một lược đồ. Enums có cú pháp sau:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Khi enum được xác định trong lược đồ, bạn có thể sử dụng biểu diễn chuỗi của giá trị enum để đặt một trường enum trên một thực thể. Ví dụ: bạn có thể đặt `tokenStatus` thành `SecondOwner` bằng cách xác định thực thể của bạn trước tiên và sau đó đặt trường với `entity.tokenStatus = "SecondOwner`. Ví dụ bên dưới minh họa thực thể Token sẽ trông như thế nào với trường enum:

Bạn có thể tìm thấy thêm chi tiết về cách viết enums trong [Tài liệu GraphQL](https://graphql.org/learn/schema/).

#### Mối quan hệ thực thể

Một thực thể có thể có mối quan hệ với một hoặc nhiều thực thể khác trong lược đồ của bạn. Những mối quan hệ này có thể được duyệt qua trong các truy vấn của bạn. Các mối quan hệ trong The Graph là một chiều. Có thể mô phỏng mối quan hệ hai chiều bằng cách xác định mối quan hệ một chiều ở một trong hai "điểm cuối" của mối quan hệ.

Mối quan hệ được xác định trên các thực thể giống như bất kỳ trường nào khác ngoại trừ kiểu được chỉ định là của một thực thể khác.

#### Mối quan hệ một-một

Xác định loại thực thể `Transaction` với mối quan hệ 1-1 tùy chọn với loại thực thể `TransactionReceipt`:

```graphql
type Transaction @entity {
  id: ID!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity {
  id: ID!
  transaction: Transaction
}
```

#### Mối quan hệ một-nhiều

Xác định loại thực thể `TokenBalance` với mối quan hệ một-nhiều bắt buộc với loại thực thể Token:

```graphql
type Token @entity {
  id: ID!
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}
```

#### Tra cứu ngược

Tra cứu ngược có thể được xác định trên một thực thể thông qua trường `@derivedFrom`. Điều này tạo ra một trường ảo trên thực thể có thể được truy vấn nhưng không thể được đặt theo cách thủ công thông qua API ánh xạ. Đúng hơn, nó có nguồn gốc từ mối quan hệ được xác định trên thực thể khác. Đối với các mối quan hệ như vậy, hiếm khi có ý nghĩa khi lưu trữ cả hai bên của mối quan hệ và cả hiệu suất lập chỉ mục và truy vấn sẽ tốt hơn khi chỉ một bên được lưu trữ và bên kia được dẫn xuất.

Đối với các mối quan hệ một-nhiều, mối quan hệ phải luôn được lưu trữ ở bên 'một' và bên 'nhiều' phải luôn được bắt nguồn. Lưu trữ mối quan hệ theo cách này, thay vì lưu trữ một mảng các thực thể ở phía 'nhiều', sẽ dẫn đến hiệu suất tốt hơn đáng kể cho cả lập chỉ mục và truy vấn subgraph. Nói chung, việc lưu trữ các mảng thực thể nên tránh càng nhiều càng tốt.

#### Ví dụ

Chúng tôi có thể tạo số dư cho một token có thể truy cập được từ token bằng cách lấy trường `tokenBalances`:

```graphql
type Token @entity {
  id: ID!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}
```

#### Mối quan hệ nhiều-nhiều

Đối với các mối quan hệ nhiều-nhiều, chẳng hạn như người dùng mà mỗi người có thể thuộc bất kỳ số lượng tổ chức nào, thì cách đơn giản nhất, nhưng không phải là hoạt động hiệu quả nhất, để lập mô hình mối quan hệ là một mảng trong mỗi thực thể trong số hai thực thể có liên quan. Nếu mối quan hệ là đối xứng, chỉ một mặt của mối quan hệ cần được lưu trữ và mặt còn lại có thể được suy ra.

#### Ví dụ

Define a reverse lookup from a `User` entity type to an `Organization` entity type. In the example below, this is achieved by looking up the `members` attribute from within the `Organization` entity. In queries, the `organizations` field on `User` will be resolved by finding all `Organization` entities that include the user's ID.

```graphql
type Organization @entity {
  id: ID!
  name: String!
  members: [User!]!
}

type User @entity {
  id: ID!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

A more performant way to store this relationship is through a mapping table that has one entry for each `User` / `Organization` pair with a schema like

```graphql
type Organization @entity {
  id: ID!
  name: String!
  members: [UserOrganization]! @derivedFrom(field: "organization")
}

type User @entity {
  id: ID!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: ID! # Set to `${user.id}-${organization.id}`
  user: User!
  organization: Organization!
}
```

This approach requires that queries descend into one additional level to retrieve, for example, the organizations for users:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

This more elaborate way of storing many-to-many relationships will result in less data stored for the subgraph, and therefore to a subgraph that is often dramatically faster to index and to query.

#### Adding comments to the schema

As per GraphQL spec, comments can be added above schema entity attributes using double quotations `""`. This is illustrated in the example below:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  address: Bytes!
}
```

## Defining Fulltext Search Fields

Fulltext search queries filter and rank entities based on a text search input. Fulltext queries are able to return matches for similar words by processing the query text input into stems before comparing to the indexed text data.

A fulltext query definition includes the query name, the language dictionary used to process the text fields, the ranking algorithm used to order the results, and the fields included in the search. Each fulltext query may span multiple fields, but all included fields must be from a single entity type.

To add a fulltext query, include a `_Schema_` type with a fulltext directive in the GraphQL schema.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: ID!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

The example `bandSearch` field can be used in queries to filter `Band` entities based on the text documents in the `name`, `description`, and `bio` fields. Jump to [GraphQL API - Queries](/developer/graphql-api#queries) for a description of the Fulltext search API and for more example usage.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Feature Management](#experimental-features):** From `specVersion` `0.0.4` and onwards, `fullTextSearch` must be declared under the `features` section in the subgraph manifest.

### Languages supported

Choosing a different language will have a definitive, though sometimes subtle, effect on the fulltext search API. Fields covered by a fulltext query field are examined in the context of the chosen language, so the lexemes produced by analysis and search queries vary language to language. For example: when using the supported Turkish dictionary "token" is stemmed to "toke" while, of course, the English dictionary will stem it to "token".

Supported language dictionaries:

| Mã     | Từ điển   |
| ------ | --------- |
| simple | General   |
| da     | Danish    |
| nl     | Dutch     |
| en     | English   |
| fi     | Finnish   |
| fr     | French    |
| de     | German    |
| hu     | Hungarian |
| it     | Italian   |
| no     | Norwegian |
| pt     | Portugese |
| ro     | Romanian  |
| ru     | Russian   |
| es     | Spanish   |
| sv     | Swedish   |
| tr     | Turkish   |

### Ranking Algorithms

Supported algorithms for ordering results:

| Algorithm     | Miêu tả                                                                 |
| ------------- | ----------------------------------------------------------------------- |
| rank          | Use the match quality (0-1) of the fulltext query to order the results. |
| proximityRank | Similar to rank but also includes the proximity of the matches.         |

## Writing Mappings

The mappings transform the Ethereum data your mappings are sourcing into entities defined in your schema. Mappings are written in a subset of [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) called [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki) which can be compiled to WASM ([WebAssembly](https://webassembly.org/)). AssemblyScript is stricter than normal TypeScript, yet provides a familiar syntax.

For each event handler that is defined in `subgraph.yaml` under `mapping.eventHandlers`, create an exported function of the same name. Each handler must accept a single parameter called `event` with a type corresponding to the name of the event which is being handled.

In the example subgraph, `src/mapping.ts` contains handlers for the `NewGravatar` and `UpdatedGravatar` events:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id.toHex()
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

The first handler takes a `NewGravatar` event and creates a new `Gravatar` entity with `new Gravatar(event.params.id.toHex())`, populating the entity fields using the corresponding event parameters. This entity instance is represented by the variable `gravatar`, with an id value of `event.params.id.toHex()`.

The second handler tries to load the existing `Gravatar` from the Graph Node store. If it does not exist yet, it is created on demand. The entity is then updated to match the new event parameters, before it is saved back to the store using `gravatar.save()`.

### Recommended IDs for Creating New Entities

Every entity has to have an `id` that is unique among all entities of the same type. An entity's `id` value is set when the entity is created. Below are some recommended `id` values to consider when creating new entities. NOTE: The value of `id` must be a `string`.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

We provide the [Graph Typescript Library](https://github.com/graphprotocol/graph-ts) which contains utilies for interacting with the Graph Node store and conveniences for handling smart contract data and entities. You can use this library in your mappings by importing `@graphprotocol/graph-ts` in `mapping.ts`.

## Code Generation

In order to make working smart contracts, events and entities easy and type-safe, the Graph CLI can generate AssemblyScript types from the subgraph's GraphQL schema and the contract ABIs included in the data sources.

This is done with

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

but in most cases, subgraphs are already preconfigured via `package.json` to allow you to simply run one of the following to achieve the same:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

This will generate an AssemblyScript class for every smart contract in the ABI files mentioned in `subgraph.yaml`, allowing you to bind these contracts to specific addresses in the mappings and call read-only contract methods against the block being processed. It will also generate a class for every contract event to provide easy access to event parameters as well as the block and transaction the event originated from. All of these types are written to `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts`. In the example subgraph, this would be `generated/Gravity/Gravity.ts`, allowing mappings to import these types with

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

In addition to this, one class is generated for each entity type in the subgraph's GraphQL schema. These classes provide type-safe entity loading, read and write access to entity fields as well as a `save()` method to write entities to store. All entity classes are written to `<OUTPUT_DIR>/schema.ts`, allowing mappings to import them with

```javascript
import { Gravatar } from '../generated/schema'
```

> **Note:** The code generation must be performed again after every change to the GraphQL schema or the ABIs included in the manifest. It must also be performed at least once before building or deploying the subgraph.

Code generation does not check your mapping code in `src/mapping.ts`. If you want to check that before trying to deploy your subgraph to the Graph Explorer, you can run `yarn build` and fix any syntax errors that the TypeScript compiler might find.

## Data Source Templates

A common pattern in Ethereum smart contracts is the use of registry or factory contracts, where one contract creates, manages or references an arbitrary number of other contracts that each have their own state and events. The addresses of these sub-contracts may or may not be known upfront and many of these contracts may be created and/or added over time. This is why, in such cases, defining a single data source or a fixed number of data sources is impossible and a more dynamic approach is needed: _data source templates_.

### Data Source for the Main Contract

First, you define a regular data source for the main contract. The snippet below shows a simplified example data source for the [Uniswap](https://uniswap.io) exchange factory contract. Note the `NewExchange(address,address)` event handler. This is emitted when a new exchange contract is created on chain by the factory contract.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Data Source Templates for Dynamically Created Contracts

Then, you add _data source templates_ to the manifest. These are identical to regular data sources, except that they lack a predefined contract address under `source`. Typically, you would define one template for each type of sub-contract managed or referenced by the parent contract.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Instantiating a Data Source Template

In the final step, you update your main contract mapping to create a dynamic data source instance from one of the templates. In this example, you would change the main contract mapping to import the `Exchange` template and call the `Exchange.create(address)` method on it to start indexing the new exchange contract.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **Note:** A new data source will only process the calls and events for the block in which it was created and all following blocks, but will not process historical data, i.e., data that is contained in prior blocks.
>
> If prior blocks contain data relevant to the new data source, it is best to index that data by reading the current state of the contract and creating entities representing that state at the time the new data source is created.

### Data Source Context

Data source contexts allow passing extra configuration when instantiating a template. In our example, let's say exchanges are associated with a particular trading pair, which is included in the `NewExchange` event. That information can be passed into the instantiated data source, like so:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Inside a mapping of the `Exchange` template, the context can then be accessed:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

There are setters and getters like `setString` and `getString` for all value types.

## Start Blocks

The `startBlock` is an optional setting that allows you to define from which block in the chain the data source will start indexing. Setting the start block allows the data source to skip potentially millions of blocks that are irrelevant. Typically, a subgraph developer will set `startBlock` to the block in which the smart contract of the data source was created.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Lưu ý:** Khối tạo hợp đồng có thể được nhanh chóng tra cứu trên Etherscan:
>
> 1. Tìm kiếm hợp đồng bằng cách nhập địa chỉ của nó vào thanh tìm kiếm.
> 2. Nhấp vào băm giao dịch tạo trong phần `Contract Creator`.
> 3. Load the transaction details page where you'll find the start block for that contract.

## Call Handlers

While events provide an effective way to collect relevant changes to the state of a contract, many contracts avoid generating logs to optimize gas costs. In these cases, a subgraph can subscribe to calls made to the data source contract. This is achieved by defining call handlers referencing the function signature and the mapping handler that will process calls to this function. To process these calls, the mapping handler will receive an `ethereum.Call` as an argument with the typed inputs to and outputs from the call. Calls made at any depth in a transaction's call chain will trigger the mapping, allowing activity with the data source contract through proxy contracts to be captured.

Call handlers will only trigger in one of two cases: when the function specified is called by an account other than the contract itself or when it is marked as external in Solidity and called as part of another function in the same contract.

> **Note:** Call handlers are not supported on Rinkeby, Goerli or Ganache. Call handlers currently depend on the Parity tracing API and these networks do not support it.

### Defining a Call Handler

To define a call handler in your manifest simply add a `callHandlers` array under the data source you would like to subscribe to.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

The `function` is the normalized function signature to filter calls by. The `handler` property is the name of the function in your mapping you would like to execute when the target function is called in the data source contract.

### Mapping Function

Each call handler takes a single parameter that has a type corresponding to the name of the called function. In the example subgraph above, the mapping contains a handler for when the `createGravatar` function is called and receives a `CreateGravatarCall` parameter as an argument:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash.toHex()
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

The `handleCreateGravatar` function takes a new `CreateGravatarCall` which is a subclass of `ethereum.Call`, provided by `@graphprotocol/graph-ts`, that includes the typed inputs and outputs of the call. The `CreateGravatarCall` type is generated for you when you run `graph codegen`.

## Block Handlers

In addition to subscribing to contract events or function calls, a subgraph may want to update its data as new blocks are appended to the chain. To achieve this a subgraph can run a function after every block or after blocks that match a predefined filter.

### Supported Filters

```yaml
filter:
  kind: call
```

_The defined handler will be called once for every block which contains a call to the contract (data source) the handler is defined under._

The absense of a filter for a block handler will ensure that the handler is called every block. A data source can only contain one block handler for each filter type.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### Mapping Function

The mapping function will receive an `ethereum.Block` as its only argument. Like mapping functions for events, this function can access existing subgraph entities in the store, call smart contracts and create or update entities.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash.toHex()
  let entity = new Block(id)
  entity.save()
}
```

## Anonymous Events

If you need to process anonymous events in Solidity, that can be achieved by providing the topic 0 of the event, as in the example:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0xbaa8529c00000000000000000000000000000000000000000000000000000000'
    handler: handleGive
```

An event will only be triggered when both the signature and topic 0 match. By default, `topic0` is equal to the hash of the event signature.

## Experimental features

Starting from `specVersion` `0.0.4`, subgraph features must be explicitly declared in the `features` section at the top level of the manifest file, using their `camelCase` name, as listed in the table below:

| Feature                                                   | Name                      |
| --------------------------------------------------------- | ------------------------- |
| [Non-fatal errors](#non-fatal-errors)                     | `nonFatalErrors`          |
| [Full-text Search](#defining-fulltext-search-fields)      | `fullTextSearch`          |
| [Grafting](#grafting-onto-existing-subgraphs)             | `grafting`                |
| [IPFS on Ethereum Contracts](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` |

For instance, if a subgraph uses the **Full-Text Search** and the **Non-fatal Errors** features, the `features` field in the manifest should be:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Note that using a feature without declaring it will incur in a **validation error** during subgraph deployment, but no errors will occur if a feature is declared but not used.

### IPFS on Ethereum Contracts

A common use case for combining IPFS with Ethereum is to store data on IPFS that would be too expensive to maintain on chain, and reference the IPFS hash in Ethereum contracts.

Given such IPFS hashes, subgraphs can read the corresponding files from IPFS using `ipfs.cat` and `ipfs.map`. To do this reliably, however, it is required that these files are pinned on the IPFS node that the Graph Node indexing the subgraph connects to. In the case of the [hosted service](https://thegraph.com/hosted-service), this is [https://api.thegraph.com/ipfs/](https://api.thegraph.com/ipfs/).

> **Note:** The Graph Network does not yet support `ipfs.cat` and `ipfs.map`, and developers should not deploy subgraphs using that functionality to the network via the Studio.

In order to make this easy for subgraph developers, The Graph team wrote a tool for transfering files from one IPFS node to another, called [ipfs-sync](https://github.com/graphprotocol/ipfs-sync).

> **[Feature Management](#experimental-features):** `ipfsOnEthereumContracts` must be declared under `features` in the subgraph manifest.

### Non-fatal errors

Indexing errors on already synced subgraphs will, by default, cause the subgraph to fail and stop syncing. Subgraphs can alternatively be configured to continue syncing in the presence of errors, by ignoring the changes made by the handler which provoked the error. This gives subgraph authors time to correct their subgraphs while queries continue to be served against the latest block, though the results will possibly be inconsistent due to the bug that caused the error. Note that some errors are still always fatal, to be non-fatal the error must be known to be deterministic.

> **Note:** The Graph Network does not yet support non-fatal errors, and developers should not deploy subgraphs using that functionality to the network via the Studio.

Enabling non-fatal errors requires setting the following feature flag on the subgraph manifest:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - fullTextSearch
    ...
```

The query must also opt-in to querying data with potential inconsistencies through the `subgraphError` argument. It is also recommended to query `_meta` to check if the subgraph has skipped over errors, as in the example:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

If the subgraph encounters an error that query will return both the data and a graphql error with the message `"indexing_error"`, as in this example response:

```graphql
"data": {
    "foos": [
        {
          "id": "fooId"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Grafting onto Existing Subgraphs

When a subgraph is first deployed, it starts indexing events at the genesis block of the corresponding chain (or at the `startBlock` defined with each data source) In some circumstances, it is beneficial to reuse the data from an existing subgraph and start indexing at a much later block. This mode of indexing is called _Grafting_. Grafting is, for example, useful during development to get past simple errors in the mappings quickly, or to temporarily get an existing subgraph working again after it has failed.

> **Note:** Grafting requires that the Indexer has indexed the base subgraph. It is not recommended on The Graph Network at this time, and developers should not deploy subgraphs using that functionality to the network via the Studio.

A subgraph is grafted onto a base subgraph when the subgraph manifest in `subgraph.yaml` contains a `graft` block at the toplevel:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

When a subgraph whose manifest contains a `graft` block is deployed, Graph Node will copy the data of the `base` subgraph up to and including the given `block` and then continue indexing the new subgraph from that block on. The base subgraph must exist on the target Graph Node instance and must have indexed up to at least the given block. Because of this restriction, grafting should only be used during development or during an emergency to speed up producing an equivalent non-grafted subgraph.

Because grafting copies rather than indexes base data it is much quicker in getting the subgraph to the desired block than indexing from scratch, though the initial data copy can still take several hours for very large subgraphs. While the grafted subgraph is being initialized, the Graph Node will log information about the entity types that have already been copied.

The grafted subgraph can use a GraphQL schema that is not identical to the one of the base subgraph, but merely compatible with it. It has to be a valid subgraph schema in its own right but may deviate from the base subgraph's schema in the following ways:

- It adds or removes entity types
- It removes attributes from entity types
- It adds nullable attributes to entity types
- It turns non-nullable attributes into nullable attributes
- It adds values to enums
- It adds or removes interfaces
- It changes for which entity types an interface is implemented

> **[Feature Management](#experimental-features):** `grafting` must be declared under `features` in the subgraph manifest.
