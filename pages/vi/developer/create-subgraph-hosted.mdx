---
title: Tạo một Subgraph
---

Trước khi có thể sử dụng Graph CLI, bạn cần tạo subgraph của mình trong [Subgraph Studio](https://thegraph.com/studio). Sau đó, bạn sẽ có thể thiết lập dự án subgraph của mình và triển khai nó trên nền tảng bạn chọn. Lưu ý rằng ** subgraph không lập chỉ mục mạng chính Ethereum sẽ không được xuất bản lên Mạng The Graph**.

Lệnh `graph init` có thể được sử dụng để thiết lập một dự án subgraph mới, từ một hợp đồng hiện có trên bất kỳ mạng Ethereum công cộng nào hoặc từ một subgraph mẫu. Lệnh này có thể được sử dụng để tạo một subgraph trên Subgraph Studio bằng cách chuyển vào `graph init --product subgraph-studio`. Nếu bạn đã có một hợp đồng thông minh được triển khai cho Ethereum mainnet hoặc một trong các testnet, thì việc khởi động một subgraph mới từ hợp đồng đó có thể là một cách tốt để bắt đầu. Nhưng trước tiên, hãy giới thiệu một chút về các mạng mà Graph hỗ trợ.

## Mạng lưới được hỗ trợ

Mạng The Graph hỗ trợ lập chỉ mục các subgraph mạng chính Ethereum:

- `mainnet`

**Các mạng bổ sung được hỗ trợ trong phiên bản beta trên Dịch vụ được lưu trữ**:

- `mainnet`
- `kovan`
- `rinkeby`
- `ropsten`
- `goerli`
- `poa-core`
- `poa-sokol`
- `xdai`
- `near-mainnet`
- `near-testnet`
- `matic`
- `mumbai`
- `fantom`
- `bnb`
- `chapel`
- `clover`
- `avalanche`
- `fuji`
- `celo`
- `celo-alfajores`
- `fuse`
- `moonriver`
- `mbase`
- `arbitrum-one`
- `arbitrum-rinkeby`
- `optimism`
- `optimism-kovan`
- `aurora`
- `aurora-testnet`

Dịch vụ được lưu trữ của The Graph dựa trên sự ổn định và độ tin cậy của các công nghệ cơ bản, cụ thể là các điểm cuối JSON RPC được cung cấp. Các mạng mới hơn sẽ được đánh dấu là đang trong giai đoạn thử nghiệm cho đến khi mạng đó tự chứng minh được về độ ổn định, độ tin cậy và khả năng mở rộng. Trong giai đoạn beta này, có rủi ro về thời gian chết và hành vi không mong muốn.

Hãy nhớ rằng bạn sẽ **không thể** xuất bản một subgraph lập chỉ mục một mạng không phải mainnet lên Mạng The Graph phi tập trung trong [Subgraph Studio](/studio/subgraph-studio).

## Từ Một Hợp đồng Hiện có

Lệnh sau tạo một subgraph lập chỉ mục tất cả các sự kiện của một hợp đồng hiện có. Nó cố gắng lấy ABI hợp đồng từ Etherscan và quay trở lại yêu cầu đường dẫn tệp cục bộ. Nếu thiếu bất kỳ đối số tùy chọn nào, nó sẽ đưa bạn đến một biểu mẫu tương tác.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

`<SUBGRAPH_SLUG>` là ID của subgraph của bạn trong Subgraph Studio, bạn có thể tìm thấy mã này trên trang chi tiết subgraph của mình.

## Từ một Subgraph mẫu

Chế độ thứ hai mà `graph init` hỗ trợ là tạo một dự án mới từ một subgraph mẫu. Lệnh sau thực hiện điều này:

```
graph init --studio <SUBGRAPH_SLUG>
```

Subgraph mẫu dựa trên hợp đồng Gravity của Dani Grant quản lý hình đại diện của người dùng và phát ra các sự kiện `NewGravatar` hoặc `UpdateGravatar` bất cứ khi nào hình đại diện được tạo hoặc cập nhật. Subgraph xử lý các sự kiện này bằng cách ghi các thực thể `Gravatar` vào kho lưu trữ Graph Node và đảm bảo chúng được cập nhật theo sự kiện. Các phần sau sẽ xem xét các tệp tạo nên subgraph cho ví dụ này.

## Tệp kê khai Subgraph

Tệp kê khai subgraph `subgraph.yaml` xác định các hợp đồng thông minh lập chỉ mục subgraph của bạn, các sự kiện từ các hợp đồng này cần chú ý đến và cách ánh xạ dữ liệu sự kiện tới các thực thể mà Graph Node lưu trữ và cho phép truy vấn. Bạn có thể tìm thấy thông số kỹ thuật đầy đủ cho các tệp kê khai subgraph [tại đây](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

Đối với subgraph mẫu, `subgraph.yaml` là:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/example-subgraph
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - function: handleBlock
        - function: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

Các mục nhập quan trọng cần cập nhật cho tệp kê khai là:

- `description`: một mô tả mà con người có thể đọc được về nội dung của subgraph này. Mô tả này được Graph Explorer hiển thị khi subgraph được triển khai cho Dịch vụ được lưu trữ.

- `repository`: URL của kho lưu trữ nơi có thể tìm thấy tệp kê khai subgraph. Điều này cũng được hiển thị bởi Graph Explorer.

- `features`: một danh sách tất cả các tên [tính năng](#experimental-features) đã sử dụng.

- `dataSources.source`: địa chỉ của hợp đồng thông minh, các nguồn subgraph và abi của hợp đồng thông minh để sử dụng. Địa chỉ là tùy chọn; bỏ qua nó cho phép lập chỉ mục các sự kiện phù hợp từ tất cả các hợp đồng.

- `dataSources.source.startBlock`: số tùy chọn của khối mà nguồn dữ liệu bắt đầu lập chỉ mục. Trong hầu hết các trường hợp, chúng tôi khuyên bạn nên sử dụng khối mà hợp đồng đã được tạo.

- `dataSources.mapping.entities`: các thực thể mà nguồn dữ liệu ghi vào cửa hàng. Lược đồ cho mỗi thực thể được xác định trong tệp schema.graphql.

- `dataSources.mapping.abis`: một hoặc nhiều tệp ABI được đặt tên cho hợp đồng nguồn cũng như bất kỳ hợp đồng thông minh nào khác mà bạn tương tác từ bên trong ánh xạ.

- `dataSources.mapping.eventHandlers`: liệt kê các sự kiện hợp đồng thông minh mà subgraph này phản ứng và các trình xử lý trong ánh xạ—./src/mapping.ts trong ví dụ — biến những sự kiện này thành các thực thể trong cửa hàng.

- `dataSources.mapping.callHandlers`: liệt kê các chức năng của hợp đồng thông minh mà subgraph này phản ứng và xử lý trong ánh xạ chuyển đổi đầu vào và đầu ra cho các lệnh gọi hàm thành các thực thể trong cửa hàng.

- `dataSources.mapping.blockHandlers`: liệt kê các khối mà biểu đồ con này phản ứng và các trình xử lý trong ánh xạ để chạy khi một khối được nối vào chuỗi. Nếu không có bộ lọc, trình xử lý khối sẽ được chạy mỗi khối. Một bộ lọc tùy chọn có thể được cung cấp với các loại sau: call. call sẽ chạy trình xử lý nếu khối chứa ít nhất một lệnh gọi đến hợp đồng nguồn dữ liệu.

Một subgraph n có thể lập chỉ mục dữ liệu từ nhiều hợp đồng thông minh. Thêm mục nhập cho mỗi hợp đồng mà từ đó dữ liệu cần được lập chỉ mục vào mảng `dataSources`.

Các trình kích hoạt cho nguồn dữ liệu trong một khối được sắp xếp theo quy trình sau:

1. Trình kích hoạt sự kiện và cuộc gọi được sắp xếp đầu tiên theo chỉ mục giao dịch trong khối.
2. Trình kích hoạt sự kiện và cuộc gọi trong cùng một giao dịch được sắp xếp theo quy ước: trình kích hoạt sự kiện trước rồi đến trình kích hoạt cuộc gọi, mỗi loại tuân theo thứ tự mà chúng được xác định trong tệp kê khai.
3. Trình kích hoạt chặn được chạy sau trình kích hoạt sự kiện và cuộc gọi, theo thứ tự chúng được xác định trong tệp kê khai.

Các quy tắc đặt hàng này có thể thay đổi.

### Nhận các ABI

(Các) tệp ABI phải khớp với (các) hợp đồng của bạn. Có một số cách để lấy tệp ABI:

- Nếu bạn đang xây dựng dự án của riêng mình, bạn có thể sẽ có quyền truy cập vào các ABI mới nhất của mình.
- Nếu bạn đang xây dựng một subgraph cho một dự án công cộng, bạn có thể tải dự án đó xuống máy tính của mình và lấy ABI bằng cách sử dụng [`truffle compile`](https://truffleframework.com/docs/truffle/overview) hoặc sử dụng solc để biên dịch.
- Bạn cũng có thể tìm thấy ABI trên [Etherscan](https://etherscan.io/), nhưng điều này không phải lúc nào cũng đáng tin cậy, vì ABI được tải lên có thể đã lỗi thời. Đảm bảo rằng bạn có ABI phù hợp, nếu không việc chạy subgraph của bạn sẽ không thành công.

## Lược đồ GraphQL

Lược đồ cho subgraph của bạn nằm trong tệp `schema.graphql`. Các lược đồ GraphQL được định nghĩa bằng ngôn ngữ định nghĩa giao diện GraphQL. Nếu bạn chưa bao giờ viết lược đồ GraphQL, bạn nên xem phần sơ đồ này trên hệ thống loại GraphQL. Tài liệu tham khảo cho lược đồ GraphQL có thể được tìm thấy trong phần [GraphQL API](/developer/graphql-api).

## Xác định các Thực thể

Trước khi xác định các thực thể (entities), điều quan trọng là phải lùi lại một bước và suy nghĩ về cách dữ liệu của bạn được cấu trúc và liên kết. Tất cả các truy vấn sẽ được thực hiện dựa trên mô hình dữ liệu được xác định trong lược đồ subgraph và các thực thể được lập chỉ mục bởi subgraph. Bởi vì điều này, rất tốt để xác định lược đồ subgraph theo cách phù hợp với nhu cầu của dapp của bạn. Có thể hữu ích khi hình dung các thực thể là "đối tượng chứa dữ liệu", chứ không phải là các sự kiện hoặc chức năng.

Với The Graph, bạn chỉ cần xác định các loại thực thể trong `schema.graphql` và Graph Node sẽ tạo ra các trường cấp cao nhất để truy vấn các trường hợp và tập hợp đơn lẻ của loại thực thể đó. Mỗi loại phải là một thực thể bắt buộc phải được chú thích bằng chỉ thị `@entity`.

### Ví dụ tốt

Thực thể `Gravatar` bên dưới được cấu trúc xung quanh một đối tượng Gravatar và là một ví dụ điển hình về cách một thực thể có thể được xác định.

```graphql
type Gravatar @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Ví dụ tồi

Ví dụ về các thực thể `GravatarAccepted` và `GravatarDecline` bên dưới dựa trên các sự kiện. Không nên ánh xạ các sự kiện hoặc lệnh gọi hàm tới các thực thể 1: 1.

```graphql
type GravatarAccepted @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Các trường tùy chọn và bắt buộc

Các trường thực thể có thể được xác định theo yêu cầu hoặc tùy chọn. Các trường bắt buộc được biểu thị bằng `!` trong lược đồ. Nếu trường bắt buộc không được đặt trong ánh xạ, bạn sẽ nhận được lỗi này khi truy vấn trường:

```
Giá trị rỗng (null) được giải quyết cho trường không phải null 'name'
```

Mỗi thực thể phải có một trường `id`, thuộc loại `ID!` (string). Trường `id` đóng vai trò là khóa chính và cần phải là duy nhất giữa tất cả các thực thể cùng loại.

### Các loại vô hướng tích hợp

#### GraphQL Vô hướng được hỗ trợ

Chúng tôi hỗ trợ các đại lượng vô hướng sau trong API GraphQL của chúng tôi:

| Loại | Miêu tả |
| --- | --- |
| `Bytes` | Mảng byte, được biểu diễn dưới dạng chuỗi thập lục phân. Thường được sử dụng cho các mã băm và địa chỉ Ethereum. |
| `ID` | Được lưu trữ dưới dạng `string`. |
| `String` | Vô hướng cho các giá trị `string`. Các ký tự rỗng không được hỗ trợ và tự động bị xóa. |
| `Boolean` | Vô hướng cho các giá trị `boolean`. |
| `Int` | Thông số GraphQL xác định `Int` có kích thước 32 byte. |
| `BigInt` | Số nguyên lớn. Được sử dụng cho các loại `uint32`, `int64`, `uint64`, ..., `uint256` của Ethereum. Lưu ý: mọi thứ dưới `uint32`, như là `int32`, `uint24` or `int8` được đại diện như là `i32`. |
| `BigDecimal` | `BigDecimal` Các số thập phân có độ chính xác cao được biểu diễn dưới dạng dấu hiệu và số mũ. Phạm vi số mũ là từ −6143 đến +6144. Được làm tròn đến 34 chữ số có nghĩa. |

#### Enums

Bạn cũng có thể tạo enums trong một lược đồ. Enums có cú pháp sau:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Khi enum được xác định trong lược đồ, bạn có thể sử dụng biểu diễn chuỗi của giá trị enum để đặt một trường enum trên một thực thể. Ví dụ: bạn có thể đặt `tokenStatus` thành `SecondOwner` bằng cách xác định thực thể của bạn trước tiên và sau đó đặt trường với `entity.tokenStatus = "SecondOwner`. Ví dụ bên dưới minh họa thực thể Token sẽ trông như thế nào với trường enum:

Bạn có thể tìm thấy thêm chi tiết về cách viết enums trong [Tài liệu GraphQL](https://graphql.org/learn/schema/).

#### Mối quan hệ thực thể

Một thực thể có thể có mối quan hệ với một hoặc nhiều thực thể khác trong lược đồ của bạn. Những mối quan hệ này có thể được duyệt qua trong các truy vấn của bạn. Các mối quan hệ trong The Graph là một chiều. Có thể mô phỏng mối quan hệ hai chiều bằng cách xác định mối quan hệ một chiều ở một trong hai "điểm cuối" của mối quan hệ.

Mối quan hệ được xác định trên các thực thể giống như bất kỳ trường nào khác ngoại trừ kiểu được chỉ định là của một thực thể khác.

#### Mối quan hệ một-một

Xác định loại thực thể `Transaction` với mối quan hệ 1-1 tùy chọn với loại thực thể `TransactionReceipt`:

```graphql
type Transaction @entity {
  id: ID!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity {
  id: ID!
  transaction: Transaction
}
```

#### Mối quan hệ một-nhiều

Xác định loại thực thể `TokenBalance` với mối quan hệ một-nhiều bắt buộc với loại thực thể Token:

```graphql
type Token @entity {
  id: ID!
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}
```

#### Tra cứu ngược

Tra cứu ngược có thể được xác định trên một thực thể thông qua trường `@derivedFrom`. Điều này tạo ra một trường ảo trên thực thể có thể được truy vấn nhưng không thể được đặt theo cách thủ công thông qua API ánh xạ. Đúng hơn, nó có nguồn gốc từ mối quan hệ được xác định trên thực thể khác. Đối với các mối quan hệ như vậy, hiếm khi có ý nghĩa khi lưu trữ cả hai bên của mối quan hệ và cả hiệu suất lập chỉ mục và truy vấn sẽ tốt hơn khi chỉ một bên được lưu trữ và bên kia được dẫn xuất.

Đối với các mối quan hệ một-nhiều, mối quan hệ phải luôn được lưu trữ ở bên 'một' và bên 'nhiều' phải luôn được bắt nguồn. Lưu trữ mối quan hệ theo cách này, thay vì lưu trữ một mảng các thực thể ở phía 'nhiều', sẽ dẫn đến hiệu suất tốt hơn đáng kể cho cả lập chỉ mục và truy vấn subgraph. Nói chung, việc lưu trữ các mảng thực thể nên tránh càng nhiều càng tốt.

#### Ví dụ

Chúng tôi có thể tạo số dư cho một token có thể truy cập được từ token bằng cách lấy trường `tokenBalances`:

```graphql
type Token @entity {
  id: ID!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}
```

#### Mối quan hệ nhiều-nhiều

Đối với các mối quan hệ nhiều-nhiều, chẳng hạn như người dùng mà mỗi người có thể thuộc bất kỳ số lượng tổ chức nào, thì cách đơn giản nhất, nhưng không phải là hoạt động hiệu quả nhất, để lập mô hình mối quan hệ là một mảng trong mỗi thực thể trong số hai thực thể có liên quan. Nếu mối quan hệ là đối xứng, chỉ một mặt của mối quan hệ cần được lưu trữ và mặt còn lại có thể được suy ra.

#### Ví dụ

Xác định tra cứu ngược từ loại thực thể `User` đến một loại thực thể `Organization`. Trong ví dụ dưới đây, điều này đạt được bằng cách tra cứu thuộc tính `members` từ bên trong thực thể `Organization`. Trong các truy vấn, trường `organizations` trên `User` sẽ được giải quyết bằng cách tìm tất cả các thực thể `Organization` bao gồm ID của người dùng.

```graphql
type Organization @entity {
  id: ID!
  name: String!
  members: [User!]!
}

type User @entity {
  id: ID!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Một cách hiệu quả hơn để lưu trữ mối quan hệ này là thông qua bảng ánh xạ có một mục nhập cho mỗi cặp `User` / `Organization` với một lược đồ như

```graphql
type Organization @entity {
  id: ID!
  name: String!
  members: [UserOrganization]! @derivedFrom(field: "organization")
}

type User @entity {
  id: ID!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "user")
}

type UserOrganization @entity {
  id: ID! # Set to `${user.id}-${organization.id}`
  user: User!
  organization: Organization!
}
```

Cách tiếp cận này yêu cầu các truy vấn giảm xuống một cấp bổ sung để truy xuất, ví dụ: tổ chức cho người dùng:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

Cách lưu trữ các mối quan hệ nhiều-nhiều phức tạp hơn này sẽ dẫn đến việc lưu trữ ít dữ liệu hơn cho subgraph, và do đó, một subgraph thường nhanh hơn đáng kể để lập chỉ mục và truy vấn.

#### Thêm nhận xét vào lược đồ

Theo thông số kỹ thuật của GraphQL, các nhận xét có thể được thêm vào bên trên các thuộc tính thực thể lược đồ bằng cách sử dụng dấu ngoặc kép `""`. Điều này được minh họa trong ví dụ dưới đây:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  address: Bytes!
}
```

## Xác định các Trường Tìm kiếm toàn Văn bản

Truy vấn tìm kiếm toàn văn bản lọc và xếp hạng các thực thể dựa trên đầu vào tìm kiếm văn bản. Các truy vấn toàn văn bản có thể trả về các kết quả phù hợp cho các từ tương tự bằng cách xử lý đầu vào văn bản truy vấn thành các gốc trước khi so sánh với dữ liệu văn bản được lập chỉ mục.

Định nghĩa truy vấn toàn văn bao gồm tên truy vấn, từ điển ngôn ngữ được sử dụng để xử lý các trường văn bản, thuật toán xếp hạng được sử dụng để sắp xếp kết quả và các trường được bao gồm trong tìm kiếm. Mỗi truy vấn toàn văn bản có thể kéo dài nhiều trường, nhưng tất cả các trường được bao gồm phải từ một loại thực thể duy nhất.

Để thêm truy vấn toàn văn bản, hãy bao gồm loại `_Schema_` với chỉ thị toàn văn bản trong lược đồ GraphQL.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: ID!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

Trường `bandSearch` mẫu có thể được sử dụng trong các truy vấn để lọc các thực thể `Band` dựa trên các tài liệu văn bản trong `name`, `description` và các trường `bio`. Chuyển đến [GraphQL API - Truy vấn](/developer/graphql-api#queries) để biết mô tả về API tìm kiếm Toàn văn bản và để biết thêm ví dụ về cách sử dụng.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Quản lý Tính năng](#experimental-features):** Từ `specVersion` `0.0.4` và trở đi, `fullTextSearch` phải được khai báo dưới phần `features` trong tệp kê khai subgraph.

### Các ngôn ngữ được hỗ trợ

Việc chọn một ngôn ngữ khác sẽ có tác động dứt khoát, mặc dù đôi khi hơi tinh tế, đối với API tìm kiếm toàn văn bản. Các trường được bao phủ bởi trường truy vấn toàn văn bản được kiểm tra trong ngữ cảnh của ngôn ngữ đã chọn, vì vậy các từ vựng được tạo ra bởi phân tích và truy vấn tìm kiếm khác nhau giữa ngôn ngữ. Ví dụ: khi sử dụng từ điển tiếng Thổ Nhĩ Kỳ được hỗ trợ, "token" được đặt gốc thành "toke" trong khi tất nhiên, từ điển tiếng Anh sẽ bắt nguồn từ "token".

Từ điển ngôn ngữ được hỗ trợ:

| Mã     | Từ điển           |
| ------ | ----------------- |
| simple | Khái quát         |
| da     | Tiếng Đan Mạch    |
| nl     | Tiếng Hà Lan      |
| en     | Tiếng Anh         |
| fi     | Tiếng Phần Lan    |
| fr     | Tiếng Pháp        |
| de     | Tiếng Đức         |
| hu     | Tiếng Hungary     |
| it     | Tiếng Ý           |
| no     | Tiếng Na uy       |
| pt     | Tiếng Bồ Đào Nha  |
| ro     | Tiếng Rumani      |
| ru     | Tiếng Nga         |
| es     | Tiếng Tây Ban Nha |
| sv     | Tiếng Thụy Điển   |
| tr     | Tiếng Thổ Nhĩ Kỳ  |

### Thuật toán Xếp hạng

Các thuật toán được hỗ trợ để sắp xếp kết quả:

| Thuật toán    | Miêu tả                                                                         |
| ------------- | ------------------------------------------------------------------------------- |
| xếp hạng      | Sử dụng chất lượng đối sánh (0-1) của truy vấn toàn văn bản để sắp xếp kết quả. |
| proximityRank | Tương tự như rank nhưng cũng bao gồm các kết quả tương tự gần giống.            |

## Viết Ánh xạ

Các ánh xạ biến đổi dữ liệu Ethereum mà các ánh xạ của bạn đang cung cấp thành các thực thể được xác định trong lược đồ của bạn. Các ánh xạ được viết trong một tập hợp con của [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) được gọi là [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki) có thể được biên dịch thành WASM ([WebAssembly](https://webassembly.org/)). AssemblyScript nghiêm ngặt hơn TypeScript bình thường, nhưng vẫn cung cấp một cú pháp quen thuộc.

Đối với mỗi trình xử lý sự kiện được xác định trong `subgraph.yaml` dưới `mapping.eventHandlers`, tạo một hàm xuất cùng tên. Mỗi trình xử lý phải chấp nhận một tham số duy nhất được gọi là `event` với kiểu tương ứng với tên của sự kiện đang được xử lý.

Trong subgraph mẫu, `src/mapping.ts` chứa các trình xử lý cho `NewGravatar` và các sự kiện `UpdatedGravatar`:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id.toHex()
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

Trình xử lý đầu tiên lấy một sự kiện `NewGravatar` và tạo một thực thể `Gravatar` mới với `new Gravatar(event.params.id.toHex())`, điền các trường thực thể bằng cách sử dụng các tham số sự kiện tương ứng. Cá thể thực thể này được đại diện bởi biến `gravatar`, với giá trị id là `event.params.id.toHex()`.

Trình xử lý thứ hai cố gắng tải `Gravatar` hiện có từ cửa hàng Graph Node. Nếu nó chưa tồn tại, nó được tạo ra theo yêu cầu. Sau đó, thực thể được cập nhật để khớp với các tham số sự kiện mới, trước khi được lưu trở lại cửa hàng bằng cách sử dụng `gravatar.save()`.

### Các ID được Đề xuất để tạo các Thực thể Mới

Mọi thực thể phải có `id` là duy nhất trong số tất cả các thực thể cùng loại. Giá trị `id` của đối tượng được đặt khi đối tượng được tạo. Dưới đây là một số giá trị `id` được đề xuất cần xem xét khi tạo các thực thể mới. LƯU Ý: Giá trị của `id` phải là một `string`.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

Chúng tôi cung cấp [Thư viện Typescript Graph](https://github.com/graphprotocol/graph-ts) chứa các tiện ích để tương tác với cửa hàng Graph Node và các tiện ích để xử lý dữ liệu hợp đồng thông minh và các thực thể. Bạn có thể sử dụng thư viện này trong ánh xạ của mình bằng cách nhập `@graphprotocol/graph-ts` trong `mapping.ts`.

## Tạo mã

Để làm cho các hợp đồng, sự kiện và thực thể thông minh hoạt động dễ dàng và an toàn về kiểu, Graph CLI có thể tạo các loại AssemblyScript từ lược đồ GraphQL của subgraph và các ABI hợp đồng được bao gồm trong các nguồn dữ liệu.

Điều này được thực hiện với

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

nhưng trong hầu hết các trường hợp, các subgraph đã được định cấu hình trước qua `package.json` để cho phép bạn chỉ cần chạy một trong những thao tác sau để đạt được điều tương tự:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

Điều này sẽ tạo ra một lớp AssemblyScript cho mọi hợp đồng thông minh trong các tệp ABI được đề cập trong `subgraph.yaml`, cho phép bạn liên kết các hợp đồng này với các địa chỉ cụ thể trong ánh xạ và gọi các phương thức hợp đồng chỉ đọc đối với khối đang xử lý. Nó cũng sẽ tạo một lớp cho mọi sự kiện hợp đồng để cung cấp khả năng truy cập dễ dàng vào các tham số sự kiện cũng như khối và giao dịch mà sự kiện bắt nguồn từ đó. Tất cả các loại này đều được ghi vào `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts`. Trong subgraph mẫu, đây sẽ là `generated/Gravity/Gravity.ts`, cho phép các ánh xạ nhập các loại này với

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

Ngoài ra, một lớp được tạo cho mỗi loại thực thể trong lược đồ GraphQL của đồ thị con. Các lớp này cung cấp quyền truy cập tải, đọc và ghi thực thể an toàn kiểu đối với các trường thực thể cũng như phương thức `save()` để ghi các thực thể vào lưu trữ. Tất cả các lớp thực thể được ghi vào `<OUTPUT_DIR>/schema.ts`,, cho phép các ánh xạ nhập chúng với

```javascript
import { Gravatar } from '../generated/schema'
```

> **Lưu ý:** Việc tạo mã phải được thực hiện lại sau mỗi lần thay đổi đối với giản đồ GraphQL hoặc ABI có trong tệp kê khai. Nó cũng phải được thực hiện ít nhất một lần trước khi xây dựng hoặc triển khai subgraph.

Tạo mã không kiểm tra mã ánh xạ của bạn trong `src/mapping.ts`. Nếu bạn muốn kiểm tra điều đó trước khi cố gắng triển khai subgraph của mình cho Graph Explorer, bạn có thể chạy `yarn build` và sửa bất kỳ lỗi cú pháp nào mà trình biên dịch TypeScript có thể tìm thấy.

## Mẫu Nguồn Dữ liệu

Một mô hình phổ biến trong hợp đồng thông minh Ethereum là sử dụng hợp đồng đăng ký hoặc hợp đồng nhà máy, trong đó một hợp đồng tạo, quản lý hoặc tham chiếu đến một số lượng tùy ý các hợp đồng khác mà mỗi hợp đồng có trạng thái và sự kiện riêng. Địa chỉ của các hợp đồng phụ này có thể được biết trước hoặc có thể không được biết trước và nhiều hợp đồng trong số này có thể được tạo và / hoặc thêm vào theo thời gian. Đây là lý do tại sao, trong những trường hợp như vậy, việc xác định một nguồn dữ liệu duy nhất hoặc một số lượng nguồn dữ liệu cố định là không thể và cần có một cách tiếp cận năng động hơn: _các mẫu nguồn dữ liệu_.

### Nguồn Dữ liệu cho Hợp đồng Chính

Đầu tiên, bạn xác định nguồn dữ liệu thông thường cho hợp đồng chính. Đoạn mã dưới đây hiển thị nguồn dữ liệu mẫu đơn giản cho hợp đồng exchange factory của [Uniswap](https://uniswap.io). Lưu ý trình xử lý sự kiện `NewExchange(address,address)`. Điều này được tạo ra khi một hợp đồng exchange mới được tạo ra trên chuỗi bởi hợp đồng factory.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Mẫu Nguồn Dữ liệu cho các Hợp đồng được Tạo Tự động

Sau đó, bạn thêm _mẫu nguồn dữ liệu_ vào tệp kê khai. Chúng giống với các nguồn dữ liệu thông thường, ngoại trừ việc chúng thiếu địa chỉ hợp đồng được xác định trước trong `source`. Thông thường, bạn sẽ xác định một mẫu cho từng loại hợp đồng phụ do hợp đồng mẹ quản lý hoặc tham chiếu.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Khởi tạo một Mẫu Nguồn Dữ liệu

Trong bước cuối cùng, bạn cập nhật ánh xạ hợp đồng chính của mình để tạo phiên bản nguồn dữ liệu động từ một trong các mẫu. Trong ví dụ này, bạn sẽ thay đổi ánh xạ hợp đồng chính để nhập mẫu `Exchange` và gọi phương thức `Exchange.create(address)` trên đó để bắt đầu lập chỉ mục hợp đồng exchange mới.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **Lưu ý:** Nguồn dữ liệu mới sẽ chỉ xử lý các lệnh gọi và sự kiện cho khối mà nó được tạo và tất cả các khối tiếp theo, nhưng sẽ không xử lý dữ liệu lịch sử, tức là dữ liệu được chứa trong các khối trước đó.
>
> Nếu các khối trước đó chứa dữ liệu có liên quan đến nguồn dữ liệu mới, tốt nhất là lập chỉ mục dữ liệu đó bằng cách đọc trạng thái hiện tại của hợp đồng và tạo các thực thể đại diện cho trạng thái đó tại thời điểm nguồn dữ liệu mới được tạo.

### Bối cảnh Nguồn Dữ liệu

Các ngữ cảnh nguồn dữ liệu cho phép chuyển cấu hình bổ sung khi khởi tạo một mẫu. Trong ví dụ của chúng tôi, giả sử các sàn giao dịch được liên kết với một cặp giao dịch cụ thể, được bao gồm trong sự kiện `NewExchange`. Thông tin đó có thể được chuyển vào nguồn dữ liệu được khởi tạo, như sau:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Bên trong ánh xạ của mẫu `Exchange`, ngữ cảnh sau đó có thể được truy cập:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Có các setters và getters như `setString` và `getString` cho tất cả các loại giá trị.

## Khối Bắt đầu

`startBlock` là một cài đặt tùy chọn cho phép bạn xác định từ khối nào trong chuỗi mà nguồn dữ liệu sẽ bắt đầu lập chỉ mục. Đặt khối bắt đầu cho phép nguồn dữ liệu bỏ qua hàng triệu khối có khả năng không liên quan. Thông thường, một nhà phát triển subgraph sẽ đặt `startBlock` thành khối mà hợp đồng thông minh của nguồn dữ liệu được tạo.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Lưu ý:** Khối tạo hợp đồng có thể được nhanh chóng tra cứu trên Etherscan:
>
> 1. Tìm kiếm hợp đồng bằng cách nhập địa chỉ của nó vào thanh tìm kiếm.
> 2. Nhấp vào băm giao dịch tạo trong phần `Contract Creator`.
> 3. Tải trang chi tiết giao dịch nơi bạn sẽ tìm thấy khối bắt đầu cho hợp đồng đó.

## Trình xử lý lệnh gọi

Trong khi các sự kiện cung cấp một cách hiệu quả để thu thập các thay đổi liên quan đến trạng thái của hợp đồng, nhiều hợp đồng tránh tạo log để tối ưu hóa chi phí gas. Trong những trường hợp này, một subgraph có thể đăng ký các lệnh gọi được thực hiện tới hợp đồng nguồn dữ liệu. Điều này đạt được bằng cách xác định tham chiếu trình xử lý lệnh gọi đến chữ ký hàm và trình xử lý ánh xạ sẽ xử lý các cuộc gọi đến hàm này. Để xử lý các lệnh gọi này, trình xử lý ánh xạ sẽ nhận được `ethereum.Call` làm đối số với các đầu vào và đầu ra đã nhập từ lệnh gọi. Các lệnh gọi được thực hiện ở bất kỳ độ sâu nào trong chuỗi lệnh gọi của giao dịch sẽ kích hoạt ánh xạ, cho phép ghi lại hoạt động với hợp đồng nguồn dữ liệu thông qua các hợp đồng ủy quyền.

Trình xử lý lệnh gọi sẽ chỉ kích hoạt trong một trong hai trường hợp: khi hàm được chỉ định được gọi bởi một tài khoản khác với chính hợp đồng hoặc khi nó được đánh dấu là bên ngoài (external) trong Solidity và được gọi như một phần của một chức năng khác trong cùng một hợp đồng.

> **Lưu ý:** Trình xử lý lệnh gọi không được hỗ trợ trên Rinkeby, Goerli hoặc Ganache. Các trình xử lý lệnh gọi hiện phụ thuộc vào API theo dõi Parity và các mạng này không hỗ trợ nó.

### Xác định một Trình xử lý lệnh gọi

Để xác định trình xử lý lệnh gọi trong tệp kê khai của bạn, chỉ cần thêm mảng `callHandlers` dưới nguồn dữ liệu bạn muốn đăng ký.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

Hàm `function` là chữ ký hàm được chuẩn hóa để lọc các lệnh call. Thuộc tính `handler` là tên của hàm trong ánh xạ của bạn mà bạn muốn thực thi khi hàm đích được gọi trong hợp đồng nguồn dữ liệu.

### Chức năng Ánh xạ

Mỗi trình xử lý lệnh gọi nhận một tham số duy nhất có kiểu tương ứng với tên của hàm được gọi. Trong đoạn phụ mẫu ở trên, ánh xạ chứa trình xử lý khi hàm `createGravatar` được gọi và nhận tham số `CreateGravatarCall` làm đối số:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash.toHex()
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

Hàm `handleCreateGravatar` lấy một `CreateGravatarCall` mới, là một lớp con của `ethereum.Call`, được cung cấp bởi `@graphprotocol/graph-ts`, bao gồm các đầu vào và đầu ra đã nhập của lệnh gọi. Loại `CreateGravatarCall` được tạo cho bạn khi bạn chạy `graph codegen`.

## Trình xử lý Khối

Ngoài việc đăng ký các sự kiện hợp đồng hoặc lệnh gọi hàm, một subgraph có thể muốn cập nhật dữ liệu của nó khi các khối mới được thêm vào chuỗi. Để đạt được điều này, một subgraph có thể chạy một hàm sau mỗi khối hoặc sau các khối phù hợp với một bộ lọc được xác định trước.

### Bộ lọc được hỗ trợ

```yaml
filter:
  kind: call
```

_Trình xử lý đã xác định sẽ được gọi một lần cho mỗi khối chứa lệnh gọi đến hợp đồng (nguồn dữ liệu) mà trình xử lý được định nghĩa theo._

Việc không có bộ lọc cho trình xử lý khối sẽ đảm bảo rằng trình xử lý được gọi là mọi khối. Nguồn dữ liệu chỉ có thể chứa một trình xử lý khối cho mỗi loại bộ lọc.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### Chức năng Ánh xạ

Hàm ánh xạ sẽ nhận `ethereum.Block` làm đối số duy nhất của nó. Giống như các chức năng ánh xạ cho các sự kiện, chức năng này có thể truy cập các thực thể subgraph hiện có trong cửa hàng, gọi các hợp đồng thông minh và tạo hoặc cập nhật các thực thể.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash.toHex()
  let entity = new Block(id)
  entity.save()
}
```

## Sự kiện Ẩn danh

Nếu bạn cần xử lý các sự kiện ẩn danh trong Solidity, bạn có thể đạt được điều đó bằng cách cung cấp chủ đề 0 của sự kiện, như trong ví dụ:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0xbaa8529c00000000000000000000000000000000000000000000000000000000'
    handler: handleGive
```

Một sự kiện sẽ chỉ được kích hoạt khi cả chữ ký và chủ đề 0 trùng khớp. Theo mặc định, `topic0` bằng với hàm băm của chữ ký sự kiện.

## Các tính năng thử nghiệm

Bắt đầu từ `specVersion` `0.0.4`, các tính năng của subgraph phải được khai báo rõ ràng trong phần `features` ở cấp cao nhất của tệp kê khai, bằng cách sử dụng `camelCase` name, như được liệt kê trong bảng bên dưới:

| Tính năng                                                  | Tên                       |
| ---------------------------------------------------------- | ------------------------- |
| [Lỗi không nghiêm trọng](#non-fatal-errors)                | `nonFatalErrors`          |
| [Tìm kiếm toàn văn](#defining-fulltext-search-fields)      | `fullTextSearch`          |
| [Ghép](#grafting-onto-existing-subgraphs)                  | `grafting`                |
| [IPFS trên hợp đồng Ethereum](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` |

Ví dụ: nếu một subgraph sử dụng các tính năng **Tìm kiếm toàn văn** và **Lỗi không nghiệm trọng**, thì < trường `features` trong tệp kê khai phải là:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Lưu ý rằng việc sử dụng một tính năng mà không khai báo nó sẽ gặp phải **lỗi xác thực** trong quá trình triển khai subgraph, nhưng sẽ không có lỗi nào xảy ra nếu một tính năng được khai báo nhưng không được sử dụng.

### IPFS trên hợp đồng Ethereum

Một trường hợp sử dụng phổ biến để kết hợp IPFS với Ethereum là lưu trữ dữ liệu trên IPFS sẽ quá đắt để duy trì trên chuỗi và tham chiếu hàm băm IPFS trong các hợp đồng Ethereum.

Với các hàm băm IPFS như vậy, các subgraph có thể đọc các tệp tương ứng từ IPFS bằng cách sử dụng `ipfs.cat` và `ipfs.map`. Tuy nhiên, để thực hiện điều này một cách đáng tin cậy, yêu cầu các tệp này phải được ghim trên nút IPFS mà Graph Node lập chỉ mục subgraph kết nối với. Trong trường hợp của [dịch vụ được lưu trữ](https://thegraph.com/hosted-service), đây là [https://api.thegraph.com/ipfs/](https://api.thegraph.com/ipfs/).

> **Lưu ý:** Mạng The Graph chưa hỗ trợ `ipfs.cat` and `ipfs.map`, và các nhà phát triển không nên triển khai các subgraphs sử dụng chức năng đó vào mạng thông qua Studio.

Để giúp các nhà phát triển subgraph trở nên dễ dàng, đội ngũ The Graph đã viết một công cụ để truyền tệp từ node IPFS này sang node IPFS khác, được gọi là [ipfs-sync](https://github.com/graphprotocol/ipfs-sync).

> **[Quản lý Tính năng](#experimental-features):** `ipfsOnEthereumContracts` phải được khai báo dưới `features` trong tệp kê khai subgraph.

### Lỗi không nghiêm trọng

Theo mặc định, lỗi lập chỉ mục trên các subgrap đã được đồng bộ hóa sẽ làm cho subgraph bị lỗi và ngừng đồng bộ hóa. Theo cách khác, các subgraph có thể được định cấu hình để tiếp tục đồng bộ hóa khi có lỗi, bằng cách bỏ qua các thay đổi do trình xử lý thực hiện gây ra lỗi. Điều này cho phép các tác giả bài subgraph có thời gian để sửa các subgraph của họ trong khi các truy vấn tiếp tục được phân phát đối với khối mới nhất, mặc dù kết quả có thể sẽ không nhất quán do lỗi gây ra lỗi. Lưu ý rằng một số lỗi vẫn luôn gây tử vong, để không nghiêm trọng thì lỗi đó phải được biết là có tính xác định.

> **Lưu ý:** Mạng The Graph chưa hỗ trợ các lỗi không nghiêm trọng và các nhà phát triển không nên triển khai các subgraph sử dụng chức năng đó vào mạng thông qua Studio.

Việc kích hoạt lỗi không nghiêm trọng yêu cầu đặt cờ tính năng sau trên tệp kê khai subgraph:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - fullTextSearch
    ...
```

Truy vấn cũng phải chọn tham gia truy vấn dữ liệu có khả năng mâu thuẫn thông qua đối số `subgraphError`. Bạn cũng nên truy vấn `_meta` để kiểm tra xem subgraph có bỏ qua lỗi hay không, như trong ví dụ:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

Nếu subgraph gặp lỗi, truy vấn sẽ trả về cả dữ liệu và lỗi graphql với thông báo `"indexing_error"`, như trong phản hồi ví dụ này:

```graphql
"data": {
    "foos": [
        {
          "id": "fooId"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Ghép vào các Subgraph Hiện có

Khi một subgraph được triển khai lần đầu tiên, nó bắt đầu lập chỉ mục các sự kiện tại khối khởi đầu của chuỗi tương ứng (hoặc tại `startBlock` được xác định với mỗi nguồn dữ liệu) Trong một số trường hợp, việc sử dụng lại dữ liệu từ một subgraph hiện có và bắt đầu lập chỉ mục ở một khối muộn hơn nhiều. Chế độ lập chỉ mục này được gọi là _Grafting_ (Ghép). Ví dụ, ghép là hữu ích trong quá trình phát triển để nhanh chóng vượt qua các lỗi đơn giản trong ánh xạ hoặc để tạm thời làm cho một subgraph hiện có hoạt động trở lại sau khi nó bị lỗi.

> **Lưu ý:** Việc ghép yêu cầu Indexer đã lập chỉ mục cho subgraph cơ sở. Nó không được khuyến nghị trên Mạng The Graph vào lúc này và các nhà phát triển không nên triển khai các subgraph sử dụng chức năng đó vào mạng thông qua Studio.

Một subgraph được ghép vào một subgraph cơ sở khi bản kê khai subgraph trong `subgraph.yaml` chứa một khối `graft` ở cấp trên cùng:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

Khi một subgraph có tệp kê khai chứa khối `graft` được triển khai, Graph Node sẽ sao chép dữ liệu của subgraph `base` lên đến và bao gồm cả `block` đã cho và sau đó tiếp tục lập chỉ mục cho subgraph mới từ khối đó trở đi. Subgraph cơ sở phải tồn tại trên phiên bản Graph Node mục tiêu và phải được lập chỉ mục tối thiểu là khối nhất định. Do hạn chế này, việc ghép chỉ nên được sử dụng trong quá trình phát triển hoặc trong trường hợp khẩn cấp để tăng tốc độ tạo ra một subgraph không ghép tương đương.

Bởi vì việc ghép các bản sao thay vì lập chỉ mục dữ liệu cơ sở, việc đưa subgraph đến khối mong muốn nhanh hơn nhiều so với việc lập chỉ mục từ đầu, mặc dù bản sao dữ liệu ban đầu vẫn có thể mất vài giờ đối với các subgraph rất lớn. Trong khi subgraph được ghép đang được khởi tạo, Graph Node sẽ ghi thông tin về các loại thực thể đã được sao chép.

Subgraph được ghép có thể sử dụng một lược đồ GraphQL không giống với một trong subgraph cơ sở, nhưng chỉ tương thích với nó. Nó phải là một lược đồ subgraph hợp lệ theo đúng nghĩa của nó nhưng có thể đi chệch khỏi lược đồ của subgraph cơ sở theo những cách sau:

- Nó thêm hoặc xóa các loại thực thể
- Nó loại bỏ các thuộc tính khỏi các loại thực thể
- Nó thêm các thuộc tính nullable vào các loại thực thể
- Nó biến các thuộc tính không thể nullable thành các thuộc tính nullable
- Nó thêm giá trị vào enums
- Nó thêm hoặc xóa các giao diện
- Nó thay đổi đối với loại thực thể nào mà một giao diện được triển khai

> **[Quản lý Tính năng](#experimental-features):** `grafting` phải được khai báo dưới`features` trong tệp kê khai subgraph.
