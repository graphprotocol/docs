---
title: Khung Unit Test
---

Matchstick lÃ  má»™t khung unit test Ä‘Æ°á»£c phÃ¡t triá»ƒn bá»Ÿi [LimeChain](https://limechain.tech/), cho phÃ©p cÃ¡c nhÃ  phÃ¡t triá»ƒn subgraph kiá»ƒm tra logic Ã¡nh xáº¡ cá»§a há» trong mÃ´i trÆ°á»ng há»™p cÃ¡t vÃ  tá»± tin triá»ƒn khai cÃ¡c subgraph cá»§a há»!

LÃ m theo [hÆ°á»›ng dáº«n cÃ i Ä‘áº·t Matchstick](https://github.com/LimeChain/matchstick/blob/main/README.md#quick-start-) Ä‘á»ƒ cÃ i Ä‘áº·t. BÃ¢y giá», báº¡n cÃ³ thá»ƒ chuyá»ƒn sang viáº¿t bÃ i unit test Ä‘áº§u tiÃªn cá»§a mÃ¬nh.

## Viáº¿t Unit Test

HÃ£y xem má»™t bÃ i kiá»ƒm tra Ä‘Æ¡n vá»‹ Ä‘Æ¡n giáº£n sáº½ trÃ´ng nhÆ° tháº¿ nÃ o, báº±ng cÃ¡ch sá»­ dá»¥ng [Subgraph máº«u](https://github.com/graphprotocol/example-subgraph) Gravatar.

Giáº£ sá»­ chÃºng ta cÃ³ hÃ m xá»­ lÃ½ sau (cÃ¹ng vá»›i hai hÃ m trá»£ giÃºp Ä‘á»ƒ lÃ m cho cuá»™c sá»‘ng cá»§a chÃºng ta dá»… dÃ ng hÆ¡n):

```javascript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress))
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

We first have to create a test file in our project. This is an example of how that might look like:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})

```

KhÃ¡ nhiá»u Ä‘á»ƒ giáº£i thÃ­ch nhá»‰? TrÆ°á»›c háº¿t, má»™t Ä‘iá»u quan trá»ng cáº§n lÆ°u Ã½ lÃ  chÃºng ta Ä‘ang nháº­p má»i thá»© tá»« `matchstick-as`, thÆ° viá»‡n trÃ¬nh trá»£ giÃºp AssemblyScript cá»§a chÃºng ta (Ä‘Æ°á»£c phÃ¢n phá»‘i dÆ°á»›i dáº¡ng mÃ´-Ä‘un npm). Báº¡n cÃ³ thá»ƒ tÃ¬m tháº¥y kho lÆ°u trá»¯ [táº¡i Ä‘Ã¢y](https://github.com/LimeChain/matchstick-as). `matchstick-as` cung cáº¥p cho chÃºng ta cÃ¡c phÆ°Æ¡ng phÃ¡p kiá»ƒm tra há»¯u Ã­ch vÃ  cÅ©ng xÃ¡c Ä‘á»‹nh hÃ m `test()` mÃ  chÃºng ta sáº½ sá»­ dá»¥ng Ä‘á»ƒ xÃ¢y dá»±ng cÃ¡c khá»‘i kiá»ƒm tra cá»§a mÃ¬nh. Pháº§n cÃ²n láº¡i cá»§a nÃ³ khÃ¡ Ä‘Æ¡n giáº£n - Ä‘Ã¢y lÃ  nhá»¯ng gÃ¬ sáº½ xáº£y ra:

- ChÃºng ta Ä‘ang thiáº¿t láº­p tráº¡ng thÃ¡i ban Ä‘áº§u vÃ  thÃªm má»™t thá»±c thá»ƒ Gravatar tÃ¹y chá»‰nh;
- ChÃºng ta xÃ¡c Ä‘á»‹nh hai Ä‘á»‘i tÆ°á»£ng sá»± kiá»‡n `NewGravatar` cÃ¹ng vá»›i dá»¯ liá»‡u cá»§a chÃºng, sá»­ dá»¥ng hÃ m `createNewGravatarEvent()`;
- ChÃºng ta Ä‘ang gá»i cÃ¡c phÆ°Æ¡ng thá»©c xá»­ lÃ½ cho cÃ¡c sá»± kiá»‡n Ä‘Ã³ - `handleNewGravatars()` vÃ  chuyá»ƒn vÃ o danh sÃ¡ch cÃ¡c sá»± kiá»‡n tÃ¹y chá»‰nh cá»§a chÃºng ta;
- ChÃºng ta kháº³ng Ä‘á»‹nh tráº¡ng thÃ¡i cá»§a cá»­a hÃ ng. NÃ³ hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o? - ChÃºng ta Ä‘ang chuyá»ƒn má»™t sá»± káº¿t há»£p duy nháº¥t cá»§a loáº¡i Thá»±c thá»ƒ vÃ  id. Sau Ä‘Ã³, chÃºng ta kiá»ƒm tra má»™t trÆ°á»ng cá»¥ thá»ƒ trÃªn Äá»‘i tÆ°á»£ng Ä‘Ã³ vÃ  kháº³ng Ä‘á»‹nh ráº±ng nÃ³ cÃ³ giÃ¡ trá»‹ mÃ  chÃºng ta mong Ä‘á»£i. ChÃºng ta Ä‘ang lÃ m Ä‘iá»u nÃ y cho cáº£ Thá»±c thá»ƒ Gravatar ban Ä‘áº§u mÃ  chÃºng ta Ä‘Ã£ thÃªm vÃ o cá»­a hÃ ng, cÅ©ng nhÆ° hai thá»±c thá»ƒ Gravatar Ä‘Æ°á»£c thÃªm vÃ o khi hÃ m xá»­ lÃ½ Ä‘Æ°á»£c gá»i;
- VÃ  cuá»‘i cÃ¹ng - chÃºng ta Ä‘ang dá»n dáº¹p cá»­a hÃ ng báº±ng cÃ¡ch sá»­ dá»¥ng `clearStore()` Ä‘á»ƒ thá»­ nghiá»‡m tiáº¿p theo cá»§a chÃºng ta cÃ³ thá»ƒ báº¯t Ä‘áº§u vá»›i má»™t Ä‘á»‘i tÆ°á»£ng cá»­a hÃ ng má»›i vÃ  trá»‘ng. ChÃºng ta cÃ³ thá»ƒ xÃ¡c Ä‘á»‹nh bao nhiÃªu khá»‘i thá»­ nghiá»‡m tÃ¹y thÃ­ch.

Váº­y lÃ  xong - chÃºng ta Ä‘Ã£ táº¡o bÃ i kiá»ƒm tra Ä‘áº§u tiÃªn cá»§a mÃ¬nh! ðŸ‘

Now in order to run our tests you simply need to run the following in your subgraph root folder:

`graph test Gravity`

And if all goes well you should be greeted with the following:

![Matchstick saying â€œAll tests passed!â€](/img/matchstick-tests-passed.png)

## CÃ¡c tÃ¬nh huá»‘ng kiá»ƒm tra phá»• biáº¿n

### Hydrat hÃ³a cá»­a hÃ ng vá»›i má»™t tráº¡ng thÃ¡i nháº¥t Ä‘á»‹nh

Users are able to hydrate the store with a known set of entities. Here's an example to initialise the store with a Gravatar entity:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Gá»i má»™t hÃ m Ã¡nh xáº¡ vá»›i má»™t sá»± kiá»‡n

A user can create a custom event and pass it to a mapping function that is bound to the store:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Gá»i táº¥t cáº£ cÃ¡c Ã¡nh xáº¡ vá»›i cÃ¡c Ä‘á»“ Ä‘áº¡c sá»± kiá»‡n

Users can call the mappings with test fixtures.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Giáº£ láº­p gá»i há»£p Ä‘á»“ng

Users can mock contract calls:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

As demonstrated, in order to mock a contract call and hardcore a return value, the user must provide a contract address, function name, function signature, an array of arguments, and of course - the return value.

Users can also mock function reverts:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Kháº³ng Ä‘á»‹nh tráº¡ng thÃ¡i cá»§a cá»­a hÃ ng

Users are able to assert the final (or midway) state of the store through asserting entities. In order to do this, the user has to supply an Entity type, the specific ID of an Entity, a name of a field on that Entity, and the expected value of the field. Here's a quick example:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Running the assert.fieldEquals() function will check for equality of the given field against the given expected value. The test will fail and an error message will be outputted if the values are **NOT** equal. Otherwise the test will pass successfully.

### TÆ°Æ¡ng tÃ¡c vá»›i siÃªu dá»¯ liá»‡u Sá»± kiá»‡n

Users can use default transaction metadata, which could be returned as an ethereum.Event by using the `newMockEvent()` function. The following example shows how you can read/write to those fields on the Event object:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Kháº³ng Ä‘á»‹nh bÃ¬nh Ä‘áº³ng biáº¿n

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Kháº³ng Ä‘á»‹nh ráº±ng má»™t Thá»±c thá»ƒ **khÃ´ng** trong cá»­a hÃ ng

Users can assert that an entity does not exist in the store. The function takes an entity type and an id. If the entity is in fact in the store, the test will fail with a relevant error message. Here's a quick example of how to use this functionality:

```typescript
assert.notInStore('Gravatar', '23')
```

### Printing the whole store (for debug purposes)

You can print the whole store to the console using this helper function:

```typescript
import { logStore } from "matchstick-as/assembly/store";

logStore();
```

### Expected failure

Users can have expected test failures, using the shouldFail flag on the test() functions:

```typescript
test("Should throw an error", () => {
  throw new Error();
}, true);
```

If the test is marked with shouldFail = true but DOES NOT fail, that will show up as an error in the logs and the test block will fail. Also, if it's marked with shouldFail = false (the default state), the test executor will crash.

### Logging

Having custom logs in the unit tests is exactly the same as logging in the mappings. The difference is that the log object needs to be imported from matchstick-as rather than graph-ts. Here's a simple example with all non-critical log types:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Users can also simulate a critical failure, like so:

```typescript
test("Blow everything up", () => {
    log.critical("Boom!");
});
```

Logging critical errors will stop the execution of the tests and blow everything up. After all - we want to make sure you're code doesn't have critical logs in deployment, and you should notice right away if that were to happen.

### Testing derived fields

Testing derived fields is a feature which (as the example below shows) allows the user to set a field in a certain entity and have another entity be updated automatically if it derives one of its fields from the first entity. Important thing to note is that the first entity needs to be reloaded as the automatic update happens in the store in rust of which the AS code is agnostic.

```typescript
test("Derived fields example test", () => {
    let mainAccount = new GraphAccount("12")
    mainAccount.save()
    let operatedAccount = new GraphAccount("1")
    operatedAccount.operators = ["12"]
    operatedAccount.save()
    let nst = new NameSignalTransaction("1234")
    nst.signer = "12";
    nst.save()

    assert.assertNull(mainAccount.get("nameSignalTransactions"))
    assert.assertNull(mainAccount.get("operatorOf"))

    mainAccount = GraphAccount.load("12")!

    assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
    assert.stringEquals("1", mainAccount.operatorOf[0])
})
```

### Testing dynamic data sources

Testing dynamic data sources can be be done by mocking the return value of the context(), address() and network() functions of the dataSource namespace. These functions currently return the following: context - returns an empty entity (DataSourceContext), address - returns "0x0000000000000000000000000000000000000000", network - returns "mainnet". The create(...) and createWithContext(...) functions are mocked to do nothing so they don't need to be called in the tests at all. Changes to the return values can be done through the functions of the dataSourceMock namespace in matchstick-as (version 0.3.0+). Example below: First we have the following event handler (which has been intentionally repurposed to showcase datasource mocking):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == "rinkeby") {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get("contextVal")!.toI32() > 0) {
    tokenLockWallet.setBigInt("tokensReleased", BigInt.fromI32(context.get("contextVal")!.toI32()))
  }
  tokenLockWallet.save()
}
```

And then we have the test using one of the methods in the dataSourceMock namespace to set a new return value for all of the dataSource functions:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from "matchstick-as/assembly/index"
import { BigInt, DataSourceContext, Value } from "@graphprotocol/graph-ts"

import { handleApproveTokenDestinations } from "../../src/token-lock-wallet"
import { ApproveTokenDestinations } from "../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet"
import { TokenLockWallet } from "../../generated/schema"

test("Data source simple mocking example", () => {
    let addressString = "0xA16081F360e3847006dB660bae1c6d1b2e17eC2A"
    let address = Address.fromString(addressString)

    let wallet = new TokenLockWallet(address.toHexString())
    wallet.save()
    let context = new DataSourceContext()
    context.set("contextVal", Value.fromI32(325))
    dataSourceMock.setReturnValues(addressString, "rinkeby", context)
    let event = changetype<ApproveTokenDestinations>(newMockEvent())

    assert.assertTrue(!wallet.tokenDestinationsApproved)

    handleApproveTokenDestinations(event)

    wallet = TokenLockWallet.load(address.toHexString())!
    assert.assertTrue(wallet.tokenDestinationsApproved)
    assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

    dataSourceMock.resetValues()
})
```

Notice that dataSourceMock.resetValues() is called at the end. That's because the values are remembered when they are changed and need to be reset if you want to go back to the default values.

### Test run time duration in the log output

The log output includes the test run duration. Here's an example:

`Jul 09 14:54:42.420 INFO Program execution time: 10.06022ms`

## Pháº£n há»“i

If you have any questions, feedback, feature requests or just want to reach out, the best place would be The Graph Discord where we have a dedicated channel for Matchstick, called ðŸ”¥| unit-testing.
