---
title: Быстрая и простая отладка сабграфа с использованием форков
---

Как и во многих системах, обрабатывающих большие объемы данных, Индексерам The Graph (Ноды Graph) может потребоваться довольно много времени для синхронизации вашего сабграфа с целевой цепочкой блоков. Несоответствие между быстрыми изменениями с целью отладки и длительным временем ожидания, необходимым для индексации, крайне контрпродуктивно, и мы хорошо это осознаем. Вот почему мы представляем **разветвление сабграфа**, разработанное [LimeChain](https://limechain.tech/), и в этой статье я покажу вам, как эту функцию можно использовать для существенного ускорения работы с отладкой сабграфа!

## И так, что это?

<**Разветвление сабграфа** - это процесс ленивой выборки объектов из _ хранилища другого _ сабграфа (обычно удаленного).

В контексте отладки **разветвление сабграфа** позволяет вам отлаживать ваш проблемный сабграф в блоке _X_ без необходимости ждать синхронизации с блоком _X_.

## Что? Как?

Когда вы развертываете сабграф на ноде Graph для индексации и происходит сбой в блоке _X_, хорошей новостью является то, что нода Graph по-прежнему будет обслуживать запросы GraphQL, используя свое хранилище, которое синхронизировано с блоком _X_. Это здорово! Это означает, что мы можем воспользоваться преимуществами этого "актуального" хранилища для исправления ошибок, возникающих при индексации блока _X_.

В двух словах, мы собираемся _ форкнуть неудачный сабграф_ с удаленной ноды Graph, у которого гарантированно будет индексирован сабграф до блока _X_ для того, чтобы предоставьте локально развернутому сабграфу, отлаживаемому в блоке _X_ актуальное представление состояния индексации.

## Пожалуйста, покажите мне какой-нибудь код!

Чтобы оставаться сосредоточенным на отладке сабграфа, давайте сделаем все просто и запустим вместе с [example-subgraph](https://github.com/graphprotocol/example-subgraphs/tree/main/ethereum/gravatar) индексирование смарт-контракта Ethereum Gravity.

Вот обработчики, определенные для индексации `Gravatar`s, без каких-либо ошибок вообще:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

Упс, как неудачно, когда я разворачиваю свой идеально выглядящий сабграф в [Hosted Service](https://thegraph.com/hosted-service/) завершается ошибкой _"Gravatar не найден!"_.

Обычный способ попытаться исправить это:

1. Внести изменения в источник сопоставлений, которые, по вашему мнению, решат проблему (в то время как я знаю, что это не так).
2. Повторно развернуть сабграф в [Hosted Service](https://thegraph.com/hosted-service/) (или другую ноду Graph).
3. Подождать, пока он синхронизируется.
4. Если он снова сломается, вернуться к пункту 1, в противном случае: Ура!

Это действительно довольно знакомо для обычного процесса отладки, но есть один шаг, который ужасно замедляет процесс: _3. Подождите, пока он синхронизируется._

Используя **разветвление сабграфа**, мы можем существенно исключить этот шаг. Вот как это выглядит:

0. Запустите локальную ноду Graph с помощью **_соответствующего набора fork-base_**.
1. Внесите изменения в источник сопоставлений, которые, по вашему мнению, решат проблему.
2. Разверните на локальной ноде Graph, **_форкнув неудачный сабграф_** и **_начиная с проблемного блока_**.
3. Если он снова сломается, вернитесь к пункту 1, в противном случае: Ура!

Сейчас у вас может появиться 2 вопроса:

1. fork-base что???
2. Форкнуть кого?!

И я вам отвечаю:

1. `fork-base` - это "базовый" URL, такой, что при добавлении _идентификатора сабграфа_ результирующий URL (`<fork-base>/<subgraph-id>`) является допустимой конечной точкой GraphQL для хранилища сабграфа.
2. Форкать легко:

```bash
$ graph deploy <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

Кроме того, не забудьте установить в поле `DataSources.source.startBlock` в манифесте сабграфа номер проблемного блока, чтобы вы могли пропустить индексацию ненужных блоков и воспользоваться преимуществами fork!

Итак, вот что я делаю:

0. Я запускаю локальную ноду Graph ([вот как это сделать](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) с параметром `fork-base`, установленным в значение: `https://api.thegraph.com/subgraphs/id /`, так как я буду форкать сабграф, глючный, который я развернул ранее, из [HostedService](https://thegraph.com/hosted-service/).

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

1. После тщательной проверки я замечаю, что существует несоответствие в представлениях `id`, используемых при индексации `Gravatar`s в моих двух обработчиках. В то время как `handleNewGravatar` преобразует его в шестнадцатеричное значение (`event.params.id.toHex()`), `handleUpdatedGravatar` использует int32 (`event.params.id.toI32()`), который вызывает `handleUpdatedGravatar` панику с сообщением "Gravatar не найден!". Я заставляю их обоих преобразовать `идентификатор` в шестнадцатеричное значение.
2. После того, как я внес изменения, я развертываю свой сабграф на локальной ноде Graph, **_форкая неисправный сабграф_** и устанавливая `DataSources.source.startBlock` в `6190343` в `subgraph.yaml`:

```bash
  $ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

3. Я проверяю журналы, созданные локальной нодой Graph, и, ура!, кажется, все работает.
4. Я развертываю свой теперь свободный от ошибок сабграф на удаленной ноде Graph и живу долго и счастливо
5. Конец...
