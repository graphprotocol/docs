---
title: Marco de Unit Testing
---

Matchstick es un marco de unit testing, desarrollado por [LimeChain](https://limechain.tech/), que permite a los desarrolladores de subgrafos probar su lÃ³gica de mapeo en un entorno sandbox y desplegar sus subgrafos con confianza!

Sigue la [Matchstick installation guide](https://github.com/LimeChain/matchstick/blob/main/README.md#quick-start-) para instalar. Ahora, puede pasar a escribir tu primera unit test.

## Escribe una Unit Test

Veamos cÃ³mo serÃ­a una unit test sencilla, utilizando el Gravatar [Example Subgraph](https://github.com/graphprotocol/example-subgraph).

Suponiendo que tenemos la siguiente funciÃ³n handler (junto con dos funciones de ayuda para facilitarnos la vida):

```javascript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress))
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Primero tenemos que crear un archivo de prueba en nuestro proyecto. Hemos elegido el nombre `gravity.test.ts`. En el archivo reciÃ©n creado tenemos que definir una funciÃ³n llamada `runTests()`. Es importante que la funciÃ³n tenga ese nombre exacto. Este es un ejemplo de cÃ³mo podrÃ­an ser nuestras pruebas:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

export function runTests(): void {
  test('Can call mappings with custom events', () => {
    // Initialise
    let gravatar = new Gravatar('gravatarId0')
    gravatar.save()

    // Call mappings
    let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

    let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

    handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

    assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
    assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
    assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

    clearStore()
  })

  test('Next test', () => {
    //...
  })
}
```

Â¡Es mucho para desempacar! En primer lugar, una cosa importante a notar es que estamos importando cosas de `matchstick-as`, nuestra biblioteca de ayuda de AssemblyScript (distribuida como un mÃ³dulo npm). Puedes encontrar el repositorio [aquÃ­](https://github.com/LimeChain/matchstick-as). `matchstick-as` nos proporciona Ãºtiles mÃ©todos de prueba y tambiÃ©n define la funciÃ³n `test()` que utilizaremos para construir nuestros bloques de prueba. El resto es bastante sencillo: esto es lo que ocurre:

- Estamos configurando nuestro estado inicial y aÃ±adiendo una entidad Gravatar personalizada;
- Definimos dos objetos de evento `NewGravatar` junto con sus datos, utilizando la funciÃ³n `createNewGravatarEvent()`;
- Estamos llamando a los mÃ©todos handlers de esos eventos - `handleNewGravatars()` y pasando la lista de nuestros eventos personalizados;
- Hacemos valer el estado del almacÃ©n. Â¿CÃ³mo funciona eso? - Pasamos una combinaciÃ³n Ãºnica de tipo de Entidad e id. A continuaciÃ³n, comprobamos un campo especÃ­fico de esa Entidad y afirmamos que tiene el valor que esperamos que tenga. Hacemos esto tanto para la Entidad Gravatar inicial que aÃ±adimos al almacÃ©n, como para las dos entidades Gravatar que se aÃ±aden cuando se llama a la funciÃ³n del handler;
- Y por Ãºltimo - estamos limpiando el almacÃ©n usando `clearStore()` para que nuestra prÃ³xima prueba pueda comenzar con un objeto almacÃ©n fresco y vacÃ­o. Podemos definir tantos bloques de prueba como queramos.

Ya estÃ¡: Â¡hemos creado nuestra primera prueba! ðŸ‘

â— **IMPORTANTE:** _ Para que las pruebas funcionen, necesitamos exportar la funciÃ³n `runTests()` en nuestro archivo de mapeo. No se utilizarÃ¡ allÃ­, pero la declaraciÃ³n de exportaciÃ³n tiene que estar allÃ­ para que pueda ser recogida por Rust mÃ¡s tarde al ejecutar las pruebas._

Puedes exportar la funciÃ³n wrapper de las pruebas en tu archivo de mapeo de la siguiente manera:

```
export { runTests } from "../tests/gravity.test.ts";
```

â— **IMPORTANTE:** _Actualmente hay un problema con el uso de Matchstick cuando se despliega tu subgrafo. Por favor, sÃ³lo usa Matchstick para pruebas locales, y elimina/comenta esta lÃ­nea (`export { runTests } de "../tests/gravity.test.ts"`) una vez que hayas terminado. Esperamos resolver este problema en breve, Â¡disculpa las molestias!_

_Si no eliminas esa lÃ­nea, obtendrÃ¡s el siguiente mensaje de error al intentar desplegar tu subgrafo:_

```
/...
Mapping terminated before handling trigger: oneshot canceled
.../
```

Ahora, para ejecutar nuestras pruebas, sÃ³lo tienes que ejecutar lo siguiente en la carpeta raÃ­z de tu subgrafo:

`graph test Gravity`

Y si todo va bien deberÃ­as ser recibido con lo siguiente:

![Matchstick saying â€œAll tests passed!â€](/img/matchstick-tests-passed.png)

## Escenarios de prueba comunes

### Hydrating the store with a certain state

Users are able to hydrate the store with a known set of entities. Here's an example to initialise the store with a Gravatar entity:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Calling a mapping function with an event

A user can create a custom event and pass it to a mapping function that is bound to the store:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Calling all of the mappings with event fixtures

Users can call the mappings with test fixtures.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Mocking contract calls

Users can mock contract calls:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum. Value.fromAddress(result))
```

As demonstrated, in order to mock a contract call and hardcore a return value, the user must provide a contract address, function name, function signature, an array of arguments, and of course - the return value.

Users can also mock function reverts:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Asserting the state of the store

Users are able to assert the final (or midway) state of the store through asserting entities. In order to do this, the user has to supply an Entity type, the specific ID of an Entity, a name of a field on that Entity, and the expected value of the field. Here's a quick example:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Running the assert.fieldEquals() function will check for equality of the given field against the given expected value. The test will fail and an error message will be outputted if the values are **NOT** equal. Otherwise the test will pass successfully.

### Interacting with Event metadata

Users can use default transaction metadata, which could be returned as an ethereum. Event by using the `newMockEvent()` function. The following example shows how you can read/write to those fields on the Event object:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Asserting variable equality

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum. Value.fromString("hello"));
```

### Asserting that an Entity is **not** in the store

Users can assert that an entity does not exist in the store. The function takes an entity type and an id. If the entity is in fact in the store, the test will fail with a relevant error message. Here's a quick example of how to use this functionality:

```typescript
assert.notInStore('Gravatar', '23')
```

### Test run time duration in the log output

The log output includes the test run duration. Here's an example:

`Jul 09 14:54:42.420 INFO Program execution time: 10.06022ms`

## Feedback

If you have any questions, feedback, feature requests or just want to reach out, the best place would be The Graph Discord where we have a dedicated channel for Matchstick, called ðŸ”¥| unit-testing.
