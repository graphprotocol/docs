---
title: Crear un Subgrafo
---

Antes de poder utilizar el Graph CLI, tienes que crear tu subgrafo en [Subgraph Studio](https://thegraph.com/studio). A continuación, podrás configurar tu proyecto de subgrafo y desplegarlo en la plataforma que elijas. Ten en cuenta que **los subgrafos que no indexen Ethereum mainnet no se publicarán en The Graph Network**.

El comando `graph init` se puede utilizar para configurar un nuevo proyecto de subgrafo, ya sea desde un contrato existente en cualquiera de las redes públicas de Ethereum, o desde un subgrafo de ejemplo. Este comando se puede utilizar para crear un subgrafo en el Subgraph Studio pasando `graph init --product subgraph-studio`. Si ya tienes un contrato inteligente desplegado en la red principal de Ethereum o en una de las redes de prueba, arrancar un nuevo subgrafo a partir de ese contrato puede ser una buena manera de empezar. Pero primero, un poco sobre las redes que admite The Graph.

## Redes que admite

The Graph Network admite subgrafos que indexan la red principal de Ethereum:

- `mainnet`

**El Servicio Alojado (Hosted Service) admite Redes Adicionales en la versión beta**:

- `mainnet`
- `kovan`
- `rinkeby`
- `ropsten`
- `goerli`
- `poa-core`
- `poa-sokol`
- `xdai`
- `near-mainnet`
- `near-testnet`
- `matic`
- `mumbai`
- `fantom`
- `bsc`
- `chapel`
- `clover`
- `avalanche`
- `fuji`
- `celo`
- `celo-alfajores`
- `fuse`
- `moonriver`
- `mbase`
- `arbitrum-one`
- `arbitrum-rinkeby`
- `optimism`
- `optimism-kovan`
- `aurora`
- `aurora-testnet`

El Hosted Service (servicio alojado) de The Graph se basa en la estabilidad y la fiabilidad de las tecnologías subyacentes, es decir, los endpoints JSON RPC proporcionados. Las redes más nuevas se marcarán como beta hasta que la red haya demostrado su estabilidad, fiabilidad y escalabilidad. Durante este período beta, existe el riesgo de que se produzcan tiempos de inactividad y comportamientos inesperados.

Recuerda que **no podrás** publicar un subgrafo que indexe una red no-mainnet a la Graph Network descentralizada en [Subgraph Studio](/studio/subgraph-studio).

## Desde un Contrato Existente

El siguiente comando crea un subgrafo que indexa todos los eventos de un contrato existente. Intenta obtener la ABI del contrato desde Etherscan y vuelve a solicitar una ruta de archivo local. Si falta alguno de los argumentos opcionales, te lleva a través de un formulario interactivo.

```sh
graph init \
  --product subgraph-studio
  --from-contract <CONTRACT_ADDRESS> \
  [--network <ETHEREUM_NETWORK>] \
  [--abi <FILE>] \
  <SUBGRAPH_SLUG> [<DIRECTORY>]
```

El `<SUBGRAPH_SLUG>` es el ID de tu subgrafo en Subgraph Studio, y se puede encontrar en la página de detalles de tu subgrafo.

## Desde un Subgrafo de Ejemplo

El segundo modo que admite `graph init` es la creación de un nuevo proyecto a partir de un subgrafo de ejemplo. El siguiente comando lo hace:

```
graph init --studio <SUBGRAPH_SLUG>
```

El subgrafo de ejemplo se basa en el contrato Gravity de Dani Grant que gestiona los avatares de los usuarios y emite `NewGravatar` o `UpdateGravatar` cada vez que se crean o actualizan los avatares. El subgrafo maneja estos eventos escribiendo entidades `Gravatar` en el almacén de Graph Node y asegurándose de que éstas se actualicen según los eventos. Las siguientes secciones repasarán los archivos que componen el manifiesto del subgrafo para este ejemplo.

## El Manifiesto de Subgrafo

El manifiesto del subgrafo `subgraph.yaml` define los contratos inteligentes que indexa tu subgrafo, a qué eventos de estos contratos prestar atención, y cómo mapear los datos de los eventos a las entidades que Graph Node almacena y permite consultar. La especificación completa de los manifiestos de subgrafos puede encontrarse en [here](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

Para este subgrafo de ejemplo, `subgraph.yaml` es:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/example-subgraph
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - function: handleBlock
        - function: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

Las entradas importantes a actualizar para el manifiesto son:

- `description`: una descripción legible para el ser humano de lo que es el subgrafo. Esta descripción es mostrada por The Graph Explorer cuando el subgrafo se despliega en el Servicio Alojado.

- `repository`: la URL del repositorio donde se encuentra el manifiesto del subgrafo. Esto también lo muestra The Graph Explorer.

- `features`: una lista de todos los nombres de las [feature](#experimental-features) usadas.

- `dataSources.source`: la address del contrato inteligente, las fuentes del subgrafo, y el abi del contrato inteligente a utilizar. La address es opcional; omitirla permite indexar los eventos coincidentes de todos los contratos.

- `dataSources.source.startBlock`: el número opcional del bloque desde el que la fuente de datos comienza a indexar. En la mayoría de los casos, sugerimos utilizar el bloque en el que se creó el contrato.

- `dataSources.mapping.entities`: las entidades que la fuente de datos escribe en el almacén. El esquema de cada entidad se define en el archivo schema.graphql.

- `dataSources.mapping.abis`: uno o más archivos ABI con nombre para el contrato fuente, así como cualquier otro contrato inteligente con el que interactúes desde los mapeos.

- `dataSources.mapping.eventHandlers`: enumera los eventos de contratos inteligentes a los que reacciona este subgrafo y los handlers en el mapeo -./src/mapping.ts en el ejemplo- que transforman estos eventos en entidades en el almacén.

- `dataSources.mapping.callHandlers`: enumera las funciones de contrato inteligente a las que reacciona este subgrafo y los handlers en el mapeo que transforman las entradas y salidas a las llamadas de función en entidades en el almacén.

- `dataSources.mapping.blockHandlers`: enumera los bloques a los que reacciona este subgrafo y los handlers en el mapeo que se ejecutan cuando un bloque se agrega a la cadena. Sin un filtro, el handler de bloque se ejecutará en cada bloque. Se puede proporcionar un filtro opcional con los siguientes tipos: `call`. Un filtro `call` ejecutará el handler si el bloque contiene al menos una llamada al contrato de la fuente de datos.

Un único subgrafo puede indexar datos de múltiples contratos inteligentes. Añade una entrada por cada contrato del que haya que indexar datos a la array `dataSources`.

Las condicionales (triggers) de una fuente de datos dentro de un bloque se ordenan mediante el siguiente proceso:

1. Las condicionales de eventos y llamadas se ordenan primero por el índice de la transacción dentro del bloque.
2. Las condicionales de eventos y llamadas dentro de la misma transacción se ordenan siguiendo una convención: primero las condicionales de eventos y luego los de llamadas, respetando cada tipo el orden en que se definen en el manifiesto.
3. Las condicionales de bloques se ejecutan después de las condicionales de eventos y llamadas, en el orden en que están definidos en el manifiesto.

Estas normas de orden están sujetas a cambios.

### Obtención de ABIs

Los archivos ABI deben coincidir con tu(s) contrato(s). Hay varias formas de obtener archivos ABI:

- Si estás construyendo tu propio proyecto, es probable que tengas acceso a tus ABIs más actuales.
- Si estás construyendo un subgrafo para un proyecto público, puedes descargar ese proyecto en tu computadora y obtener la ABI utilizando [`truffle compile`](https://truffleframework.com/docs/truffle/overview) o usando solc para compilar.
- También puedes encontrar la ABI en [Etherscan](https://etherscan.io/), pero no siempre es fiable, ya que la ABI que se sube allí puede estar desactualizada. Asegúrate de que tienes la ABI correcta, de lo contrario la ejecución de tu subgrafo fallará.

## El Esquema GraphQL

El esquema para tu subgrafo está en el archivo `schema.graphql`. Los esquemas de GraphQL se definen utilizando el lenguaje de definición de interfaces de GraphQL. Si nunca has escrito un esquema GraphQL, es recomendable que consultes este manual sobre el sistema de tipos GraphQL. La documentación de referencia para los esquemas de GraphQL se puede encontrar en la sección [GraphQL API](/developer/graphql-api).

## Definir Entidades

Antes de definir las entidades, es importante dar un paso atrás y pensar en cómo están estructurados y vinculados los datos. Todas las consultas se harán contra el modelo de datos definido en el esquema del subgrafo y las entidades indexadas por el subgrafo. Debido a esto, es bueno definir el esquema del subgrafo de una manera que coincida con las necesidades de tu dapp. Puede ser útil imaginar las entidades como "objetos que contienen datos", más que como eventos o funciones.

Con The Graph, simplemente defines los tipos de entidad en `schema.graphql`, y Graph Node generará campos de nivel superior para consultar instancias individuales y colecciones de ese tipo de entidad. Cada tipo que deba ser una entidad debe ser anotado con una directiva `@entity`.

### Un buen ejemplo

La entidad `Gravatar` que aparece a continuación está estructurada en torno a un objeto Gravatar y es un buen ejemplo de cómo podría definirse una entidad.

```graphql
type Gravatar @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
  accepted: Boolean
}
```

### Un mal ejemplo

El ejemplo las entidades `GravatarAccepted` y `GravatarDeclined` que aparecen a continuación se basan en eventos. No se recomienda asignar eventos o llamadas a funciones a entidades 1:1.

```graphql
type GravatarAccepted @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
}

type GravatarDeclined @entity {
  id: ID!
  owner: Bytes
  displayName: String
  imageUrl: String
}
```

### Campos opcionales y obligatorios

Los campos de la entidad pueden definirse como obligatorios u opcionales. Los campos obligatorios se indican con el `!` en el esquema. Si un campo obligatorio no está establecido en la asignación, recibirá este error al consultar el campo:

```
Null value resolved for non-null field 'name'
```

Cada entidad debe tener un campo `id`, que es de tipo `ID!` (string). El campo `id` sirve de clave primaria y debe ser único entre todas las entidades del mismo tipo.

### Tipos de Scalars incorporados

#### GraphQL admite Scalars

Admitimos los siguientes scalars en nuestra API GraphQL:

| Tipo         | Descripción                                                                                                                                                                                        |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Bytes`      | Byte array, representado como un string hexadecimal. Comúnmente utilizado para los hashes y direcciones de Ethereum.                                                                               |
| `ID`         | Almacenado como un `string`.                                                                                                                                                                       |
| `String`     | Scalar para valores `string`. Los caracteres null no se admiten y se eliminan automáticamente.                                                                                                     |
| `Boolean`    | Scalar para valores `boolean`.                                                                                                                                                                     |
| `Int`        | The GraphQL spec define `Int` para tener un tamano de 32 bytes.                                                                                                                                    |
| `BigInt`     | Números enteros grandes. Usados para los tipos `uint32`, `int64`, `uint64`, ..., `uint256` de Ethereum. Nota: Todo debajo de `uint32`, como `int32`, `uint24` o `int8` es representado como `i32`. |
| `BigDecimal` | `BigDecimal` Decimales de alta precisión representados como un signo y un exponente. El rango de exponentes va de -6143 a +6144. Redondeado a 34 dígitos significativos.                           |

#### Enums

También puedes crear enums dentro de un esquema. Los Enums tienen la siguiente sintaxis:

```graphql
enum TokenStatus {
  OriginalOwner
  SecondOwner
  ThirdOwner
}
```

Una vez definido el enum en el esquema, puedes utilizar la representación del string del valor del enum para establecer un campo enum en una entidad. Por ejemplo, puedes establecer el `tokenStatus` a `SecondOwner` definiendo primero tu entidad y posteriormente estableciendo el campo con `entity.tokenStatus = "SecondOwner`. El ejemplo siguiente muestra el aspecto de la entidad Token con un campo enum:

Puedes encontrar más detalles sobre la escritura de enums en la [GraphQL documentation](https://graphql.org/learn/schema/).

#### Relaciones entre Entidades

Una entidad puede tener una relación con una o más entidades de tu esquema. Estas relaciones pueden ser recorridas en tus consultas. Las relaciones en The Graph son unidireccionales. Es posible simular relaciones bidireccionales definiendo una relación unidireccional en cada "extremo" de la relación.

Las relaciones se definen en las entidades como cualquier otro campo, salvo que el tipo especificado es el de otra entidad.

#### Relaciones Uno a Uno

Define un tipo de entidad `Transaction` con una relación opcional de uno a uno con un tipo de entidad `TransactionReceipt`:

```graphql
type Transaction @entity {
  id: ID!
  transactionReceipt: TransactionReceipt
}

type TransactionReceipt @entity {
  id: ID!
  transaction: Transaction
}
```

#### Relaciones one-to-many

Define un tipo de entidad `TokenBalance` con una relación requerida de uno a varios con un tipo de entidad Token:

```graphql
type Token @entity {
  id: ID!
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}
```

#### Búsquedas Inversas

Se pueden definir búsquedas inversas en una entidad a través del campo `@derivedFrom`. Esto crea un campo virtual en la entidad que puede ser consultado pero que no puede ser establecido manualmente a través de la API de mapeo. Más bien, se deriva de la relación definida en la otra entidad. Para este tipo de relaciones, rara vez tiene sentido almacenar ambos lados de la relación, y tanto la indexación como el rendimiento de la consulta serán mejores cuando sólo se almacene un lado y el otro se derive.

En el caso de las relaciones one-to-many, la relación debe almacenarse siempre en el lado "one", y el lado "many" debe derivarse siempre. Almacenar la relación de esta manera, en lugar de almacenar una array de entidades en el lado "many", resultará en un rendimiento dramáticamente mejor tanto para la indexación como para la consulta del subgrafo. En general, debe evitarse, en la medida de lo posible, el almacenamiento de arrays de entidades.

#### Ejemplo

Podemos hacer que los balances de un token sean accesibles desde el token derivando un campo `tokenBalances`:

```graphql
type Token @entity {
  id: ID!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}
```

#### Relaciones de many-to-many

Para las relaciones de many-to-many, como los usuarios pueden pertenecer a cualquier número de organizaciones, la forma más directa, pero generalmente no la más eficaz, de modelar la relación es en un array en cada una de las dos entidades implicadas. Si la relación es simétrica, sólo es necesario almacenar un lado de la relación y el otro puede derivarse.

#### Ejemplo

Define una búsqueda inversa desde un tipo de entidad `User` a un tipo de entidad `Organization`. En el ejemplo siguiente, esto se consigue buscando el atributo `members` desde la entidad `Organization`. En las consultas, el campo `organizations` en `User` se resolverá buscando todas las entidades de `Organization` que incluyan el ID del usuario.

```graphql
type Organization @entity {
  id: ID!
  name: String!
  members: [User!]!
}

type User @entity {
  id: ID!
  name: String!
  organizations: [Organization!]! @derivedFrom(field: "members")
}
```

Una forma más eficaz de almacenar esta relación es a través de una tabla de asignación que tiene una entrada para cada par `User` / `Organization` con un esquema como

```graphql
type Organization @entity {
  id: ID!
  name: String!
  members: [UserOrganization]! @derivedFrom(field: "user")
}

type User @entity {
  id: ID!
  name: String!
  organizations: [UserOrganization!] @derivedFrom(field: "organization")
}

type UserOrganization @entity {
  id: ID! # Set to `${user.id}-${organization.id}`
  user: User!
  organization: Organization!
}
```

Este enfoque requiere que las consultas desciendan a un nivel adicional para recuperar, por ejemplo, las organizaciones para los usuarios:

```graphql
query usersWithOrganizations {
  users {
    organizations {
      # this is a UserOrganization entity
      organization {
        name
      }
    }
  }
}
```

Esta forma más elaborada de almacenar las relaciones de muchos a muchos se traducirá en menos datos almacenados para el subgrafo y, por tanto, en un subgrafo que suele ser mucho más rápido de indexar y consultar.

#### Agregar comentarios al esquema

Según la especificación GraphQL, se pueden añadir comentarios por encima de los atributos de entidad del esquema utilizando comillas dobles `""`. Esto se ilustra en el siguiente ejemplo:

```graphql
type MyFirstEntity @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  address: Bytes!
}
```

## Definición de campos de búsqueda de texto completo

Las consultas de búsqueda de texto completo filtran y clasifican las entidades basándose en una entrada de búsqueda de texto. Las consultas de texto completo pueden devolver coincidencias de palabras similares procesando el texto de la consulta en stems antes de compararlo con los datos del texto indexado.

La definición de una consulta de texto completo incluye el nombre de la consulta, el diccionario lingüístico utilizado para procesar los campos de texto, el algoritmo de clasificación utilizado para ordenar los resultados y los campos incluidos en la búsqueda. Cada consulta de texto completo puede abarcar varios campos, pero todos los campos incluidos deben ser de un solo tipo de entidad.

Para agregar una consulta de texto completo, incluye un tipo `_Schema_` con una directiva de texto completo en el esquema GraphQL.

```graphql
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )

type Band @entity {
  id: ID!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}
```

El ejemplo campo `bandSearch` se puede utilizar en las consultas para filtrar las entidades `Band` con base en los documentos de texto en los campos `name`, `description`, y `bio`. Ve a [GraphQL API - Queries](/developer/graphql-api#queries) para ver una descripción de la API de búsqueda de texto completo y más ejemplos de uso.

```graphql
query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}
```

> **[Feature Management](#experimental-features):** Desde `specVersion` `0.0.4` y en adelante, `fullTextSearch` se debe declarar bajo la sección `features` en el manifiesto del subgrafo.

### Idiomas admitidos

La elección de un idioma diferente tendrá un efecto definitivo, aunque a veces sutil, en la API de búsqueda de texto completo. Los campos cubiertos por un campo de consulta de texto completo se examinan en el contexto de la lengua elegida, por lo que los lexemas producidos por las consultas de análisis y búsqueda varían de un idioma a otro. Por ejemplo: al utilizar el diccionario turco compatible, "token" se convierte en "toke", mientras que el diccionario inglés lo convierte en "token".

Diccionarios de idiomas admitidos:

| Código | Diccionario |
| ------ | ----------- |
| simple | General     |
| da     | Danés       |
| nl     | Holandés    |
| en     | Inglés      |
| fi     | Finlandés   |
| fr     | Francés     |
| de     | Alemán      |
| hu     | Húngaro     |
| it     | Italiano    |
| no     | Noruego     |
| pt     | Portugués   |
| ro     | Rumano      |
| ru     | Ruso        |
| es     | Español     |
| sv     | Sueco       |
| tr     | Turco       |

### Algoritmos de Clasificación

Algoritmos admitidos para ordenar los resultados:

| Algoritmos          | Descripción                                                                                        |
| ------------------- | -------------------------------------------------------------------------------------------------- |
| rango               | Usa la calidad de coincidencia (0-1) de la consulta de texto completo para ordenar los resultados. |
| rango de proximidad | Similar al rango, pero también incluye la proximidad de los matches.                               |

## Escribir mapeos

Los mapeos transforman los datos de Ethereum de los que se abastecen tus mapeos en entidades definidas en tu esquema. Los mapeos se escriben en un subconjunto de [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) llamado [AssemblyScript](https://github.com/AssemblyScript/assemblyscript/wiki) que puede ser compilado a WASM ([WebAssembly](https://webassembly.org/)). AssemblyScript es más estricto que el TypeScript normal, pero proporciona una sintaxis familiar.

Para cada handler de eventos que se define en `subgraph.yaml` bajo `mapping.eventHandlers`, crea una función exportada del mismo nombre. Cada handler debe aceptar un único parámetro llamado `event` con un tipo correspondiente al nombre del evento que se está manejando.

En el subgrafo de ejemplo, `src/mapping.ts` contiene handlers para los eventos `NewGravatar` y `UpdatedGravatar`:

```javascript
import { NewGravatar, UpdatedGravatar } from '../generated/Gravity/Gravity'
import { Gravatar } from '../generated/schema'

export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let id = event.params.id.toHex()
  let gravatar = Gravatar.load(id)
  if (gravatar == null) {
    gravatar = new Gravatar(id)
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

El primer handler toma un evento `NewGravatar` y crea una nueva entidad `Gravatar` con `new Gravatar(event.params.id.toHex())`, poblando los campos de la entidad usando los parámetros correspondientes del evento. Esta instancia de entidad está representada por la variable `gravatar`, con un valor de id de `event.params.id.toHex()`.

El segundo handler intenta cargar el `Gravatar` existente desde el almacén de The Graph Node. Si aún no existe, se crea bajo demanda. A continuación, la entidad se actualiza para que coincida con los nuevos parámetros del evento, antes de volver a guardarla en el almacén mediante `gravatar.save()`.

### ID recomendados para la creación de nuevas entidades

Cada entidad tiene que tener un `id` que sea único entre todas las entidades del mismo tipo. El valor del `id` de una entidad se establece cuando se crea la entidad. A continuación se recomiendan algunos valores de `id` a tener en cuenta a la hora de crear nuevas entidades. NOTA: El valor del `id` debe ser un `string`.

- `event.params.id.toHex()`
- `event.transaction.from.toHex()`
- `event.transaction.hash.toHex() + "-" + event.logIndex.toString()`

Proporcionamos la [Graph Typescript Library](https://github.com/graphprotocol/graph-ts) que contiene utilidades para interactuar con el almacén Graph Node y comodidades para manejar datos y entidades de contratos inteligentes. Puedes utilizar esta biblioteca en tus mapeos importando `@graphprotocol/graph-ts` in `mapping.ts`.

## Generación de código

Para que trabajar con contratos inteligentes, eventos y entidades sea fácil y seguro desde el punto de vista de los tipos, Graph CLI puede generar tipos AssemblyScript a partir del esquema GraphQL del subgrafo y de las ABIs de los contratos incluidas en las fuentes de datos.

Esto se hace con

```sh
graph codegen [--output-dir <OUTPUT_DIR>] [<MANIFEST>]
```

pero en la mayoría de los casos, los subgrafos ya están preconfigurados a través de `package.json` para permitirte simplemente ejecutar uno de los siguientes para lograr lo mismo:

```sh
# Yarn
yarn codegen

# NPM
npm run codegen
```

Esto generará una clase AssemblyScript para cada contrato inteligente en los archivos ABI mencionados en `subgraph.yaml`, permitiéndote vincular estos contratos a direcciones específicas en los mapeos y llamar a métodos de contrato de sólo lectura contra el bloque que se está procesando. También generará una clase para cada evento del contrato para facilitar el acceso a los parámetros del evento, así como el bloque y la transacción que originó el evento. Todos estos tipos se escriben en `<OUTPUT_DIR>/<DATA_SOURCE_NAME>/<ABI_NAME>.ts`. En el subgrafo de ejemplo, esto sería `generated/Gravity/Gravity.ts`, permitiendo a los mapeos importar estos tipos con

```javascript
import {
  // The contract class:
  Gravity,
  // The events classes:
  NewGravatar,
  UpdatedGravatar,
} from '../generated/Gravity/Gravity'
```

Además, se genera una clase para cada tipo de entidad en el esquema GraphQL del subgrafo. Estas clases proporcionan una carga de entidades segura, acceso de lectura y escritura a los campos de la entidad, así como un método `save()` para escribir entidades en el almacén. Todas las clases de entidades se escriben en `<OUTPUT_DIR>/schema.ts`, lo que permite que los mapeos los importen con

```javascript
import { Gravatar } from '../generated/schema'
```

> **Nota:** La generación de código debe realizarse de nuevo después de cada cambio en el esquema GraphQL o en las ABIs incluidas en el manifiesto. También debe realizarse al menos una vez antes de construir o desplegar el subgrafo.

La generación de código no comprueba tu código de mapeo en `src/mapping.ts`. Si quieres comprobarlo antes de intentar desplegar tu subgrafo en the Graph Explorer, puedes ejecutar `yarn build` y corregir cualquier error de sintaxis que el compilador de TypeScript pueda encontrar.

## Plantillas para fuentes de datos

Un patrón común en los contratos inteligentes de Ethereum es el uso de contratos de registro o fábrica, donde un contrato crea, gestiona o hace referencia a un número arbitrario de otros contratos que tienen cada uno su propio estado y eventos. Las direcciones de estos subcontratos pueden o no conocerse de antemano y muchos de estos contratos pueden crearse y/o añadirse con el tiempo. Por eso, en estos casos, es imposible definir una única fuente de datos o un número fijo de fuentes de datos y se necesita un enfoque más dinámico: _data source templates_.

### Fuente de Datos para el Contrato Principal

En primer lugar, define una fuente de datos regular para el contrato principal. El siguiente fragmento muestra un ejemplo simplificado de fuente de datos para el contrato de fábrica de exchange [Uniswap](https://uniswap.io). Nota el handler `NewExchange(address,address)` del evento. Se emite cuando el contrato de fábrica crea un nuevo contrato de exchange en la cadena.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Plantillas de fuentes de datos para contratos creados dinámicamente

A continuación, añade _plantillas de origen de datos_ al manifiesto. Son idénticas a las fuentes de datos normales, salvo que carecen de una dirección de contrato predefinida en `source`. Normalmente, defines un modelo para cada tipo de subcontrato gestionado o referenciado por el contrato principal.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Instanciación de una plantilla de fuente de datos

En el último paso, actualiza la asignación del contrato principal para crear una instancia de fuente de datos dinámica a partir de una de las plantillas. En este ejemplo, cambiarías el mapeo del contrato principal para importar la plantilla `Exchange` y llamaría al método `Exchange.create(address)` en él para empezar a indexar el nuevo contrato de exchange.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **Nota:** Un nuevo origen de datos sólo procesará las llamadas y los eventos del bloque en el que fue creado y todos los bloques siguientes, pero no procesará los datos históricos, es decir, los datos que están contenidos en bloques anteriores.
> 
> Si los bloques anteriores contienen datos relevantes para la nueva fuente de datos, lo mejor es indexar esos datos leyendo el estado actual del contrato y creando entidades que representen ese estado en el momento de crear la nueva fuente de datos.

### Contexto de la fuente de datos

Los contextos de fuentes de datos permiten pasar una configuración extra al instanciar una plantilla. En nuestro ejemplo, digamos que los exchanges se asocian a un par de trading concreto, que se incluye en el evento `NewExchange`. Esa información se puede pasar a la fuente de datos instanciada, así:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Dentro de un mapeo de la plantilla `Exchange`, se puede acceder al contexto:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

Hay setters y getters como `setString` and `getString` para todos los tipos de valores.

## Bloques iniciales

El `startBlock` es un ajuste opcional que permite definir a partir de qué bloque de la cadena comenzará a indexar la fuente de datos. Establecer el bloque inicial permite a la fuente de datos omitir potencialmente millones de bloques que son irrelevantes. Normalmente, un desarrollador de subgrafos establecerá `startBlock` al bloque en el que se creó el contrato inteligente de la fuente de datos.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Nota:** El bloque de creación del contrato se puede buscar rápidamente en Etherscan:
> 
> 1. Busca el contrato introduciendo su dirección en la barra de búsqueda.
> 2. Haz clic en el hash de la transacción de creación en la sección `Contract Creator`.
> 3. Carga la página de detalles de la transacción, donde encontrarás el bloque inicial de ese contrato.

## Call Handlers

Aunque los eventos proporcionan una forma eficaz de recoger los cambios relevantes en el estado de un contrato, muchos contratos evitan generar registros para optimizar los costos de gas. En estos casos, un subgrafo puede suscribirse a las llamadas realizadas al contrato de la fuente de datos. Esto se consigue definiendo los handlers de llamadas que hacen referencia a la firma de la función y al handler de mapeo que procesará las llamadas a esta función. Para procesar estas llamadas, el manejador de mapeo recibirá un `ethereum.Call` como argumento con las entradas y salidas tipificadas de la llamada. Las llamadas realizadas en cualquier profundidad de la cadena de llamadas de una transacción activarán el mapeo, permitiendo capturar la actividad con el contrato de origen de datos a través de los contratos proxy.

Los handlers de llamadas sólo se activarán en uno de estos dos casos: cuando la función especificada sea llamada por una cuenta distinta del propio contrato o cuando esté marcada como externa en Solidity y sea llamada como parte de otra función en el mismo contrato.

> **Nota:**Los handlers de llamadas no son compatibles con Rinkeby, Goerli o Ganache. Los handlers de llamadas dependen actualmente de la API de rastreo de Parity y estas redes no la admiten.

### Definición de un Call Handler

Para definir un handler de llamadas en su manifiesto simplemente añade una array `callHandlers` bajo la fuente de datos a la que deseas suscribirte.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

La `función` es la firma de la función normalizada por la que se filtran las llamadas. La propiedad `handler` es el nombre de la función de tu mapeo que quieres ejecutar cuando se llame a la función de destino en el contrato de origen de datos.

### Función mapeo

Cada handler de llamadas toma un solo parámetro que tiene un tipo correspondiente al nombre de la función llamada. En el subgrafo de ejemplo anterior, el mapeo contiene un handler para cuando la función `createGravatar` es llamada y recibe un parámetro `CreateGravatarCall` como argumento:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash.toHex()
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

La función `handleCreateGravatar` toma una nueva `CreateGravatarCall` que es una subclase de `ethereum.Call`, proporcionada por `@graphprotocol/graph-ts`, que incluye las entradas y salidas tipificadas de la llamada. El tipo `CreateGravatarCall` se genera por ti cuando ejecutas `graph codegen`.

## Handlers de bloques

Además de suscribirse a eventos del contracto o llamadas a funciones, un subgrafo puede querer actualizar sus datos a medida que se añaden nuevos bloques a la cadena. Para ello, un subgrafo puede ejecutar una función después de cada bloque o después de los bloques que coincidan con un filtro predefinido.

### Filtros admitidos

```yaml
filter:
  kind: call
```

_El handler definido será llamado una vez por cada bloque que contenga una llamada al contrato (fuente de datos) bajo el cual está definido el handler._

La ausencia de un filtro para un handler de bloque asegurará que el handler sea llamado en cada bloque. Una fuente de datos sólo puede contener un handler de bloque para cada tipo de filtro.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### Función mapeo

La función de mapeo recibirá un `ethereum.Block` como único argumento. Al igual que las funciones de mapeo de eventos, esta función puede acceder a las entidades del subgrafo existentes en el almacén, llamar a los contratos inteligentes y crear o actualizar entidades.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash.toHex()
  let entity = new Block(id)
  entity.save()
}
```

## Eventos anónimos

Si necesitas procesar eventos anónimos en Solidity, puedes hacerlo proporcionando el tema 0 del evento, como en el ejemplo:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0xbaa8529c00000000000000000000000000000000000000000000000000000000'
    handler: handleGive
```

Un evento sólo se activará cuando la firma y el tema 0 coincidan. Por defecto, `topic0` es igual al hash de la firma del evento.

## Características experimentales

Las características del subgrafo que parten de `specVersion` `0.0.4` deben declararse explícitamente en la sección `features` del nivel superior del archivo del manifiesto, utilizando su nombre `camelCase`, como se indica en la tabla siguiente:

| Característica                                            | Nombre                    |
| --------------------------------------------------------- | ------------------------- |
| [Non-fatal errors](#non-fatal-errors)                     | `nonFatalErrors`          |
| [Full-text Search](#defining-fulltext-search-fields)      | `fullTextSearch`          |
| [Grafting](#grafting-onto-existing-subgraphs)             | `grafting`                |
| [IPFS on Ethereum Contracts](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` |

Por ejemplo, si un subgrafo utiliza las características **Full-Text Search** y **Non-fatal Errors**, el campo `features` del manifiesto debería ser:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Ten en cuenta que el uso de una característica sin declararla incurrirá en un **error de validación** durante el despliegue del subgrafo, pero no se producirá ningún error si se declara una característica pero no se utiliza.

### IPFS en Contratos de Ethereum

Un caso de uso común para combinar IPFS con Ethereum es almacenar datos en IPFS que serían demasiado costosos de mantener en la cadena, y hacer referencia al hash de IPFS en los contratos de Ethereum.

Dados estos hashes de IPFS, los subgrafos pueden leer los archivos correspondientes desde IPFS utilizando `ipfs.cat` y `ipfs.map`. Sin embargo, para hacer esto de forma fiable, es necesario que estos archivos estén anclados en el nodo IPFS al que se conecta the Graph Node que indexa el subgrafo. En el caso del [hosted service](https://thegraph.com/hosted-service), es [https://api.thegraph.com/ipfs/](https://api.thegraph.com/ipfs/).

> **Nota:** The Graph Network todavía no admite `ipfs.cat` y `ipfs.map`, y los desarrolladores no deben desplegar subgrafos que utilicen esa funcionalidad en la red a través de Studio.

Para facilitar esto a los desarrolladores de subgrafos, el equipo de The Graph escribió una herramienta para transferir archivos de un nodo IPFS a otro, llamada [ipfs-sync](https://github.com/graphprotocol/ipfs-sync).

> **[La Gestión de Funciones](#experimental-features):** `ipfsOnEthereumContracts` debe declararse en `funciones` en el manifiesto del subgrafo.

### Errores no fatales

Los errores de indexación en subgrafos ya sincronizados harán que, por defecto, el subgrafo falle y deje de sincronizarse. Los subgrafos pueden ser configurados alternativamente para continuar la sincronización en presencia de errores, ignorando los cambios realizados por el handler que provocó el error. Esto da a los autores de subgrafos tiempo para corregir sus subgrafos mientras las consultas siguen siendo servidas contra el último bloque, aunque los resultados serán posiblemente inconsistentes debido al fallo que causó el error. Ten en cuenta que algunos errores siguen siendo siempre fatales, para que el error no sea fatal debe saberse que es determinista.

> **Nota:** The Graph Network todavía no admite errores no fatales, y los desarrolladores no deben desplegar subgrafos que utilicen esa funcionalidad en la red a través de Studio.

La activación de los errores no fatales requiere el establecimiento de la siguiente bandera de características en el manifiesto del subgrafo:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - fullTextSearch
    ...
```

La consulta también debe optar por consultar datos con posibles inconsistencias a través del argumento `subgraphError`. También se recomienda consultar `_meta` para comprobar si el subgrafo ha saltado los errores, como en el ejemplo:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

Si el subgrafo encuentra un error esa consulta devolverá tanto los datos como un error de graphql con el mensaje `"indexing_error"`, como en este ejemplo de respuesta:

```graphql
"data": {
    "foos": [
        {
          "id": "fooId"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Grafting en subgrafos existentes

Cuando un subgrafo se despliega por primera vez, comienza a indexar eventos en el bloque génesis de la cadena correspondiente (o en el `startBlock` definido con cada fuente de datos) En algunas circunstancias, es beneficioso reutilizar los datos de un subgrafo existente y comenzar a indexar en un bloque mucho más tarde. Este modo de indexación se denomina _Grafting_. El grafting es, por ejemplo, útil durante el desarrollo para superar rápidamente errores simples en los mapeos, o para hacer funcionar temporalmente un subgrafo existente después de que haya fallado.

> **Nota:** El grafting requiere que el indexador haya indexado el subgrafo base. No se recomienda en The Graph Network en este momento, y los desarrolladores no deberían desplegar subgrafos que utilicen esa funcionalidad en la red a través de Studio.

Un subgrafo se injerta en un subgrafo base cuando el manifiesto del subgrafo en `subgraph.yaml` contiene un bloque `graft` en el nivel superior:

```yaml
descripción: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

Cuando se despliega un subgrafo cuyo manifiesto contiene un bloque `graft`, Graph Node copiará los datos del subgrafo `base` hasta e incluyendo el `block` dado y luego continuará indexando el nuevo subgrafo a partir de ese bloque. El subgrafo base debe existir en el target de Graph Node de destino y debe haber indexado hasta al menos el bloque dado. Debido a esta restricción, el grafting sólo debería utilizarse durante el desarrollo o durante una emergencia para acelerar la producción de un subgrafo equivalente no grafted.

Dado que el grafting copia en lugar de indexar los datos de base, es mucho más rápido llevar el subgrafo al bloque deseado que indexar desde cero, aunque la copia inicial de los datos puede tardar varias horas en el caso de subgrafos muy grandes. Mientras se inicializa el subgrafo grafteado, the Graph Node registrará información sobre los tipos de entidad que ya han sido copiados.

El subgrafo grafteado puede utilizar un esquema GraphQL que no es idéntico al del subgrafo base, sino simplemente compatible con él. Tiene que ser un esquema de subgrafo válido por sí mismo, pero puede desviarse del esquema del subgrafo base de las siguientes maneras:

- Agrega o elimina tipos de entidades
- Elimina los atributos de los tipos de entidad
- Agrega atributos anulables a los tipos de entidad
- Convierte los atributos no anulables en atributos anulables
- Añade valores a los enums
- Agrega o elimina interfaces
- Cambia para qué tipos de entidades se implementa una interfaz

> **[La gestión de características](#experimental-features):** `grafting` se declara en `features` en el manifiesto del subgrafo.
