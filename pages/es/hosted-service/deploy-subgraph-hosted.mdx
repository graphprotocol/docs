---
title: Despliega un Subgrafo en el Servicio Alojado
---

Si aún no lo has comprobado, revisa cómo escribir los archivos que componen un [subgraph manifest](/developer/create-subgraph-hosted#the-subgraph-manifest) y cómo instalar el [Graph CLI](https://github.com/graphprotocol/graph-cli) para generar el código para tu subgrafo. Ahora, es el momento de desplegar tu subgrafo en el Servicio Alojado, también conocido como Hosted Service.

## Crea una cuenta en el Servicio Alojado

Antes de utilizar el Servicio Alojado, crea una cuenta en nuestro Servicio Alojado. Para ello necesitarás una cuenta [Github](https://github.com/); si no tienes una, debes crearla primero. A continuación, navega hasta el [Hosted Service](https://thegraph.com/hosted-service/), haz clic en el botón _'Sign up with Github'_ y completa el flujo de autorización de Github.

## Almacena el Token de Acceso

Luego de crear la cuenta, navega a tu [dashboard](https://thegraph.com/hosted-service/dashboard). Copia el token de acceso que aparece en el dashboard y ejecuta `graph auth --product hosted-service <ACCESS_TOKEN>`. Esto almacenará el token de acceso en tu computadora. Sólo tienes que hacerlo una vez, o si alguna vez regeneras el token de acceso.

## Crea un Subgrafo en el Servicio Alojado

Antes de desplegar el subgrafo, es necesario crearlo en The Graph Explorer. Ve a [dashboard](https://thegraph.com/hosted-service/dashboard) y haz clic en el botón _'Add Subgraph'_ y completa la información siguiente según corresponda:

**Image** - Selecciona una imagen que se utilizará como imagen de vista previa y miniatura para el subgrafo.

**Subgraph Name** -Junto con el nombre de la cuenta con la que se crea el subgrafo, esto también definirá el nombre de estilo `account-name/subgraph-name` utilizado para los despliegues y los endpoints de GraphQL. _Este campo no puede ser cambiado posteriormente._

**Account** - La cuenta con la que se crea el subgrafo. Puede ser la cuenta de un individuo o de una organización. _Los Subgrafos no pueden ser movidos entre cuentas posteriormente._

**Subtitle** - Texto que aparecerá en las tarjetas del subgrafo.

**Description** - Descripción del subgrafo, visible en la página de detalles del subgrafo.

**GitHub URL** Enlace al repositorio de subgrafos en GitHub.

**Hide** - Al activar esta opción se oculta el subgrafo en the Graph Explorer.

Después de guardar el nuevo subgrafo, se te muestra una pantalla con ayuda sobre cómo instalar the Graph CLI, cómo generar el andamiaje para un nuevo subgrafo, y cómo desplegar tu subgrafo. Los dos primeros pasos se trataron en la sección [Definir un Subgrafo](/developer/define-subgraph-hosted).

## Despliega un Subgrupo en el Servicio Alojado

Deploying your subgraph will upload the subgraph files that you've built with `yarn build` to IPFS and tell the Graph Explorer to start indexing your subgraph using these files.

You deploy the subgraph by running `yarn deploy`

After deploying the subgraph, the Graph Explorer will switch to showing the synchronization status of your subgraph. Depending on the amount of data and the number of events that need to be extracted from historical Ethereum blocks, starting with the genesis block, syncing can take from a few minutes to several hours. The subgraph status switches to `Synced` once the Graph Node has extracted all data from historical blocks. The Graph Node will continue inspecting Ethereum blocks for your subgraph as these blocks are mined.

## Redeploying a Subgraph

When making changes to your subgraph definition, for example to fix a problem in the entity mappings, run the `yarn deploy` command above again to deploy the updated version of your subgraph. Any update of a subgraph requires that Graph Node reindexes your entire subgraph, again starting with the genesis block.

If your previously deployed subgraph is still in status `Syncing`, it will be immediately replaced with the newly deployed version. If the previously deployed subgraph is already fully synced, Graph Node will mark the newly deployed version as the `Pending Version`, sync it in the background, and only replace the currently deployed version with the new one once syncing the new version has finished. This ensures that you have a subgraph to work with while the new version is syncing.

### Deploying the subgraph to multiple Ethereum networks

In some cases, you will want to deploy the same subgraph to multiple Ethereum networks without duplicating all of its code. The main challenge that comes with this is that the contract addresses on these networks are different. One solution that allows to parameterize aspects like contract addresses is to generate parts of it using a templating system like [Mustache](https://mustache.github.io/) or [Handlebars](https://handlebarsjs.com/).

To illustrate this approach, let's assume a subgraph should be deployed to mainnet and Ropsten using different contract addresses. You could then define two config files providing the addresses for each network:

```json
{
  "network": "mainnet",
  "address": "0x123..."
}
```

and

```json
{
  "network": "ropsten",
  "address": "0xabc..."
}
```

Along with that, you would substitute the network name and addresses in the manifest with variable placeholders `{{network}}` and `{{address}}` and rename the manifest to e.g. `subgraph.template.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

In order generate a manifest to either network, you could add two additional commands to `package.json` along with a dependency on `mustache`:

```json
{
  ...
  "scripts": {
    ...
    "prepare:mainnet": "mustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
    "prepare:ropsten": "mustache config/ropsten.json subgraph.template.yaml > subgraph.yaml"
  },
  "devDependencies": {
    ...
    "mustache": "^3.1.0"
  }
}
```

To deploy this subgraph for mainnet or Ropsten you would now simply run one of the two following commands:

```sh
# Mainnet:
yarn prepare:mainnet && yarn deploy

# Ropsten:
yarn prepare:ropsten && yarn deploy
```

A working example of this can be found [here](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759).

**Note:** This approach can also be applied more complex situations, where it is necessary to substitute more than contract addresses and network names or where generating mappings or ABIs from templates as well.

## Checking subgraph health

If a subgraph syncs successfully, that is a good sign that it will continue to run well forever. However, new triggers on the chain might cause your subgraph to hit an untested error condition or it may start to fall behind due to performance issues or issues with the node operators.

Graph Node exposes a graphql endpoint which you can query to check the status of your subgraph. On the Hosted Service, it is available at `https://api.thegraph.com/index-node/graphql`. On a local node it is available on port `8030/graphql` by default. The full schema for this endpoint can be found [here](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql). Here is an example query that checks the status of the current version of a subgraph:

```graphql
{
  indexingStatusForCurrentVersion(subgraphName: "org/subgraph") {
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      chainHeadBlock {
        number
      }
      latestBlock {
        number
      }
    }
  }
}
```

This will give you the `chainHeadBlock` which you can compare with the `latestBlock` on your subgraph to check if it is running behind. `synced` informs if the subgraph has ever caught up to the chain. `health` can currently take the values of `healthy` if no errors ocurred, or `failed` if there was an error which halted the progress of the subgraph. In this case you can check the `fatalError` field for details on this error.

## Subgraph archive policy

The Hosted Service is a free Graph Node indexer. Developers can deploy subgraphs indexing a range of networks, which will be indexed, and made available to query via graphQL.

To improve the performance of the service for active subgraphs, the Hosted Service will archive subgraphs which are inactive.

**A subgraph is defined as "inactive" if it was deployed to the Hosted Service more than 45 days ago, and if it has received 0 queries in the last 30 days.**

Developers will be notified by email if one of their subgraphs has been marked as inactive 7 days before it is removed. If they wish to "activate" their subgraph, they can do so by making a query in their subgraph's Hosted Service graphQL playground. Developers can always redeploy an archived subgraph if it is required again.
