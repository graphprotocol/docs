---
title: indexación
---

import { Difficulty } from '@/components'

Los Indexadores son operadores de nodos en The Graph Network que stakean Graph Tokens (GRT) para proporcionar servicios de indexación y procesamiento de consultas. Los Indexadores obtienen tarifas de consulta y recompensas de indexación por sus servicios. También obtienen ganacias de un pool de reembolso que se comparte con todos los contribuyentes de la red en proporción a su trabajo, siguiendo la idea de Function Rebate por parte de Cobbs-Douglas.

Los GRT que se bloquean (en stake) dentro del protocolo están sujetos a un período de descongelación y pueden ser reducidos si los Indexadores son maliciosos y entregan datos incorrectos a las aplicaciones o si indexan información incorrecta. A los Indexadores también se les puede asignar participaciones por parte de los Delegadores, quienes buscan contribuir a la red.

Los Indexadores seleccionan subgrafos para indexar basados en la señal de curación del subgrafo, donde los curadores acuñan sus GRT para indicar qué subgrafos son de mejor calidad y deben tener prioridad para ser indexados. Los consumidores (por ejemplo, aplicaciones, clientes) también pueden establecer parámetros para los cuales los Indexadores procesan consultas para sus subgrafos y establecen preferencias para el precio asignado a cada consulta.

<Difficulty level="ADVANCED" />

## Preguntas frecuentes

### ¿Cuál es la participación mínima requerida (stake) para ser Indexador en la red?

El stake mínimo para un indexador es actualmente de 100.000 GRT.

### ¿Cuáles son las fuentes de ingresos de un indexador?

** Descuentos en las tarifas de consulta**: Pagos por atender consultas en la red. Estos pagos están asignados a través de unos canales entre el Indexador y un gateway. Cada solicitud de consulta de una puerta de enlace contiene un pago y la respuesta correspondiente una prueba de la validez del resultado de la consulta.

**Recompensas de indexación**: Generadas a través de una inflación anual del protocolo equivalente al 3% , las recompensas de indexación se distribuyen a los indexadores que indexan las implementaciones de subgrafos para la red.

### ¿Cómo se distribuyen las recompensas?

Las recompensas de indexación provienen de la inflación del protocolo, que se establece en una emisión anual del 3%. Se distribuyen en subgrafos según la proporción de toda la señal de curación en cada uno, luego se distribuyen proporcionalmente a los indexadores en función de su stake asignado en ese subgrafo. ** Una asignación debe cerrarse con una prueba de indexación (POI) válida que cumpla con los estándares establecidos por la carta de arbitraje para ser elegible dentro de las recompensas.**

La comunidad ha creado numerosas herramientas para calcular las recompensas; encontrarás una colección de ellos organizados en la [colección de herramientas creeadas por la Comunidad](https://www.notion.so/Community-Guides-abbb10f4dba040d5ba81648ca093e70c). También puedes encontrar una lista actualizada de herramientas en los canales de #delegators e #indexers en el [ servidor de Discord](https://discord.gg/vtvv7FP).

### ¿Qué es una prueba de indexación (POI)?

POI se utilizan en la red para verificar que un indexador está indexando los subgrafos en los que ha asignado. Se debe enviar un POI para el primer bloque del ciclo actual al cerrar una asignación para que esa asignación sea elegible para las recompensas de indexación. Un POI para un bloque, es un resumen de todas las transacciones de las entidades involucradas en la implementación de un subgrafo específico e incluyendo ese bloque.

### ¿Cuándo se distribuyen las recompensas de indexación?

Las asignaciones acumulan recompensas continuamente mientras están activas. Los indexadores recogen las recompensas y las distribuyen cada vez que se cierran sus asignaciones. Eso sucede ya sea manualmente, siempre que el indexador quiera forzar el cierre, o después de 28 ciclos un delegador puede cerrar la asignación para el indexador, pero esto da como resultado que no se generen recompensas. 28 ciclos es la duración máxima de la asignación (en este momento, un ciclo dura aproximadamente 24 h).

### ¿Se pueden monitorear las recompensas pendientes del indexador?

Muchos de los paneles creados por la comunidad incluyen valores de recompensas pendientes y se pueden verificar fácilmente de forma manual siguiendo estos pasos:

Usa Etherscan para llamar `getRewards()`:

1. Consulta el [ subgrafo de la red principal](https://thegraph.com/hosted-service/subgraph/graphprotocol/graph-network-mainnet) para obtener los ID de todas las asignaciones activas:

```graphql
query indexerAllocations {
  indexer(id: "<INDEXER_ADDRESS>") {
    allocations {
      activeForIndexer {
        allocations {
          id
        }
      }
    }
  }
}
```

Utiliza Etherscan para solicitar el `getRewards()`:

- Navega a través de [la interfaz de Etherscan para ver el contrato de recompensas](https://etherscan.io/address/0x9Ac758AB77733b4150A901ebd659cbF8cB93ED66#readProxyContract)

* Para llamar `getRewards()`:
  - Eleva el **10. getRewards** dropdown.
  - Introduce el **allocationID** en la entrada.
  - Presiona el botón de **Query**.

### ¿Qué son las disputas y dónde puedo verlas?

Las consultas y asignaciones del Indexador se pueden disputar en The Graph durante el período de disputa. El período de disputa varía según el tipo de disputa. Las consultas tienen una ventana de disputa de 7 ciclos, mientras que las asignaciones tienen 56 ciclos. Una vez transcurridos estos períodos, no se pueden abrir disputas contra asignaciones o consultas. Cuando se abre una disputa, los Fishermen requieren un depósito mínimo de 10,000 GRT, que permanecerá bloqueado hasta que finalice la disputa y se haya dado una resolución. Los Fishermen (o pescadores) son todos los participantes de la red que abren disputas.

Las disputas se pueden ver en la interfaz de usuario, en la página de perfil de un Indexador, en la pestaña `Disputas`.

- Si se rechaza la disputa, los GRT depositados por los Fishermen se quemarán y el Indexador en disputa no será recortado.
- Si la disputa se resuelve como empate, se devolverá el depósito de los Fishermen y no se recortará al indexador en disputa.
- Si la disputa es aceptada, los GRT depositados por los Fishermen será devuelto, el Indexador en disputa será recortado y los Fishermen ganarán el 50% de los GRT recortados.

Las disputas se podran visualizar en la interfaz correspondiente al perfil del indexador en la pestaña de `disputas`.

### ¿Qué son los reembolsos de tarifas de consulta y cuándo se distribuyen?

La puerta de enlace (gateway) recoge las tarifas de consulta cada vez que se cierra una asignación y se acumulan en el pool de reembolsos de tarifas de consulta del subgrafo. El pool de reembolsos está diseñado para alentar a los Indexadores a asignar participación en una proporción aproximada del monto de tarifas de consulta que ganan para la red. La parte de las tarifas de consulta en el pool que se asigna a un indexador en particular se calcula mediante la Función de Producción Cobbs-Douglas; el monto distribuido por indexador es una función de sus contribuciones al pool y su asignación de participación (stake) en el subgrafo.

Una vez que se ha cerrado una asignación y ha pasado el período de disputa, los reembolsos están disponibles para ser reclamados por el indexador. Al reclamar, los reembolsos de la tarifa de consulta se distribuyen al indexador y sus delegadores en función del recorte de la tarifa de consulta y las proporciones del pool de delegación.

### ¿Qué es el recorte de la tarifa de consulta y el recorte de la recompensa de indexación?

Los valores `queryFeeCut` y `indexingRewardCut` son parámetros de delegación que el Indexador puede establecer junto con cooldownBlocks para controlar la distribución de GRT entre el indexador y sus delegadores. Consulta los últimos pasos en [Staking en el protocolo](/indexing#stake-in-the-protocol) para obtener instrucciones sobre cómo configurar los parámetros de delegación.

- **queryFeeCut**: el porcentaje de los reembolsos de tarifas de consulta acumulados en un subgrafo que se distribuirá al indexador. Si se establece en 95%, el indexador recibirá el 95% del pool de reembolsos de la tarifa de consulta cuando se reclame una asignación y el otro 5% irá a los delegadores.

- **indexingRewardCut**: el porcentaje de las recompensas de indexación acumuladas en un subgrafo que se distribuirá al indexador. Si se establece en 95%, el indexador recibirá el 95% del pool de recompensas de indexación cuando se cierre una asignación y los delegadores dividirán el otro 5%.

### ¿Cómo saben los indexadores qué subgrafos indexar?

Los indexadores pueden diferenciarse aplicando técnicas avanzadas para tomar decisiones de indexación de subgrafos, pero para dar una idea general, discutiremos varias métricas clave que se utilizan para evaluar subgrafos en la red:

- **Señal de curación **: la proporción de señal de curación de la red aplicada a un subgrafo en particular es un buen indicador del interés en ese subgrafo, especialmente durante la fase de lanzamiento cuando el volumen de consultas aumenta.

- ** Tarifas de consulta recogidas**: Los datos históricos del volumen de tarifas de consulta recogidas para un subgrafo específico son un buen indicador de la demanda futura.

- ** Cantidad en staking**: Monitorear el comportamiento de otros indexadores u observar las proporciones de la participación total asignada a subgrafos específicos puede permitirle al indexador monitorear el lado de la oferta en busca de consultas de subgrafos para identificar subgrafos que los que la red muestra confianza o subgrafos que pueden mostrar una necesidad de mayor suministro.

- ** Subgrafos sin recompensas de indexación**: Algunos subgrafos no generan recompensas de indexación principalmente porque utilizan funciones no compatibles como IPFS o porque están consultando otra red fuera de la red principal. Verás un mensaje en un subgrafo si no genera recompensas de indexación.

### ¿Cuáles son los requisitos de hardware?

- **Pequeño**: Lo suficiente como para comenzar a indexar varios subgrafos, es probable que deba expandirse.
- **Estándar**: Configuración predeterminada, esto es lo que se usa en los manifiestos de implementación de k8s/terraform de ejemplo.
- **Medio**: Indexador de producción que admite 100 subgrafos y 200-500 solicitudes por segundo.
- **Grande**: Preparado para indexar todos los subgrafos utilizados actualmente y atender solicitudes para el tráfico relacionado.

| Configuración | Postgres<br />(CPUs) | Postgres<br />(memory in GBs) | Postgres<br />(disk in TBs) | VMs<br />(CPUs) | VMs<br />(memory in GBs) |
| ------------- |:--------------------------:|:-----------------------------------:|:---------------------------------:|:---------------------:|:------------------------------:|
| Pequeño       |             4              |                  8                  |                 1                 |           4           |               16               |
| Estándar      |             8              |                 30                  |                 1                 |          12           |               48               |
| Medio         |             16             |                 64                  |                 2                 |          32           |               64               |
| Grande        |             72             |                 468                 |                3,5                |          48           |              184               |

### ¿Cuáles son algunas de las precauciones de seguridad básicas que debe tomar un indexador?

- ** Billetera del operador**: Configurar una billetera del operador es una precaución importante porque permite que un indexador mantenga la separación entre sus claves que controlan la participación (stake) y las que tienen el control de las operaciones diarias. Consulta [Participación en el Protocolo](/indexing#stake-in-the-protocol) para obtener instrucciones.

- **Firewall**: Solo el servicio indexador debe exponerse públicamente y se debe prestar especial atención al bloqueo de los puertos de administración y el acceso a la base de datos: el punto final JSON-RPC de Graph Node (puerto predeterminado: 8030), el punto final de la API de administración del indexador (puerto predeterminado: 18000) y el punto final de la base de datos de Postgres (puerto predeterminado: 5432) no deben estar expuestos.

## Infraestructura

En el centro de la infraestructura de un indexador está el Graph Node que monitorea Ethereum, extrae y carga datos según una definición de subgrafo y lo sirve como una [GraphQL API](/about/introduction#how-the-graph-works). El Graph Node debe estar conectado a los puntos finales del nodo Ethereum EVM y al nodo IPFS para obtener datos; una base de datos PostgreSQL para su tienda; y componentes del indexador que facilitan sus interacciones con la red.

- **Base de datos PostgreSQL**: El almacén principal para Graph Node, aquí es donde se almacenan los datos del subgrafo. El servicio y el agente del indexador también utilizan la base de datos para almacenar datos del canal de estado, modelos de costos y reglas de indexación.

- **Endpoint de Ethereum**: Un punto final que expone una API Ethereum JSON-RPC. Esto puede tomar la forma de un solo cliente Ethereum o podría ser una configuración más compleja que equilibre la carga en varios. Es importante tener en cuenta que ciertos subgrafos requerirán capacidades particulares del cliente Ethereum, como el modo de archivo y la API de seguimiento.

- **Nodo IPFS (versión inferior a 5)**: Los metadatos de implementación de Subgrafo se almacenan en la red IPFS. El Graph Node accede principalmente al nodo IPFS durante la implementación del subgrafo para obtener el manifiesto del subgrafo y todos los archivos vinculados. Los indexadores de la red no necesitan alojar su propio nodo IPFS, un nodo IPFS para la red está alojado en https://ipfs.network.thegraph.com.

- **Servicio de indexador**: Gestiona todas las comunicaciones externas necesarias con la red. Comparte modelos de costos y estados de indexación, transfiere solicitudes de consulta desde la puerta de acceso (gateway) a Graph Node y administra los pagos de consultas a través de canales de estado con la puerta de acceso.

- **Agente indexador**: Facilita las interacciones de los indexadores en cadena, incluido el registro en la red, la gestión de implementaciones de subgrafos en sus Graph Node y la gestión de asignaciones. Servidor de métricas de Prometheus: los componentes Graph Node y el Indexer registran sus métricas en el servidor de métricas.

Nota: Para admitir el escalado ágil, se recomienda que las inquietudes de consulta e indexación se separen entre diferentes conjuntos de nodos: nodos de consulta y nodos de índice.

### Resumen de puertos

> **Importante**: Ten cuidado con la exposición de los puertos públicamente; los **puertos de administración** deben mantenerse bloqueados. Esto incluye el Graph Node JSON-RPC y los extremos de administración del indexador que se detallan a continuación.

#### Graph Node

| Puerto | Objeto                                                           | Rutas                                                | Argumento CLI     | Variable de Entorno |
| ------ | ---------------------------------------------------------------- | ---------------------------------------------------- | ----------------- | ------------------- |
| 8000   | Servidor HTTP GraphQL <br /> (para consultas de subgrafos) | /subgraphs/id/...<br />/subgraphs/name/.../... | --http-port       | -                   |
| 8001   | GraphQL WS <br /> (para suscripciones a subgrafos)         | /subgraphs/id/...<br />/subgraphs/name/.../... | --ws-port         | -                   |
| 8020   | JSON-RPC <br /> (para administrar implementaciones)        | /                                                    | --admin-port      | -                   |
| 8030   | API de estado de indexación de subgrafos                         | /graphql                                             | --index-node-port | -                   |
| 8040   | Métricas de Prometheus                                           | /metrics                                             | --metrics-port    | -                   |

#### Servicio de Indexador

| Puerto | Objeto                                                                  | Rutas                                                                   | Argumento CLI  | Variable de Entorno    |
| ------ | ----------------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------- | ---------------------- |
| 7600   | Servidor HTTP GraphQL <br /> (para consultas de subgrafo pagadas) | /subgraphs/id/...<br />/status<br />/channel-messages-inbox | --port         | `INDEXER_SERVICE_PORT` |
| 7300   | Métricas de Prometheus                                                  | /metrics                                                                | --metrics-port | -                      |

#### Agente Indexador

| Puerto | Objeto                        | Rutas | Argumento CLI             | Variable de <br /> Entorno        |
| ------ | ----------------------------- | ----- | ------------------------- | --------------------------------------- |
| 8000   | API de gestión de indexadores | /     | --indexer-management-port | `INDEXER_AGENT_INDEXER_MANAGEMENT_PORT` |

### Configurar la infraestructura del servidor con Terraform en Google Cloud

#### Instalar requisitos previos

- SDK de Google Cloud
- Herramienta de línea de comandos de Kubectl
- Terraform

#### Crear un proyecto de Google Cloud

- Clona o navega hasta el repositorio del indexador.

- Navega al directorio ./terraform, aquí es donde se deben ejecutar todos los comandos.

```sh
cd terraform
```

- Autentícate con Google Cloud y crea un nuevo proyecto.

```sh
gcloud auth login
project=<PROJECT_NAME>
gcloud projects create --enable-cloud-apis $project
```

- Usa la \[página de facturación\](página de facturación) de Google Cloud Console para habilitar la facturación del nuevo proyecto.

- Crea una configuración de Google Cloud.

```sh
proj_id=$(gcloud projects list --format='get(project_id)' --filter="name=$project")
gcloud config configurations create $project
gcloud config set project "$proj_id"
gcloud config set compute/region us-central1
gcloud config set compute/zone us-central1-a
```

- Habilita las API requeridas de Google Cloud.

```sh
gcloud services enable compute.googleapis.com
gcloud services enable container.googleapis.com
gcloud services enable servicenetworking.googleapis.com
gcloud services enable sqladmin.googleapis.com
```

- Crea una cuenta de servicio.

```sh
svc_name=<SERVICE_ACCOUNT_NAME>
gcloud iam service-accounts create $svc_name \
  --description="Service account for Terraform" \
  --display-name="$svc_name"
gcloud iam service-accounts list
# Get the email of the service account from the list
svc=$(gcloud iam service-accounts list --format='get(email)'
--filter="displayName=$svc_name")
gcloud iam service-accounts keys create .gcloud-credentials.json \
  --iam-account="$svc"
gcloud projects add-iam-policy-binding $proj_id \
  --member serviceAccount:$svc \
  --role roles/editor
```

- Habilita el emparejamiento entre la base de datos y el clúster de Kubernetes que se creará en el siguiente paso.

```sh
gcloud compute addresses create google-managed-services-default \
  --prefix-length=20 \
  --purpose=VPC_PEERING \
  --network default \
  --global \
  --description 'IP Range for peer networks.'
gcloud services vpc-peerings connect \
  --network=default \
  --ranges=google-managed-services-default
```

- Crea un archivo de configuración mínimo de terraform (actualiza según sea necesario).

```sh
indexer=<INDEXER_NAME>
cat > terraform.tfvars <<EOF
project = "$proj_id"
indexer = "$indexer"
database_password = "<database passowrd>"
EOF
```

#### Usa Terraform para crear infraestructura

Antes de ejecutar cualquier comando, lee [ variables.tf ](https://github.com/graphprotocol/indexer/blob/main/terraform/variables.tf) y crea un archivo `terraform.tfvars` en este directorio (o modifica el que creamos en el último paso). Para cada variable en la que deseas anular el valor predeterminado, o donde necesites establecer un valor, ingresa una configuración en `terraform.tfvars`.

- Ejecuta los siguientes comandos para crear la infraestructura.

```sh
# Install required plugins
terraform init

# View plan for resources to be created
terraform plan

# Create the resources (expect it to take up to 30 minutes)
terraform apply
```

Implementa todos los recursos con `kubectl apply -k $dir`.

```sh
gcloud container clusters get-credentials $indexer
kubectl config use-context $(kubectl config get-contexts --output='name'
| grep $indexer)
```

#### Crea los componentes de Kubernetes para el indexador

- Copia el directorio `k8s/overlays` a un nuevo directorio `$dir,` y ajusta la entrada `bases` en `$dir/kustomization.yaml` para que apunte al directorio `k8s/base`.

- Lee todos los archivos en `$dir` y ajusta cualquier valor como se indica en los comentarios.

Despliega todas las fuentes usando `kubectl apply -k $dir`.

### Graph Node

[Graph Node](https://github.com/graphprotocol/graph-node) es una implementación de Rust de código abierto que genera eventos en la blockchain Ethereum para actualizar de manera determinista un almacén de datos que se puede consultar a través del Punto final GraphQL. Los desarrolladores usan subgrafos para definir su esquema, y ​​un conjunto de mapeos para transformar los datos provenientes de la blockchain y Graph Node maneja la sincronización de toda la cadena, monitorea nuevos bloques y sirve a través de un punto final GraphQL.

#### Empezar desde el origen

#### Instalar Prerrequisitos

- **Rust**

- **PostgreSQL**

- **IPFS**

- **Requisitos adicionales para usuarios de Ubuntu**: Para ejecutar un nodo Graph en Ubuntu, es posible que se necesiten algunos paquetes adicionales.

```sh
sudo apt-get install -y clang libpg-dev libssl-dev pkg-config
```

#### Configurar

1. Inicia un servidor de base de datos PostgreSQL

```sh
initdb -D .postgres
pg_ctl -D .postgres -l logfile start
createdb graph-node
```

2. Clona el repositorio [Graph Node](https://github.com/graphprotocol/graph-node) y crea la fuente ejecutando `cargo build`

3. Ahora que todas las dependencias están configuradas, inicia el nodo Graph (Graph Node):

```sh
cargo run -p graph-node --release -- \
  --postgres-url postgresql://[USERNAME]:[PASSWORD]@localhost:5432/graph-node \
  --ethereum-rpc [NETWORK_NAME]:[URL] \
  --ipfs https://ipfs.network.thegraph.com
```

#### Empezar usando Docker

#### Prerrequisitos

- ** nodo Ethereum**: De forma predeterminada, la configuración de composición de Docker utilizará la red principal: [http://host.docker.internal:8545](http://host.docker.internal:8545) para conectarse al nodo Ethereum en su máquina alojada. Puedes reemplazar este nombre de red y url actualizando `docker-compose.yaml`.

#### Configurar

1. Clona Graph Node y navega hasta el directorio de Docker:

```sh
git clone http://github.com/graphprotocol/graph-node
cd graph-node/docker
```

2. Solo para usuarios de Linux: usa la dirección IP del host en lugar de `host.docker.internal` en `docker-compose.yaml`usando el texto incluido:

```sh
./setup.sh
```

3. Inicia un Graph Node local que se conectará a su punto final de Ethereum:

```sh
docker-compose up
```

### Componentes de Indexador

Para participar con éxito en la red se requiere una supervisión e interacción casi constantes, por lo que hemos creado un conjunto de aplicaciones de Typecript para facilitar la participación de una red de indexadores. Hay tres componentes de indexador:

- ** Agente indexador**: el agente monitorea la red y la propia infraestructura del indexador y administra qué implementaciones de subgrafos se indexan y asignan en la cadena y cuánto se asigna a cada uno.

- **Servicio de indexación**: El único componente que debe exponerse externamente, el servicio transfiere las consultas de subgrafo al graph node, administra los canales de estado para los pagos de consultas, comparte información importante para la toma de decisiones a clientes como las puertas de acceso (gateway).

- **CLI de Indexador**: La interfaz de línea de comandos para administrar el agente indexador. Permite a los indexadores administrar modelos de costos y reglas de indexación.

#### Comenzar

El agente indexador y el servicio indexador deben ubicarse junto con su infraestructura Graph Node. Hay muchas formas de configurar entornos de ejecución virtual para tus componentes de indexador; aquí explicaremos cómo ejecutarlos en baremetal utilizando paquetes o fuente NPM, o mediante kubernetes y docker en Google Cloud Kubernetes Engine. Si estos ejemplos de configuración no se traducen bien en tu infraestructura, es probable que haya una guía de la comunidad de referencia, ¡ven a saludar en [Discord](https://thegraph.com/discord)! Recuerda [stake en el protocolo](/indexing#stake-in-the-protocol) antes de iniciar tus componentes de indexador! ¡Recuerda hacer [staking en el protocolo](/indexing#stake-in-the-protocol) antes de establecer tus componentes como indexer!

#### Paquetes de NPM

```sh
npm install -g @graphprotocol/indexer-service
npm install -g @graphprotocol/indexer-agent

# Indexer CLI is a plugin for Graph CLI, so both need to be installed:
npm install -g @graphprotocol/graph-cli
npm install -g @graphprotocol/indexer-cli

# Indexer service
graph-indexer-service start ...

# Indexer agent
graph-indexer-agent start ...

# Indexer CLI
#Forward the port of your agent pod if using Kubernetes
kubectl port-forward pod/POD_ID 18000:8000
graph indexer connect http://localhost:18000/
graph indexer ...
```

#### Fuente

```sh
# From Repo root directory
yarn

# Indexer Service
cd packages/indexer-service
./bin/graph-indexer-service start ...

# Indexer agent
cd packages/indexer-agent
./bin/graph-indexer-service start ...

# Indexer CLI
cd packages/indexer-cli
./bin/graph-indexer-cli indexer connect http://localhost:18000/
./bin/graph-indexer-cli indexer ...
```

#### Uso de Docker

- Extrae imágenes del registro

```sh
docker pull ghcr.io/graphprotocol/indexer-service:latest
docker pull ghcr.io/graphprotocol/indexer-agent:latest
```

**NOTA**: Después de iniciar los contenedores, se debe poder acceder al servicio de indexación en [http://localhost:7600](http://localhost:7600) y el agente indexador debería exponer la API de administración del indexador en [ http://localhost:18000/](http://localhost:18000/).

```sh
# Indexer service
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-service \
  -t indexer-service:latest \
# Indexer agent
docker build \
  --build-arg NPM_TOKEN=<npm-token> \
  -f Dockerfile.indexer-agent \
  -t indexer-agent:latest \
```

- Ejecuta los componentes

```sh
docker run -p 7600:7600 -it indexer-service:latest ...
docker run -p 18000:8000 -it indexer-agent:latest ...
```

Consulta la sección [Configuración de la infraestructura del servidor con Terraform en Google Cloud](/indexing#setup-server-infrastructure-using-terraform-on-google-cloud)

#### Uso de K8s y Terraform

Indexer CLI es un complemento para [ `@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) accesible en la terminal en `graph indexer`.

#### Uso

> **NOTA**: Todas las variables de configuración de tiempo de ejecución se pueden aplicar como parámetros al comando en el inicio o usando variables de entorno con el formato `COMPONENT_NAME_VARIABLE_NAME`(ej. `INDEXER_AGENT_ETHEREUM`).

#### Agente Indexador

```sh
graph-indexer-agent start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --graph-node-admin-endpoint http://localhost:8020/ \
  --public-indexer-url http://localhost:7600/ \
  --indexer-geo-coordinates <YOUR_COORDINATES> \
  --index-node-ids default \
  --indexer-management-port 18000 \
  --metrics-port 7040 \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  --default-allocation-amount 100 \
  --register true \
  --inject-dai true \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database indexer \
  | pino-pretty
```

#### Servicio de Indexador

```sh
SERVER_HOST=localhost \
SERVER_PORT=5432 \
SERVER_DB_NAME=is_staging \
SERVER_DB_USER=<DB_USERNAME> \
SERVER_DB_PASSWORD=<DB_PASSWORD> \
graph-indexer-service start \
  --ethereum <MAINNET_ETH_ENDPOINT> \
  --ethereum-network mainnet \
  --mnemonic <MNEMONIC> \
  --indexer-address <INDEXER_ADDRESS> \
  --port 7600 \
  --metrics-port 7300 \
  --graph-node-query-endpoint http://localhost:8000/ \
  --graph-node-status-endpoint http://localhost:8030/graphql \
  --postgres-host localhost \
  --postgres-port 5432 \
  --postgres-username <DB_USERNAME> \
  --postgres-password <DB_PASSWORD> \
  --postgres-database is_staging \
  --network-subgraph-endpoint https://gateway.network.thegraph.com/network \
  | pino-pretty
```

#### Indexer CLI

Indexer CLI es un complemento para [`@graphprotocol/graph-cli`](https://www.npmjs.com/package/@graphprotocol/graph-cli) accesible en la terminal de `graph indexer`.

```sh
graph indexer connect http://localhost:18000
graph indexer status
```

#### Gestión del indexador mediante Indexer CLI

El agente indexador necesita información de un indexador para interactuar de forma autónoma con la red en nombre del indexador. El mecanismo para definir el comportamiento del agente indexador son las **reglas de indexación**. Con las **reglas de indexación**, un indexador puede aplicar su estrategia específica para seleccionar subgrafos para indexar y atender consultas. Las reglas se administran a través de una API GraphQL proporcionada por el agente y conocida como API de administración de indexadores (Indexer Management API). La herramienta sugerida para interactuar con la **API de Administración del Indexador** es la **Indexer CLI**, una extensión de **Graph CLI**.

#### Uso

La **CLI del Indexador** se conecta al agente del indexador, normalmente a través del reenvío de puertos, por lo que no es necesario que CLI se ejecute en el mismo servidor o clúster. Para ayudarte a comenzar y proporcionar algo de contexto, la CLI se describirá brevemente aquí.

- `graph indexer connect <url>` - Conéctate a la API de administración del indexador. Normalmente, la conexión al servidor se abre mediante el reenvío de puertos, por lo que la CLI se puede operar fácilmente de forma remota. (Ejemplo: `kubectl port-forward pod/<indexer-agent-pod> 8000:8000`)

- `graph indexer rules get [options] <deployment-id< [<key1> ...]` - Obtén una o más reglas de indexación usando `all` `<deployment-id>` para obtener todas las reglas, o `global` para obtener los valores globales predeterminados. Se puede usar un argumento adicional `--merged` para especificar que las reglas específicas de implementación se fusionan con la regla global. Así es como se aplican en el agente indexador.

- `graph indexer rules set [options] <deployment-id> <key1> <value1> ...` - Establece una o más reglas de indexación.

- `graph indexer rules start [options] <deployment-id>` - Empieza a indexar una implementación de subgrafo si está disponible y establece su `decisionBasis` en `always`, por lo que el agente indexador siempre elegirá indexarlo. Si la regla global se establece en siempre, se indexarán todos los subgrafos disponibles en la red.

- `graph indexer rules stop [options] <deployment-id>` - Dejq de indexar una implementación y establece tu `decisionBasis` en never (nunca), por lo que omitirá esta implementación cuando decida qué implementaciones indexar.

- `graph indexer rules maybe [options] <deployment-id>` - Configura `thedecisionBasis` para una implementación en `rules`, de modo que el agente indexador use las reglas de indexación para decidir si indexar esta implementación.

Todos los comandos que muestran reglas en la salida pueden elegir entre los formatos de salida admitidos (`table`, `yaml` y `json`) utilizando `-output` argument.

#### Reglas de Indexación

Las reglas de indexación se pueden aplicar como valores predeterminados globales o para implementaciones de subgrafos específicos usando sus ID. Los campos `deployment` y `decisionBasis` son obligatorios, mientras que todos los demás campos son opcionales. Cuando una regla de indexación tiene `rules` como `decisionBasis`, el agente indexador comparará los valores de umbral no nulos en esa regla con los valores obtenidos de la red para la implementación correspondiente. Si la implementación del subgrafo tiene valores por encima (o por debajo) de cualquiera de los umbrales, se elegirá para la indexación.

Por ejemplo, si la regla global tiene un `minStake` de **5** (GRT), cualquier implementación de subgrafo que tenga más de 5 (GRT) de participación (stake) asignado a él será indexado. Las reglas de umbral incluyen `maxAllocationPercentage`, `minSignal`, `maxSignal`, `minStake` y `minAverageQueryFees`.

Modelo de Datos:

```graphql
type IndexingRule {
  deployment: string
  allocationAmount: string | null
  parallelAllocations: number | null
  decisionBasis: IndexingDecisionBasis
  maxAllocationPercentage: number | null
  minSignal: string | null
  maxSignal: string | null
  minStake: string | null
  minAverageQueryFees: string | null
  custom: string | null
}

IndexingDecisionBasis {
  rules
  never
  always
}
```

#### Modelos de Costos

Los modelos de costos proporcionan precios dinámicos para consultas basadas en el mercado y los atributos de la consulta. El Servicio de Indexación comparte un modelo de costos con las puertas de enlace para cada subgrafo para el que pretenden responder a las consultas. Las puertas de enlace, a su vez, utilizan el modelo de costos para tomar decisiones de selección de indexadores por consulta y para negociar el pago con los indexadores elegidos.

#### Agora

El lenguaje Agora proporciona un formato flexible para declarar modelos de costos para consultas. Un modelo de precios de Agora es una secuencia de declaraciones que se ejecutan en orden para cada consulta de nivel superior en una consulta GraphQL. Para cada consulta de nivel superior, la primera declaración que coincide con ella determina el precio de esa consulta.

Una declaración se compone de un predicado, que se utiliza para hacer coincidir consultas GraphQL, y una expresión de costo que, cuando se evalúa, genera un costo en GRT decimal. Los valores en la posición del argumento nombrado de una consulta pueden capturarse en el predicado y usarse en la expresión. Los globales también se pueden establecer y sustituir por marcadores de posición en una expresión.

Ejemplo de costos de consultas utilizando el modelo anterior:

```
# This statement captures the skip value,
# uses a boolean expression in the predicate to match specific queries that use `skip`
# and a cost expression to calculate the cost based on the `skip` value and the SYSTEM_LOAD global
query { pairs(skip: $skip) { id } } when $skip > 2000 => 0.0001 * $skip * $SYSTEM_LOAD;

# This default will match any GraphQL expression.
# It uses a Global substituted into the expression to calculate cost
default => 0.1 * $SYSTEM_LOAD;
```

Ejemplo de modelo de costo:

| Consulta                                                                     | Precio  |
| ---------------------------------------------------------------------------- | ------- |
| &#123; pairs(skip: 5000) &#123; id &#125; &#125;                             | 0.5 GRT |
| &#123; tokens &#123; symbol &#125; &#125;                                    | 0.1 GRT |
| &#123; pairs(skip: 5000) &#123; id &#123; tokens &#125; symbol &#125; &#125; | 0.6 GRT |

#### Aplicando el modelo de costos

Los modelos de costos se aplican a través de la CLI de Indexer, que los pasa a la API de Administración de Indexador del agente indexador para almacenarlos en la base de datos. Luego, el Servicio del Indexador los recogerá y entregará los modelos de costos a las puertas de enlace siempre que los soliciten.

```sh
indexer cost set variables '{ "SYSTEM_LOAD": 1.4 }'
indexer cost set model my_model.agora
```

## Interactuar con la red

### Participar en el protocolo

Los primeros pasos para participar en la red como Indexador son aprobar el protocolo, stakear fondos y (opcionalmente) configurar una dirección de operador para las interacciones diarias del protocolo. _ **Nota**: A los efectos de estas instrucciones, Remix se utilizará para la interacción del contrato, pero no dudes en utilizar la herramienta que elijas (\[OneClickDapp\](https: // oneclickdapp.com/), [ABItopic](https://abitopic.io/) y [MyCrypto](https://www.mycrypto.com/account) son algunas otras herramientas conocidas)._

Después de ser creada por un indexador, una asignación saludable pasa por cuatro estados.

#### Aprobar tokens

1. Abre la [aplicación Remix](https://remix.ethereum.org/) en un navegador

2. En el `File Explorer`, crea un archivo llamado **GraphToken.abi** con [token ABI](https://raw.githubusercontent.com/graphprotocol/contracts/mainnet-deploy-build/build/abis/GraphToken.json).

3. Con `GraphToken.abi` seleccionado y abierto en el editor, cambia a la sección Implementar (Deploy) y `Run Transactions` en la interfaz Remix.

4. En entorno, selecciona `Injected Web3` y en `Account` selecciona tu dirección de indexador.

5. Establece la dirección del contrato GraphToken: pega la dirección del contrato GraphToken (`0xc944E90C64B2c07662A292be6244BDf05Cda44a7`) junto a `At Address` y haz clic en el botón `At address` para aplicar.

6. Llame a la función `approve(spender, amount)` para aprobar el contrato de Staking. Completa `spender` con la dirección del contrato de Staking (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) y `amount` con los tokens en stake (en wei).

#### Staking de tokens

1. Abre la [aplicación Remix](https://remix.ethereum.org/) en un navegador

2. En el `File Explorer`, crea un archivo llamado ** Staking.abi** con la ABI de staking.

3. Con `Staking.abi` seleccionado y abierto en el editor, cambia a la sección `Deploy` y `Run Transactions` en la interfaz Remix.

4. En entorno, selecciona `Injected Web3` y en `Account` selecciona tu dirección de indexador.

5. Establece la dirección del contrato de staking - Pega la dirección del contrato de Staking (`0xF55041E37E12cD407ad00CE2910B8269B01263b9`) junto a `At Address` y haz clic en el botón `At address` para aplicar.

6. Llama a `stake()` para bloquear GRT en el protocolo.

7. (Opcional) Los indexadores pueden aprobar otra dirección para que sea el operador de su infraestructura de indexación a fin de separar las claves que controlan los fondos de las que realizan acciones cotidianas, como la asignación en subgrafos y el servicio de consultas (pagadas). Para configurar el operador, llama a `setOperator()` con la dirección del operador.

8. (Opcional) Para controlar la distribución de recompensas y atraer estratégicamente a los delegadores, los indexadores pueden actualizar sus parámetros de delegación actualizando su indexingRewardCut (partes por millón), queryFeeCut (partes por millón) y cooldownBlocks (número de bloques). Para hacerlo, llama a `setDelegationParameters()`. El siguiente ejemplo establece queryFeeCut para distribuir el 95% de los reembolsos de consultas al indexador y el 5% a los delegadores, establece indexingRewardCut para distribuir el 60% de las recompensas de indexación al indexador y el 40% a los delegadores, y establece `thecooldownBlocks` Periodo a 500 bloques.

```
setDelegationParameters(950000, 600000, 500)
```

### La vida de una asignación

Después de ser creada por un indexador, una asignación saludable pasa por cuatro fases.

- **Activo**: Una vez que se crea una asignación en la cadena (\[allocateFrom()\](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol # L873)) se considera **activo**. Una parte de la participación propia y/o delegada del indexador se asigna a una implementación de subgrafo, lo que le permite reclamar recompensas de indexación y atender consultas para esa implementación de subgrafo. El agente indexador gestiona la creación de asignaciones basadas en las reglas del indexador.

- **Cerrado**: Un indexador puede cerrar una asignación una vez que haya pasado 1 ciclo ([closeAllocation()](https://github.com/graphprotocol/contracts/blob/master/contracts/staking/Staking.sol#L873)) o su agente indexador cerrará automáticamente la asignación después de **maxAllocationEpochs** (actualmente 28 días). Cuando una asignación se cierra con una prueba válida de indexación (POI), sus recompensas de indexación se distribuyen al indexador y sus delegadores (consulta "¿Cómo se distribuyen las recompensas?" A continuación para obtener más información).

- **Finalizada**: Una vez que se ha cerrado una asignación, hay un período de disputa después del cual la asignación se considera **finalizada** y los reembolsos de tarifas de consulta están disponibles para ser reclamados (claim()). El agente indexador supervisa la red para detectar asignaciones ** finalizadas** y las reclama si están por encima de un umbral configurable (y opcional), ** - -allocation-claim-threshold**.

- **Reclamado**: El estado final de una asignación; ha seguido su curso como una asignación activa, se han distribuido todas las recompensas elegibles y se han reclamado los reembolsos de las tarifas de consulta.
