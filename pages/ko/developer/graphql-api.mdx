---
title: GraphQL API
---

이 가이드에서는 Graph Protocol에 사용되는 GraphQL Query API를 설명합니다.

## 쿼리

여러분의 서브그래프 스키마에서 `Entities` 유형을 정의합니다. 각 `Entity` 유형에 대해 최상위 `Query` 유형에 `Entity` 및 `entities` 필드가 생성됩니다. The Graph를 사용할 때는 `graphql` 쿼리의 맨 위에 `query`를 포함할 필요가 없습니다.

#### 예시

스키마에 정의된 단일 `Token` 엔티티에 대한 쿼리:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

**참고:**: 단일 엔터티를 쿼리할 때 `id` 필드는 필수이며 문자열이어야 합니다.

모든 `Token` 엔티티들을 쿼리합니다:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### 정렬

컬렉션을 쿼리할 때 `orderBy` 매개변수를 사용하여 특정 속성을 기준으로 정렬할 수 있습니다. 또한 `orderDirection`을 사용하여 정렬 방향을 지정할 수 있습니다. 오름차순은 `asc`, 내림차순은 `desc`입니다.

#### 예시

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

### 쪽수 매기기

컬렉션을 쿼리할 때 `first` 매개변수를 사용하여 컬렉션의 시작 부분부터 페이지를 매길 수 있습니다. 기본 정렬 순서는 생성 시간이 아니라 ID를 기준으로 영숫자 오름차순으로 정렬됩니다.

또한 `skip` 매개변수를 사용하여 엔터티를 건너뛰고 페이지를 매길 수 있습니다. 예를 들어 `first:100`은 처음 100개 항목을 표시하고 `first:100, skip:100`은 다음 100개 항목을 표시합니다.

쿼리는 일반적으로 성능이 좋지 않으므로 매우 큰 `skip` 값을 사용하지 않아야 합니다. 많은 수의 항목을 검색하려면 마지막 예와 같이 속성을 기반으로 엔터티를 통해 페이지를 이동하는 것이 훨씬 좋습니다.

#### Example using `first`

처음 10 토큰들을 쿼리합니다:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

컬렉션 중간에 엔터티 그룹을 쿼리하기 위해 `skip` 매개변수를 `first` 매개변수와 함께 사용하여 컬렉션 시작 부분에서 시작하여 지정된 수의 엔터티를 건너뛸 수 있습니다.

#### Example using `first` and `skip`

컬렉션 시작 부분에서 10자리 오프셋된 10개의 `Token`을 쿼리합니다:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Example using `first` and `id_ge`

클라이언트가 많은 수의 엔터티를 검색해야 하는 경우, 속성을 기반으로 쿼리하고 해당 속성으로 필터링하는 것이 훨씬 더 성능이 좋습니다. 예를 들어 클라이언트는 다음 쿼리를 사용하여 많은 수의 토큰을 검색합니다:

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

처음에는 `lastID = ""`인 쿼리를 보내고 후속 요청의 경우 `lastID`를 이전 요청의 마지막 엔터티의 `id` 속성으로 설정합니다. 이 접근 방식은 증가하는 `skip` 값을 사용하는 것보다 훨씬 더 나은 성능을 보입니다.

### 필터링

쿼리에서 `where` 매개변수를 사용하여 다양한 속성을 필터링할 수 있습니다. `where` 매개변수 내에서 여러 값을 필터링할 수 있습니다.

#### Example using `where`

`failed` 결과로 첼린지들을 쿼리합니다.

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

값 비교를 위해 `_gt`, `_lte`와 같은 접미사를 사용할 수 있습니다.

#### Example for range filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Example for block filtering

You can also filter entities by the `_change_block(number_gte: Int)` - this filters entities which were updated in or after the specified block.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### All Filters

Full list of parameter suffixes:

```
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`.

In addition, the following global filters are available as part of `where` argument:

```gr
_change_block(number_gte: Int)
```

### Time-travel 쿼리

You can query the state of your entities not just for the latest block, which is the by default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the Ethereum chain, the result might change if that block turns out to not be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

Note that the current implementation is still subject to certain limitations that might violate these gurantees. The implementation can not always tell that a given block hash is not on the main chain at all, or that the result of a query by block hash for a block that can not be considered final yet might be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### 예시

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### 예시

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### 전체 텍스트 검색 쿼리(Fulltext Search Queries)

Fulltext search query fields provide an expressive text search API that can be added to the subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developer/create-subgraph-hosted#defining-fulltext-search-fields) to add fulltext search to your subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

Fulltext search operators:

| 심볼 | 연산자 | 설명 |
| --- | --- | --- |
| `&` | `And` | 제공된 모든 용어를 포함하는 엔터티에 대한 필터로, 여러 검색어를 결합하기 위해 사용합니다. |
| &#x7c; | `Or` | the 혹은 오퍼레이터에 의해 구분된 다중 검색어들과 함께 쿼리는 제공된 어떠한 용어들로부터 일치하는 모든 엔티티들을 반환합니다. |
| `<->` | `Follow by` | 두 단어 사이의 거리를 지정합니다. |
| `:*` | `Prefix` | 접두사 검색어를 사용하여 접두사가 일치하는 단어를 찾습니다(2글자 필요). |

#### 예시

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### 엔티티

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## 스키마

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your subgraph is automatically generated from the GraphQL schema that's included in your subgraph manifest.

> **Note:** Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### Entities

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.
