---
title: AssemblyScript API
---

> 참고: 만약 `graph-cli`/`graph-ts` 버전 `0.22.0` 이전의 서브그래프를 생성하는 경우, 이전 버젼의 AssemblyScript를 사용중인 경우, [`Migration Guide`](/developer/assemblyscript-migration-guide)를 참고하시길 권장드립니다.

이 페이지는 서브그래프 매핑을 작성할 때 사용할 수 있는 내장 API를 설명합니다. 다음 두 가지 종류의 API를 즉시 사용할 수 있습니다 :

- [Graph TypeScript library](https://github.com/graphprotocol/graph-ts) (`graph-ts`) 그리고
- `graph codegen`에 의해 서브그래프 파일들에서 생성된 코드

[AssemblyScript](https://github.com/AssemblyScript/assemblyscript)와 호환되는 한 다른 라이브러리들을 의존성(dependencies)으로서 추가할 수도 있습니다. 이것은 언어 매핑이 작성되기 때문에 [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki) 위키는 언어 및 표준 라이브러리 기능과 관련한 좋은 소스입니다.

## 설치

[`graph init`](/developer/create-subgraph-hosted)로 생성된 서브그래프는 미리 구성된 의존성들(dependencies)을 함께 동반합니다. 이러한 의존성들을 설치하려면 다음 명령 중 하나를 실행해야 합니다.

```sh
yarn install # Yarn
npm install  # NPM
```

서브그래프가 처음부터 만들어진 경우 다음 두 명령 중 하나가 의존성으로서 그래프 타입스크립트 라이브러리를 설치할 것입니다.

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## API 참조

`@graphprotocol/graph-ts` 라이브러리가 다음과 같은 API들을 제공합니다.

- 이더리움 스마트 컨트렉트, 이벤트, 블록, 트랜젝션, 그리고 이더리움 값들과 작업하기 위한 `ethereum` API
- 더그래프 노드 스토어에서 엔티티를 로드하고 저장하기 위한 `store` API
- 더그래프 노드 출력 및 그래프 탐색기에 메세지를 기록하는 `log` API
- IPFS로부터 파일들을 로드하기 위한 `ipfs` API
- JSON 데이터를 구문 분석하는 `json` API
- 암호화 기능을 사용하기 위한 `crypto` API
- Ethereum, JSON, GraphQL 및 AssemblyScript와 같은 다양한 유형 시스템 간의 변환을 위한 저수준 프리미티브

### 버전

서브그래프 매니페스트의 `apiVersion`은 주어진 서브그래프에 대해 그래프 노드가 실행하는 매핑 API 버전을 지정합니다. 현재 맵핑 API 버전은 0.0.6 입니다.

| 버전 | 릴리스 노트 |
| :-: | --- |
| 0.0.6 | 이더리움 트랜잭션 개체에 `nonce` 필드를 추가했습니다.<br />`baseFeePerGas`가 이더리움 블록 개체에 추가되었습니다. |
| 0.0.5 | AssemblyScript를 버전 0.19.10으로 업그레이드했습니다(변경 내용 깨짐 포함. [`Migration Guide`](/developer/assemblyscript-migration-guide) 참조)<br />`ethereum.transaction.gasUsed`의 이름이 `ethereum.transaction.gasLimit`로 변경되었습니다. |
| 0.0.4 | Ethereum SmartContractCall 개체에 `functionSignature` 필드를 추가했습니다. |
| 0.0.3 | Ethereum Call 개체에 `from` 필드를 추가했습니다.<br />`etherem.call.address`의 이름이 `ethereum.call.to`로 변경되었습니다. |
| 0.0.2 | Ethereum Transaction 개체에 `input` 필드를 추가했습니다. |

### 기본 제공 유형

AssemblyScript에 내장된 기본 유형에 대한 설명서는 [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types)에서 확인할 수 있습니다.

다음의 추가적인 유형들이 `@graphprotocol/graph-ts`에 의해 제공됩니다.

#### ByteArray

```typescript
'@graphprotocol/graph-ts'에서 { ByteArray }를 입력합니다.
```

`ByteArray`가 `u8`의 배열을 나타냅니다.

_Construction_

- `fromI32(x: i32): ByteArray` - `x`를 바이트로 분해합니다.
- `fromHexString(hex: string): ByteArray` - 입력 길이는 반드시 짝수여야 합니다. `0x` 접두사는 선택사항입니다.

_유형 변환_

- `toHexString(): string` - 접두사가 `0x`인 16진 문자열로 변환합니다.
- `toString(): string` - 바이트를 UTF-8 문자열로 해석합니다.
- `toBase58(): string` - 바이트를 base58 문자열로 인코딩합니다.
- `toU32(): u32` - 바이트를 little-endian `u32`로 해석합니다. 오버플로우의 경우에는 Throws 합니다.
- `toI32(): i32` - 바이트 배열을 little-endian `i32`로 해석합니다. 오버플로우의 경우에는 Throws 합니다.

_연산자_

- `equals(y: ByteArray): bool` – `x == y`로 쓸 수 있습니다

#### BigDecimal

```typescript
'@graphprotocol/graph-ts'로 부터 { BigDecimal }을 입력합니다.
```

`BigDecimal`은 임의의 정밀도 소수를 나타내는 데 사용됩니다.

_Construction_

- `constructor(bigInt: BigInt)` – `BigInt`로 부터 `BigDecimal`을 생성합니다.
- `static fromString(s: string): BigDecimal` – 10진수 문자열에서 구문 분석을 수행합니다.

_유형 변환_

- `toString(): string` – 10진수 문자열로 인쇄합니다.

_Math_

- `plus(y: BigDecimal): BigDecimal` – `x + y`로 쓸 수 있습니다.
- `minus(y: BigDecimal): BigDecimal` – `x - y`로 쓸 수 있습니다.
- `times(y: BigDecimal): BigDecimal` – `x * y`로 쓸 수 있습니다.
- `div(y: BigDecimal): BigDecimal` – `x / y`로 쓸 수 있습니다.
- `equals(y: BigDecimal): bool` – `x == y`로 쓸 수 있습니다.
- `notEqual(y: BigDecimal): bool` – `x != y`로 쓸 수 있습니다.
- `lt(y: BigDecimal): bool` – `x < y`로 쓸 수 있습니다.
- `le(y: BigDecimal): bool` – `x <= y`로 쓸 수 있습니다.
- `gt(y: BigDecimal): bool` – `x > y`로 쓸 수 있습니다.
- `ge(y: BigDecimal): bool` – `x >= y`로 쓸 수 있습니다.
- `neg(): BigDecimal` - `-x`로 쓸 수 있습니다.

#### BigInt

```typescript
'@graphprotocol/graph-ts'에서 { BigInt }를 입력합니다.
```

`BigInt`는 큰 정수를 나타내는 데 사용됩니다. 여기에는 `uint32` ~ `uint256` 및 `int64` ~ `int256`값이 포함됩니다. `int32`, `uint24` 혹은 `int8`과 같은 `uint32` 이하는 전부 `i32`로 표시됩니다.

`BigInt` 클래스에는 다음의 API가 있습니다:

_Construction_

- `BigInt.fromI32(x: i32): BigInt` – `i32`로 부터 `BigInt`를 생성합니다.
- `BigInt.fromString(s: string): BigInt`– 문자열로부터 `BigInt`를 구문 분석합니다.
- `BigInt.fromUnsignedBytes(x: Bytes): BigInt` – `bytes`를 부호 없는 little-endian 정수로 해석합니다. 입력 값이 big-endian인 경우, 먼저 `.reverse()`를 호출하십시오.
- `BigInt.fromSignedBytes(x: Bytes): BigInt` – `bytes`를 signed, little-endian 정수로 해석합니다. 입력 값이 big-endian인 경우, 먼저 `.reverse()`를 호출하십시오.

  _유형 변환_

- `x.toHex(): string` – `BigInt`를 16진수 문자열로 바꿉니다.
- `x.toString(): string` – `BigInt`를 10진수 문자열로 바꿉니다.
- `x.toI32(): i32` – `BigInt`를 `i32`로 반환합니다; 만약 값이 `i32`에 부합하지 않으면, 실패합니다. `x.isI32()`를 먼저 확인하는 것이 좋습니다.
- `x.toBigDecimal(): BigDecimal` - 소수 부분 없이 십진수로 변환합니다.

_Math_

- `x.plus(y: BigInt): BigInt` – `x + y`로 쓸 수 있습니다.
- `x.minus(y: BigInt): BigInt` – `x - y`로 쓸 수 있습니다.
- `x.times(y: BigInt): BigInt` – `x * y`로 쓸 수 있습니다.
- `x.div(y: BigInt): BigInt` – `x / y`로 쓸 수 있습니다.
- `x.mod(y: BigInt): BigInt` – `x % y`로 쓸 수 있습니다.
- `x.equals(y: BigInt): bool` – `x == y`로 쓸 수 있습니다.
- `x.notEqual(y: BigInt): bool` – `x != y`로 쓸 수 있습니다.
- `x.lt(y: BigInt): bool` – `x < y`로 쓸 수 있습니다.
- `x.le(y: BigInt): bool` – `x <= y`로 쓸 수 있습니다.
- `x.gt(y: BigInt): bool` – `x > y`로 쓸 수 있습니다.
- `x.ge(y: BigInt): bool` – `x >= y`로 쓸 수 있습니다.
- `x.neg(): BigInt` – `-x`로 쓸 수 있습니다.
- `x.divDecimal(y: BigDecimal): BigDecimal` – 십진수로 나누어, 십진 결과를 제공합니다.
- `x.isZero(): bool` – 숫자가 0인지 확인하는데 편리합니다.
- `x.isI32(): bool` – 숫자가 `i32`에 부합하는지 확인합니다.
- `x.abs(): BigInt` – 절대값.
- `x.pow(exp: u8): BigInt` – 지수화.
- `bitOr(x: BigInt, y: BigInt): BigInt` – `x | y`로 쓸 수 있습니다.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – `x & y`로 쓸 수 있습니다.
- `leftShift(x: BigInt, bits: u8): BigInt` – `x << y`로 쓸 수 있습니다.
- `rightShift(x: BigInt, bits: u8): BigInt` – `x >> y`로 쓸 수 있습니다.

#### TypedMap

```typescript
'@graphprotocol/graph-ts'에서 { TypedMap }를 입력합니다.
```

`TypedMap`는 key-value 쌍을 저장하는데 사용될 수 있습니다. [이 예](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51)를 보시기 바랍니다.

`TypedMap` 클래스에는 다음의 API가 있습니다.

- `new TypedMap<K, V>()` – 유형 `K`의 키와 유형 `T`의 값을 사용하여 빈 맵을 생성합니다.
- `map.set(key: K, value: V): void` – `key` 값을 `value`로 설정합니다.
- `map.getEntry(key: K): TypedMapEntry<K, V> | null` – 만약 `key`가 맵에 존재하지 않는 경우, `key` 혹은 `null` 에 대한 key-value 쌍을 반환합니다.
- `map.get(key: K): V | null` – 만약 `key`가 맵에 존재하지 않으면, `key` 혹은 `null` 값을 반환합니다.
- `map.isSet(key: K): bool` – 만약 `key`는 맵에 존재하나, `false`가 맵에 존재하지 않는 경우, `true`를 반환합니다.

#### Bytes

```typescript
'@graphprotocol/graph-ts'에서 { Bytes }를 입력합니다.
```

`Bytes`는 임의 길이의 바이트 배열을 나타내는 데 사용됩니다. 이는 `bytes`, `bytes32` 등의 이더리움 값을 포함합니다.

`Bytes` 클래스는 AssemblyScript의 [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64)를 확장하며, 모든 `Uint8Array` 기능과 다음과 같은 새 매서드를 지원합니다:

- `b.toHex()` – 배열상의 바이트를 나타내는 16진수 문자열을 반환합니다.
- `b.toString()` – 배열상의 바이트를 유니코드 문자 문자열로 변환합니다.
- `b.toBase58()` – 이더리움 바이트 값을 base58 인코딩(IPFS 해시에 사용)으로 변환합니다.

#### Address

```typescript
'@graphprotocol/graph-ts'에서 { Address } 를 입력합니다.
```

`Address`는 `Bytes`를 확장하여 이더리움 `address` 값을 나타냅니다.

`Bytes` API 위에 다음 메서드를 추가합니다:

- `Address.fromString(s: string): Address` – 16진수 문자열에서 `Address` 를 생성합니다.

### Store API

```typescript
'@graphprotocol/graph-ts'에서 { store }를 입력합니다.
```

`store` API 를 사용하면 더 그래프 노드 스토어에서 엔티티를 로드, 저장 및 제거할 수 있습니다.

스토어에 작성된 엔티티는 서브그래프의 GraphQL 스키마에 정의된 `@entity` 유형에 일대일로 매핑됩니다. 이러한 엔터티 작업을 편리하게 하기 위해 [Graph CLI](https://github.com/graphprotocol/graph-cli)에서 제공하는 `graph codegen` 명령은 기본 제공 `Entity` 유형의 서브 클래스인 엔터티 클래스를 생성하며, 스키마의 필드에 대한 속성 getter 및 setter와 이러한 엔티티를 로드 및 저장하는 메서드를 사용합니다.

#### Creating entities

다음은 이더리움 이벤트에서 엔티티를 생성하기 위한 일반적인 패턴입니다.

```typescript
// Import the Transfer event class generated from the ERC20 ABI
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// Import the Transfer entity type generated from the GraphQL schema
import { Transfer } from '../generated/schema'

// Transfer event handler
export function handleTransfer(event: TransferEvent): void {
  // Create a Transfer entity, using the hexadecimal string representation
  // of the transaction hash as the entity ID
  let id = event.transaction.hash.toHex()
  let transfer = new Transfer(id)

  // Set properties on the entity, using the event parameters
  transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Save the entity to the store
  transfer.save()
}
```

체인을 처리하는 동안 `Transfer` 이벤트가 발생하면, 이는 생성된 `Transfer` 유형(엔터티 유형과 이름 충돌이 발생하지 않도록 여기서 `TransferEvent`로 별칭 지정)을 사용하여 `handleTransfer` 이벤트 핸들러에 전달됩니다. 이 유형을 사용하면 이벤트의 상위 트랜잭션 및 해당 매개 변수와 같은 데이터에 액세스할 수 있습니다.

각 엔티티는 다른 엔티티와의 충돌을 피하기 위해 고유한 ID를 가져야 합니다. 이벤트 매개변수에 사용할 수 있는 고유 식별자가 포함되는 것은 매우 일반적입니다. 참고: 트랜잭션 해시를 ID로 사용하면 동일한 트랜잭션의 다른 이벤트가 이 해시를 ID로 사용하여 엔티티를 만들지 않는다고 가정합니다.

#### 스토어에서 엔티티 로드

엔티티가 이미 존재하는 경우, 이는 다음을 사용하여 스토어에서 로드할 수 있습니다.

```typescript
let id = event.transaction.hash.toHex() // or however the ID is constructed
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Use the Transfer entity as before
```

엔티티가 스토어에 아직 존재하지 않을 수도 있으므로, `load` 메서드는 `Transfer | null` 유형의 값을 반환합니다. 떠라서 해당 값을 사용하기 전에 `null` 케이스를 확인해야 할 수 있습니다.

> **Note:**: 매핑에서 변경한 내용이 엔티티의 이전 데이터에 종속된 경우에만 엔티티 로드가 필요합니다. 다음 섹션에서 기존 엔티티들을 업데이트하는 두 가지 방법을 확인하시기 바랍니다.

#### 기존 엔티티 업데이트

기존 엔티티를 업데이트 하는 방법에는 두 가지가 있습니다.

1. 엔터티를 로드합니다. `Transfer.load(id)`를 예로들어, 엔터티의 속성을 설정한 다음, 스토어에 다시 `.save()`합니다.
2. `new Transfer(id)`를 예로 들어, 간단하게 엔티티를 생성하기만 하면 됩니다. 엔티티의 속성을 설정한 다음 이를 스토어에 `.save()` 합니다. 만약 엔티티가 이미 존재하는 경우, 변경사항들은 병합됩니다.

속성 변경은 생성된 속성 설정기 덕분에 대부분의 경우 간단합니다.

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

다음 두 가지 지침 중 하나로 속성을 설정 해제할 수도 있습니다.

```typescript
transfer.from.unset()
transfer.from = null
```

이는 오직 선택적 속성으로만 작동하는데, 예를 들어 GraphQL에서 `!` 없이 표기된 속성들입니다. `owner: Bytes` 혹은 `amount: BigInt`를 두 가지 예로 들 수 있습니다.

엔터티에서 배열을 가져오면 해당 배열의 복사본이 생성되기 때문에 배열 속성 업데이트는 조금 더 복잡합니다. 이는 배열을 변경한 후 명시적으로 배열 속성을 다시 설정해야 함을 의미합니다. 다음은 `entity`에 `numbers: [BigInt!]!` 필드가 있다고 가정합니다.

```typescript
// 이는 작동하지 않을 것입니다.
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// 이는 작동 할 것입니다.
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### 스토어에서 엔티티 제거하기

현재 생성된 유형을 통해 엔티티를 제거할 수 있는 방법은 없습니다. 대신 엔티티를 제거하려면 엔티티 유형의 이름과 엔티티 ID를 `store.remove`에 전달해야 합니다.

```typescript
'@graphprotocol/graph-ts'에서 { store }를 입력합니다.
...
let id = event.transaction.hash.toHex()
store.remove('Transfer', id)
```

### 이더리움 API

이더리움 API는 스마트 컨트렉트, 퍼블릭 상태 변수, 컨트렉트 기능, 이벤트, 트랜잭션, 블록 및 이더리움 데이터 인코딩/디코딩에 대한 액세스를 제공합니다.

#### 이더리움 유형 지원

엔터티와 마찬가지로 `graph codegen`은 서브그래프에서 사용되는 모든 스마트 컨트랙트 및 이벤트에 대한 클래스를 생성합니다. 이를 위해 컨트랙트 ABI는 서브그래프 매니페스트에서 데이터 소스의 일부여야 합니다. 일반적으로 ABI 파일은 `abis/` 폴더에 저장됩니다.

생성된 클래스를 사용하면 이더리움 유형과 [내장 유형](#built-in-types) 간의 변환이 뒤에서 이루어지므로 서브그래프 작성자는 이에 대해 걱정할 필요가 없습니다.

다음의 예가 이를 보여줍니다. 다음과 같은 서브그래프 스키마가 주어지면

```graphql
type Transfer @entity {
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

그리고 이더리움 상의 `Transfer(address,address,uint256)` 이벤트 서명, `from`, `to` 및 `amount` 유형 값 `address`, `address` 그리고 `uint256`는 `Address` 및 `BigInt`로 변환되고, `Bytes!` 및 `Transfer` 엔티티의 `BigInt!` 속성에 전달됩니다:

```typescript
let id = event.transaction.hash.toHex()
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### 이벤트 및 블록/트랜젝션 데이터

이전의 예시에서 `Transfer` 이벤트에 대해 설명한 바와 같이, 이벤트 핸들로들에게 전달된 이더리움 이벤트들은 이벤트 매개변수에 엑세스를 제공할 뿐만 아니라 상위 트랜잭션과 이벤트 핸들러가 속한 블록에 대한 액세스를 제공합니다. 다음의 데이터는 이벤트 인스턴스(이러한 클래스들은 `graph-ts`의 `ethereum` 모듈의 일부입니다)에서 얻을 수 있습니다:

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}
```

#### Access to Smart Contract State

The code generated by `graph codegen` also includes classes for the smart contracts used in the subgraph. These can be used to access public state variables and call functions of the contract at the current block.

A common pattern is to access the contract from which an event originates. This is achieved with the following code:

```typescript
// Import the generated contract class
import { ERC20Contract } from '../generated/ERC20Contract/ERC20Contract'
// Import the generated entity class
import { Transfer } from '../generated/schema'

export function handleTransfer(event: Transfer) {
  // Bind the contract to the address that emitted the event
  let contract = ERC20Contract.bind(event.address)

  // Access state variables and functions by calling them
  let erc20Symbol = contract.symbol()
}
```

As long as the `ERC20Contract` on Ethereum has a public read-only function called `symbol`, it can be called with `.symbol()`. For public state variables a method with the same name is created automatically.

Any other contract that is part of the subgraph can be imported from the generated code and can be bound to a valid address.

#### Handling Reverted Calls

If the read-only methods of your contract may revert, then you should handle that by calling the generated contract method prefixed with `try_`. For example, the Gravity contract exposes the `gravatarToOwner` method. This code would be able to handle a revert in that method:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

Note that a Graph node connected to a Geth or Infura client may not detect all reverts, if you rely on this we recommend using a Graph node connected to a Parity client.

#### Encoding/Decoding ABI

Data can be encoded and decoded according to Ethereum's ABI encoding format using the `encode` and `decode` functions in the `ethereum` module.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

For more information:

- [ABI Spec](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Encoding/decoding [Rust library/CLI](https://github.com/rust-ethereum/ethabi)
- More [complex example](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Logging API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

The `log` API allows subgraphs to log information to the Graph Node standard output as well as the Graph Explorer. Messages can be logged using different log levels. A basic format string syntax is provided to compose log messages from argument.

The `log` API includes the following functions:

- `log.debug(fmt: string, args: Array<string>): void` - logs a debug message.
- `log.info(fmt: string, args: Array<string>): void` - logs an informational message.
- `log.warning(fmt: string, args: Array<string>): void` - logs a warning.
- `log.error(fmt: string, args: Array<string>): void` - logs an error message.
- `log.critical(fmt: string, args: Array<string>): void` – logs a critical message _and_ terminates the subgraph.

The `log` API takes a format string and an array of string values. It then replaces placeholders with the string values from the array. The first `{}` placeholder gets replaced by the first value in the array, the second `{}` placeholder gets replaced by the second value and so on.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Logging one or more values

##### Logging a single value

In the example below, the string value "A" is passed into an array to become`['A']` before being logged:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Logging a single entry from an existing array

In the example below, only the first value of the argument array is logged, despite the array containing three values.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"  (Even though three values are passed to `log.info`)
  log.info('My value is: {}', myArray)
}
```

#### Logging multiple entries from an existing array

Each entry in the arguments array requires its own placeholder `{}` in the log message string. The below example contains three placeholders `{}` in the log message. Because of this, all three values in `myArray` are logged.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Logging a specific entry from an existing array

To display a specific value in the array, the indexed value must be provided.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Logging event information

The example below logs the block number, block hash and transaction hash from an event:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

Smart contracts occasionally anchor IPFS files on chain. This allows mappings to obtain the IPFS hashes from the contract and read the corresponding files from IPFS. The file data will be returned as `Bytes`, which usually requires further processing, e.g. with the `json` API documented later on this page.

Given an IPFS hash or path, reading a file from IPFS is done as follows:

```typescript
// Put this inside an event handler in the mapping
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Paths like `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// that include files in directories are also supported
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

**Note:** `ipfs.cat` is not deterministic at the moment. If the file cannot be retrieved over the IPFS network before the request times out, it will return `null`. Due to this, it's always worth checking the result for `null`. To ensure that files can be retrieved, they have to be pinned to the IPFS node that Graph Node connects to. On the [hosted service](https://thegraph.com/hosted-service), this is [https://api.thegraph.com/ipfs/](https://api.thegraph.com/ipfs). See the [IPFS pinning](/developer/create-subgraph-hosted#ipfs-pinning) section for more information.

It is also possible to process larger files in a streaming fashion with `ipfs.map`. The function expects the hash or path for an IPFS file, the name of a callback, and flags to modify its behavior:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Callbacks can also created entities
  let newItem = new Item(id.toString())
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Set parent to "parentId"
  newitem.save()
}

// Put this inside an event handler in the mapping
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Alternatively, use `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

The only flag currently supported is `json`, which must be passed to `ipfs.map`. With the `json` flag, the IPFS file must consist of a series of JSON values, one value per line. The call to `ipfs.map` will read each line in the file, deserialize it into a `JSONValue` and call the callback for each of them. The callback can then use entity operations to store data from the `JSONValue`. Entity changes are stored only when the handler that called `ipfs.map` finishes successfully; in the meantime, they are kept in memory, and the size of the file that `ipfs.map` can process is therefore limited.

On success, `ipfs.map` returns `void`. If any invocation of the callback causes an error, the handler that invoked `ipfs.map` is aborted, and the subgraph is marked as failed.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

The `crypto` API makes a cryptographic functions available for use in mappings. Right now, there is only one:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON data can be parsed using the `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array
- `json.try_fromBytes(data: Bytes): Result<JSONValue, boolean>` – safe version of `json.fromBytes`, it returns an error variant if the parsing failed
- `json.fromString(data: Bytes): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(data: Bytes): Result<JSONValue, boolean>` – safe version of `json.fromString`, it returns an error variant if the parsing failed

The `JSONValue` class provides a way to pull values out of an arbitrary JSON document. Since JSON values can be booleans, numbers, arrays and more, `JSONValue` comes with a `kind` property to check the type of a value:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

In addition, there is a method to check if the value is `null`:

- `value.isNull(): boolean`

When the type of a value is certain, it can be converted to a [built-in type](#built-in-types) using one of the following methods:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (이후 `JSONValue`를 상기 5개 방법 중 하나로 변환합니다.)

### 유형 변환 참조

| Source(s)            | Destination          | Conversion function          |
| -------------------- | -------------------- | ---------------------------- |
| Address              | Bytes                | none                         |
| Address              | ID                   | s.toHexString()              |
| Address              | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | none                         |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)    |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Bytes                | String (hexadecimal) | s.toHexString() or s.toHex() |
| Bytes                | String (unicode)     | s.toString()                 |
| Bytes                | String (base58)      | s.toBase58()                 |
| Bytes                | i32                  | s.toI32()                    |
| Bytes                | u32                  | s.toU32()                    |
| Bytes                | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | none                         |
| int32                | i32                  | none                         |
| int32                | BigInt               | Bigint.fromI32(s)            |
| uint24               | i32                  | none                         |
| int64 - int256       | BigInt               | none                         |
| uint32 - uint256     | BigInt               | none                         |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Address              | Address.fromString(s)        |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Bytes                | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)        |

### 데이터 소스 메타데이터

`dataSource` 네임스페이스를 통해 핸들러를 호출한 데이터 소스의 계약 주소, 네트워크 및 컨텍스트를 검사할 수 있습니다

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### 엔티티 및 Entity and DataSourceContext

기본 `Entity` 클래스 및 child `DataSourceContext`는 필드를 동적으로 설정하고 필드를 가져오는 도우미가 있습니다.

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`
