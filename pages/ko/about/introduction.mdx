---
title: 소개
---

이 페이지는 더 그래프가 무엇이며, 여러분들이 시작하는 방법에 대해 설명합니다.

## 더 그래프란 무엇인가?

더 그래프는 이더리움으로부터 시작한 블록체인 데이터를 인덱싱하고 쿼리하기 위한 분산형 프로토콜입니다. 이는 직접 쿼리하기 어려운 데이터 쿼리를 가능하게 해줍니다.

[유니스왑](https://uniswap.org/) 처럼 복잡한 스마트 컨트렉트를 구현하는 프로젝트나 [Bored Ape Yacht Club](https://boredapeyachtclub.com/)과 같은 NFT 이니셔티브들은 이더리움 블록체인에 데이터를 저장하기 때문에, 블록체인의 기본 데이터 외에는 직접적으로 읽기가 매우 어렵습니다.

Bored Ape Yacht Club의 경우에 우리는 [해당 컨트렉트](https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code) 에서 특정 유인원의 주인을 확인하거나, 그들의 ID를 기반으로 Ape의 콘텐츠 URI를 확인하거나, 혹은 총 공급량을 확인하는 등의 기본적인 읽기 작업을 수행할 수 있습니다. 이는 이러한 읽기 작업이 스마트 컨트렉트에 직접적으로 프로그래밍 되었기 때문에 가능하지만, 집계, 검색, 관계 및 단순하지 않은 필터링과 같은 더 고급 적인 실생활 쿼리 및 작업은 불가능합니다. 예를 들어 여러분들이 특정 주소가 소유한 유인원을 쿼리하고, 그 특성 중 하나로 필터링하고자 하는 경우, 우리는 해당 컨트렉트 자체와 직접 상호 작용하여 해당 정보를 얻을 수 없습니다.

이러한 데이터를 얻기 위해서, 여러분들은 아마 그동안 발생한 모든 단일  [`transfer`](https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code#L1746) 이벤트 들을 모두 처리하고, 토큰 ID와 IPFS 해시를 사용하여 IPFS로부터 메타데이터를 읽은 후 이들을 집계해야 합니다. 이러한 유형의 비교적 간단한 쿼리에 대해서도, 아마 브라우저에서 실행되는 탈중앙화 애필리케이션(dapp)은 답을 얻기 위해 **몇 시간 혹은 며칠**이 걸릴 수도 있습니다.

또한 여러분들은 데이터를 쿼리하기 위해 자체 서버를 구축하고, 그곳에서 트랜잭션을 처리하고, 데이터베이스에 저장하고, 그 위에 API 엔드포인트를 구축할 수도 있습니다. 하지만 이 옵션은 많은 리소스를 사용하고, 유지 관리가 필요하며, 단일 실패 지점을 제공하고 또한 탈중앙화에 필수적인 중요한 보안 속성을 손상시킵니다.

**블록체인 데이터를 인덱싱하는 것은 정말로, 정말로 어렵습니다.**

Blockchain properties like finality, chain reorganizations, or uncled blocks complicate this process further, and make it not just time consuming but conceptually hard to retrieve correct query results from blockchain data.

The Graph solves this with a decentralized protocol that indexes and enables the performant and efficient querying of blockchain data. These APIs (indexed "subgraphs") can then be queried with a standard GraphQL API. Today, there is a hosted service as well as a decentralized protocol with the same capabilities. Both are backed by the open source implementation of [Graph Node](https://github.com/graphprotocol/graph-node).

## How The Graph Works

The Graph learns what and how to index Ethereum data based on subgraph descriptions, known as the subgraph manifest. The subgraph description defines the smart contracts of interest for a subgraph, the events in those contracts to pay attention to, and how to map event data to data that The Graph will store in its database.

Once you have written a `subgraph manifest`, you use the Graph CLI to store the definition in IPFS and tell the indexer to start indexing data for that subgraph.

This diagram gives more detail about the flow of data once a subgraph manifest has been deployed, dealing with Ethereum transactions:

![](/img/graph-dataflow.png)

The flow follows these steps:

1. A decentralized application adds data to Ethereum through a transaction on a smart contract.
2. The smart contract emits one or more events while processing the transaction.
3. Graph Node continually scans Ethereum for new blocks and the data for your subgraph they may contain.
4. Graph Node finds Ethereum events for your subgraph in these blocks and runs the mapping handlers you provided. The mapping is a WASM module that creates or updates the data entities that Graph Node stores in response to Ethereum events.
5. The decentralized application queries the Graph Node for data indexed from the blockchain, using the node's [GraphQL endpoint](https://graphql.org/learn/). The Graph Node in turn translates the GraphQL queries into queries for its underlying data store in order to fetch this data, making use of the store's indexing capabilities. The decentralized application displays this data in a rich UI for end-users, which they use to issue new transactions on Ethereum. The cycle repeats.

## Next Steps

In the following sections we will go into more detail on how to define subgraphs, how to deploy them, and how to query data from the indexes that Graph Node builds.

Before you start writing your own subgraph, you might want to have a look at the Graph Explorer and explore some of the subgraphs that have already been deployed. The page for each subgraph contains a playground that lets you query that subgraph's data with GraphQL.
