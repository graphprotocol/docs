---
title: GraphQL API
---

يشرح هذا الدليل GraphQL Query API المستخدمة في بروتوكول Graph.

## الاستعلامات

في مخطط الـ subgraph الخاص بك ، يمكنك تعريف أنواع وتسمى `Entities`. لكل نوع من `Entity` ، سيتم إنشاء حقل `entity` و `entities` في المستوى الأعلى من نوع `Query`. لاحظ أنه لا يلزم تضمين `query` أعلى استعلام `graphql` عند استخدام The Graph.

#### أمثلة

الاستعلام عن كيان `Token` واحد معرف في مخططك:

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

** ملاحظة: ** عند الاستعلام عن كيان واحد ، فإن الحقل `id` يكون مطلوبا ويجب أن يكون string.

الاستعلام عن جميع كيانات `Token`:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### الفرز

عند الاستعلام عن مجموعة ، يمكن استخدام البارامتر `orderBy` للترتيب حسب صفة معينة. بالإضافة إلى ذلك ، يمكن استخدام `OrderDirection` لتحديد اتجاه الفرز ،`asc` للترتيب التصاعدي أو `desc` للترتيب التنازلي.

#### مثال

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

### ترقيم الصفحات

عند الاستعلام عن مجموعة ، يمكن استخدام البارامتر `first` لترقيم الصفحات من بداية المجموعة. من الجدير بالذكر أن ترتيب الفرز الافتراضي يكون حسب الـ ID بترتيب رقمي تصاعدي ، وليس حسب وقت الإنشاء.

علاوة على ذلك ، يمكن استخدام البارامتر `skip` لتخطي الكيانات وترقيم الصفحات. على سبيل المثال `first:100` يعرض أول 100 عنصر و `first:100, skip:100` يعرض 100 عنصر التالية.

الاستعلامات يجب أن تتجنب استخدام قيم `skip` كبيرة جدا نظرا لأنها تؤدي بشكل عام أداء ضعيفا. لجلب عدد كبير من العناصر ، من الأفضل تصفح الكيانات بناء على صفة كما هو موضح في المثال الأخير.

#### مثال

استعلم عن أول 10 توكن:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

للاستعلام عن مجموعات الكيانات في منتصف المجموعة ، يمكن استخدام البارامتر `skip` بالاصافة لبارامتر `first` لتخطي عدد محدد من الكيانات بدءا من بداية المجموعة.

#### مثال

الاستعلام عن 10 كيانات `Token` ،بإزاحة 10 أماكن من بداية المجموعة:

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### مثال

إذا احتاج العميل إلى جلب عدد كبير من الكيانات ، فمن الأفضل أن تستند الاستعلامات إلى إحدى الصفات والفلترة حسب تلك الصفة. على سبيل المثال ، قد يجلب العميل عددا كبيرا من التوكن باستخدام هذا الاستعلام:

```graphql
{
  query manyTokens($lastID: String) {
    tokens(first: 1000, where: { id_gt: $lastID  }) {
      id
      owner
    }
  }
}
```

في المرة الأولى ، سيتم إرسال الاستعلام مع `lastID = ""` ، وبالنسبة للطلبات اللاحقة ، سيتم تعيين `lastID` إلى صفة `id` للكيان الأخير في الطلب السابق. أداء هذا الأسلوب أفضل بكثير من استخدام زيادة قيم `skip`.

### الفلترة

يمكنك استخدام البارامتر `where` في الاستعلام لتصفية الخصائص المختلفة. يمكنك الفلترة على قيم متعددة ضمن البارامتر `where`.

#### مثال

تحديات الاستعلام مع نتيجة `failed`:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

يمكنك استخدام لواحق مثل `gt` ، `_lte_` لمقارنة القيم:

#### مثال

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

القائمة الكاملة للواحق البارامترات:

```graphql
not_
gt_
lt_
gte_
lte_
in_
not_in_
contains_
not_contains_
starts_with_
ends_with_
not_starts_with_
not_ends_with_
```

يرجى ملاحظة أن بعض اللواحق مدعومة فقط لأنواع معينة. على سبيل المثال ، `Boolean` يدعم فقط `not_` و `_in` و `not_in_`.

### الاستعلامات المنتقلة زمنيا

يمكنك الاستعلام عن حالة الكيانات الخاصة بك ليس فقط للكتلة الأخيرة ، والتي هي افتراضيا ، ولكن أيضا لكتلة في الماضي. يمكن تحديد الكتلة التي يجب أن يحدث فيها الاستعلام إما عن طريق رقم الكتلة أو hash الكتلة الخاص بها عن طريق تضمين وسيطة `block` في حقول المستوى الأعلى للاستعلامات.

لن تتغير نتيجة مثل هذا الاستعلام بمرور الوقت ، أي أن الاستعلام في كتلة سابقة معينة سيعيد نفس النتيجة بغض النظر عن وقت تنفيذها ، باستثناء أنه إذا قمت بالاستعلام في كتلة قريبة جدا من رأس سلسلة Ethereum ، قد تتغير النتيجة إذا تبين أن هذه الكتلة ليست في السلسلة الرئيسية وتمت إعادة تنظيم السلسلة. بمجرد اعتبار الكتلة نهائية ، لن تتغير نتيجة الاستعلام.

لاحظ أن التنفيذ الحالي لا يزال يخضع لقيود معينة قد تنتهك هذه الضمانات. لا يمكن للتنفيذ دائما أن يخبرنا أن hash كتلة معينة ليست في السلسلة الرئيسية ، أو أن نتيجة استعلام لكتلة عن طريق hash الكتلة لا يمكن اعتبارها نهائية ومع ذلك قد تتأثر بإعادة تنظيم الكتلة التي تعمل بشكل متزامن مع الاستعلام. لا تؤثر نتائج الاستعلامات عن طريق hash الكتلة عندما تكون الكتلة نهائية ومعروفة بأنها موجودة في السلسلة الرئيسية. [ تشرح هذه المشكلة ](https://github.com/graphprotocol/graph-node/issues/1405) ماهية هذه القيود بالتفصيل.

#### مثال

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

سيعود هذا الاستعلام بكيانات `Challenge` وكيانات `Application` المرتبطة بها ، كما كانت موجودة مباشرة بعد معالجة رقم الكتلة 8،000،000.

#### مثال

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

سيعود هذا الاستعلام بكيانات `Challenge` وكيانات `Application` المرتبطة بها ، كما كانت موجودة مباشرة بعد معالجة الكتلة باستخدام hash المحددة.

### استعلامات بحث النص الكامل(Fulltext Search)

حقول استعلام البحث عن نص كامل توفر API للبحث عن نص تعبيري يمكن إضافتها إلى مخطط الـ subgraph وتخصيصها. راجع [ تعريف حقول بحث النص الكامل ](/developer/create-subgraph-hosted#defining-fulltext-search-fields) لإضافة بحث نص كامل إلى الـ subgraph الخاص بك.

استعلامات البحث عن النص الكامل لها حقل واحد مطلوب ، وهو `text` ، لتوفير عبارة البحث. تتوفر العديد من عوامل النص الكامل الخاصة لاستخدامها في حقل البحث `text`.

عوامل تشغيل البحث عن النص الكامل:

| رمز         | عامل التشغيل | الوصف                                                                                                                       |
| ----------- | ------------ | --------------------------------------------------------------------------------------------------------------------------- |
| `&`     | `And`        | لدمج عبارات بحث متعددة في فلتر للكيانات التي تتضمن جميع العبارات المتوفرة                                                   |
| &#x7c;      | `Or`         | الاستعلامات التي تحتوي على عبارات بحث متعددة مفصولة بواسطة عامل التشغيل or ستعيد جميع الكيانات المتطابقة من أي عبارة متوفرة |
| `<->` | `Follow by`  | يحدد المسافة بين كلمتين.                                                                                                    |
| `*:`        | `Prefix`     | يستخدم عبارة البحث prefix للعثور على الكلمات التي تتطابق بادئتها (مطلوب حرفان.)                                             |

#### أمثلة

باستخدام العامل `or` ، سيقوم الاستعلام هذا بتصفية blog الكيانات التي تحتوي على أشكال مختلفة من "anarchism" أو "crumpet" في حقول النص الكامل الخاصة بها.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

العامل `follow by` يحدد الكلمات بمسافة محددة عن بعضها في مستندات النص-الكامل. الاستعلام التالي سيعيد جميع الـ blogs التي تحتوي على أشكال مختلفة من "decentralize" متبوعة بكلمة "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

اجمع بين عوامل تشغيل النص-الكامل لعمل فلترة أكثر تعقيدا. فمثلا باستخدام عامل تشغيل البحث pretext مع follow by ،سيتم مطابقة هذا الاستعلام بجميع كيانات الـ blog بالكلمات التي تبدأ بـ "lou" متبوعة بـ "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### الكيانات

يتم تعريف مخطط مصدر البيانات الخاص بك - كأنواع الكيانات والقيم والعلاقات المتاحة للاستعلام - من خلال [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

## المخطط

مخططات GraphQL تحدد عموما أنواع الجذر(root) لـ `queries`, و `subscriptions` و`mutations`. يدعم The Graph فقط الـ `queries`. يتم إنشاء نوع الجذر `Query` لـ subgraph تلقائيا من مخطط GraphQL المضمن في subgraph manifest الخاص بك.

سيتم التعامل مع جميع أنواع GraphQL التي تحتوي على توجيهات `entity@` في مخططك على أنها كيانات ويجب أن تحتوي على حقل `ID`.

> ** ملاحظة: ** الـ API الخاصة بنا لا تعرض الـ mutations لأنه يُتوقع من المطورين إصدار إجراءات مباشرة لـblockchain الأساسي من تطبيقاتهم.

### الكيانات (Entities)

سيتم التعامل مع جميع أنواع GraphQL التي تحتوي على توجيهات `entity@` في مخططك على أنها كيانات ويجب أن تحتوي على حقل `ID`.

> ** ملاحظة: ** في الوقت الحالي ، يجب أن تحتوي جميع الأنواع في مخططك على توجيه `entity@`. في المستقبل ، سنتعامل مع الأنواع التي لا تحتوي على التوجيه `entity@` ككائنات، لكن هذا غير مدعوم حتى الآن.
