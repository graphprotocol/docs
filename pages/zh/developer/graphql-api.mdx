---
title: GraphQL API
---

本指南介绍了用于 Graph 协议的 GraphQL 查询 API。

## 查询

在您的子图模式中，您定义了称为 `Entities` 的类型。 对于每个 `Entity` 类型，将在顶级 `Query` 类型上生成一个 `entity` 和 `entities` 字段。 请注意，使用 The Graph 时，`query` 不需要包含在 `graphql` 查询的顶部。

#### 例子

查询模式中定义的单个 `Token` 实体：

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

**注意：**查询单个实体时，`id`字段为必填项，而且必须为字符串。

查询所有 `Token` 实体：

```graphql
{
  tokens {
    id
    owner
  }
}
```

### 排序

查询集合时，`orderBy` 参数可用于按特定属性排序。 此外，`orderDirection` 可用于指定排序方向，`asc` 用于升序，而`desc` 用于降序。

#### 例子

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

### 分页

查询集合时，可以使用 `first` 参数从集合的开头进行分页。 值得注意的是，默认排序顺序是按 ID 以字母数字升序排列，而不是按创建时间排列。

此外，`skip` 参数可用于跳过实体和分页。 例如 `first:100` 显示前 100 个实体，`first:100, skip:100` 显示接下来的 100 个实体。

查询应该避免使用非常大的 `skip` 值，因为它们通常性能表现不佳。 要检索大量项目，最好根据上一个示例中所示的属性对实体进行分页。

#### Example using `first`

查询前 10 个 token：

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

要查询集合中间的实体组，`skip` 参数可以与 `first` 参数结合使用，以跳过集合开头的指定数量的实体。

#### Example using `first` and `skip`

查询从集合开头偏移 10 个位置的 10 个`Token` 实体：

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Example using `first` and `id_ge`

如果客户端需要检索大量实体，则基于属性进行查询和过滤会明显提高性能。 例如，客户端可以使用以下查询检索大量 token：

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

第一次，它会发送带有 `lastID = ""` 的查询，对于后续请求，会将 `lastID` 设置为上一个请求中的最后一个实体的`id` 属性。 与简单的提高 `skip` 值相比，这种方法的性能要好得多。

### 过滤

您可以在查询中使用 `where` 参数来过滤不同的属性。 您可以在 `where` 参数内过滤多个值。

#### Example using `where`

查询 challenges 的 `failed` 结果:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

您可以使用 `_gt`、`_lte` 等后缀进行值比较：

#### Example for range filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Example for block filtering

You can also filter entities by the `_change_block(number_gte: Int)` - this filters entities which were updated in or after the specified block.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### All Filters

Full list of parameter suffixes:

```
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`.

In addition, the following global filters are available as part of `where` argument:

```gr
_change_block(number_gte: Int)
```

### 跨时间查询

You can query the state of your entities not just for the latest block, which is the by default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the Ethereum chain, the result might change if that block turns out to not be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

Note that the current implementation is still subject to certain limitations that might violate these gurantees. The implementation can not always tell that a given block hash is not on the main chain at all, or that the result of a query by block hash for a block that can not be considered final yet might be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### 例子

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### 例子

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### 全文搜索查询

Fulltext search query fields provide an expressive text search API that can be added to the subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developer/create-subgraph-hosted#defining-fulltext-search-fields) to add fulltext search to your subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

Fulltext search operators:

| 符号   | 运算符      | 描述                                                                   |
| ------ | ----------- | ---------------------------------------------------------------------- |
| `&`    | `And`       | 用于将多个搜索词组合到包含所有提供词条的实体的过滤器中                 |
| &#x7c; | `Or`        | 由 or 运算符分隔的多个搜索词的查询，将返回与任何提供的词匹配的所有实体 |
| `<->`  | `Follow by` | 指定两个单词之间的距离。                                               |
| `:*`   | `Prefix`    | 使用前缀搜索词查找前缀匹配的单词（需要 2 个字符）                      |

#### 例子

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### 实体

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## 模式

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your subgraph is automatically generated from the GraphQL schema that's included in your subgraph manifest.

> **Note:** Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### 实体

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.
