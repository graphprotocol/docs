---
title: 将子图部署到托管服务上
---

如果您尚未查看，请先查看如何编写组成 [子图清单](/developer/create-subgraph-hosted#the-subgraph-manifest) 的文件以及如何安装 [Graph CLI](https://github.com/graphprotocol/graph-cli) 为您的子图生成代码。 现在，让我们将您的子图部署到托管服务上。

## 创建托管服务帐户

在使用托管服务之前，请先在我们的托管服务中创建一个帐户。 为此，您将需要一个 [Github](https://github.com/) 帐户；如果您还没有，您需要先创建一个账户。 然后，导航到 [托管服务](https://thegraph.com/hosted-service/), 单击 _'使用 Github 注册'_ 按钮并完成 Github 的授权流程。

## 存储访问令牌

创建帐户后，导航到您的 [仪表板](https://thegraph.com/hosted-service/dashboard)。 复制仪表板上显示的访问令牌并运行 `graph auth --product hosted-service <ACCESS_TOKEN>`。 这会将访问令牌存储在您的计算机上。 如果您不需要重新生成访问令牌，您就只需要这样做一次。

## 在托管服务上创建子图

在部署子图之前，您需要在 The Graph Explorer 中创建它。 转到 [仪表板](https://thegraph.com/hosted-service/dashboard) ，单击 _'添加子图'_ 按钮，并根据需要填写以下信息:

**图像** - 选择要用作子图的预览图和缩略图的图像。

**子图名称** - 子图名称连同下面将要创建的子图帐户名称，将定义用于部署和 GraphQL 端点的`account-name/subgraph-name`样式名称。 _此字段以后无法更改。_

**Account** - The account that the subgraph is created under. This can be the account of an individual or organization. _Subgraphs cannot be moved between accounts later._

**Subtitle** - Text that will appear in subgraph cards.

**Description** - Description of the subgraph, visible on the subgraph details page.

**GitHub URL** - Link to the subgraph repository on GitHub.

**Hide** - Switching this on hides the subgraph in the Graph Explorer.

After saving the new subgraph, you are shown a screen with help on how to install the Graph CLI, how to generate the scaffolding for a new subgraph, and how to deploy your subgraph. The first two steps were covered in the [Define a Subgraph section](/developer/define-subgraph-hosted).

## 在托管服务上部署子图

一旦部署您的子图，您使用`yarn build` 命令构建的子图文件将被上传到 IPFS，并告诉 Graph Explorer 开始使用这些文件索引您的子图。

您可以通过运行 `yarn deploy`来部署子图。

部署子图后，Graph Explorer将切换到显示子图的同步状态。 根据需要从历史以太坊区块中提取的数据量和事件数量的不同，从创世区块开始，同步操作可能需要几分钟到几个小时。 一旦 Graph节点从历史区块中提取了所有数据，子图状态就会切换到`Synced`。 当新的以太坊区块出现时，Graph节点将继续按照子图的要求检查这些区块的信息。

## 重新部署子图

更改子图定义后，例如：修复实体映射中的一个问题，再次运行上面的 `yarn deploy` 命令可以部署新版本的子图。 子图的任何更新都需要Graph节点再次从创世块开始重新索引您的整个子图。

如果您之前部署的子图仍处于`Syncing`状态，系统则会立即将其替换为新部署的版本。 如果之前部署的子图已经完全同步，Graph节点会将新部署的版本标记为`Pending Version`，在后台进行同步，只有在新版本同步完成后，才会用新的版本替换当前部署的版本。 这样做可以确保在新版本同步时您仍然有子图可以使用。

### 将子图部署到多个以太坊网络

在某些情况下，您可能希望将相同的子图部署到多个以太坊网络，而无需复制其所有代码。 这样做的主要挑战是这些网络上的合约地址不同。 One solution that allows to parameterize aspects like contract addresses is to generate parts of it using a templating system like [Mustache](https://mustache.github.io/) or [Handlebars](https://handlebarsjs.com/).

To illustrate this approach, let's assume a subgraph should be deployed to mainnet and Ropsten using different contract addresses. You could then define two config files providing the addresses for each network:

```json
{
  "network": "mainnet",
  "address": "0x123..."
}
```

and

```json
{
  "network": "ropsten",
  "address": "0xabc..."
}
```

Along with that, you would substitute the network name and addresses in the manifest with variable placeholders `{{network}}` and `{{address}}` and rename the manifest to e.g. `subgraph.template.yaml`:

```yaml
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

In order generate a manifest to either network, you could add two additional commands to `package.json` along with a dependency on `mustache`:

```json
{
  ...
  "scripts": {
    ...
    "prepare:mainnet": "mustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
    "prepare:ropsten": "mustache config/ropsten.json subgraph.template.yaml > subgraph.yaml"
  },
  "devDependencies": {
    ...
    "mustache": "^3.1.0"
  }
}
```

To deploy this subgraph for mainnet or Ropsten you would now simply run one of the two following commands:

```sh
# Mainnet:
yarn prepare:mainnet && yarn deploy

# Ropsten:
yarn prepare:ropsten && yarn deploy
```

A working example of this can be found [here](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759).

**Note:** This approach can also be applied more complex situations, where it is necessary to substitute more than contract addresses and network names or where generating mappings or ABIs from templates as well.

## 检查子图状态

如果子图成功同步，这是表明它将运行良好的一个好的信号。 但是，链上的新事件可能会导致您的子图遇到未经测试的错误环境，或者由于性能或节点方面的问题而开始落后于链上数据。

Graph 节点公开了一个 graphql 端点，您可以通过查询该端点来检查子图的状态。 在托管服务上，该端点的链接是 `https://api.thegraph.com/index-node/graphql`。 在本地节点上，默认情况下该端点在端口 `8030/graphql` 上可用。 该端点的完整数据模式可以在[此处](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql)找到。 这是一个检查子图当前版本状态的示例查询：

```graphql
{
  indexingStatusForCurrentVersion(subgraphName: "org/subgraph") {
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      chainHeadBlock {
        number
      }
      latestBlock {
        number
      }
    }
  }
}
```

这将为您提供 `chainHeadBlock`，您可以将其与子图上的 `latestBlock` 进行比较，以检查子图是否落后。 通过`synced`，可以了解子图是否与链上数据完全同步。 如果子图没有发生错误，`health` 将返回`healthy`，如果有一个错误导致子图的同步进度停止，那么 `health`将返回`failed` 。 在这种情况下，您可以检查 `fatalError` 字段以获取有关此错误的详细信息。

## 子图归档策略

托管服务是一个免费的Graph节点索引器。 开发人员可以部署索引一系列网络的子图，这些网络将被索引，并可以通过 graphQL 进行查询。

为了提高活跃子图的服务性能，托管服务将归档不活跃的子图。

**如果一个子图在 45 天前部署到托管服务，并且在过去 30 天内收到 0 个查询，则将其定义为“不活跃”。**

如果开发人员的一个子图被标记为不活跃，并将 7 天后被删除，托管服务会通过电子邮件通知开发者。 如果他们希望“激活”他们的子图，他们可以通过在其子图的托管服务 graphQL playground中发起查询来实现。 如果再次需要使用这个子图，开发人员也可以随时重新部署存档的子图。
