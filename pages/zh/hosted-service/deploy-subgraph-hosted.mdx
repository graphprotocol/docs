---
title: 将子图部署到托管服务上
---

If you have not checked out already, check out how to write the files that make up a [subgraph manifest](/developer/create-subgraph-hosted#the-subgraph-manifest) and how to install the [Graph CLI](https://github.com/graphprotocol/graph-cli) to generate code for your subgraph. Now, it's time to deploy your subgraph to the Hosted Service, also known as the Hosted Service. 现在，让我们将您的子图部署到托管服务上。

## 创建托管服务帐户

在使用托管服务之前，请先在我们的托管服务中创建一个帐户。 为此，您将需要一个 [Github](https://github.com/) 帐户；如果您还没有，您需要先创建一个账户。 Before using the Hosted Service, create an account in our Hosted Service. You will need a [Github](https://github.com/) account for that; if you don't have one, you need to create that first. Then, navigate to the [Hosted Service](https://thegraph.com/hosted-service/), click on the _'Sign up with Github'_ button and complete Github's authorization flow.

## 存储访问令牌

创建帐户后，导航到您的 [仪表板](https://thegraph.com/hosted-service/dashboard)。 After creating an account, navigate to your [dashboard](https://thegraph.com/hosted-service/dashboard). Copy the access token displayed on the dashboard and run `graph auth --product hosted-service <ACCESS_TOKEN>`. This will store the access token on your computer. You only need to do this once, or if you ever regenerate the access token. 这会将访问令牌存储在您的计算机上。 如果您不需要重新生成访问令牌，您就只需要这样做一次。

## 在托管服务上创建子图

在部署子图之前，您需要在 The Graph Explorer 中创建它。 Before deploying the subgraph, you need to create it in The Graph Explorer. Go to the [dashboard](https://thegraph.com/hosted-service/dashboard) and click on the _'Add Subgraph'_ button and fill in the information below as appropriate:

**图像** - 选择要用作子图的预览图和缩略图的图像。

**Subgraph Name** - Together with the account name that the subgraph is created under, this will also define the `account-name/subgraph-name`-style name used for deployments and GraphQL endpoints. _This field cannot be changed later._ _此字段以后无法更改。_

**Account** - The account that the subgraph is created under. This can be the account of an individual or organization. _Subgraphs cannot be moved between accounts later._ 这可以是个人或组织的帐户。 _以后不能在帐户之间移动子图。_

**副标题** - 将出现在子图卡中的文本。

**描述** - 子图的描述，在子图详细信息页面上可见。

**GitHub URL** - 存储在GitHub 上的子图代码的链接。

**隐藏** - 打开此选项可隐藏Graph Explorer中的子图。

After saving the new subgraph, you are shown a screen with help on how to install the Graph CLI, how to generate the scaffolding for a new subgraph, and how to deploy your subgraph. The first two steps were covered in the [Define a Subgraph section](/developer/define-subgraph-hosted). 前面两部分在[定义子图](/developer/define-subgraph-hosted)中进行了介绍。

## 在托管服务上部署子图

一旦部署您的子图，您使用`yarn build` 命令构建的子图文件将被上传到 IPFS，并告诉 Graph Explorer 开始使用这些文件索引您的子图。

您可以通过运行 `yarn deploy`来部署子图。

部署子图后，Graph Explorer将切换到显示子图的同步状态。 根据需要从历史以太坊区块中提取的数据量和事件数量的不同，从创世区块开始，同步操作可能需要几分钟到几个小时。 一旦 Graph节点从历史区块中提取了所有数据，子图状态就会切换到`Synced`。 After deploying the subgraph, the Graph Explorer will switch to showing the synchronization status of your subgraph. Depending on the amount of data and the number of events that need to be extracted from historical Ethereum blocks, starting with the genesis block, syncing can take from a few minutes to several hours. The subgraph status switches to `Synced` once the Graph Node has extracted all data from historical blocks. The Graph Node will continue inspecting Ethereum blocks for your subgraph as these blocks are mined.

## 重新部署子图

When making changes to your subgraph definition, for example to fix a problem in the entity mappings, run the `yarn deploy` command above again to deploy the updated version of your subgraph. Any update of a subgraph requires that Graph Node reindexes your entire subgraph, again starting with the genesis block. 子图的任何更新都需要Graph节点再次从创世块开始重新索引您的整个子图。

如果您之前部署的子图仍处于`Syncing`状态，系统则会立即将其替换为新部署的版本。 If your previously deployed subgraph is still in status `Syncing`, it will be immediately replaced with the newly deployed version. If the previously deployed subgraph is already fully synced, Graph Node will mark the newly deployed version as the `Pending Version`, sync it in the background, and only replace the currently deployed version with the new one once syncing the new version has finished. This ensures that you have a subgraph to work with while the new version is syncing. 这样做可以确保在新版本同步时您仍然有子图可以使用。

### 将子图部署到多个以太坊网络

In some cases, you will want to deploy the same subgraph to multiple Ethereum networks without duplicating all of its code. The main challenge that comes with this is that the contract addresses on these networks are different. One solution that allows to parameterize aspects like contract addresses is to generate parts of it using a templating system like [Mustache](https://mustache.github.io/) or [Handlebars](https://handlebarsjs.com/). 这样做的主要挑战是这些网络上的合约地址不同。 允许参数化合约地址等配置的一种解决方案是使用 [Mustache](https://mustache.github.io/)或 [Handlebars](https://handlebarsjs.com/)等模板系统。

To illustrate this approach, let's assume a subgraph should be deployed to mainnet and Ropsten using different contract addresses. You could then define two config files providing the addresses for each network: 您可以定义两个配置文件，为每个网络提供相应的地址：

```json
{
  "network": "mainnet",
  "address": "0x123..."
}
}
```

和

```json
{
  "network": "ropsten",
  "address": "0xabc..."
}
}
```

除此之外，您可以用变量占位符 `{{network}}` 和 `{{address}}` 替换清单中的网络名称和地址，并将清单重命名为例如 `subgraph.template.yaml`：

```yaml
# ...
# ...
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    network: {{network}}
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      address: '{{address}}'
      abi: Gravity
    mapping:
      kind: ethereum/events
```

为了给每个网络生成清单，您可以向 `package.json` 添加两个附加命令，以及对 `mustache` 的依赖项：

```json
{
  ...
  "scripts": {
    ...
    {
  ...
  "scripts": {
    ...
    "prepare:mainnet": "mustache config/mainnet.json subgraph.template.yaml > subgraph.yaml",
    "prepare:ropsten": "mustache config/ropsten.json subgraph.template.yaml > subgraph.yaml"
  },
  "devDependencies": {
    ...
    "mustache": "^3.1.0"
  }
}
    "mustache": "^3.1.0"
  }
}
```

要为主网或 Ropsten 部署此子图，您现在只需运行以下两个命令中的任意一个：

```sh
# Mainnet:
yarn prepare:mainnet && yarn deploy

# Ropsten:
yarn prepare:ropsten && yarn deploy
```

您可以在[这里](https://github.com/graphprotocol/example-subgraph/tree/371232cf68e6d814facf5e5413ad0fef65144759)找到一个工作示例。

**注意：** 这种方法也可以应用在更复杂的情况下，例如：需要替换的不仅仅是合约地址和网络名称，或者还需要从模板生成映射或 ABI。

## 检查子图状态

如果子图成功同步，这是表明它将运行良好的一个好的信号。 If a subgraph syncs successfully, that is a good sign that it will continue to run well forever. However, new triggers on the chain might cause your subgraph to hit an untested error condition or it may start to fall behind due to performance issues or issues with the node operators.

Graph Node exposes a graphql endpoint which you can query to check the status of your subgraph. On the Hosted Service, it is available at `https://api.thegraph.com/index-node/graphql`. On a local node it is available on port `8030/graphql` by default. The full schema for this endpoint can be found [here](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql). Here is an example query that checks the status of the current version of a subgraph: 在托管服务上，该端点的链接是 `https://api.thegraph.com/index-node/graphql`。 在本地节点上，默认情况下该端点在端口 `8030/graphql` 上可用。 该端点的完整数据模式可以在[此处](https://github.com/graphprotocol/graph-node/blob/master/server/index-node/src/schema.graphql)找到。 这是一个检查子图当前版本状态的示例查询：

```graphql
{
  indexingStatusForCurrentVersion(subgraphName: "org/subgraph") {
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      chainHeadBlock {
        number
      }
      latestBlock {
        number
      }
    }
  }
}
```

This will give you the `chainHeadBlock` which you can compare with the `latestBlock` on your subgraph to check if it is running behind. `synced` informs if the subgraph has ever caught up to the chain. `health` can currently take the values of `healthy` if no errors ocurred, or `failed` if there was an error which halted the progress of the subgraph. In this case you can check the `fatalError` field for details on this error. 通过`synced`，可以了解子图是否与链上数据完全同步。 如果子图没有发生错误，`health` 将返回`healthy`，如果有一个错误导致子图的同步进度停止，那么 `health`将返回`failed` 。 在这种情况下，您可以检查 `fatalError` 字段以获取有关此错误的详细信息。

## 子图归档策略

托管服务是一个免费的Graph节点索引器。 The Hosted Service is a free Graph Node indexer. Developers can deploy subgraphs indexing a range of networks, which will be indexed, and made available to query via graphQL.

为了提高活跃子图的服务性能，托管服务将归档不活跃的子图。

**如果一个子图在 45 天前部署到托管服务，并且在过去 30 天内收到 0 个查询，则将其定义为“不活跃”。**

Developers will be notified by email if one of their subgraphs has been marked as inactive 7 days before it is removed. If they wish to "activate" their subgraph, they can do so by making a query in their subgraph's Hosted Service graphQL playground. Developers can always redeploy an archived subgraph if it is required again. 如果他们希望“激活”他们的子图，他们可以通过在其子图的托管服务 graphQL playground中发起查询来实现。 如果再次需要使用这个子图，开发人员也可以随时重新部署存档的子图。
