---
title: GraphQL API
---

Graph Protocol で使用される GraphQL Query API について説明します。

## クエリ

サブグラフのスキーマには、`Entities`と呼ばれるタイプが定義されています。各`Entity`タイプには、トップレベルの`Query`タイプに`entity`と`entities`フィールドが生成されます。なお、The Graph を使用する際には、`graphql`の`query` の先頭にクエリを含める必要はありません。

#### 例

スキーマで定義された 1 つの`Token`エンティティに対するクエリ。

```graphql
{
  token(id: "1") {
    id
    owner
  }
}
```

**注:** 単一のエンティティをクエリする場合、`id`フィールドは必須で、文字列でなければなりません。

すべての`Token`エンティティをクエリする:

```graphql
{
  tokens {
    id
    owner
  }
}
```

### ソート

コレクションをクエリする際、`orderBy`パラメータを使用して特定の属性でソートすることができます。また、`orderDirection`でソートの方向を指定することができ、`asc`は昇順、`desc`は降順となります。

#### 例

```graphql
{
  tokens(orderBy: price, orderDirection: asc) {
    id
    owner
  }
}
```

### ページネーション

コレクションを照会する際、`最初`のパラメータを使用して、コレクションの先頭からページングすることができます。なお、デフォルトのソート順は、作成時刻順ではなく、ID による英数字の昇順となっていることに注意してください。

例えば、`first:100`では最初の 100 個のエンティティを表示し、`first:100, skip:100`では次の 100 個のエンティティを表示することができます。

クエリは、非常に大きな`skip`値を使用すると、一般的にパフォーマンスが低下するため、避けるべきです。多数のアイテムを検索する場合は、最後の例で示すように、属性に基づいてエンティティをページングする方がはるかに良いでしょう。

#### Example using `first`

最初の 10 個のトークンを検索します:

```graphql
{
  tokens(first: 10) {
    id
    owner
  }
}
```

コレクションの途中にあるエンティティのグループを検索する場合は、 `skip`パラメータを`first`パラメータと組み合わせて使用し、コレクションの先頭から指定した数のエンティティをスキップすることができます。

#### Example using `first` and `skip`

コレクションの先頭から 10 個ずつオフセットした 10 個の`Token`エンティティをクエリします。

```graphql
{
  tokens(first: 10, skip: 10) {
    id
    owner
  }
}
```

#### Example using `first` and `id_ge`

クライアントが多数のエンティティを取得する必要がある場合、属性に基づいてクエリを行い、その属性でフィルタリングする方がはるかにパフォーマンスが高くなります。たとえば、クライアントが大量のトークンを取得するには、次のようなクエリを使用します。

```graphql
query manyTokens($lastID: String) {
  tokens(first: 1000, where: { id_gt: $lastID }) {
    id
    owner
  }
}
```

最初のリクエストでは`lastID = ""`でクエリを送信し、それ以降のリクエストでは`lastID`を前回のリクエストの最後のエンティティの `id`属性に設定することになります。この方法は、`skip`値を増やしていく方法に比べて格段にパフォーマンスが向上します。

### フィルタリング

クエリの`where`パラメータを使用して、さまざまなプロパティに対してフィルタリングすることができます。`where`パラメータ内の複数の値でフィルタリングできます。

#### Example using `where`

`失敗`結果を持つクエリの課題:

```graphql
{
  challenges(where: { outcome: "failed" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

値の比較には、`_gt`, `_lte`などの接尾語を使用できます:

#### Example for range filtering

```graphql
{
  applications(where: { deposit_gt: "10000000000" }) {
    id
    whitelisted
    deposit
  }
}
```

#### Example for block filtering

You can also filter entities by the `_change_block(number_gte: Int)` - this filters entities which were updated in or after the specified block.

This can be useful if you are looking to fetch only entities which have changed, for example since the last time you polled. Or alternatively it can be useful to investigate or debug how entities are changing in your subgraph (if combined with a block filter, you can isolate only entities that changed in a specific block).

```graphql
{
  applications(where: { _change_block: { number_gte: 100 } }) {
    id
    whitelisted
    deposit
  }
}
```

#### All Filters

Full list of parameter suffixes:

```
_not
_gt
_lt
_gte
_lte
_in
_not_in
_contains
_contains_nocase
_not_contains
_not_contains_nocase
_starts_with
_starts_with_nocase
_ends_with
_ends_with_nocase
_not_starts_with
_not_starts_with_nocase
_not_ends_with
_not_ends_with_nocase
```

> Please note that some suffixes are only supported for specific types. For example, `Boolean` only supports `_not`, `_in`, and `_not_in`.

In addition, the following global filters are available as part of `where` argument:

```gr
_change_block(number_gte: Int)
```

### タイムトラベルクエリ

You can query the state of your entities not just for the latest block, which is the by default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a `block` argument in the toplevel fields of queries.

The result of such a query will not change over time, i.e., querying at a certain past block will return the same result no matter when it is executed, with the exception that if you query at a block very close to the head of the Ethereum chain, the result might change if that block turns out to not be on the main chain and the chain gets reorganized. Once a block can be considered final, the result of the query will not change.

Note that the current implementation is still subject to certain limitations that might violate these gurantees. The implementation can not always tell that a given block hash is not on the main chain at all, or that the result of a query by block hash for a block that can not be considered final yet might be influenced by a block reorganization running concurrently with the query. They do not affect the results of queries by block hash when the block is final and known to be on the main chain. [This issue](https://github.com/graphprotocol/graph-node/issues/1405) explains what these limitations are in detail.

#### 例

```graphql
{
  challenges(block: { number: 8000000 }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing block number 8,000,000.

#### 例

```graphql
{
  challenges(block: { hash: "0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c" }) {
    challenger
    outcome
    application {
      id
    }
  }
}
```

This query will return `Challenge` entities, and their associated `Application` entities, as they existed directly after processing the block with the given hash.

### フルテキスト検索クエリ

Fulltext search query fields provide an expressive text search API that can be added to the subgraph schema and customized. Refer to [Defining Fulltext Search Fields](/developer/create-subgraph-hosted#defining-fulltext-search-fields) to add fulltext search to your subgraph.

Fulltext search queries have one required field, `text`, for supplying search terms. Several special fulltext operators are available to be used in this `text` search field.

Fulltext search operators:

| シンボル | オペレーター | 説明 |
| --- | --- | --- |
| `&` | `And` | 複数の検索語を組み合わせて、指定したすべての検索語を含むエンティティをフィルタリングします。 |
| &#x7c; | `Or` | 複数の検索語をオペレーターで区切って検索すると、指定した語のいずれかにマッチするすべてのエンティティが返されます。 |
| `<->` | `Follow by` | 2 つの単語の間の距離を指定します。 |
| `:*` | `Prefix` | プレフィックス検索語を使って、プレフィックスが一致する単語を検索します（2 文字必要） |

#### 例

Using the `or` operator, this query will filter to blog entities with variations of either "anarchism" or "crumpet" in their fulltext fields.

```graphql
{
  blogSearch(text: "anarchism | crumpets") {
    id
    title
    body
    author
  }
}
```

The `follow by` operator specifies a words a specific distance apart in the fulltext documents. The following query will return all blogs with variations of "decentralize" followed by "philosophy"

```graphql
{
  blogSearch(text: "decentralized <-> philosophy") {
    id
    title
    body
    author
  }
}
```

Combine fulltext operators to make more complex filters. With a pretext search operator combined with a follow by this example query will match all blog entities with words that start with "lou" followed by "music".

```graphql
{
  blogSearch(text: "lou:* <-> music") {
    id
    title
    body
    author
  }
}
```

### エンティティ

Graph Node implements [specification-based](https://spec.graphql.org/October2021/#sec-Validation) validation of the GraphQL queries it receives using [graphql-tools-rs](https://github.com/dotansimha/graphql-tools-rs#validation-rules), which is based on the [graphql-js reference implementation](https://github.com/graphql/graphql-js/tree/main/src/validation). Queries which fail a validation rule do so with a standard error - visit the [GraphQL spec](https://spec.graphql.org/October2021/#sec-Validation) to learn more.

## スキーマ

The schema of your data source--that is, the entity types, values, and relationships that are available to query--are defined through the [GraphQL Interface Definition Langauge (IDL)](https://facebook.github.io/graphql/draft/#sec-Type-System).

GraphQL schemas generally define root types for `queries`, `subscriptions` and `mutations`. The Graph only supports `queries`. The root `Query` type for your subgraph is automatically generated from the GraphQL schema that's included in your subgraph manifest.

> **Note:** Our API does not expose mutations because developers are expected to issue transactions directly against the underlying blockchain from their applications.

### エンティティ

All GraphQL types with `@entity` directives in your schema will be treated as entities and must have an `ID` field.

> **Note:** Currently, all types in your schema must have an `@entity` directive. In the future, we will treat types without an `@entity` directive as value objects, but this is not yet supported.
