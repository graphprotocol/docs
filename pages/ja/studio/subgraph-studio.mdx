---
title: Subgraph Studioã®ä½¿ã„æ–¹
---

æ–°ã—ã„ãƒ­ãƒ¼ãƒ³ãƒãƒ‘ãƒƒãƒ‰ã¸ã‚ˆã†ã“ãğŸ‘©ğŸ½â€ğŸš€

Subgraph Studioã¯ã€ã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰ãƒ»ä½œæˆã—ã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¦ã€æ–°ã—ã„åˆ†æ•£å‹ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã«å…¬é–‹ã™ã‚‹ãŸã‚ã®å ´æ‰€ã§ã™ï¼ˆè©³ç´°ã¯[ã“ã¡ã‚‰](/explorer)ï¼‰

Subgraph Studioã§ã§ãã‚‹ã“ã¨

- Studio UIã«ã‚ˆã‚‹ã‚µãƒ–ã‚°ãƒ©ãƒ•ã®ä½œæˆ
- CLIã‚’ä½¿ç”¨ã—ãŸã‚µãƒ–ã‚°ãƒ©ãƒ•ã®ãƒ‡ãƒ—ãƒ­ã‚¤
- Studio UIã§ã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’å…¬é–‹ã™ã‚‹
- ãƒ—ãƒ¬ã‚¤ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã®ãƒ†ã‚¹ãƒˆ
- ã‚¯ã‚¨ãƒªURLã‚’ä½¿ç”¨ã—ã¦ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã«çµ±åˆã™ã‚‹
- ç‰¹å®šã®ã‚µãƒ–ã‚°ãƒ©ãƒ•ç”¨ã®APIã‚­ãƒ¼ã®ä½œæˆã¨ç®¡ç†

Subgraph Studioã§ã¯ã€ã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’å®Œå…¨ã«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’å…¬é–‹ã™ã‚‹å‰ã«ãƒ†ã‚¹ãƒˆã§ãã‚‹ã ã‘ã§ãªãã€APIã‚­ãƒ¼ã‚’ç‰¹å®šã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã«é™å®šã—ãŸã‚Šã€ç‰¹å®šã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚µã«APIã‚­ãƒ¼ã‹ã‚‰ã®ã‚¯ã‚¨ãƒªã‚’è¨±å¯ã—ãŸã‚Šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

ã‚µãƒ–ã‚°ãƒ©ãƒ•ã¸ã®ã‚¯ã‚¨ãƒªã¯ã‚¯ã‚¨ãƒªãƒ•ã‚£ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã€ã‚°ãƒ©ãƒ•ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®[ã‚¤ãƒ³ãƒ‡ã‚¯ã‚µãƒ¼](/indexing)ã¸ã®å ±é…¬ã¨ã—ã¾ã™ã€‚dappã®é–‹ç™ºè€…ã‚„ã‚µãƒ–ã‚°ãƒ©ãƒ•ã®é–‹ç™ºè€…ã¯ã€ã“ã®Studioã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå„ªã‚ŒãŸã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰ã—ã€è‡ªåˆ†ã‚„ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®ã‚¯ã‚¨ãƒªã‚’å¼·åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚Studioã¯5ã¤ã®ä¸»è¦éƒ¨åˆ†ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ç®¡ç†
- ä½œæˆã—ãŸã‚µãƒ–ã‚°ãƒ©ãƒ•ã®ãƒªã‚¹ãƒˆ
- ç‰¹å®šã®ã‚µãƒ–ã‚°ãƒ©ãƒ•ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç®¡ç†ã€è©³ç´°è¡¨ç¤ºã€è¦–è¦šåŒ–ã™ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³
- ã‚µãƒ–ã‚°ãƒ©ãƒ•ã®ã‚¯ã‚¨ãƒªã«å¿…è¦ãªAPIã‚­ãƒ¼ã‚’ç®¡ç†ã™ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³
- è«‹æ±‚æ›¸ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³

## ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ä½œæˆæ–¹æ³•

1. ãŠä½¿ã„ã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã§ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã—ã¾ã™ - MetaMaskã¾ãŸã¯WalletConnectã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
1. ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã™ã‚‹ã¨ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸ã«å›ºæœ‰ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã‚­ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚µãƒ–ã‚°ãƒ©ãƒ•ã®å…¬é–‹ã‚„APIã‚­ãƒ¼ã¨èª²é‡‘ã®ç®¡ç†ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚å›ºæœ‰ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã‚­ãƒ¼ã¯ã€æ¼æ´©ã—ãŸã¨æ€ã‚ã‚Œã‚‹å ´åˆã«å†ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## Subgraph Studioã§ã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’ä½œæˆã™ã‚‹æ–¹æ³•

ä¸€ç•ªã®ãƒã‚¤ãƒ³ãƒˆã§ã™ - æœ€åˆã«ã‚µãƒ–ã‚°ãƒ©ãƒ•ã‚’ä½œæˆã™ã‚‹éš›ã«ã¯ã€ä»¥ä¸‹ã®é …ç›®ã‚’å…¥åŠ›ã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã•ã‚Œã¾ã™:

- Your Subgraph Name
- Image
- èª¬æ˜
- Categories
- Website

## Subgraph Compatibility with The Graph Network

The Graph Network is not yet able to support all of the data-sources & features available on the Hosted Service. In order to be supported by indexers on the network, subgraphs must:

- Index mainnet Ethereum
- Must not use any of the following features:
  - ipfs.cat & ipfs.map
  - Non-fatal errors
  - Grafting

More features & networks will be added to The Graph Network incrementally.

### Subgraph lifecycle flow

![Subgraph Lifecycle](/img/subgraph-lifecycle.png)

After you have created your subgraph, you will be able to deploy it using the [CLI](https://github.com/graphprotocol/graph-cli), or command line interface. Deploying a subgraph with the CLI will push the subgraph to the Studio where youâ€™ll be able to test subgraphs using the playground. This will eventually allow you to publish to the Graph Network. For more information on CLI setup, [check this out](/developer/define-subgraph-hosted#install-the-graph-cli) (pst, make sure you have your deploy key on hand). Remember, deploying is **not the same as** publishing. When you deploy a subgraph, you just push it to the Studio where youâ€™re able to test it. Versus, when you publish a subgraph, you are publishing it on-chain.

## Testing your Subgraph in Subgraph Studio

If youâ€™d like to test your subgraph before publishing it to the network, you can do this in the Subgraph **Playground** or look at your logs. The Subgraph logs will tell you **where** your subgraph fails in the case that it does.

## Publish your Subgraph in Subgraph Studio

Youâ€™ve made it this far - congrats! Publishing your subgraph means that an IPFS hash was generated when you deployed the subgraph within the CLI and is stored in the networkâ€™s Ethereum smart contracts. In order to publish your subgraph successfully, youâ€™ll need to go through the following steps outlined in this [blog](https://thegraph.com/blog/building-with-subgraph-studio). Check out the video overview below as well:

<figure className="video-container">
  <iframe
    className="video-iframe"
    src="https://www.youtube.com/embed/HfDgC2oNnwo"
    title="YouTube ãƒ“ãƒ‡ã‚ªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼"
    frameBorder="0"
    allowFullScreen
></iframe>
</figure>

Remember, while youâ€™re going through your publishing flow, youâ€™ll be able to push to either mainnet or Rinkeby, the testnet we support. If youâ€™re a first time subgraph developer, we highly suggest you start with publishing to Rinkeby, which is free to do. This will allow you to see how the subgraph will work in The Graph Explorer and will allow you to test curation elements.

Youâ€™ll only be able to index data from mainnet (even if your subgraph was published to a testnet) because only subgraphs that are indexing mainnet data can be published to the network. This is because indexers need to submit mandatory Proof of Indexing records as of a specific block hash. Because publishing a subgraph is an action taken on-chain, remember that the transaction can take up to a few minutes to go through. Any address you use to publish the contract will be the only one able to publish future versions. Choose wisely!

Subgraphs with curation signal are shown to Indexers so that they can be indexed on the decentralized network. You can publish subgraphs and signal in one transaction, which allows you to mint the first curation signal on the subgraph and saves on gas costs. By adding your signal to the signal later provided by Curators, your subgraph will also have a higher chance of ultimately serving queries.

**Now that youâ€™ve published your subgraph, letâ€™s get into how youâ€™ll manage them on a regular basis.** Note that you cannot publish your subgraph to the network if it has failed syncing. This is usually because the subgraph has bugs - the logs will tell you where those issues exist!

## Versioning your Subgraph with the CLI

Developers might want to update their subgraph, for a variety of reasons. When this is the case, you can deploy a new version of your subgraph to the Studio using the CLI (it will only be private at this point) and if you are happy with it, you can publish this new deployment to The Graph Explorer. This will create a new version of your subgraph that curators can start signaling on and indexers will be able to index this new version.

Up until recently, developers were forced to deploy and publish a new version of their subgraph to the Explorer to update the metadata of their subgraphs. Now, developers can update the metadata of their subgraphs **without having to publish a new version**. Developers can update their subgraph details in the Studio (under profile picture, name, description, etc) by checking an option called **Update Details** in The Graph Explorer. If this is checked, an on-chain transaction will be generated that updates subgraph details in the Explorer without having to publish a new version with a new deployment.

Please note that there are costs associated with publishing a new version of a subgraph to the network. In addition to the transaction fees, developers must also fund a part of the curation tax on auto-migrating signal. You cannot publish a new version of your subgraph if curators have not signaled on it. For more information on the risks of curation, please read more [here](/curating).

### Automatic Archiving of Subgraph Versions

Whenever you deploy a new subgraph version in the Subgraph Studio, the previous version will be archived. Archived versions won't be indexed/synced and therefore cannot be queried. You can unarchive an archived version of your subgraph in the Studio UI. Please note that previous versions of non-published subgraphs deployed to the Studio will be automatically archived.

![Subgraph Studio - Unarchive](/img/Unarchive.png)

## Managing your API Keys

Regardless of whether youâ€™re a dapp developer or a subgraph developer, youâ€™ll need to manage your API keys. This is important for you to be able to query subgraphs because API keys make sure the connections between application services are valid and authorized. This includes authenticating the end user and the device using the application.

The Studio will list out existing API keys, which will give you the ability to manage or delete them.

1. The **Overview** section will allow you to:
   - Edit your key name
   - Regenerate API keys
   - View the current usage of the API key with stats:
     - Number of queries
     - Amount of GRT spent
2. Under **Manage Security Settings**, youâ€™ll be able to opt into security settings depending on the level of control youâ€™d like to have over your API keys. In this section, you can:
   - View and manage the domain names authorized to use your API key
   - Assign subgraphs that can be queried with your API key

## How to Manage your Subgraph

API keys aside, youâ€™ll have many tools at your disposal to manage your subgraphs. You can organize your subgraphs by their **status** and **category**.

- The **Status** tag allows you to pick between a variety of tags including `<created>`, `<deployed>`, `<published>`, `<archived>`, etc.
- Meanwhile, **Category** allows you to designate what category your subgraph falls into. Options include `<DeFi>`, `<NFTs>`, `<Governance>`, etc.
